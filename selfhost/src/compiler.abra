import "fs" as fs
import Position from "./lexer"
import LiteralAstNode from "./parser"
import Project, TypedModule, TypedAstNode, TypedAstNodeKind, Type, TypeKind, Struct, StructOrEnum, TypedInvokee, Function, FunctionKind from "./typechecker"
import ModuleBuilder, QbeType, AggregateType, Dest, Instruction, QbeFunction, Value from "./qbe"

type CompilationError {
  modulePath: String
  error: CompileError

  func getMessage(self): String {
    val contents = match fs.readFile(self.modulePath) {
      Ok(v) => v
      Err => return "Could not read file '${self.modulePath}'"
    }
    self.error.getMessage(self.modulePath, contents)
  }
}

type CompileError {
  position: Position
  kind: CompileErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      CompileErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      CompileErrorKind.Unreachable(message) => {
        lines.push("Unreachable code reached")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Internal error: $message")
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum CompileErrorKind {
  NotYetImplemented(reason: String)
  Unreachable(message: String)
}

type Context {
  name: String
  numLocals: Int = 0

  func nextLocal(self): String {
    val name = "_${self.numLocals}"
    self.numLocals += 1
    name
  }
}

// Each module's root code is wrapped in a specially-named function; this function name
// starts with two dots, which is not possible in ordinary Abra source code and will
// thus introduce no conflicts (qbe doesn't care about function name rules).
func moduleWrapperFnName(module: TypedModule): String = "..module_${module.id}"

func structTypeName(struct: Struct): String = ".${struct.moduleId}.${struct.label.name}"
func structInitializerFnName(struct: Struct): String = "${structTypeName(struct)}.init"

func methodFnName(struct: Struct, fn: Function): String {
  val typeName = structTypeName(struct)
  val sep = match fn.kind {
    FunctionKind.InstanceMethod => ".."
    _ => "."
  }
  "${typeName}${sep}${fn.label.name}"
}

func getInstanceTypeForType(project: Project, ty: Type): Result<(StructOrEnum, Type[]), CompileError> {
  match ty.kind {
    TypeKind.Any => unreachable("getInstanceTypeForType: Any")
    TypeKind.PrimitiveUnit => unreachable("getInstanceTypeForType: Unit")
    TypeKind.PrimitiveInt => Ok((StructOrEnum.Struct(project.preludeIntStruct), []))
    TypeKind.PrimitiveFloat => Ok((StructOrEnum.Struct(project.preludeFloatStruct), []))
    TypeKind.PrimitiveBool => Ok((StructOrEnum.Struct(project.preludeBoolStruct), []))
    TypeKind.PrimitiveString => Ok((StructOrEnum.Struct(project.preludeStringStruct), []))
    TypeKind.Never => unreachable("getInstanceTypeForType: Never")
    TypeKind.Generic(name) => unreachable("getInstanceTypeForType: Generic($name)")
    TypeKind.Instance(structOrEnum, typeParams) => Ok((structOrEnum, typeParams))
    TypeKind.Tuple(types) => todo("getInstanceTypeForType: Tuple${types.length}")
    TypeKind.Func(_paramTypes, _returnType) => todo("getInstanceTypeForType: Func")
    TypeKind.Type(_structOrEnum) => todo("getInstanceTypeForType: Type")
    TypeKind.Hole => unreachable("getInstanceTypeForType: Hole")
  }
}

export type Compiler {
  _project: Project
  _builder: ModuleBuilder
  _currentModule: TypedModule
  _ctx: Context
  _currentFn: QbeFunction

  func compile(project: Project, entry: TypedModule): Result<ModuleBuilder, CompilationError> {
    val builder = ModuleBuilder()
    val rootCtx = Context(name: "\$root")

    val fn = builder.buildFunction(name: "main", returnType: Some(QbeType.U32), exported: true)
    fn.meta.push("main entrypoint function")
    val mainFnBlock = fn.block

    val compiler = Compiler(_project: project, _builder: builder, _currentModule: entry, _ctx: rootCtx, _currentFn: fn)

    match compiler._compileModule(entry) { Ok(v) => v, Err(e) => return Err(CompilationError(modulePath: entry.name, error: e)) }
    val modFnName = moduleWrapperFnName(entry)
    mainFnBlock.append(Instruction.Call(dst: None, fn: "\$$modFnName", args: []))

    mainFnBlock.append(Instruction.Return(Some(Value.Int(0))))

    Ok(builder)
  }

  func _compileModule(self, module: TypedModule): Result<Int, CompileError> {
    val modFnName = moduleWrapperFnName(module)
    self._currentModule = module
    self._ctx = Context(name: modFnName)

    val fn = self._builder.buildFunction(name: modFnName, returnType: None)
    fn.meta.push(module.name)
    self._currentFn = fn

    for node, idx in module.code {
      val value = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
      // TODO: This is just a crude mechanism to verify things are working - if the last statement in the module
      //       is an expression, call the `toString` method on that expression, and print the result using `printf`.
      //       This is temporary and will go away when the `println` function is supported (which is top priority).
      if idx == module.code.length - 1 {
        if value |v| {
          val dataPtr = self._builder.buildGlobalString("%s\\n")
          val tostringMethod = match self._getOrCompileToStringMethod(node.ty) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.append(Instruction.Call(dst: Some(Dest(name: "%_tostring_repr", ty: QbeType.Pointer)), fn: "\$${tostringMethod.name}", args: [v]))
          self._currentFn.block.append(Instruction.Add(dst: Dest(name: "%_repr_chars_ptr", ty: QbeType.Pointer), l: Value.Int(8), r: Value.Ident("_tostring_repr", QbeType.Pointer)))
          self._currentFn.block.append(Instruction.LoadL(dst: Dest(name: "%_repr_chars", ty: QbeType.Pointer), mem: Value.Ident("_repr_chars_ptr", QbeType.Pointer)))
          self._currentFn.block.append(Instruction.CallVarargs(dst: None, fn: "\$printf", varargsIdx: 1, args: [dataPtr, Value.Ident("_repr_chars", QbeType.Pointer)]))
        }
      }
    }

    fn.block.append(Instruction.Return(None))

    Ok(0)
  }

  func _compileStatement(self, node: TypedAstNode): Result<Value?, CompileError> {
    match node.kind {
      TypedAstNodeKind.If => todo("compiling if stmt/expr", node.token.position)
      TypedAstNodeKind.Match => todo("compiling match stmt/expr", node.token.position)
      TypedAstNodeKind.While => todo("compiling while-loop", node.token.position)
      TypedAstNodeKind.For => todo("compiling for-loop", node.token.position)
      TypedAstNodeKind.BindingDeclaration => todo("compiling binding declaration", node.token.position)
      TypedAstNodeKind.FunctionDeclaration => todo("compiling function declaration", node.token.position)
      TypedAstNodeKind.TypeDeclaration => todo("compiling type declaration", node.token.position)
      TypedAstNodeKind.EnumDeclaration => todo("compiling enum declaration", node.token.position)
      TypedAstNodeKind.Break => todo("compiling break statement", node.token.position)
      TypedAstNodeKind.Continue => todo("compiling continue statement", node.token.position)
      TypedAstNodeKind.Return => todo("compiling return statement", node.token.position)
      TypedAstNodeKind.Placeholder => unreachable("placeholder ast node emitted from typechecker", node.token.position)
      _ => {
        val v = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
        Ok(Some(v))
      }
    }
  }

  func _compileExpression(self, node: TypedAstNode): Result<Value, CompileError> {
    match node.kind {
      TypedAstNodeKind.Literal(lit) => {
        match lit {
          LiteralAstNode.Int(v) => {
            val nextLocal = self._ctx.nextLocal()
            val value = Value.Int(v)
            val resultTy = value.ty()
            self._currentFn.block.append(Instruction.Add(Dest(name: "%$nextLocal", ty: resultTy), Value.Int(0), value))

            Ok(Value.Ident(nextLocal, resultTy))
          }
          LiteralAstNode.String(s) => {
            val dataPtr = self._builder.buildGlobalString(s)
            val instancePtr = match self._constructString(dataPtr, Value.Int(s.length)) { Ok(v) => v, Err(e) => return Err(e) }
            Ok(instancePtr)
          }
          _ => todo("other literal types", node.token.position)
        }
      }
      TypedAstNodeKind.StringInterpolation => todo("compiling string interpolation expression", node.token.position)
      TypedAstNodeKind.Unary => todo("compiling unary expression", node.token.position)
      TypedAstNodeKind.Binary => todo("compiling binary expression", node.token.position)
      TypedAstNodeKind.Grouped => todo("compiling grouped expression", node.token.position)
      TypedAstNodeKind.Identifier => todo("compiling identifier expression", node.token.position)
      TypedAstNodeKind.Accessor => todo("compiling accessor expression", node.token.position)
      TypedAstNodeKind.Invocation(invokee, arguments) => {
        match invokee {
          TypedInvokee.Method(fn, selfVal, isOptSafe) => {
            if isOptSafe return todo("opt-safe method invocation", node.token.position)

            val fnVal = match self._getOrCompileMethod(selfVal.ty, fn) { Ok(v) => v, Err(e) => return Err(e) }

            val args: Value[] = []
            args.push(match self._compileExpression(selfVal) { Ok(v) => v, Err(e) => return Err(e) })
            for arg in arguments {
              if arg |arg| {
                args.push(match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) })
              } else {
                return todo("optional parameters")
              }
            }

            val nextLocal = self._ctx.nextLocal()
            self._currentFn.block.append(Instruction.Call(
              dst: Some(Dest(name: "%$nextLocal", ty: QbeType.Pointer)),
              fn: "\$${fnVal.name}",
              args: args,
            ))

            Ok(Value.Ident(nextLocal, QbeType.Pointer))
          }
          _ => todo("non-method invokees", node.token.position)
        }
      }
      TypedAstNodeKind.Array => todo("compiling array expression", node.token.position)
      TypedAstNodeKind.Set => todo("compiling set expression", node.token.position)
      TypedAstNodeKind.Map => todo("compiling map expression", node.token.position)
      TypedAstNodeKind.Tuple => todo("compiling tuple expression", node.token.position)
      TypedAstNodeKind.Indexing => todo("compiling indexing expression", node.token.position)
      TypedAstNodeKind.Lambda => todo("compiling lambda expression", node.token.position)
      TypedAstNodeKind.Assignment => todo("compiling assignment stmt", node.token.position)
      TypedAstNodeKind.If => todo("compiling if stmt/expr", node.token.position)
      TypedAstNodeKind.Match => todo("compiling match stmt/expr", node.token.position)
      _ => unreachable("node must be a statement", node.token.position)
    }
  }

  func _constructString(self, ptrVal: Value, lenVal: Value): Result<Value, CompileError> {
    val fn = match self._getOrCompileStructInitializer(self._project.preludeStringStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val structTy = if fn.returnType |ty| ty else return unreachable("initializer functions must have return types specified")

    val nextLocal = self._ctx.nextLocal()
    self._currentFn.block.append(Instruction.Call(
      dst: Some(Dest(name: "%$nextLocal", ty: structTy)),
      fn: "\$${fn.name}",
      args: [lenVal, ptrVal]
    ))

    val _stringTypeQbe = match self._getOrAddQbeTypeForType(Type(kind: TypeKind.PrimitiveString)) { Ok(v) => v, Err(e) => return Err(e) }
    val stringTypeQbe = if _stringTypeQbe |ty| ty else return unreachable("string qbe type should exist")
    Ok(Value.Ident(nextLocal, stringTypeQbe))
  }

  func _getOrAddQbeTypeForType(self, ty: Type): Result<QbeType?, CompileError> {
    match ty.kind {
      TypeKind.PrimitiveUnit => Ok(None)
      TypeKind.PrimitiveInt => Ok(Some(QbeType.U64))
      TypeKind.PrimitiveFloat => Ok(Some(QbeType.F64))
      TypeKind.PrimitiveBool => todo("TypeKind.PrimitiveBool")
      TypeKind.PrimitiveString => Ok(Some(QbeType.Pointer))
      TypeKind.Never => Ok(None)
      TypeKind.Any => todo("TypeKind.Any")
      TypeKind.Generic(name) => unreachable("attempting to resolve qbe type for generic $name")
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => {
            // moduleId == 1 -> "_intrinsics" module
            if struct.moduleId == 1 {
              if struct.label.name == "Byte" return Ok(Some(QbeType.U8))

              if struct.label.name == "Pointer" {
                val typeArg = if generics[0] |t| t else return unreachable("Pointer<T> must have 1 type argument")
                val typeArgQbeType = match self._getOrAddQbeTypeForType(typeArg) { Ok(v) => v, Err(e) => return Err(e) }
                val ty = if typeArgQbeType |innerTy| {
                  Some(QbeType.Pointer)
                } else {
                  return unreachable("Pointer<T> type arg cannot be resolved")
                }

                return Ok(ty)
              }
            }
          }
          _ => {}
        }

        todo("TypeKind.Instance")
      }
      TypeKind.Func(paramTypes, returnType) => todo("TypeKind.Func")
      TypeKind.Type(type_) => todo("TypeKind.Type")
      TypeKind.Tuple(types) => todo("TypeKind.Tuple")
      TypeKind.Hole => unreachable("unexpected hole in emitted typed ast")
    }
  }

  func _getOrCompileStructInitializer(self, struct: Struct): Result<QbeFunction, CompileError> {
    val fnName = structInitializerFnName(struct)
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val fn = self._builder.buildFunction(name: fnName, returnType: Some(QbeType.Pointer))
    fn.meta.push("type ${struct.label.name} {")
    var size = 0
    for field in struct.fields {
      val _fieldTy = match self._getOrAddQbeTypeForType(field.ty) { Ok(v) => v, Err(e) => return Err(e) }
      val fieldTy = if _fieldTy |fieldTy| fieldTy else return unreachable("unacceptable type for field", field.name.position)
      size += fieldTy.size()
      fn.parameters.push((field.name.name, fieldTy))
      fn.meta.push("  ${field.name.name}: ${field.ty.repr()}")
    }
    fn.meta.push("}")

    val sizeVal = Value.Int(size)
    fn.block.append(Instruction.Call(dst: Some(Dest(name: "%mem", ty: QbeType.Pointer)), fn: "\$malloc", args: [sizeVal]))

    val memLocal = Value.Ident("mem", QbeType.Pointer)

    var offset = 0
    for field in struct.fields {
      val _fieldTy = match self._getOrAddQbeTypeForType(field.ty) { Ok(v) => v, Err(e) => return Err(e) }
      val fieldTy = if _fieldTy |fieldTy| fieldTy else return unreachable("unacceptable type for field", field.name.position)
      val param = Value.Ident(field.name.name, fieldTy)

      val localName = "mem_offset_${field.name.name}"
      fn.block.append(Instruction.Add(dst: Dest(name: "%$localName", ty: QbeType.Pointer), r: Value.Int(offset), l: memLocal))
      val memCursorLocal = Value.Ident(localName, QbeType.Pointer)
      fn.block.append(Instruction.StoreL(value: param, mem: memCursorLocal))
      offset += fieldTy.size()
    }

    fn.block.append(Instruction.Return(Some(memLocal)))

    Ok(fn)
  }

  func _getOrCompileMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val _t = match getInstanceTypeForType(self._project, selfType) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val fnMetaNameParts: String[] = []
    val methodName = match selfTy {
      StructOrEnum.Struct(struct) => {
        if struct == self._project.preludeStringStruct {
          if fn.label.name == "toString" {
            return self._getOrCompileStringToStringMethod()
          }
        }

        fnMetaNameParts.push(struct.label.name)
        fnMetaNameParts.push("#")
        fnMetaNameParts.push(fn.label.name)
        methodFnName(struct, fn)
      }
      StructOrEnum.Enum => return todo("enum methods")
    }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val returnTypeQbe = match self._getOrAddQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val fnVal = self._builder.buildFunction(name: methodName, returnType: returnTypeQbe)

    val _selfTyQbe = match self._getOrAddQbeTypeForType(selfType) { Ok(v) => v, Err(e) => return Err(e) }
    val selfTyQbe = if _selfTyQbe |selfTyQbe| selfTyQbe else return unreachable("unacceptable type for self")
    fnVal.parameters.push(("self", selfTyQbe))
    val argsMeta = ["self"]

    for param in fn.params {
      val _paramTy = match self._getOrAddQbeTypeForType(param.ty) { Ok(v) => v, Err(e) => return Err(e) }
      val paramTy = if _paramTy |paramTy| paramTy else return unreachable("unacceptable type for param", param.label.position)
      fnVal.parameters.push((param.label.name, paramTy))

      argsMeta.push("${param.label.name}: ${param.ty.repr()}")
    }

    fnMetaNameParts.push("(")
    fnMetaNameParts.push(argsMeta.join(", "))
    fnMetaNameParts.push("): ${fn.returnType.repr()}")
    fnVal.meta.push(fnMetaNameParts.join())

    todo("rest of _getOrCompileMethod")
  }

  func _getOrCompileToStringMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val _t = match getInstanceTypeForType(self._project, ty) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val _p = match selfTy {
      StructOrEnum.Struct(struct) => {

        if struct == self._project.preludeStringStruct {
          return self._getOrCompileStringToStringMethod()
        }

        val _fn = struct.instanceMethods.find(m => m.label.name == "toString")
        val fn = if _fn |f| f else return unreachable("every struct has a toString method defined")

        (methodFnName(struct, fn), fn)
      }
      StructOrEnum.Enum => return todo("enum methods")
    }
    // TODO: destructuring
    val methodName = _p[0]
    val fn = _p[1]
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    todo("_getOrCompileToStringMethod implementation")
  }

  func _getOrCompileStringToStringMethod(self): Result<QbeFunction, CompileError> {
    val _stringTypeQbe = match self._getOrAddQbeTypeForType(Type(kind: TypeKind.PrimitiveString)) { Ok(v) => v, Err(e) => return Err(e) }
    val stringTypeQbe = if _stringTypeQbe |ty| ty else return unreachable("string qbe type should exist")

    val typeName = structTypeName(self._project.preludeStringStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    fnVal.meta.push("String#toString(self): String")
    fnVal.parameters.push(("self", stringTypeQbe))

    fnVal.block.append(Instruction.Return(Some(Value.Ident("self", stringTypeQbe))))

    Ok(fnVal)
  }
}

func todo<V>(message: String, position = Position(line: 0, col: 0)): Result<V, CompileError> = Err(CompileError(position: position, kind: CompileErrorKind.NotYetImplemented(message)))
func unreachable<V>(message: String, position = Position(line: 0, col: 0)): Result<V, CompileError> = Err(CompileError(position: position, kind: CompileErrorKind.Unreachable(message)))
