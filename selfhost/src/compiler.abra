import "fs" as fs
import Position from "./lexer"
import LiteralAstNode, BinaryOp, AssignOp, BindingPattern from "./parser"
import Project, TypedModule, TypedAstNode, TypedAstNodeKind, Type, TypeKind, Struct, StructOrEnum, TypedInvokee, Function, FunctionKind, Decorator, AccessorPathSegment, TypedIdentifierKind, TypedAssignmentMode from "./typechecker"
import ModuleBuilder, QbeType, Dest, QbeFunction, Value, Label from "./qbe"

type CompilationError {
  modulePath: String
  error: CompileError

  func getMessage(self): String {
    val contents = match fs.readFile(self.modulePath) {
      Ok(v) => v
      Err => return "Could not read file '${self.modulePath}'"
    }
    self.error.getMessage(self.modulePath, contents)
  }
}

type CompileError {
  position: Position
  kind: CompileErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      CompileErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      CompileErrorKind.Unreachable(message) => {
        lines.push("Unreachable code reached")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Internal error: $message")
      }
      CompileErrorKind.QbeError(message) => {
        // todo: somehow thread the `node` which generated the error through to the error message
        lines.push("Encountered error while generating qbe code:")
        lines.push(message)
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum CompileErrorKind {
  NotYetImplemented(reason: String)
  Unreachable(message: String)
  QbeError(message: String)
}

func qbeError<V>(message: String): Result<V, CompileError> = Err(CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(message)))

// Each module's root code is wrapped in a specially-named function; this function name
// starts with two dots, which is not possible in ordinary Abra source code and will
// thus introduce no conflicts (qbe doesn't care about function name rules).
func moduleWrapperFnName(module: TypedModule): String = "..module_${module.id}"

func structTypeName(struct: Struct): String = ".${struct.moduleId}.${struct.label.name}"
func structInitializerFnName(struct: Struct): String = "${structTypeName(struct)}.init"

func fnName(fn: Function): String = ".${fn.label.name}"
func methodFnName(struct: Struct, fn: Function): String {
  val typeName = structTypeName(struct)
  val sep = match fn.kind {
    FunctionKind.InstanceMethod => ".."
    _ => "."
  }
  "${typeName}${sep}${fn.label.name}"
}

func fnSignature(structOrEnum: StructOrEnum?, fn: Function): String {
  val parts: String[] = []
  match structOrEnum {
    StructOrEnum.Struct(struct) => {
      parts.push(struct.label.name)
      parts.push(if fn.kind == FunctionKind.InstanceMethod "#" else ".")
    }
    StructOrEnum.Enum => return "todo: enum methods"
    None => {}
  }
  parts.push(fn.label.name)
  parts.push("(")

  val args: String[] = []
  if fn.kind == FunctionKind.InstanceMethod args.push("self")
  for param in fn.params {
    args.push("${param.label.name}: ${param.ty.repr()}")
  }
  parts.push(args.join(", "))
  parts.push(")")

  if fn.returnType.kind != TypeKind.PrimitiveUnit {
    parts.push(": ${fn.returnType.repr()}")
  }

  parts.join()
}

func structSignature(struct: Struct): String[] {
  val parts = ["type ${struct.label.name} {"]
  for field in struct.fields {
    parts.push("  ${field.name.name}: ${field.ty.repr()}")
  }
  parts.push("}")

  parts
}

func getInstanceTypeForType(project: Project, ty: Type): Result<(StructOrEnum, Type[]), CompileError> {
  match ty.kind {
    TypeKind.Any => unreachable("getInstanceTypeForType: Any")
    TypeKind.PrimitiveUnit => unreachable("getInstanceTypeForType: Unit")
    TypeKind.PrimitiveInt => Ok((StructOrEnum.Struct(project.preludeIntStruct), []))
    TypeKind.PrimitiveFloat => Ok((StructOrEnum.Struct(project.preludeFloatStruct), []))
    TypeKind.PrimitiveBool => Ok((StructOrEnum.Struct(project.preludeBoolStruct), []))
    TypeKind.PrimitiveString => Ok((StructOrEnum.Struct(project.preludeStringStruct), []))
    TypeKind.Never => unreachable("getInstanceTypeForType: Never")
    TypeKind.Generic(name) => unreachable("getInstanceTypeForType: Generic($name)")
    TypeKind.Instance(structOrEnum, typeParams) => Ok((structOrEnum, typeParams))
    TypeKind.Tuple(types) => todo("getInstanceTypeForType: Tuple${types.length}")
    TypeKind.Func(_paramTypes, _returnType) => todo("getInstanceTypeForType: Func")
    TypeKind.Type(structOrEnum) => Ok((structOrEnum, []))
    TypeKind.Hole => unreachable("getInstanceTypeForType: Hole")
  }
}

export type Compiler {
  _project: Project
  _builder: ModuleBuilder
  _currentModule: TypedModule
  _currentFn: QbeFunction
  // cached fns
  _printf: QbeFunction = QbeFunction.spec(name: "printf", returnType: None, parameters: [], variadicIdx: Some(1))
  _snprintf: QbeFunction = QbeFunction.spec(name: "snprintf", returnType: Some(QbeType.U64), parameters: [], variadicIdx: Some(3))
  _malloc: QbeFunction = QbeFunction.spec(name: "malloc", returnType: Some(QbeType.Pointer))
  _realloc: QbeFunction = QbeFunction.spec(name: "realloc", returnType: Some(QbeType.Pointer))

  func compile(project: Project, entry: TypedModule): Result<ModuleBuilder, CompilationError> {
    val builder = ModuleBuilder()

    val fn = builder.buildFunction(name: "main", returnType: Some(QbeType.U32), exported: true)
    fn.addComment("main entrypoint function")
    val mainFnBlock = fn.block

    val compiler = Compiler(_project: project, _builder: builder, _currentModule: entry, _currentFn: fn)

    val moduleFn = match compiler._compileModule(entry) { Ok(v) => v, Err(e) => return Err(CompilationError(modulePath: entry.name, error: e)) }
    val modFnName = moduleWrapperFnName(entry)
    mainFnBlock.buildVoidCall(moduleFn, [])
    mainFnBlock.buildReturn(Some(Value.Int(0)))

    match mainFnBlock.verify() { Ok(v) => v, Err(e) => return Err(CompilationError(modulePath: entry.name, error: CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(e)))) }

    Ok(builder)
  }

  func _compileModule(self, module: TypedModule): Result<QbeFunction, CompileError> {
    val modFnName = moduleWrapperFnName(module)
    self._currentModule = module

    val fn = self._builder.buildFunction(name: modFnName, returnType: None)
    fn.addComment(module.name)

    self._currentFn = fn

    for node, idx in module.code {
      val value = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
      // If the last statement in the module is an expression, call the `toString` method on that expression, and print the result using `printf`.
      if idx == module.code.length - 1 && node.ty.kind != TypeKind.PrimitiveUnit {
        if value |v| {
          self._currentFn.block.addComment("call `toString` on final expression, and `printf` the String's chars")
          val dataPtr = self._builder.buildGlobalString("%s\\n")
          val tostringMethod = match self._getOrCompileToStringMethod(node.ty) { Ok(v) => v, Err(e) => return Err(e) }

          val tostringRepr = match self._currentFn.block.buildCall(tostringMethod, [v], Some("_to_string_repr")) { Ok(v) => v, Err(e) => return qbeError(e) }
          val reprCharsPtr = match self._currentFn.block.buildAdd(Value.Int(8), tostringRepr, Some("_repr_chars_ptr")) { Ok(v) => v, Err(e) => return qbeError(e) }
          val reprChars = self._currentFn.block.buildLoadL(reprCharsPtr, Some("_repr_chars"))
          self._currentFn.block.buildVoidCall(self._printf, [dataPtr, reprChars])
        }
      }
    }

    fn.block.buildReturn()

    match fn.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    Ok(fn)
  }

  func _compileStatement(self, node: TypedAstNode): Result<Value?, CompileError> {
    match node.kind {
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, elseBlock) => {
        if !isStatement {
          val res = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
          return Ok(Some(res))
        }
        if conditionBinding return todo("condition bindings in if-stmt", node.token.position)

        val condVal = match self._compileExpression(cond) { Ok(v) => v, Err(e) => return Err(e) }

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        self._currentFn.block.buildJnz(condVal, labelThen, if elseBlock.isEmpty() labelCont else labelElse)

        self._currentFn.block.registerLabel(labelThen)
        for node in ifBlock {
          match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
        }
        self._currentFn.block.buildJmp(labelCont)

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node in elseBlock {
            match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
          }
          self._currentFn.block.buildJmp(labelCont)
        }

        self._currentFn.block.registerLabel(labelCont)

        Ok(None)
      }
      TypedAstNodeKind.Match => todo("compiling match stmt/expr", node.token.position)
      TypedAstNodeKind.While => todo("compiling while-loop", node.token.position)
      TypedAstNodeKind.For => todo("compiling for-loop", node.token.position)
      TypedAstNodeKind.BindingDeclaration(bindingDeclNode) => {
        val bindingName = match bindingDeclNode.bindingPattern {
          BindingPattern.Variable(label) => label.name
        }

        if bindingDeclNode.expr |expr| {
          val res = match self._compileExpression(expr, Some(bindingName)) { Ok(v) => v, Err(e) => return Err(e) }
        }

        Ok(None)
      }
      TypedAstNodeKind.FunctionDeclaration => todo("compiling function declaration", node.token.position)
      TypedAstNodeKind.TypeDeclaration => todo("compiling type declaration", node.token.position)
      TypedAstNodeKind.EnumDeclaration => todo("compiling enum declaration", node.token.position)
      TypedAstNodeKind.Break => todo("compiling break statement", node.token.position)
      TypedAstNodeKind.Continue => todo("compiling continue statement", node.token.position)
      TypedAstNodeKind.Return => todo("compiling return statement", node.token.position)
      TypedAstNodeKind.Placeholder => unreachable("placeholder ast node emitted from typechecker", node.token.position)
      TypedAstNodeKind.Assignment(mode, op, expr) => {
        match mode {
          TypedAssignmentMode.Variable(variable) => return todo("compiling variable assignment stmt", node.token.position)
          TypedAssignmentMode.Indexing(_node) => return todo("compiling indexing assignment stmt", node.token.position)
          TypedAssignmentMode.Accessor(head, middle, tail) => {
            val ptr = match self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: false) { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }

            // TODO: this only works for int-assignable (ie. Int and Pointer types, not Bool or Float types)
            self._currentFn.block.buildStoreL(res, ptr)
            Ok(None) // should be unused, as assignment nodes are treated as statements rather than expressions
          }
        }
      }
      _ => {
        val v = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
        if node.ty.kind == TypeKind.PrimitiveUnit {
          Ok(None)
        } else {
          Ok(Some(v))
        }
      }
    }
  }

  func _compileExpression(self, node: TypedAstNode, resultLocalName: String? = None): Result<Value, CompileError> {
    match node.kind {
      TypedAstNodeKind.Literal(lit) => {
        match lit {
          LiteralAstNode.Int(v) => {
            val res = match self._currentFn.block.buildAdd(Value.Int(0), Value.Int(v), resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          LiteralAstNode.Float(f) => {
            val res = match self._currentFn.block.buildAdd(Value.Float(0.0), Value.Float(f)) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          LiteralAstNode.Bool(b) => {
            val res = match self._currentFn.block.buildAdd(Value.Int32(0), Value.Int32(if b 1 else 0)) { Ok(v) => v, Err(e) => return qbeError(e) }
            self._currentFn.block.addCommentBefore(b.toString())
            Ok(res)
          }
          LiteralAstNode.String(s) => {
            val dataPtr = self._builder.buildGlobalString(s)
            val instancePtr = match self._constructString(dataPtr, Value.Int(s.length)) { Ok(v) => v, Err(e) => return Err(e) }
            Ok(instancePtr)
          }
        }
      }
      TypedAstNodeKind.StringInterpolation => todo("compiling string interpolation expression", node.token.position)
      TypedAstNodeKind.Unary => todo("compiling unary expression", node.token.position)
      TypedAstNodeKind.Binary(left, op, right) => {
        match op {
          BinaryOp.Add => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if left.ty.kind == TypeKind.PrimitiveInt || left.ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeIntStruct), []) {
              val res = match self._currentFn.block.buildAdd(leftVal, rightVal) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              return todo("compiling non-Int Add")
            }
          }
          BinaryOp.Sub => todo("compiling binary expression: Sub", node.token.position)
          BinaryOp.Mul => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if left.ty.kind == TypeKind.PrimitiveInt || left.ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeIntStruct), []) {
              val res = match self._currentFn.block.buildMul(leftVal, rightVal) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              return todo("compiling non-Int Mul")
            }
          }
          BinaryOp.Div => todo("compiling binary expression: Div", node.token.position)
          BinaryOp.Mod => todo("compiling binary expression: Mod", node.token.position)
          BinaryOp.Pow => todo("compiling binary expression: Pow", node.token.position)
          BinaryOp.And => todo("compiling binary expression: And", node.token.position)
          BinaryOp.Or => todo("compiling binary: Or expression", node.token.position)
          BinaryOp.Xor => todo("compiling binary expression: Xor", node.token.position)
          BinaryOp.Coalesce => todo("compiling binary expression: Coalesce", node.token.position)
          BinaryOp.Eq => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if left.ty.kind == TypeKind.PrimitiveInt || left.ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeIntStruct), []) {
              val res = match self._currentFn.block.buildCompareEq(leftVal, rightVal) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              return todo("compiling non-Int Eq")
            }
          }
          BinaryOp.Neq => todo("compiling binary expression: Neq", node.token.position)
          BinaryOp.LT => todo("compiling binary expression: LT", node.token.position)
          BinaryOp.LTE => todo("compiling binary expression: LTE", node.token.position)
          BinaryOp.Shl => todo("compiling binary expression: Shl", node.token.position)
          BinaryOp.GT => todo("compiling binary expression: GT", node.token.position)
          BinaryOp.GTE => todo("compiling binary expression: GTE", node.token.position)
          BinaryOp.Shr => todo("compiling binary expression: Shr", node.token.position)
        }
      }
      TypedAstNodeKind.Grouped(inner) => self._compileExpression(inner)
      TypedAstNodeKind.Identifier(kind) => {
        match kind {
          TypedIdentifierKind.Named(name, variable) => {
            // TODO: This assumes that every variable will be available as a `%local` within the block. Make sure to test this assumption
            //       (eg. captured variables in closures, global variables, etc).
            val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
            Ok(Value.Ident(name, varTy))
          }
          _ => todo("other identifier kinds (${node.token})", node.token.position)
        }
      }
      TypedAstNodeKind.Accessor(head, middle, tail) => self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: true)
      TypedAstNodeKind.Invocation(invokee, arguments) => {
        match invokee {
          TypedInvokee.Function(fn) => {
            if fn.label.name == "println" return self._invokePrintln(arguments)

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "Intrinsic")
            if intrinsicDec |dec| return self._invokeIntrinsicFn(dec, fn, arguments)

            val cBindingDec = fn.decorators.find(dec => dec.label.name == "CBinding")
            if cBindingDec |dec| return self._invokeCBindingFn(dec, fn, arguments)

            match fn.kind {
              FunctionKind.StaticMethod(parentTy) => {
                val fnVal = match self._getOrCompileMethod(Type(kind: TypeKind.Type(parentTy)), fn) { Ok(v) => v, Err(e) => return Err(e) }

                val args: Value[] = []
                for arg in arguments {
                  if arg |node| {
                    val arg = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
                    args.push(arg)
                  } else {
                    return todo("optional parameters")
                  }
                }

                val res = match self._currentFn.block.buildCall(fnVal, args) { Ok(v) => v, Err(e) => return qbeError(e) }

                Ok(res)
              }
              FunctionKind.Standalone => {
                val fnVal = match self._getOrCompileFunction(fn) { Ok(v) => v, Err(e) => return Err(e) }

                val args: Value[] = []
                for arg in arguments {
                  if arg |node| {
                    val arg = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
                    args.push(arg)
                  } else {
                    return todo("optional parameters")
                  }
                }

                val res = if fnVal.returnType {
                  val res = match self._currentFn.block.buildCall(fnVal, args) { Ok(v) => v, Err(e) => return qbeError(e) }
                  res
                } else {
                  self._currentFn.block.buildVoidCall(fnVal, args)
                  Value.Ident("bogus", QbeType.F32)
                }

                Ok(res)
              }
              _ => todo("standalone functions", node.token.position)
            }
          }
          TypedInvokee.Method(fn, selfVal, isOptSafe) => {
            if isOptSafe return todo("opt-safe method invocation", node.token.position)

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "Intrinsic")
            if intrinsicDec |dec| return self._invokeIntrinsicFn(dec, fn, [Some(selfVal)].concat(arguments))

            val fnVal = match self._getOrCompileMethod(selfVal.ty, fn) { Ok(v) => v, Err(e) => return Err(e) }

            val args: Value[] = []
            args.push(match self._compileExpression(selfVal) { Ok(v) => v, Err(e) => return Err(e) })
            for arg in arguments {
              if arg |node| {
                val arg = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
                args.push(arg)
              } else {
                return todo("optional parameters")
              }
            }

            val res = if fnVal.returnType {
              val res = match self._currentFn.block.buildCall(fnVal, args) { Ok(v) => v, Err(e) => return qbeError(e) }
              res
            } else {
              self._currentFn.block.buildVoidCall(fnVal, args)
              Value.Ident("bogus", QbeType.F32)
            }

            Ok(res)
          }
          TypedInvokee.Struct(struct) => {
            val fnVal = match self._getOrCompileStructInitializer(struct) { Ok(v) => v, Err(e) => return Err(e) }

            val args: Value[] = []
            for arg in arguments {
              if arg |node| {
                val arg = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
                args.push(arg)
              } else {
                return todo("optional parameters")
              }
            }

            val res = match self._currentFn.block.buildCall(fnVal, args) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          _ => todo("non-method invokees", node.token.position)
        }
      }
      TypedAstNodeKind.Array(items) => {
        val arrayWithCapacityFn = if self._project.preludeArrayStruct.staticMethods.find(m => m.label.name == "withCapacity") |fn| fn else return unreachable("Array.withCapacity must exist")
        val arrayWithCapacityFnVal = match self._getOrCompileMethod(node.ty, arrayWithCapacityFn) { Ok(v) => v, Err(e) => return Err(e) }

        val sizeVal = Value.Int(items.length.nextPowerOf2())
        val arrayInstance = match self._currentFn.block.buildCall(arrayWithCapacityFnVal, [sizeVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.addCommentBefore("${arrayInstance.repr()}: ${node.ty.repr()}")

        val arrayPushFn = if self._project.preludeArrayStruct.instanceMethods.find(m => m.label.name == "push") |fn| fn else return unreachable("Array#push must exist")
        val arrayPushFnVal = match self._getOrCompileMethod(node.ty, arrayPushFn) { Ok(v) => v, Err(e) => return Err(e) }

        for item in items {
          val itemVal = match self._compileExpression(item) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildVoidCall(arrayPushFnVal, [arrayInstance, itemVal])
        }

        Ok(arrayInstance)
      }
      TypedAstNodeKind.Set => todo("compiling set expression", node.token.position)
      TypedAstNodeKind.Map => todo("compiling map expression", node.token.position)
      TypedAstNodeKind.Tuple => todo("compiling tuple expression", node.token.position)
      TypedAstNodeKind.Indexing => todo("compiling indexing expression", node.token.position)
      TypedAstNodeKind.Lambda => todo("compiling lambda expression", node.token.position)
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, elseBlock) => {
        if isStatement return unreachable("if-statements are handled elsewhere", node.token.position)
        if conditionBinding return todo("condition bindings in if-stmt", node.token.position)

        val condVal = match self._compileExpression(cond) { Ok(v) => v, Err(e) => return Err(e) }

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        if elseBlock.isEmpty() return unreachable("if-expressions must not have empty else-blocks", node.token.position)
        self._currentFn.block.buildJnz(condVal, labelThen, labelElse)

        val phiCases: (Label, Value)[] = []

        self._currentFn.block.registerLabel(labelThen)
        for node, idx in ifBlock {
          if idx == ifBlock.length - 1 {
            val res = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
            phiCases.push((labelThen, res))
          } else {
            match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
          }
        }
        self._currentFn.block.buildJmp(labelCont)

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node, idx in elseBlock {
            if idx == elseBlock.length - 1 {
              val res = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
              phiCases.push((labelElse, res))
            } else {
              match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
            }
          }
          self._currentFn.block.buildJmp(labelCont)
        }

        self._currentFn.block.registerLabel(labelCont)

        val res = match self._currentFn.block.buildPhi(phiCases, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }

        Ok(res)
      }
      TypedAstNodeKind.Match => todo("compiling match stmt/expr", node.token.position)
      _ => unreachable("node must be a statement", node.token.position)
    }
  }

  func _constructString(self, ptrVal: Value, lenVal: Value): Result<Value, CompileError> {
    val fnVal = match self._getOrCompileStructInitializer(self._project.preludeStringStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val structTy = if fnVal.returnType |ty| ty else return unreachable("initializer functions must have return types specified")

    val res = match self._currentFn.block.buildCall(fnVal, [lenVal, ptrVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
    self._currentFn.block.addCommentBefore("${res.repr()}: String")
    Ok(res)
  }

  func _getQbeTypeForType(self, ty: Type): Result<QbeType?, CompileError> {
    match ty.kind {
      TypeKind.PrimitiveUnit => Ok(None)
      TypeKind.PrimitiveInt => Ok(Some(QbeType.U64))
      TypeKind.PrimitiveFloat => Ok(Some(QbeType.F64))
      TypeKind.PrimitiveBool => Ok(Some(QbeType.U32))
      TypeKind.PrimitiveString => Ok(Some(QbeType.Pointer))
      TypeKind.Never => Ok(None)
      TypeKind.Any => todo("TypeKind.Any")
      TypeKind.Generic(name) => {
        // println("[warn] using QbeType.U64 as type for generic '$name' in type '${ty.repr()}'")
        // unreachable("attempting to resolve qbe type for generic $name")
        Ok(Some(QbeType.U64))
      }
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => {
            // moduleId == 1 -> "_intrinsics" module
            if struct.moduleId == 1 {
              if struct.label.name == "Byte" return Ok(Some(QbeType.U8))

              if struct.label.name == "Pointer" {
                // val typeArg = if generics[0] |t| t else return unreachable("Pointer<T> must have 1 type argument")
                // val typeArgQbeType = match self._getQbeTypeForType(typeArg) { Ok(v) => v, Err(e) => return Err(e) }
                // val ty = if typeArgQbeType |innerTy| {
                  val ty = Some(QbeType.Pointer)
                // } else {
                //   return unreachable("Pointer<T> type arg cannot be resolved")
                // }

                return Ok(ty)
              }
            }
          }
          _ => {}
        }

        Ok(Some(QbeType.Pointer))
      }
      TypeKind.Func(paramTypes, returnType) => todo("TypeKind.Func")
      TypeKind.Type(type_) => todo("TypeKind.Type")
      TypeKind.Tuple(types) => todo("TypeKind.Tuple")
      TypeKind.Hole => unreachable("unexpected hole in emitted typed ast")
    }
  }

  func _getQbeTypeForTypeExpect(self, ty: Type, reason: String, position: Position? = None): Result<QbeType, CompileError> {
    val _ty = match self._getQbeTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    if _ty |ty| Ok(ty) else if position |pos| unreachable(reason, pos) else unreachable(reason)
  }

  func _followAccessorPath(self, head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment, loadFinal: Bool): Result<Value, CompileError> {
    // TODO: assert that `head.ty` is a pointer type (attempting to do pointer arithmetic later on will fail otherwise)
    val _t = match getInstanceTypeForType(self._project, head.ty) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    var instTy = _t[0]
    val _typeArgs = _t[1]

    var curVal = match self._compileExpression(head) { Ok(v) => v, Err(e) => return Err(e) }
    self._currentFn.block.addCommentBefore("${curVal.repr()}: ${head.ty.repr()}")

    val segs = middle.concat([tail])
    for seg, idx in segs {
      match seg {
        AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => return todo("enum variant accessor")
        AccessorPathSegment.Method(label, fn) => return todo("method accessor")
        AccessorPathSegment.Field(label, ty, field) => {
          match instTy {
            StructOrEnum.Struct(struct) => {
              var offset = 0
              for f in struct.fields {
                if f.name.name == field.name.name break

                val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
                offset += fieldTy.size()
              }

              val ptr = match self._currentFn.block.buildAdd(Value.Int(offset), curVal) { Ok(v) => v, Err(e) => return qbeError(e) }
              if idx == segs.length - 1 && !loadFinal {
                curVal = ptr
              } else {
                val nextVal = self._currentFn.block.buildLoadL(ptr)
                self._currentFn.block.addCommentBefore("${nextVal.repr()}: ${curVal.repr()}.${field.name.name}")
                curVal = nextVal
              }
            }
            StructOrEnum.Enum(_enum) => return todo("enum field accessor")
          }
        }
      }
    }

    Ok(curVal)
  }

  func _getOrCompileStructInitializer(self, struct: Struct): Result<QbeFunction, CompileError> {
    val fnName = structInitializerFnName(struct)
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val fn = self._builder.buildFunction(name: fnName, returnType: Some(QbeType.Pointer))
    val prevFn = self._currentFn
    self._currentFn = fn

    fn.addCommentMultiline(structSignature(struct))
    var size = 0
    for field in struct.fields {
      val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
      size += fieldTy.size()
      fn.addParameter(field.name.name, fieldTy)
    }

    val memLocal = match fn.block.buildCall(self._malloc, [Value.Int(size)], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

    var offset = 0
    for field in struct.fields {
      val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
      val param = Value.Ident(field.name.name, fieldTy)

      val localName = "mem_offset_${field.name.name}"
      val memCursorLocal = match fn.block.buildAdd(Value.Int(offset), memLocal, Some(localName)) { Ok(v) => v, Err(e) => return qbeError(e) }
      fn.block.buildStoreL(param, memCursorLocal)

      offset += fieldTy.size()
    }

    fn.block.buildReturn(Some(memLocal))

    match fn.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fn)
  }

  func _invokePrintln(self, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    self._currentFn.block.addComment("begin println...")
    val varargItems = if arguments[0] |node| {
      if node |node| {
        val items = match node.kind {
          TypedAstNodeKind.Array(items) => items
          _ => return unreachable("`println` receives an array of its variadic arguments")
        }
        items
      } else return unreachable("`println` receives an array of its variadic arguments")
    } else []

    val stdoutWriteFn = if self._project.preludeScope.functions.find(fn => fn.label.name == "stdoutWrite") |fn| fn else return unreachable("`stdoutWrite` must exist in prelude")
    val stdoutWriteFnVal = match self._getOrCompileFunction(stdoutWriteFn) { Ok(v) => v, Err(e) => return Err(e) }

    val space = self._builder.buildGlobalString(" ")
    val spaceStr = match self._constructString(space, Value.Int(1)) { Ok(v) => v, Err(e) => return Err(e) }
    val newline = self._builder.buildGlobalString("\\n")
    val newlineStr = match self._constructString(newline, Value.Int(1)) { Ok(v) => v, Err(e) => return Err(e) }

    for item, idx in varargItems {
      val itemVal = match self._compileExpression(item) { Ok(v) => v, Err(e) => return Err(e) }
      val itemToStringFnVal = match self._getOrCompileToStringMethod(item.ty) { Ok(v) => v, Err(e) => return Err(e) }
      val toStringVal = match self._currentFn.block.buildCall(itemToStringFnVal, [itemVal]) { Ok(v) => v, Err(e) => return qbeError(e) }

      self._currentFn.block.buildVoidCall(stdoutWriteFnVal, [toStringVal])

      if idx == varargItems.length - 1 {
        self._currentFn.block.buildVoidCall(stdoutWriteFnVal, [newlineStr])
      } else {
        self._currentFn.block.buildVoidCall(stdoutWriteFnVal, [spaceStr])
      }
    }
    self._currentFn.block.addComment("...println end")

    Ok(Value.Ident("bogus", QbeType.F32))
  }

  func _invokeCBindingFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val cFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => return unreachable("@CBinding decorator requires 1 string argument for the name")
    }

    val args: Value[] = []
    for arg in arguments {
      if arg |node| {
        val arg = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
        args.push(arg)
      } else {
        return unreachable("functions with @CBinding decorator cannot have optional parameters")
      }
    }

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val res = if returnTypeQbe |returnTy| {
      val res = match self._currentFn.block.buildCallRaw(cFnName, returnTy, args) { Ok(v) => v, Err(e) => return qbeError(e) }
      res
    } else {
      self._currentFn.block.buildVoidCallRaw(cFnName, args)
      Value.Ident("bogus", QbeType.F32)
    }
    Ok(res)
  }

  func _invokeIntrinsicFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val intrinsicFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => return unreachable("@Intrinsic decorator requires 1 string argument for the name")
    }

    match intrinsicFnName {
      "pointer_malloc" => {
        self._currentFn.block.addComment("begin pointer_malloc...")

        val _count = if arguments[0] |arg| arg else return unreachable("'pointer_malloc' has 1 required argument")
        val count = if _count |arg| arg else return unreachable("'pointer_malloc' has 1 required argument")
        val countVal = match self._compileExpression(count) { Ok(v) => v, Err(e) => return Err(e) }

        // TODO: this assumes a size of 8 bytes for each type that could be allocated with `Pointer.malloc` - this is of course valid
        //       for ints (Int values in Abra are 64 bits at the moment), floats (Float values are 64 bits as well), and pointers (all
        //       non-primitive values are heap-allocated and passed by reference), but _not_ for booleans. It may become necessary to
        //       treat boolean values as 64-bit integers when used as a generic argument (which would be wasteful, but would greatly
        //       simply this implementation), or else have a special "generic-resolution" strategy to mimic the reference
        //       implementation (this comes at great cost in complexity, imo).
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(8), countVal) { Ok(v) => v, Err(e) => return qbeError(e) }
        val mem = match self._currentFn.block.buildCall(self._malloc, [sizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_malloc end")

        Ok(mem)
      }
      "pointer_realloc" => {
        self._currentFn.block.addComment("begin pointer_realloc...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _count = if arguments[1] |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val count = if _count |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val countVal = match self._compileExpression(count) { Ok(v) => v, Err(e) => return Err(e) }
        // TODO: this assumes a size of 8 bytes for each type that could be allocated with `Pointer.malloc` - this is of course valid
        //       for ints (Int values in Abra are 64 bits at the moment), floats (Float values are 64 bits as well), and pointers (all
        //       non-primitive values are heap-allocated and passed by reference), but _not_ for booleans. It may become necessary to
        //       treat boolean values as 64-bit integers when used as a generic argument (which would be wasteful, but would greatly
        //       simply this implementation), or else have a special "generic-resolution" strategy to mimic the reference
        //       implementation (this comes at great cost in complexity, imo).
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(8), countVal) { Ok(v) => v, Err(e) => return qbeError(e) }
        val mem = match self._currentFn.block.buildCall(self._malloc, [ptrVal, sizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_realloc end")

        Ok(mem)
      }
      "pointer_store" => {
        self._currentFn.block.addComment("begin pointer_store...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _value = if arguments[1] |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val value = if _value |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val valueVal = match self._compileExpression(value) { Ok(v) => v, Err(e) => return Err(e) }
        // TODO: this assumes a size of 8 bytes for each type that could be stored into a pointer (see other comments above).
        self._currentFn.block.buildStoreL(valueVal, ptrVal)

        self._currentFn.block.addComment("...pointer_store end")

        Ok(Value.Ident("bogus", QbeType.F32))
      }
      "pointer_offset" => {
        self._currentFn.block.addComment("begin pointer_offset...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _offset = if arguments[1] |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val offset = if _offset |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val offsetVal = match self._compileExpression(offset) { Ok(v) => v, Err(e) => return Err(e) }
        // TODO: this assumes a size of 8 bytes for each type that could be stored into a pointer (see other comments above).
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(8), offsetVal) { Ok(v) => v, Err(e) => return qbeError(e) }
        val mem = match self._currentFn.block.buildAdd(offsetVal, ptrVal) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_offset end")

        Ok(mem)
      }
      _ => unreachable("unsupported intrinsic '$intrinsicFnName'", fn.label.position)
    }
  }

  func _getOrCompileFunction(self, fn: Function): Result<QbeFunction, CompileError> {
    val fnName = fnName(fn)
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val fnVal = self._builder.buildFunction(name: fnName, returnType: returnTypeQbe)
    val prevFn = self._currentFn
    self._currentFn = fnVal

    for param in fn.params {
      val paramTy = match self._getQbeTypeForTypeExpect(param.ty, "unacceptable type for param", Some(param.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
      fnVal.addParameter(param.label.name, paramTy)
    }
    fnVal.addComment(fnSignature(None, fn))

    var retVal: Value? = None
    for node, idx in fn.body {
      val res = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
      if idx == fn.body.length - 1 && fn.returnType.kind != TypeKind.PrimitiveUnit {
        retVal = res
      }
    }
    fnVal.block.buildReturn(retVal)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val isInstanceMethod = match fn.kind { FunctionKind.InstanceMethod => true, _ => false }
    if isInstanceMethod && fn.label.name == "toString" && fn.isGenerated return self._getOrCompileToStringMethod(selfType)

    val _t = match getInstanceTypeForType(self._project, selfType) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val methodName = match selfTy {
      StructOrEnum.Struct(struct) => methodFnName(struct, fn)
      StructOrEnum.Enum => return todo("enum methods")
    }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val fnVal = self._builder.buildFunction(name: methodName, returnType: returnTypeQbe)
    val prevFn = self._currentFn
    self._currentFn = fnVal

    if isInstanceMethod {
      val selfTyQbe = match self._getQbeTypeForTypeExpect(selfType, "unacceptable type for self") { Ok(v) => v, Err(e) => return Err(e) }
      fnVal.addParameter("self", selfTyQbe)
    }

    for param in fn.params {
      val paramTy = match self._getQbeTypeForTypeExpect(param.ty, "unacceptable type for param", Some(param.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
      fnVal.addParameter(param.label.name, paramTy)
    }
    fnVal.addComment(fnSignature(Some(selfTy), fn))

    var retVal: Value? = None
    for node, idx in fn.body {
      val res = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
      if idx == fn.body.length - 1 && fn.returnType.kind != TypeKind.PrimitiveUnit {
        retVal = res
      }
    }
    fnVal.block.buildReturn(retVal)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileToStringMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val _t = match getInstanceTypeForType(self._project, ty) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val _p = match selfTy {
      StructOrEnum.Struct(struct) => {
        if struct == self._project.preludeIntStruct return self._getOrCompileIntToStringMethod()
        if struct == self._project.preludeFloatStruct return self._getOrCompileFloatToStringMethod()
        if struct == self._project.preludeStringStruct return self._getOrCompileStringToStringMethod()
        if struct == self._project.preludeBoolStruct return self._getOrCompileBoolToStringMethod()

        val _fn = struct.instanceMethods.find(m => m.label.name == "toString")
        val fn = if _fn |f| f else return unreachable("every struct has a toString method defined")

        (methodFnName(struct, fn), fn)
      }
      StructOrEnum.Enum => return todo("enum methods")
    }
    // TODO: destructuring
    val methodName = _p[0]
    val fn = _p[1]
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated {
      return todo("_getOrCompileToStringMethod implementation")
    }

    self._getOrCompileMethod(ty, fn)
  }

  func _getOrCompileIntToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
    val intTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = structTypeName(self._project.preludeIntStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Int#toString(self): String")
    val selfParam = fnVal.addParameter("self", intTypeQbe)

    val intFmtPtr = self._builder.buildGlobalString("%d")
    val sizeVal = match fnVal.block.buildCall(self._snprintf, [Value.Int(0), Value.Int(0), intFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }
    val mallocSizeVal = match fnVal.block.buildAdd(Value.Int(1), sizeVal) { Ok(v) => v, Err(e) => return qbeError(e) }

    val mem = match fnVal.block.buildCall(self._malloc, [mallocSizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }
    match fnVal.block.buildCall(self._snprintf, [mem, mallocSizeVal, intFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }

    val str = match self._constructString(mem, sizeVal) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(str))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileFloatToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
    val floatTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = structTypeName(self._project.preludeFloatStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Float#toString(self): String")
    val selfParam = fnVal.addParameter("self", floatTypeQbe)

    val floatFmtPtr = self._builder.buildGlobalString("%g")
    val sizeVal = match fnVal.block.buildCall(self._snprintf, [Value.Int(0), Value.Int(0), floatFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }
    val mallocSizeVal = match fnVal.block.buildAdd(Value.Int(1), sizeVal) { Ok(v) => v, Err(e) => return qbeError(e) }

    val mem = match fnVal.block.buildCall(self._malloc, [mallocSizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }
    match fnVal.block.buildCall(self._snprintf, [mem, mallocSizeVal, floatFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }

    val str = match self._constructString(mem, sizeVal) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(str))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileBoolToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
    val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = structTypeName(self._project.preludeBoolStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Bool#toString(self): String")
    val selfParam = fnVal.addParameter("self", boolTypeQbe)

    val labelIfTrue = fnVal.block.addLabel("if_true")
    val labelIfFalse = fnVal.block.addLabel("if_false")
    fnVal.block.buildJnz(selfParam, labelIfTrue, labelIfFalse)

    fnVal.block.registerLabel(labelIfTrue)
    val trueStrData = self._builder.buildGlobalString("true")
    val trueStr = match self._constructString(trueStrData, Value.Int(4)) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(trueStr))

    fnVal.block.registerLabel(labelIfFalse)
    val falseStrData = self._builder.buildGlobalString("false")
    val falseStr = match self._constructString(falseStrData, Value.Int(5)) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(falseStr))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileStringToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = structTypeName(self._project.preludeStringStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("String#toString(self): String")
    val selfParam = fnVal.addParameter("self", stringTypeQbe)
    fnVal.block.buildReturn(Some(selfParam))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }
}

func todo<V>(message: String, position = Position(line: 0, col: 0)): Result<V, CompileError> = Err(CompileError(position: position, kind: CompileErrorKind.NotYetImplemented(message)))
func unreachable<V>(message: String, position = Position(line: 0, col: 0)): Result<V, CompileError> = Err(CompileError(position: position, kind: CompileErrorKind.Unreachable(message)))
