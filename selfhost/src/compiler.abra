import "fs" as fs
import Position from "./lexer"
import LiteralAstNode, UnaryOp, BinaryOp, AssignOp, BindingPattern, IndexingMode from "./parser"
import Project, TypedModule, Scope, TypedAstNode, TypedAstNodeKind, Type, TypeKind, Field, Struct, StructOrEnum, TypedInvokee, Function, FunctionKind, Decorator, AccessorPathSegment, TypedAssignmentMode, Enum, TypedEnumVariant, EnumVariantKind, TypedIndexingNode, VariableAlias, TypedMatchCase, TypedMatchCaseKind, BuiltinModule, Variable from "./typechecker"
import ModuleBuilder, QbeType, Dest, QbeFunction, Value, Label, Callable, QbeData, QbeDataKind, Var from "./qbe"

type CompilationError {
  modulePath: String
  error: CompileError

  func getMessage(self): String {
    val contents = match fs.readFile(self.modulePath) {
      Ok(v) => v
      Err => return "Could not read file '${self.modulePath}'"
    }
    self.error.getMessage(self.modulePath, contents)
  }
}

type CompileError {
  position: Position
  kind: CompileErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      CompileErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      CompileErrorKind.Unreachable(message) => {
        lines.push("Unreachable code reached")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Internal error: $message")
      }
      CompileErrorKind.QbeError(message) => {
        // todo: somehow thread the `node` which generated the error through to the error message
        lines.push("Encountered error while generating qbe code:")
        lines.push(message)
      }
      CompileErrorKind.ResolvedGenericsError(context, message) => {
        // todo: somehow thread the `node` which generated the error through to the error message
        lines.push("Encountered error resolving generics for '$context':")
        lines.push(message)
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum CompileErrorKind {
  NotYetImplemented(reason: String)
  Unreachable(message: String)
  QbeError(message: String)
  ResolvedGenericsError(context: String, message: String)
}

func qbeError<V>(message: String): Result<V, CompileError> = Err(CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(message)))

type ResolvedGenerics {
  _layers: (String, Map<String, Type>)[] = []

  func toString(self): String {
    val parts = ["ResolvedGenerics(_layers: ["]
    for layer, idx in self._layers {
      parts.push("(\"${layer[0]}\", { ")
      for _p in layer[1] {
        parts.push("\"${_p[0]}\": \"${_p[1].repr()}\", ")
      }
      parts.push("}")

      if idx != self._layers.length - 1 { parts.push(", ") }
    }
    parts.push("])")

    parts.join()
  }

  func resolveGeneric(self, name: String): Type? {
    var idx = self._layers.length - 1
    while self._layers[idx] |layer| {
      if layer[1][name] |ty| return Some(ty)
      idx -= 1
    }

    None
  }

  func _resolveType(self, ty: Type): Result<Type, String> {
    match ty.kind {
      TypeKind.Generic(genericName) => {
        if self.resolveGeneric(genericName) |resolved| {
          Ok(resolved)
        } else {
          Err("layer: could not resolve generic '$genericName'")
        }
      }
      TypeKind.Instance(structOrEnum, typeArgs) => {
        val resolvedGenerics: Type[] = []
        for typeArg in typeArgs {
          resolvedGenerics.push(match self._resolveType(typeArg) { Ok(v) => v, Err(e) => return Err(e) })
        }
        Ok(Type(kind: TypeKind.Instance(structOrEnum, resolvedGenerics)))
      }
      TypeKind.Tuple(typeArgs) => {
        val resolvedGenerics: Type[] = []
        for typeArg in typeArgs {
          resolvedGenerics.push(match self._resolveType(typeArg) { Ok(v) => v, Err(e) => return Err(e) })
        }
        Ok(Type(kind: TypeKind.Tuple(resolvedGenerics)))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val resolvedParams: (Type, Bool)[] = []
        for _p in paramTypes {
          // TODO: destructuring
          val ty = match self._resolveType(_p[0]) { Ok(v) => v, Err(e) => return Err(e) }
          resolvedParams.push((ty, _p[1]))
        }
        val resolvedReturn = match self._resolveType(returnType) { Ok(v) => v, Err(e) => return Err(e) }

        Ok(Type(kind: TypeKind.Func(resolvedParams, resolvedReturn)))
      }
      _ => Ok(ty)
    }
  }

  func addLayer(self, context: String, given: Map<String, Type>): Result<Int, String> {
    val newLayer: Map<String, Type> = {}
    for _p in given {
      // TODO: destructuring
      val name = _p[0]
      val ty = _p[1]

      newLayer[name] = match self._resolveType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    }

    self._layers.push((context, newLayer))

    Ok(0)
  }

  func popLayer(self) {
    self._layers.pop()
  }
}

func variableToVar(v: Variable): Var = Var(name: v.label.name, location: (v.label.position.line, v.label.position.col))

export type Compiler {
  _project: Project
  _builder: ModuleBuilder
  _currentModule: TypedModule
  _currentFn: QbeFunction
  _currentFunction: Function?
  _currentNode: TypedAstNode?
  _argcPtr: Value
  _argvPtr: Value
  _resolvedGenerics: ResolvedGenerics = ResolvedGenerics()
  _loopStack: (/* loopStart: */ Label, /* loopEnd: */ Label)[] = []
  // cached things
  _printf: QbeFunction = QbeFunction.spec(name: "printf", returnType: None, parameters: [], variadicIdx: Some(1))
  _snprintf: QbeFunction = QbeFunction.spec(name: "snprintf", returnType: Some(QbeType.U64), parameters: [], variadicIdx: Some(3))
  _memcpy: QbeFunction = QbeFunction.spec(name: "memcpy", returnType: None)
  _malloc: QbeFunction = QbeFunction.spec(name: "GC_malloc", returnType: Some(QbeType.Pointer))
  _realloc: QbeFunction = QbeFunction.spec(name: "GC_realloc", returnType: Some(QbeType.Pointer))
  _tupleStructs: Map<String, Struct> = {}
  _functionStructs: Map<String, Struct> = {}
  _aliasedTypeNames: Map<String, String> = {}

  func compile(project: Project): Result<ModuleBuilder, CompilationError> {
    val builder = ModuleBuilder()

    val mainFn = builder.buildFunction(name: "main", returnType: Some(QbeType.U32), exported: true)
    mainFn.addComment("main entrypoint function")
    val argcParam = mainFn.addParameter("argc", QbeType.U64)
    val argvParam = mainFn.addParameter("argv", QbeType.U64)

    val argcPtr = builder.addData(QbeData(name: "__argc", kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(0))])))
    mainFn.block.buildStoreL(argcParam, argcPtr)
    val argvPtr = builder.addData(QbeData(name: "__argv", kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(0))])))
    mainFn.block.buildStoreL(argvParam, argvPtr)

    // Seed the RNG, for any future calls to `libc.rand()`
    val timeVal = match mainFn.block.buildCallRaw("time", QbeType.U64, [Value.Int(0)]) { Ok(v) => v, Err(e) => return Err(CompilationError(modulePath: "<entrypoint>", error: CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(e)))) }
    mainFn.block.buildVoidCallRaw("srand", [timeVal])

    mainFn.block.buildVoidCallRaw("GC_init", [])

    val dummyMod = TypedModule(id: -1, name: "dummy", code: [], rootScope: Scope.bogus())
    val compiler = Compiler(_project: project, _builder: builder, _currentModule: dummyMod, _currentFn: mainFn, _currentFunction: None, _currentNode: None, _argcPtr: argcPtr, _argvPtr: argvPtr)

    val allModules = project.modules.values().sortBy(m => m.id)
    for mod in allModules {
      val moduleFn = match compiler._compileModule(mod) { Ok(v) => v, Err(e) => {
        // println(compiler._currentNode?.token)
        return Err(CompilationError(modulePath: mod.name, error: e))
      }}
      match moduleFn.block.verify() { Ok(v) => v, Err(e) => return Err(CompilationError(modulePath: mod.name, error: CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(e)))) }
      mainFn.block.buildVoidCall(Callable.Function(moduleFn), [])
    }

    mainFn.block.buildReturn(Some(Value.Int(0)))

    match mainFn.block.verify() { Ok(v) => v, Err(e) => return Err(CompilationError(modulePath: "<entrypoint>", error: CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(e)))) }

    Ok(builder)
  }

  func _compileModule(self, module: TypedModule): Result<QbeFunction, CompileError> {
    val modFnName = self._moduleWrapperFnName(module)
    self._currentModule = module

    val fn = self._builder.buildFunction(name: modFnName, returnType: None)
    fn.addComment(module.name)

    self._currentFn = fn

    for node, idx in module.code {
      val value = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
      // If the last statement in the module is an expression, call the `toString` method on that expression, and print the result using `printf`.
      if idx == module.code.length - 1 && node.ty.kind != TypeKind.PrimitiveUnit {
        if value |v| {
          self._currentFn.block.addComment("call `toString` on final expression, and `printf` the String's chars")
          val dataPtr = self._builder.buildGlobalString("%s\\n")
          val tostringMethod = match self._getOrCompileToStringMethod(node.ty) { Ok(v) => v, Err(e) => return Err(e) }

          val tostringRepr = match self._currentFn.block.buildCall(Callable.Function(tostringMethod), [v], Some("_to_string_repr")) { Ok(v) => v, Err(e) => return qbeError(e) }
          val reprCharsPtr = match self._currentFn.block.buildAdd(Value.Int(8), tostringRepr, Some("_repr_chars_ptr")) { Ok(v) => v, Err(e) => return qbeError(e) }
          val reprChars = self._currentFn.block.buildLoadL(reprCharsPtr, Some("_repr_chars"))
          self._currentFn.block.buildVoidCall(Callable.Function(self._printf), [dataPtr, reprChars])
        }
      }
    }

    fn.block.buildReturn()

    match fn.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    Ok(fn)
  }

  func _compileStatement(self, node: TypedAstNode): Result<Value?, CompileError> {
    val prevNode = self._currentNode
    self._currentNode = Some(node)

    val res: Result<Value?, CompileError> = match node.kind {
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if !isStatement {
          val res = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
          return Ok(Some(res))
        }

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        val condVal = match self._compileExpression(cond) { Ok(v) => v, Err(e) => return Err(e) }
        val condExprIsOpt = self._typeIsOption(cond.ty)

        if condExprIsOpt {
          val variantIsOptionSome = match self._emitOptValueIsSomeVariant(condVal) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildJnz(variantIsOptionSome, labelThen, if elseBlock.isEmpty() labelCont else labelElse)
        } else {
          self._currentFn.block.buildJnz(condVal, labelThen, if elseBlock.isEmpty() labelCont else labelElse)
        }

        self._currentFn.block.registerLabel(labelThen)
        if conditionBinding |_p| {
          // TODO: destructuring
          val _bindingPattern = _p[0]
          val vars = _p[1]

          val bindingVar = if vars[0] |v| v else return unreachable("Binding pattern requires 1 variable", node.token.position)
          val slotName = self._currentFn.block.addVar(variableToVar(bindingVar))
          if condExprIsOpt |innerTy| {
            val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
            val optInnerValue = match self._emitOptValueGetValue(innerQbeType, condVal) { Ok(v) => v, Err(e) => return Err(e) }

            val slot = self._buildStackAllocForQbeType(innerQbeType, Some(slotName))
            self._currentFn.block.buildStore(innerQbeType, optInnerValue, slot)
          } else {
            val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
            val slot = self._buildStackAllocForQbeType(boolTypeQbe, Some(slotName))
            self._currentFn.block.buildStore(boolTypeQbe, Value.Int32(1), slot)
          }
        }
        for node in ifBlock {
          match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
        }
        if !ifBlockTerminator {
          self._currentFn.block.buildJmp(labelCont)
        }

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node in elseBlock {
            match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
          }
          if !elseBlockTerminator {
            self._currentFn.block.buildJmp(labelCont)
          }
        }

        self._currentFn.block.registerLabel(labelCont)

        Ok(None)
      }
      TypedAstNodeKind.Match(isStatement, expr, cases) => self._compileMatch(node, isStatement, expr, cases)
      TypedAstNodeKind.While(cond, conditionBinding, block, blockTerminator) => {
        val loopStartLabel = self._currentFn.block.addLabel("while_loop_start")
        val loopBodyLabel = self._currentFn.block.addLabel("while_loop_body")
        val loopEndLabel = self._currentFn.block.addLabel("while_loop_end")

        self._loopStack.push((loopStartLabel, loopEndLabel))

        self._currentFn.block.registerLabel(loopStartLabel)
        val condVal = match self._compileExpression(cond) { Ok(v) => v, Err(e) => return Err(e) }
        val condExprIsOpt = self._typeIsOption(cond.ty)

        if condExprIsOpt {
          val variantIsOptionSome = match self._emitOptValueIsSomeVariant(condVal) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildJnz(variantIsOptionSome, loopBodyLabel, loopEndLabel)
        } else {
          self._currentFn.block.buildJnz(condVal, loopBodyLabel, loopEndLabel)
        }

        self._currentFn.block.registerLabel(loopBodyLabel)
        if conditionBinding |_p| {
          // TODO: destructuring
          val _bindingPattern = _p[0]
          val vars = _p[1]

          // }
          val bindingVar = if vars[0] |v| v else return unreachable("Binding pattern requires 1 variable", node.token.position)
          val slotName = self._currentFn.block.addVar(variableToVar(bindingVar))
          if condExprIsOpt |innerTy| {
            val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
            val optInnerValue = match self._emitOptValueGetValue(innerQbeType, condVal) { Ok(v) => v, Err(e) => return Err(e) }

            val slot = self._buildStackAllocForQbeType(innerQbeType, Some(slotName))
            self._currentFn.block.buildStore(innerQbeType, optInnerValue, slot)
          } else {
            val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
            val slot = self._buildStackAllocForQbeType(boolTypeQbe, Some(slotName))
            self._currentFn.block.buildStore(boolTypeQbe, Value.Int32(1), slot)
          }
        }

        for node in block {
          match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
        }
        if !blockTerminator {
          self._currentFn.block.buildJmp(loopStartLabel)
        }

        self._currentFn.block.registerLabel(loopEndLabel)

        self._loopStack.pop()

        Ok(None)
      }
      TypedAstNodeKind.For(typedIterator, itemBindingPattern, indexBinding, block) => {
        val forLabelPrefix = "for_${node.token.position.line}_${node.token.position.col}"
        val _t = match self._getInstanceTypeForType(typedIterator.ty) { Ok(v) => v, Err(e) => return Err(e) }
        // TODO: destructuring
        val instTy = _t[0]
        val typeArgs = _t[1]

        val _p = match instTy {
          StructOrEnum.Struct(s) => {
            val _p = if s == self._project.preludeArrayStruct {
              val innerTy = if typeArgs[0] |t| t else return unreachable("Array has 1 required type argument")
              match self._resolvedGenerics.addLayer("array literal", { "T": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "array literal", message: e))) }

              val arrayVal = match self._compileExpression(typedIterator) { Ok(v) => v, Err(e) => return Err(e) }
              val instType = match self._addResolvedGenericsLayerForInstanceMethod(typedIterator.ty, "iterator", typedIterator.token.position) { Ok(v) => v, Err(e) => return Err(e) }
              val iteratorFn = if s.instanceMethods.find(m => m.label.name == "iterator") |fn| fn else return unreachable("Array#iterator must exist")
              val iteratorFnVal = match self._getOrCompileMethod(instType, iteratorFn) { Ok(v) => v, Err(e) => return Err(e) }
              self._resolvedGenerics.popLayer()

              val iter = match self._currentFn.block.buildCall(Callable.Function(iteratorFnVal), [arrayVal], Some("${forLabelPrefix}_iterator")) { Ok(v) => v, Err(e) => return qbeError(e) }

              val _t = match self._getInstanceTypeForType(iteratorFn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
              // TODO: destructuring
              val instanceMethods = match _t[0] {
                StructOrEnum.Struct(s) => s.instanceMethods
                StructOrEnum.Enum(e) => e.instanceMethods
              }
              val nextFn = if instanceMethods.find(m => m.label.name == "next") |fn| fn else return unreachable("a type must have a 'next' method if it's to be iterable")

              val iterTy = Type(kind: TypeKind.Instance(_t[0], _t[1]))
              (iter, iterTy, nextFn, true)
            } else if s == self._project.preludeSetStruct {
              val innerTy = if typeArgs[0] |t| t else return unreachable("Set has 1 required type argument")
              match self._resolvedGenerics.addLayer("set literal", { "T": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "set literal", message: e))) }

              val mapVal = match self._compileExpression(typedIterator) { Ok(v) => v, Err(e) => return Err(e) }
              val instType = match self._addResolvedGenericsLayerForInstanceMethod(typedIterator.ty, "iterator", typedIterator.token.position) { Ok(v) => v, Err(e) => return Err(e) }
              val iteratorFn = if s.instanceMethods.find(m => m.label.name == "iterator") |fn| fn else return unreachable("Set#iterator must exist")
              val iteratorFnVal = match self._getOrCompileMethod(instType, iteratorFn) { Ok(v) => v, Err(e) => return Err(e) }
              self._resolvedGenerics.popLayer()

              val iter = match self._currentFn.block.buildCall(Callable.Function(iteratorFnVal), [mapVal], Some("${forLabelPrefix}_iterator")) { Ok(v) => v, Err(e) => return qbeError(e) }

              val _t = match self._getInstanceTypeForType(iteratorFn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
              // TODO: destructuring
              val instanceMethods = match _t[0] {
                StructOrEnum.Struct(s) => s.instanceMethods
                StructOrEnum.Enum(e) => e.instanceMethods
              }
              val nextFn = if instanceMethods.find(m => m.label.name == "next") |fn| fn else return unreachable("a type must have a 'next' method if it's to be iterable")

              val iterTy = Type(kind: TypeKind.Instance(_t[0], _t[1]))
              (iter, iterTy, nextFn, true)
            } else if s == self._project.preludeMapStruct {
              val keyTy = if typeArgs[0] |t| t else return unreachable("Map has 2 required type arguments")
              val valTy = if typeArgs[1] |t| t else return unreachable("Map has 2 required type arguments")
              match self._resolvedGenerics.addLayer("map literal", { "K": keyTy, "V": valTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "map literal", message: e))) }

              val mapVal = match self._compileExpression(typedIterator) { Ok(v) => v, Err(e) => return Err(e) }
              val instType = match self._addResolvedGenericsLayerForInstanceMethod(typedIterator.ty, "iterator", typedIterator.token.position) { Ok(v) => v, Err(e) => return Err(e) }
              val iteratorFn = if s.instanceMethods.find(m => m.label.name == "iterator") |fn| fn else return unreachable("Map#iterator must exist")
              val iteratorFnVal = match self._getOrCompileMethod(instType, iteratorFn) { Ok(v) => v, Err(e) => return Err(e) }
              self._resolvedGenerics.popLayer()

              val iter = match self._currentFn.block.buildCall(Callable.Function(iteratorFnVal), [mapVal], Some("${forLabelPrefix}_iterator")) { Ok(v) => v, Err(e) => return qbeError(e) }

              val _t = match self._getInstanceTypeForType(iteratorFn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
              // TODO: destructuring
              val instanceMethods = match _t[0] {
                StructOrEnum.Struct(s) => s.instanceMethods
                StructOrEnum.Enum(e) => e.instanceMethods
              }
              val nextFn = if instanceMethods.find(m => m.label.name == "next") |fn| fn else return unreachable("a type must have a 'next' method if it's to be iterable")

              val iterTy = Type(kind: TypeKind.Instance(_t[0], _t[1]))
              (iter, iterTy, nextFn, true)
            } else {
              val iter = match self._compileExpression(typedIterator) { Ok(v) => v, Err(e) => return Err(e) }
              val nextFn = if s.instanceMethods.find(m => m.label.name == "next") |fn| fn else return unreachable("a type must have a 'next' method if it's to be iterable")

              (iter, typedIterator.ty, nextFn, false)
            }
            _p
          }
          StructOrEnum.Enum(_enum) => return todo("enum as for-loop target")
        }
        // TODO: destructuring
        val iterVal = _p[0]
        val iterTy = _p[1]
        val nextFn = _p[2]
        val popAdditionalResolvedGenericsLayer = _p[3]

        val nextItemTy = if self._typeIsOption(nextFn.returnType) |innerTy| innerTy else return unreachable("a 'next' method must return an Option type")
        val iterInstTy = match self._addResolvedGenericsLayerForInstanceMethod(iterTy, "next", node.token.position) { Ok(v) => v, Err(e) => return Err(e) }
        val nextItemQbeTy = match self._getQbeTypeForTypeExpect(nextItemTy, "unacceptable type for 'next' method return type") { Ok(v) => v, Err(e) => return Err(e) }

        val nextFnVal = match self._getOrCompileMethod(iterInstTy, nextFn) { Ok(v) => v, Err(e) => return Err(e) }
        self._resolvedGenerics.popLayer()
        if popAdditionalResolvedGenericsLayer self._resolvedGenerics.popLayer()

        val loopStartLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_start")
        val loopBodyLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_body")
        val loopEndLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_end")

        self._loopStack.push((loopStartLabel, loopEndLabel))

        val indexBindingSlot = if indexBinding |bindingVar| {
          val slotName = self._currentFn.block.addVar(variableToVar(bindingVar))
          val slot = self._buildStackAllocForQbeType(QbeType.U64, Some(slotName))
          self._currentFn.block.buildStoreL(Value.Int(-1), slot)
          Some(slot)
        } else {
          None
        }

        self._currentFn.block.registerLabel(loopStartLabel)
        val itemBindingVar = if itemBindingPattern[1][0] |v| v else return unreachable("Binding pattern requires 1 variable", node.token.position)
        val nextRet = match self._currentFn.block.buildCall(Callable.Function(nextFnVal), [iterVal], Some("next_ret")) { Ok(v) => v, Err(e) => return qbeError(e) }

        val variantIsOptionSome = match self._emitOptValueIsSomeVariant(nextRet) { Ok(v) => v, Err(e) => return Err(e) }
        self._currentFn.block.buildJnz(variantIsOptionSome, loopBodyLabel, loopEndLabel)

        self._currentFn.block.registerLabel(loopBodyLabel)
        val itemSlotName = self._currentFn.block.addVar(variableToVar(itemBindingVar))
        val optInnerValue = match self._emitOptValueGetValue(nextItemQbeTy, nextRet) { Ok(v) => v, Err(e) => return Err(e) }
        val itemSlot = self._buildStackAllocForQbeType(nextItemQbeTy, Some(itemSlotName))
        self._currentFn.block.buildStore(nextItemQbeTy, optInnerValue, itemSlot)
        if indexBindingSlot |idxSlot| {
          val idxVal = self._currentFn.block.buildLoadL(idxSlot)
          val idxIncrVal = match self._currentFn.block.buildAdd(Value.Int(1), idxVal) { Ok(v) => v, Err(e) => return qbeError(e) }
          self._currentFn.block.buildStoreL(idxIncrVal, idxSlot)
        }

        for node in block {
          match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
        }
        self._currentFn.block.buildJmp(loopStartLabel)

        self._currentFn.block.registerLabel(loopEndLabel)

        self._loopStack.pop()

        Ok(None)
      }
      TypedAstNodeKind.BindingDeclaration(bindingDeclNode) => {
        val bindingName = match bindingDeclNode.bindingPattern {
          BindingPattern.Variable(label) => label.name
        }
        val variable = if bindingDeclNode.variables[0] |v| v else return unreachable("binding decl needs at least 1 variable")

        val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
        val slotName = self._currentFn.block.addVar(variableToVar(variable))

        if bindingDeclNode.expr |expr| {
          val res = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
          if variable.isExported {
            val name = self._exportedVarName(self._currentModule.id, variable.label.name)
            val slot = self._builder.addData(QbeData(name: name, kind: QbeDataKind.Constants([(varTy, varTy.zeroValue())])))
            self._currentFn.block.buildStore(varTy, res, slot)
          } else if variable.isCaptured && variable.mutable {
            // Only move captured variables to the heap if they're mutable - captured immutable variables can just have their value present in
            // a closure's captures array, but a mutable variable needs an additional layer of indirection to handle possible reassignment.
            self._currentFn.block.addComment("move captured mutable '${variable.label.name}' to heap")
            val size = varTy.size()
            val heapMem = match self._currentFn.block.buildCall(Callable.Function(self._malloc), [Value.Int(size)], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }
            self._currentFn.block.buildStore(varTy, res, heapMem)

            val slot = self._buildStackAllocForQbeType(QbeType.Pointer, Some(slotName))
            self._currentFn.block.buildStore(QbeType.Pointer, heapMem, slot)
          } else {
            val slot = self._buildStackAllocForQbeType(varTy, Some(slotName))
            self._currentFn.block.buildStore(varTy, res, slot)
          }
        }

        Ok(None)
      }
      TypedAstNodeKind.FunctionDeclaration(fn) => {
        if fn.isClosure() {
          val capturesMem = match self._createClosureCaptures(fn) { Ok(v) => v, Err(e) => return Err(e) }
          val capturesSlot = self._buildStackAllocForQbeType(QbeType.Pointer, Some("${fn.label.name}.captures"))
          self._currentFn.block.buildStore(QbeType.Pointer, capturesMem, capturesSlot)
        }

        Ok(None)
      }
      TypedAstNodeKind.TypeDeclaration(struct) => {
        for fn in struct.instanceMethods {
          if fn.isClosure() {
            val capturesMem = match self._createClosureCaptures(fn) { Ok(v) => v, Err(e) => return Err(e) }
            val methodName = "${struct.label.name}..${fn.label.name}"
            val capturesSlot = self._buildStackAllocForQbeType(QbeType.Pointer, Some("$methodName.captures"))
            self._currentFn.block.buildStore(QbeType.Pointer, capturesMem, capturesSlot)
          }
        }

        for fn in struct.staticMethods {
          if fn.isClosure() {
            val capturesMem = match self._createClosureCaptures(fn) { Ok(v) => v, Err(e) => return Err(e) }
            val methodName = "${struct.label.name}.${fn.label.name}"
            val capturesSlot = self._buildStackAllocForQbeType(QbeType.Pointer, Some("$methodName.captures"))
            self._currentFn.block.buildStore(QbeType.Pointer, capturesMem, capturesSlot)
          }
        }

        Ok(None)
      }
      TypedAstNodeKind.EnumDeclaration => Ok(None)
      TypedAstNodeKind.Break => {
        if self._loopStack[-1] |currentLoop| {
          // TODO: destructuring
          val loopEndLabel = currentLoop[1]
          self._currentFn.block.buildJmp(loopEndLabel)

          Ok(None)
        } else {
          unreachable("cannot have a break statement outside of a loop", node.token.position)
        }
      }
      TypedAstNodeKind.Continue => {
        if self._loopStack[-1] |currentLoop| {
          // TODO: destructuring
          val loopStartLabel = currentLoop[0]
          self._currentFn.block.buildJmp(loopStartLabel)

          Ok(None)
        } else {
          unreachable("cannot have a continue statement outside of a loop", node.token.position)
        }
      }
      TypedAstNodeKind.Return(expr) => {
        if expr |expr| {
          val retVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildReturn(Some(retVal))
        } else {
          self._currentFn.block.buildReturn(None)
        }

        Ok(None)
      }
      TypedAstNodeKind.Placeholder => unreachable("placeholder ast node emitted from typechecker", node.token.position)
      TypedAstNodeKind.Assignment(mode, op, expr) => {
        val res = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }

        match mode {
          TypedAssignmentMode.Variable(variable) => {
            if variable.isParameter return unreachable("parameters cannot be reassigned to", node.token.position)

            val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
            if variable.isCaptured {
              val ptr = match self._getCapturedVarPtr(variable) { Ok(v) => v, Err(e) => return Err(e) }
              self._currentFn.block.addComment("overwrite ptr to captured '${variable.label.name}'")
              self._currentFn.block.buildStore(varTy, res, ptr)
            } else {
              val slotName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else return unreachable("Could not resolve name for variable '${variable.label.name}'", node.token.position)
              val slot = Value.Ident(slotName, QbeType.Pointer)
              self._currentFn.block.buildStore(varTy, res, slot)
            }
          }
          TypedAssignmentMode.Indexing(idxNode) => {
            match idxNode {
              TypedIndexingNode.ArrayLike(expr, indexingMode) => {
                match indexingMode {
                  IndexingMode.Single(idxExpr) => {
                    val exprVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
                    val idxExprVal = match self._compileExpression(idxExpr) { Ok(v) => v, Err(e) => return Err(e) }

                    val instType = match self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "set", expr.token.position) { Ok(v) => v, Err(e) => return Err(e) }
                    val _t = match self._getInstanceTypeForType(expr.ty) { Ok(v) => v, Err(e) => return Err(e) }
                    // TODO: destructuring
                    val struct = match _t[0] {
                      StructOrEnum.Struct(struct) => struct
                      StructOrEnum.Enum => return unreachable("index-assignment only implemented for arrays")
                    }
                    if struct != self._project.preludeArrayStruct return unreachable("index-assignment only implemented for arrays")

                    val setFn = if self._project.preludeArrayStruct.instanceMethods.find(m => m.label.name == "set") |fn| fn else return unreachable("Array#set must exist")
                    val setFnVal = match self._getOrCompileMethod(instType, setFn) { Ok(v) => v, Err(e) => return Err(e) }
                    self._resolvedGenerics.popLayer()

                    match self._currentFn.block.buildCall(Callable.Function(setFnVal), [exprVal, idxExprVal, res]) { Ok(v) => v, Err(e) => return qbeError(e) }
                  }
                  _ => return unreachable("cannot use range index in index-assignment")
                }
              }
              TypedIndexingNode.Map(expr, idxExpr) => {
                val exprVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
                val idxExprVal = match self._compileExpression(idxExpr) { Ok(v) => v, Err(e) => return Err(e) }

                val instType = match self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "set", expr.token.position) { Ok(v) => v, Err(e) => return Err(e) }
                val _t = match self._getInstanceTypeForType(expr.ty) { Ok(v) => v, Err(e) => return Err(e) }
                // TODO: destructuring
                val struct = match _t[0] {
                  StructOrEnum.Struct(struct) => struct
                  StructOrEnum.Enum => return unreachable("index-assignment only implemented for maps")
                }
                if struct != self._project.preludeMapStruct return unreachable("index-assignment only implemented for map")

                val insertFn = if self._project.preludeMapStruct.instanceMethods.find(m => m.label.name == "insert") |fn| fn else return unreachable("Map#insert must exist")
                val insertFnVal = match self._getOrCompileMethod(instType, insertFn) { Ok(v) => v, Err(e) => return Err(e) }
                self._resolvedGenerics.popLayer()

                match self._currentFn.block.buildCall(Callable.Function(insertFnVal), [exprVal, idxExprVal, res]) { Ok(v) => v, Err(e) => return qbeError(e) }
              }
              TypedIndexingNode.Tuple(_, _) => return unreachable("tuples are not assignable via index-assignment")
            }
          }
          TypedAssignmentMode.Accessor(head, middle, tail) => {
            val ptr = match self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: false) { Ok(v) => v, Err(e) => return Err(e) }
            self._currentFn.block.buildStore(res.ty(), res, ptr)
          }
        }

        Ok(None)
      }
      _ => {
        val v = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
        if node.ty.kind == TypeKind.PrimitiveUnit {
          Ok(None)
        } else {
          Ok(Some(v))
        }
      }
    }

    self._currentNode = prevNode

    res
  }

  func _compileExpression(self, node: TypedAstNode, resultLocalName: String? = None): Result<Value, CompileError> {
    val prevNode = self._currentNode
    self._currentNode = Some(node)

    val res: Result<Value, CompileError> = match node.kind {
      TypedAstNodeKind.Literal(lit) => {
        val _p = match self._compileLiteral(lit) { Ok(v) => v, Err(e) => return Err(e) }
        // TODO: destructuring
        Ok(_p[0])
      }
      TypedAstNodeKind.StringInterpolation(exprs) => {
        self._currentFn.block.addComment("begin string interpolation...")

        val strVals: Value[] = []
        var lenVal = Value.Int(0)
        for item in exprs {
          val itemVal = match self._compileExpression(item) { Ok(v) => v, Err(e) => return Err(e) }

          val itemInstanceType = match self._addResolvedGenericsLayerForInstanceMethod(item.ty, "toString", item.token.position) { Ok(v) => v, Err(e) => return Err(e) }
          val itemToStringFnVal = match self._getOrCompileToStringMethod(itemInstanceType) { Ok(v) => v, Err(e) => return Err(e) }
          self._resolvedGenerics.popLayer()

          val toStringVal = match self._currentFn.block.buildCall(Callable.Function(itemToStringFnVal), [itemVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
          strVals.push(toStringVal)

          val stringLength = self._currentFn.block.buildLoadL(toStringVal)
          lenVal = match self._currentFn.block.buildAdd(lenVal, stringLength) { Ok(v) => v, Err(e) => return qbeError(e) }
        }

        val stringWithLengthFn = if self._project.preludeStringStruct.staticMethods.find(m => m.label.name == "withLength") |fn| fn else return unreachable("String.withLength must exist")
        val stringWithLengthFnVal = match self._getOrCompileMethod(Type(kind: TypeKind.Type(StructOrEnum.Struct(self._project.preludeStringStruct))), stringWithLengthFn) { Ok(v) => v, Err(e) => return Err(e) }
        val newString = match self._currentFn.block.buildCall(Callable.Function(stringWithLengthFnVal), [lenVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
        var newBuffer = self._currentFn.block.buildLoadL(match self._currentFn.block.buildAdd(Value.Int(8), newString) { Ok(v) => v, Err(e) => return qbeError(e) })

        for strVal, idx in strVals {
          val strValLen = self._currentFn.block.buildLoadL(strVal)
          val strValBuf = self._currentFn.block.buildLoadL(match self._currentFn.block.buildAdd(Value.Int(8), strVal) { Ok(v) => v, Err(e) => return qbeError(e) })

          self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newBuffer, strValBuf, strValLen])
          if idx != strVals.length {
            newBuffer = match self._currentFn.block.buildAdd(newBuffer, strValLen) { Ok(v) => v, Err(e) => return qbeError(e) }
          }
        }

        self._currentFn.block.addComment("...string interpolation end")

        Ok(newString)
      }
      TypedAstNodeKind.Unary(op, expr) => {
        match op {
          UnaryOp.Minus => {
            val exprVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildNeg(exprVal) { Ok(v) => v, Err(e) => return qbeError(e) }

            Ok(res)
          }
          UnaryOp.Negate => {
            val exprVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
            val exprIsOpt = self._typeIsOption(expr.ty)
            if exprIsOpt {
              val variantIsNotOptionSome = match self._emitOptValueIsSomeVariant(exprVal: exprVal, negate: true) { Ok(v) => v, Err(e) => return Err(e) }
              Ok(variantIsNotOptionSome)
            } else {
              val plusOneVal = match self._currentFn.block.buildAdd(Value.Int32(1), exprVal) { Ok(v) => v, Err(e) => return qbeError(e) }
              val res = match self._currentFn.block.buildRem(plusOneVal, Value.Int32(2)) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            }
          }
        }
      }
      TypedAstNodeKind.Binary(left, op, right) => {
        match op {
          BinaryOp.Add => {
            val leftIsString = self._typeIsString(left.ty)
            val rightIsString = self._typeIsString(right.ty)

            if leftIsString || rightIsString {
              self._currentFn.block.addComment("begin string concatenation...")
              var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
              if !leftIsString {
                val leftInstanceType = match self._addResolvedGenericsLayerForInstanceMethod(left.ty, "toString", left.token.position) { Ok(v) => v, Err(e) => return Err(e) }
                val leftToStringFnVal = match self._getOrCompileToStringMethod(leftInstanceType) { Ok(v) => v, Err(e) => return Err(e) }
                self._resolvedGenerics.popLayer()

                leftVal = match self._currentFn.block.buildCall(Callable.Function(leftToStringFnVal), [leftVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
              }

              var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }
              if !rightIsString {
                val rightInstanceType = match self._addResolvedGenericsLayerForInstanceMethod(right.ty, "toString", right.token.position) { Ok(v) => v, Err(e) => return Err(e) }
                val rightToStringFnVal = match self._getOrCompileToStringMethod(rightInstanceType) { Ok(v) => v, Err(e) => return Err(e) }
                self._resolvedGenerics.popLayer()

                rightVal = match self._currentFn.block.buildCall(Callable.Function(rightToStringFnVal), [rightVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
              }

              val stringWithLengthFn = if self._project.preludeStringStruct.staticMethods.find(m => m.label.name == "withLength") |fn| fn else return unreachable("String.withLength must exist")
              val stringWithLengthFnVal = match self._getOrCompileMethod(Type(kind: TypeKind.Type(StructOrEnum.Struct(self._project.preludeStringStruct))), stringWithLengthFn) { Ok(v) => v, Err(e) => return Err(e) }
              val leftLength = self._currentFn.block.buildLoadL(leftVal)
              val rightLength = self._currentFn.block.buildLoadL(rightVal)
              val totalLength = match self._currentFn.block.buildAdd(leftLength, rightLength) { Ok(v) => v, Err(e) => return qbeError(e) }
              val newString = match self._currentFn.block.buildCall(Callable.Function(stringWithLengthFnVal), [totalLength]) { Ok(v) => v, Err(e) => return qbeError(e) }

              var newBuffer = self._currentFn.block.buildLoadL(match self._currentFn.block.buildAdd(Value.Int(8), newString) { Ok(v) => v, Err(e) => return qbeError(e) })

              val leftBuffer = self._currentFn.block.buildLoadL(match self._currentFn.block.buildAdd(Value.Int(8), leftVal) { Ok(v) => v, Err(e) => return qbeError(e) })
              self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newBuffer, leftBuffer, leftLength])

              val rightBuffer = self._currentFn.block.buildLoadL(match self._currentFn.block.buildAdd(Value.Int(8), rightVal) { Ok(v) => v, Err(e) => return qbeError(e) })
              newBuffer = match self._currentFn.block.buildAdd(newBuffer, leftLength) { Ok(v) => v, Err(e) => return qbeError(e) }
              self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newBuffer, rightBuffer, rightLength])

              self._currentFn.block.addComment("...string concatenation end")

              return Ok(newString)
            }

            val vals = match self._compileBinaryOperands(left, right, "+") { Ok(v) => v, Err(e) => return Err(e) }
            // TODO: destructuring
            val res = match self._currentFn.block.buildAdd(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Sub => {
            val vals = match self._compileBinaryOperands(left, right, "-") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildSub(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Mul => {
            val vals = match self._compileBinaryOperands(left, right, "*") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildMul(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Div => {
            var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if !self._typeIsFloat(left.ty)
              leftVal = self._currentFn.block.buildLToF(leftVal)
            if !self._typeIsFloat(right.ty)
              rightVal = self._currentFn.block.buildLToF(rightVal)

            val res = match self._currentFn.block.buildDiv(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Mod => {
            var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val res = match self._currentFn.block.buildRem(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              if !self._typeIsFloat(left.ty)
                leftVal = self._currentFn.block.buildLToF(leftVal)
              if !self._typeIsFloat(right.ty)
                rightVal = self._currentFn.block.buildLToF(rightVal)

              val res = match self._currentFn.block.buildCallRaw("fmod", QbeType.F64, [leftVal, rightVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            }
          }
          BinaryOp.Pow => {
            var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              leftVal = self._currentFn.block.buildLToF(leftVal)
              rightVal = self._currentFn.block.buildLToF(rightVal)
              val res = match self._currentFn.block.buildCallRaw("pow", QbeType.F64, [leftVal, rightVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              // if a < 0 { -(-a ** b) } else { a ** b }
              if !self._typeIsFloat(left.ty)
                leftVal = self._currentFn.block.buildLToF(leftVal)
              if !self._typeIsFloat(right.ty)
                rightVal = self._currentFn.block.buildLToF(rightVal)

              val labelThen = self._currentFn.block.addLabel("fpow_l_neg")
              val labelElse = self._currentFn.block.addLabel("fpow_l_pos")
              val labelCont = self._currentFn.block.addLabel("fpow_cont")
              val cond = match self._currentFn.block.buildCompareLt(leftVal, Value.Float(0.0)) { Ok(v) => v, Err(e) => return qbeError(e) }
              self._currentFn.block.buildJnz(cond, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              val leftValNeg = match self._currentFn.block.buildMul(leftVal, Value.Float(-1.0)) { Ok(v) => v, Err(e) => return qbeError(e) }
              val thenValNeg = match self._currentFn.block.buildCallRaw("pow", QbeType.F64, [leftValNeg, rightVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
              val thenVal = match self._currentFn.block.buildMul(thenValNeg, Value.Float(-1.0)) { Ok(v) => v, Err(e) => return qbeError(e) }
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              val elseVal = match self._currentFn.block.buildCallRaw("pow", QbeType.F64, [leftVal, rightVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(labelThen, thenVal), (labelElse, elseVal)]
              val res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }

              Ok(res)
            }
          }
          BinaryOp.And => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

              val res = match self._currentFn.block.buildAnd(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              val labelThen = self._currentFn.block.addLabel("bool_and_then")
              val labelElse = self._currentFn.block.addLabel("bool_and_else")
              val labelCont = self._currentFn.block.addLabel("bool_and_cont")

              self._currentFn.block.buildJnz(leftVal, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }
              val rightLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(rightLabel, rightVal), (labelElse, leftVal)]
              val res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }

              Ok(res)
            }
          }
          BinaryOp.Or => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

              val res = match self._currentFn.block.buildOr(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              val labelThen = self._currentFn.block.addLabel("bool_or_then")
              val labelElse = self._currentFn.block.addLabel("bool_or_else")
              val labelCont = self._currentFn.block.addLabel("bool_or_cont")

              self._currentFn.block.buildJnz(leftVal, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }
              val rightLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(labelThen, leftVal), (rightLabel, rightVal)]
              val res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }

              Ok(res)
            }
          }
          BinaryOp.Xor => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) || self._typeIsBool(left.ty) && self._typeIsBool(right.ty) {
              val res = match self._currentFn.block.buildXor(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              unreachable("unknown operator '^' between types '${left.ty.repr()}' and '${right.ty.repr()}")
            }
          }
          BinaryOp.Coalesce => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }

            val labelThen = self._currentFn.block.addLabel("coalesce_then")
            val labelElse = self._currentFn.block.addLabel("coalesce_else")
            val labelCont = self._currentFn.block.addLabel("coalesce_cont")

            val isSome = match self._emitOptValueIsSomeVariant(leftVal) { Ok(v) => v, Err(e) => return Err(e) }

            self._currentFn.block.buildJnz(isSome, labelThen, labelElse)

            self._currentFn.block.registerLabel(labelThen)
            val innerTy = if self._typeIsOption(left.ty) |innerTy| innerTy else return unreachable("", node.token.position)
            val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
            val innerVal = match self._emitOptValueGetValue(innerQbeType, leftVal) { Ok(v) => v, Err(e) => return Err(e) }
            val leftLabel = self._currentFn.block.currentLabel
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.registerLabel(labelElse)
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }
            val rightLabel = self._currentFn.block.currentLabel
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.registerLabel(labelCont)

            val phiCases = [(leftLabel, innerVal), (rightLabel, rightVal)]
            val res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }

            Ok(res)
          }
          BinaryOp.Eq => self._compileBinaryEq(left, right)
          BinaryOp.Neq => self._compileBinaryEq(left: left, right: right, negate: true)
          BinaryOp.LT => {
            val vals = match self._compileBinaryOperands(left, right, "<") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildCompareLt(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.LTE => {
            val vals = match self._compileBinaryOperands(left, right, "<=") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildCompareLte(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Shl => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            val res = match self._currentFn.block.buildShl(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.GT => {
            val vals = match self._compileBinaryOperands(left, right, ">") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildCompareGt(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.GTE => {
            val vals = match self._compileBinaryOperands(left, right, ">=") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildCompareGte(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Shr => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            val res = match self._currentFn.block.buildShr(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
        }
      }
      TypedAstNodeKind.Grouped(inner) => self._compileExpression(inner, resultLocalName)
      TypedAstNodeKind.Identifier(name, variable, fnAliasTypeHint, varImportModule) => {
        // If a variable is function parameter, it can just be referenced by name as a temporary/local, otherwise it can be obtained by
        // loading the value pointed to by the temporary/local with that name.
        // TODO: handle captured variables in closures, global variables, etc).
        val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
        if variable.isParameter {
          if variable.isCaptured {
            if variable.mutable return unreachable("parameters cannot be mutable", node.token.position)
            val value = match self._getCapturedVarPtr(variable) { Ok(v) => v, Err(e) => return Err(e) }
            Ok(value)
          } else {
            val varName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else return unreachable("Could not resolve name for variable '${variable.label.name}'", node.token.position)
            Ok(Value.Ident(varName, varTy))
          }
        } else {
          match variable.alias {
            VariableAlias.Function(fn) => {
              val targetParamTypes = if fnAliasTypeHint |hint| {
                val paramTypes = match hint.kind {
                  TypeKind.Func(paramTypes, _) => Some(paramTypes)
                  TypeKind.Any => None // if the function value is being treated as an Any, then no param type info needs to be known later anyway
                  _ => return unreachable("fnAliasTypeKind must be TypeKind.Func", node.token.position)
                }
                paramTypes
              } else {
                None
              }

              val capturesMem = if !fn.isClosure() None else {
                val mem = match self._getCapturesArrForClosure(fn) { Ok(v) => v, Err(e) => return Err(e) }
                Some(mem)
              }

              val fnValBase = match self._getOrCompileFunction(fn) { Ok(v) => v, Err(e) => return Err(e) }
              self._compileFunctionValue(node.token.position, fn, fnValBase, targetParamTypes, capturesMem, None)
            }
            _ => {
              if varImportModule |mod| {
                val name = self._exportedVarName(mod.id, name)
                val slot = Value.Global(name, QbeType.Pointer)
                val res = self._currentFn.block.buildLoad(varTy, slot)
                Ok(res)
              } else if variable.isCaptured {
                val ptr = match self._getCapturedVarPtr(variable) { Ok(v) => v, Err(e) => return Err(e) }
                val res = if variable.mutable {
                  self._currentFn.block.addComment("deref ptr to captured mutable '${variable.label.name}'")
                  self._currentFn.block.buildLoad(varTy, ptr)
                } else {
                  ptr
                }
                Ok(res)
              } else {
                val slotName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else return unreachable("Could not resolve name for variable '${variable.label.name}'")
                val slot = Value.Ident(slotName, QbeType.Pointer)
                val res = self._currentFn.block.buildLoad(varTy, slot)
                Ok(res)
              }
            }
          }
        }
      }
      TypedAstNodeKind.Accessor(head, middle, tail) => self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: true, localName: resultLocalName)
      TypedAstNodeKind.Invocation(invokee, arguments, resolvedGenerics) => {
        val args: Value[] = []
        var fnHasOptionalParameters = false
        var optSafeCtx: (Label, Value?, QbeFunction, Label)? = None
        var closureEnvCtx: (Value, Bool)? = None
        var closureSelfCtx: Value? = None

        val _p = match invokee {
          TypedInvokee.Function(fn) => {
            match self._resolvedGenerics.addLayer(fn.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: fn.label.name, message: e))) }

            if fn.label.name == "println" || fn.label.name == "print" {
              val res = self._invokePrint(arguments: arguments, withNewline: fn.label.name == "println")
              self._resolvedGenerics.popLayer()
              return res
            }

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "Intrinsic")
            if intrinsicDec |dec| {
              val res = self._invokeIntrinsicFn(dec, fn, arguments)
              self._resolvedGenerics.popLayer()
              return res
            }

            val cBindingDec = fn.decorators.find(dec => dec.label.name == "CBinding")
            if cBindingDec |dec| {
              val res = self._invokeCBindingFn(dec, fn, arguments)
              self._resolvedGenerics.popLayer()
              return res
            }

            if fn.isClosure() {
              val capturesArr = match self._getCapturesArrForClosure(fn) { Ok(v) => v, Err(e) => return Err(e) }
              closureEnvCtx = Some((capturesArr, false))
            }

            fnHasOptionalParameters = fn.params.any(p => !!p.defaultValue)

            val fnVal = match fn.kind {
              FunctionKind.StaticMethod(parentTy) => {
                val fnVal = match self._getOrCompileMethod(Type(kind: TypeKind.Type(parentTy)), fn) { Ok(v) => v, Err(e) => return Err(e) }
                fnVal
              }
              FunctionKind.Standalone => {
                val fnVal = match self._getOrCompileFunction(fn) { Ok(v) => v, Err(e) => return Err(e) }
                fnVal
              }
              FunctionKind.InstanceMethod => return unreachable("instance methods handled elsewhere", node.token.position)
            }

            self._resolvedGenerics.popLayer()

            val argMetadata = fn.params.map(p => (!!p.defaultValue, p.ty))
            (Callable.Function(fnVal), argMetadata)
          }
          TypedInvokee.Method(fn, selfExpr, isOptSafe) => {
            var selfInstanceType = match self._addResolvedGenericsLayerForInstanceMethod(selfExpr.ty, fn.label.name, node.token.position, resolvedGenerics) { Ok(v) => v, Err(e) => return Err(e) }

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "Intrinsic")
            if intrinsicDec |dec| {
              if isOptSafe return unreachable("cannot have opt-safe intrinsic method calls")
              val res = self._invokeIntrinsicFn(dec, fn, [Some(selfExpr)].concat(arguments))
              self._resolvedGenerics.popLayer()
              return res
            }

            if fn.isClosure() {
              val capturesArr = match self._getCapturesArrForClosure(fn) { Ok(v) => v, Err(e) => return Err(e) }
              closureEnvCtx = Some((capturesArr, false))
            }

            fnHasOptionalParameters = fn.params.any(p => !!p.defaultValue)

            val selfVal = if isOptSafe {
              val innerTy = if self._typeIsOption(selfInstanceType) |innerTy| innerTy else return unreachable("an opt-safe invocation needs to have an Option type as its lhs")
              selfInstanceType = innerTy

              val selfVal = match self._compileExpression(selfExpr) { Ok(v) => v, Err(e) => return Err(e) }
              val variantIsOptionSome = match self._emitOptValueIsSomeVariant(selfVal) { Ok(v) => v, Err(e) => return Err(e) }

              val labelIsSome = self._currentFn.block.addLabel("optsafe_call_is_some")
              val labelIsNone = self._currentFn.block.addLabel("optsafe_call_is_none")
              val labelCont = self._currentFn.block.addLabel("optsafe_call_cont")

              self._currentFn.block.addComment("begin opt-safe call...")
              self._currentFn.block.buildJnz(variantIsOptionSome, labelIsSome, labelIsNone)

              self._currentFn.block.registerLabel(labelIsNone)
              val noneRes = if fn.returnType.kind != TypeKind.PrimitiveUnit {
                val optNoneVariant = if self._project.preludeOptionEnum.variants.find(v => v.label.name == "None") |v| v else return unreachable("Option.None must exist")
                match self._resolvedGenerics.addLayer("Option.None", { "V": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "Option.None", message: e))) }
                val noneVariantFn = match self._getOrCompileEnumVariantFn(self._project.preludeOptionEnum, optNoneVariant) { Ok(v) => v, Err(e) => return Err(e) }
                self._resolvedGenerics.popLayer()
                val noneRes = match self._currentFn.block.buildCall(Callable.Function(noneVariantFn), []) { Ok(v) => v, Err(e) => return qbeError(e) }
                Some(noneRes)
              } else None
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelIsSome)
              val optSomeVariant = if self._project.preludeOptionEnum.variants.find(v => v.label.name == "Some") |v| v else return unreachable("Option.Some must exist")
              match self._resolvedGenerics.addLayer("Option.Some", { "V": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "Option.Some", message: e))) }
              val someVariantFn = match self._getOrCompileEnumVariantFn(self._project.preludeOptionEnum, optSomeVariant) { Ok(v) => v, Err(e) => return Err(e) }
              self._resolvedGenerics.popLayer()

              optSafeCtx = Some((labelIsNone, noneRes, someVariantFn, labelCont))

              val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
              val v = match self._emitOptValueGetValue(innerQbeType, selfVal) { Ok(v) => v, Err(e) => return Err(e) }
              v
            } else {
              val v = match self._compileExpression(selfExpr) { Ok(v) => v, Err(e) => return Err(e) }
              v
            }

            val fnVal = match self._getOrCompileMethod(selfInstanceType, fn) { Ok(v) => v, Err(e) => return Err(e) }
            args.push(selfVal)

            self._resolvedGenerics.popLayer()

            val argMetadata = fn.params.map(p => (!!p.defaultValue, p.ty))
            (Callable.Function(fnVal), argMetadata)
          }
          TypedInvokee.Struct(struct) => {
            match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }
            fnHasOptionalParameters = struct.fields.any(f => !!f.initializer)
            val fnVal = match self._getOrCompileStructInitializer(struct) { Ok(v) => v, Err(e) => return Err(e) }

            self._resolvedGenerics.popLayer()

            val argMetadata = struct.fields.map(f => (!!f.initializer, f.ty))
            (Callable.Function(fnVal), argMetadata)
          }
          TypedInvokee.EnumVariant(enum_, variant) => {
            match self._resolvedGenerics.addLayer(variant.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: variant.label.name, message: e))) }
            val enumVariantFn = match self._getOrCompileEnumVariantFn(enum_, variant) { Ok(v) => v, Err(e) => return Err(e) }

            self._resolvedGenerics.popLayer()

            val argMetadata = match variant.kind {
              EnumVariantKind.Container(fields) => fields.map(f => (!!f.initializer, f.ty))
              _ => []
            }
            (Callable.Function(enumVariantFn), argMetadata)
          }
          TypedInvokee.Expr(expr) => {
            val fnObj = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
            val envPtr = self._currentFn.block.buildLoadL(fnObj)
            closureEnvCtx = Some((envPtr, true))

            val selfPtrSlot = match self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size() * 2), fnObj) { Ok(v) => v, Err(e) => return qbeError(e) }
            val selfPtr = self._currentFn.block.buildLoadL(selfPtrSlot)
            closureSelfCtx = Some(selfPtr)

            val fnValPtrSlot = match self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size()), fnObj) { Ok(v) => v, Err(e) => return qbeError(e) }
            val fnValPtr = self._currentFn.block.buildLoadL(fnValPtrSlot)

            val retTypeQbe = if node.ty.kind == TypeKind.PrimitiveUnit {
              None
            } else {
              val ty = match self._getQbeTypeForTypeExpect(node.ty, "unacceptable return type", None) { Ok(v) => v, Err(e) => return Err(e) }
              Some(ty)
            }
            (Callable.Value(fnValPtr, retTypeQbe), [])
          }
        }
        // TODO: destructuring
        val fnVal = _p[0]
        val argMetadata = _p[1]

        var defaultValueParamIdx = -1
        var defaultValueFlags = 0
        for arg, idx in arguments {
          var argHasDefaultValue = false
          var argTy: Type? = None
          if argMetadata[idx] |_m| {
            // TODO: destructuring
            argHasDefaultValue = _m[0]
            argTy = Some(_m[1])
          }

          if argHasDefaultValue {
            defaultValueParamIdx += 1
          }

          if arg |node| {
            val arg = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
            args.push(arg)
          } else if argTy |argTy| {
            defaultValueFlags ||= (1 << defaultValueParamIdx)

            val argQbeType = match self._getQbeTypeForTypeExpect(argTy, "unacceptable type for argument", Some(node.token.position)) { Ok(v) => v, Err(e) => return Err(e) }
            args.push(argQbeType.zeroValue())
          } else {
            return unreachable("invocation target must be an arbitrary expression, which do not have default-valued arguments", node.token.position)
          }
        }

        if fnHasOptionalParameters {
          args.push(Value.Int32(defaultValueFlags))
        }

        // TODO: yikes...
        var res = if fnVal.returnType() {
          if closureEnvCtx |_ctx| {
            // TODO: destructuring
            val closureEnvPtr = _ctx[0]
            val needsNullCheck = _ctx[1]
            val res = if needsNullCheck {
              val labelCallWithEnv = self._currentFn.block.addLabel("call_fn_val_with_env")
              val labelCallWithoutEnv = self._currentFn.block.addLabel("call_fn_val_without_env")
              val labelCont = self._currentFn.block.addLabel("call_fn_val_cont")

              self._currentFn.block.buildJnz(closureEnvPtr, labelCallWithEnv, labelCallWithoutEnv)

              self._currentFn.block.registerLabel(labelCallWithEnv)
              val resWithEnv = if closureSelfCtx |selfVal| {
                val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_with_env_with_self")
                val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_with_env_without_self")
                val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_with_env")

                self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

                self._currentFn.block.registerLabel(labelCallWithSelf)
                val resWithSelf = match self._currentFn.block.buildCall(fnVal, [selfVal].concat(args), resultLocalName, Some(closureEnvPtr)) { Ok(v) => v, Err(e) => return qbeError(e) }
                val resWithSelfLabel = self._currentFn.block.currentLabel
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCallWithoutSelf)
                val resWithoutSelf = match self._currentFn.block.buildCall(fnVal, args, resultLocalName, Some(closureEnvPtr)) { Ok(v) => v, Err(e) => return qbeError(e) }
                val resWithoutSelfLabel = self._currentFn.block.currentLabel
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCont)

                val phiCases = [(resWithSelfLabel, resWithSelf), (resWithoutSelfLabel, resWithoutSelf)]
                val res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }
                res
              } else {
                val res = match self._currentFn.block.buildCall(fnVal, args, resultLocalName, Some(closureEnvPtr)) { Ok(v) => v, Err(e) => return qbeError(e) }
                res
              }
              val resWithEnvLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCallWithoutEnv)
              val resWithoutEnv = if closureSelfCtx |selfVal| {
                val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_without_env_with_self")
                val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_without_env_without_self")
                val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_without_env")

                self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

                self._currentFn.block.registerLabel(labelCallWithSelf)
                val resWithSelf = match self._currentFn.block.buildCall(fnVal, [selfVal].concat(args), resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
                val resWithSelfLabel = self._currentFn.block.currentLabel
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCallWithoutSelf)
                val resWithoutSelf = match self._currentFn.block.buildCall(fnVal, args, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
                val resWithoutSelfLabel = self._currentFn.block.currentLabel
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCont)

                val phiCases = [(resWithSelfLabel, resWithSelf), (resWithoutSelfLabel, resWithoutSelf)]
                val res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }
                res
              } else {
                val res = match self._currentFn.block.buildCall(fnVal, args, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
                res
              }
              val resWithoutEnvLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(resWithEnvLabel, resWithEnv), (resWithoutEnvLabel, resWithoutEnv)]

              val res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }
              res
            } else {
              val res = match self._currentFn.block.buildCall(fnVal, args, resultLocalName, Some(closureEnvPtr)) { Ok(v) => v, Err(e) => return qbeError(e) }
              res
            }
            res
          } else {
            val res = match self._currentFn.block.buildCall(fnVal, args, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            res
          }
        } else {
          if closureEnvCtx |_ctx| {
            // TODO: destructuring
            val closureEnvPtr = _ctx[0]
            val needsNullCheck = _ctx[1]
            if needsNullCheck {
              val labelCallWithEnv = self._currentFn.block.addLabel("call_fn_val_with_env")
              val labelCallWithoutEnv = self._currentFn.block.addLabel("call_fn_val_without_env")
              val labelCont = self._currentFn.block.addLabel("call_fn_val_cont")

              self._currentFn.block.buildJnz(closureEnvPtr, labelCallWithEnv, labelCallWithoutEnv)

              self._currentFn.block.registerLabel(labelCallWithEnv)
              if closureSelfCtx |selfVal| {
                val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_with_env_with_self")
                val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_with_env_without_self")
                val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_with_env")

                self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

                self._currentFn.block.registerLabel(labelCallWithSelf)
                self._currentFn.block.buildVoidCall(fnVal, [selfVal].concat(args), Some(closureEnvPtr))
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCallWithoutSelf)
                self._currentFn.block.buildVoidCall(fnVal, args, Some(closureEnvPtr))
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCont)
              } else {
                self._currentFn.block.buildVoidCall(fnVal, args, Some(closureEnvPtr))
              }
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCallWithoutEnv)
              if closureSelfCtx |selfVal| {
                val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_without_env_with_self")
                val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_without_env_without_self")
                val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_without_env")

                self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

                self._currentFn.block.registerLabel(labelCallWithSelf)
                self._currentFn.block.buildVoidCall(fnVal, [selfVal].concat(args))
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCallWithoutSelf)
                self._currentFn.block.buildVoidCall(fnVal, args)
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCont)
              } else {
                self._currentFn.block.buildVoidCall(fnVal, args, Some(closureEnvPtr))
              }
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)
            } else {
              self._currentFn.block.buildVoidCall(fnVal, args, Some(closureEnvPtr))
            }
          } else {
            if closureSelfCtx |selfVal| {
              val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_with_env_with_self")
              val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_with_env_without_self")
              val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_with_env")

              self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

              self._currentFn.block.registerLabel(labelCallWithSelf)
              self._currentFn.block.buildVoidCall(fnVal, [selfVal].concat(args))
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCallWithoutSelf)
              self._currentFn.block.buildVoidCall(fnVal, args)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)
            } else {
              self._currentFn.block.buildVoidCall(fnVal, args)
            }
          }

          Value.Ident("bogus", QbeType.F32)
        }

        if optSafeCtx |_ctx| {
          val labelIsNone = _ctx[0]
          val noneRes = _ctx[1]
          val someVariantFn = _ctx[2]
          val labelCont = _ctx[3]

          val labelIsSome = if noneRes |noneRes| {
            val labelIsSome = self._currentFn.block.currentLabel
            val someRes = match self._currentFn.block.buildCall(Callable.Function(someVariantFn), [res]) { Ok(v) => v, Err(e) => return qbeError(e) }
            Some((labelIsSome, someRes, noneRes))
          } else None
          self._currentFn.block.buildJmp(labelCont)

          self._currentFn.block.addComment("...opt-safe call end")
          self._currentFn.block.registerLabel(labelCont)

          if labelIsSome |_p| {
            // TODO: destructuring
            val labelIsSome = _p[0]
            val someRes = _p[1]
            val noneRes = _p[2]
            val phiCases = [(labelIsNone, noneRes), (labelIsSome, someRes)]
            res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }
          }
        }

        Ok(res)
      }
      TypedAstNodeKind.Array(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val inner = if generics[0] |t| t else return unreachable("Array has 1 required type argument")
            match self._resolvedGenerics.addLayer("array literal", { "T": inner }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "array literal", message: e))) }
          }
          _ => return unreachable("we know it's an array instance here")
        }

        val arrayWithCapacityFn = if self._project.preludeArrayStruct.staticMethods.find(m => m.label.name == "withCapacity") |fn| fn else return unreachable("Array.withCapacity must exist")
        val arrayWithCapacityFnVal = match self._getOrCompileMethod(node.ty, arrayWithCapacityFn) { Ok(v) => v, Err(e) => return Err(e) }

        val sizeVal = Value.Int(items.length.nextPowerOf2())
        val arrayInstance = match self._currentFn.block.buildCall(Callable.Function(arrayWithCapacityFnVal), [sizeVal], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.addCommentBefore("${arrayInstance.repr()}: ${node.ty.repr()}")

        val arrayPushFn = if self._project.preludeArrayStruct.instanceMethods.find(m => m.label.name == "push") |fn| fn else return unreachable("Array#push must exist")
        val arrayPushFnVal = match self._getOrCompileMethod(node.ty, arrayPushFn) { Ok(v) => v, Err(e) => return Err(e) }

        for item in items {
          val itemVal = match self._compileExpression(item) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildVoidCall(Callable.Function(arrayPushFnVal), [arrayInstance, itemVal])
        }

        self._resolvedGenerics.popLayer()

        Ok(arrayInstance)
      }
      TypedAstNodeKind.Set(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val inner = if generics[0] |t| t else return unreachable("Set has 1 required type argument")
            match self._resolvedGenerics.addLayer("set literal", { "T": inner }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "set literal", message: e))) }
          }
          _ => return unreachable("we know it's a set instance here")
        }

        val setNewFn = if self._project.preludeSetStruct.staticMethods.find(m => m.label.name == "new") |fn| fn else return unreachable("Set.new must exist")
        val setNewFnVal = match self._getOrCompileMethod(node.ty, setNewFn) { Ok(v) => v, Err(e) => return Err(e) }

        val setInstance = match self._currentFn.block.buildCall(Callable.Function(setNewFnVal), [Value.Int(0), Value.Int32(1)], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.addCommentBefore("${setInstance.repr()}: ${node.ty.repr()}")

        val setInsertFn = if self._project.preludeSetStruct.instanceMethods.find(m => m.label.name == "insert") |fn| fn else return unreachable("Set#insert must exist")
        val setInsertFnVal = match self._getOrCompileMethod(node.ty, setInsertFn) { Ok(v) => v, Err(e) => return Err(e) }

        for item in items {
          val itemVal = match self._compileExpression(item) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildVoidCall(Callable.Function(setInsertFnVal), [setInstance, itemVal])
        }

        self._resolvedGenerics.popLayer()

        Ok(setInstance)
      }
      TypedAstNodeKind.Map(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val key = if generics[0] |t| t else return unreachable("Map has 2 required type arguments")
            val value = if generics[1] |t| t else return unreachable("Map has 2 required type arguments")
            match self._resolvedGenerics.addLayer("map literal", { "K": key, "V": value }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "map literal", message: e))) }
          }
          _ => return unreachable("we know it's a map instance here")
        }


        val mapNewFn = if self._project.preludeMapStruct.staticMethods.find(m => m.label.name == "new") |fn| fn else return unreachable("Map.new must exist")
        val mapNewFnVal = match self._getOrCompileMethod(node.ty, mapNewFn) { Ok(v) => v, Err(e) => return Err(e) }

        val mapInstance = match self._currentFn.block.buildCall(Callable.Function(mapNewFnVal), [Value.Int(0), Value.Int32(1)], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.addCommentBefore("${mapInstance.repr()}: ${node.ty.repr()}")

        val mapInsertFn = if self._project.preludeMapStruct.instanceMethods.find(m => m.label.name == "insert") |fn| fn else return unreachable("Map#insert must exist")
        val mapInsertFnVal = match self._getOrCompileMethod(node.ty, mapInsertFn) { Ok(v) => v, Err(e) => return Err(e) }

        for _item in items {
          val keyVal = match self._compileExpression(_item[0]) { Ok(v) => v, Err(e) => return Err(e) }
          val valueVal = match self._compileExpression(_item[1]) { Ok(v) => v, Err(e) => return Err(e) }
          match self._currentFn.block.buildCall(Callable.Function(mapInsertFnVal), [mapInstance, keyVal, valueVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
        }

        self._resolvedGenerics.popLayer()

        Ok(mapInstance)
      }
      TypedAstNodeKind.Tuple(items) => {
        val tupleStruct = self._tupleStruct(items.length)
        val selfType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(tupleStruct), items.map(node => node.ty)))

        val resolvedGenerics: Map<String, Type> = {}
        val template = Type(kind: TypeKind.Instance(StructOrEnum.Struct(tupleStruct), tupleStruct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        for _p in selfType.extractGenerics(template) {
          resolvedGenerics[_p[0]] = _p[1]
        }
        match self._resolvedGenerics.addLayer(tupleStruct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: tupleStruct.label.name, message: e))) }
        val fnVal = match self._getOrCompileStructInitializer(tupleStruct) { Ok(v) => v, Err(e) => return Err(e) }

        self._resolvedGenerics.popLayer()

        val itemVals: Value[] = []
        for item in items {
          val itemVal = match self._compileExpression(item) { Ok(v) => v, Err(e) => return Err(e) }
          itemVals.push(itemVal)
        }

        val tuple = match self._currentFn.block.buildCall(Callable.Function(fnVal), itemVals) { Ok(v) => v, Err(e) => return qbeError(e) }
        Ok(tuple)
      }
      TypedAstNodeKind.Indexing(indexingNode) => {
        match indexingNode {
          TypedIndexingNode.ArrayLike(expr, indexingMode) => {
            val exprVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }

            match indexingMode {
              IndexingMode.Single(idxExpr) => {
                val idxExprVal = match self._compileExpression(idxExpr) { Ok(v) => v, Err(e) => return Err(e) }

                val instType = match self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "get", expr.token.position) { Ok(v) => v, Err(e) => return Err(e) }
                val _t = match self._getInstanceTypeForType(expr.ty) { Ok(v) => v, Err(e) => return Err(e) }
                // TODO: destructuring
                val getFn = match _t[0] {
                  StructOrEnum.Struct(struct) => if struct.instanceMethods.find(m => m.label.name == "get") |fn| fn else return unreachable("#get must exist for array-like indexing")
                  StructOrEnum.Enum => return unreachable("array-like indexing never applies to enum instances")
                }
                val getFnVal = match self._getOrCompileMethod(instType, getFn) { Ok(v) => v, Err(e) => return Err(e) }
                self._resolvedGenerics.popLayer()

                val res = match self._currentFn.block.buildCall(Callable.Function(getFnVal), [exprVal, idxExprVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
                Ok(res)
              }
              IndexingMode.Range(startExpr, endExpr) => {
                var maskParam = 0
                val startExprVal = if startExpr |startExpr| {
                  val res = match self._compileExpression(startExpr) { Ok(v) => v, Err(e) => return Err(e) }
                  res
                } else {
                  maskParam ||= 1
                  Value.Int(0)
                }
                val endExprVal = if endExpr |endExpr| {
                  val res = match self._compileExpression(endExpr) { Ok(v) => v, Err(e) => return Err(e) }
                  res
                } else {
                  maskParam ||= (1 << 1)
                  Value.Int(0)
                }

                val instType = match self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "getRange", expr.token.position) { Ok(v) => v, Err(e) => return Err(e) }
                val _t = match self._getInstanceTypeForType(expr.ty) { Ok(v) => v, Err(e) => return Err(e) }
                // TODO: destructuring
                val getRangeFn = match _t[0] {
                  StructOrEnum.Struct(struct) => if struct.instanceMethods.find(m => m.label.name == "getRange") |fn| fn else return unreachable("#getRange must exist for array-like indexing")
                  StructOrEnum.Enum => return unreachable("array-like indexing never applies to enum instances")
                }
                val getRangeFnVal = match self._getOrCompileMethod(instType, getRangeFn) { Ok(v) => v, Err(e) => return Err(e) }
                self._resolvedGenerics.popLayer()

                val res = match self._currentFn.block.buildCall(Callable.Function(getRangeFnVal), [exprVal, startExprVal, endExprVal, Value.Int32(maskParam)]) { Ok(v) => v, Err(e) => return qbeError(e) }
                Ok(res)
              }
            }
          }
          TypedIndexingNode.Map(expr, idxExpr) => {
            val exprVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
            val idxExprVal = match self._compileExpression(idxExpr) { Ok(v) => v, Err(e) => return Err(e) }

            val instType = match self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "get", expr.token.position) { Ok(v) => v, Err(e) => return Err(e) }
            val _t = match self._getInstanceTypeForType(expr.ty) { Ok(v) => v, Err(e) => return Err(e) }
            // TODO: destructuring
            val struct = match _t[0] {
              StructOrEnum.Struct(struct) => struct
              StructOrEnum.Enum => return unreachable("map indexing never applies to enum instances")
            }
            if struct != self._project.preludeMapStruct return unreachable("map indexing only implemented for map")

            val getFn = if self._project.preludeMapStruct.instanceMethods.find(m => m.label.name == "get") |fn| fn else return unreachable("Map#get must exist")
            val getFnVal = match self._getOrCompileMethod(instType, getFn) { Ok(v) => v, Err(e) => return Err(e) }
            self._resolvedGenerics.popLayer()

            val res = match self._currentFn.block.buildCall(Callable.Function(getFnVal), [exprVal, idxExprVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          TypedIndexingNode.Tuple(tupleExpr, idx) => {
            val exprVal = match self._compileExpression(tupleExpr) { Ok(v) => v, Err(e) => return Err(e) }

            val _t = match self._getInstanceTypeForType(tupleExpr.ty) { Ok(v) => v, Err(e) => return Err(e) }
            // TODO: destructuring
            val struct = match _t[0] {
              StructOrEnum.Struct(struct) => struct
              StructOrEnum.Enum => return unreachable("tuples are represented as structs")
            }

            val selfType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), _t[1]))

            val resolvedGenerics: Map<String, Type> = {}
            val template = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
            for _p in selfType.extractGenerics(template) {
              resolvedGenerics[_p[0]] = _p[1]
            }
            match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }

            var offset = 0
            for f, fieldIdx in struct.fields {
              if fieldIdx == idx break

              val fieldTy = match self._getQbeTypeForTypeExpect(f.ty, "unacceptable type for field", Some(f.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
              offset += fieldTy.size()
            }

            self._resolvedGenerics.popLayer()

            val ptr = match self._currentFn.block.buildAdd(Value.Int(offset), exprVal) { Ok(v) => v, Err(e) => return qbeError(e) }
            val res = self._currentFn.block.buildLoadL(ptr)
            self._currentFn.block.addCommentBefore("${res.repr()}: ${exprVal.repr()}.$idx")
            Ok(res)
          }
        }
      }
      TypedAstNodeKind.Lambda(fn, typeHint) => {
        val targetParamTypes = if typeHint |hint| {
          val paramTypes = match hint.kind {
            TypeKind.Func(paramTypes, _) => Some(paramTypes)
            TypeKind.Any => None // if the function value is being treated as an Any, then no param type info needs to be known later anyway
            _ => return unreachable("typeKind must be TypeKind.Func", node.token.position)
          }
          paramTypes
        } else {
          None
        }

        val capturesMem = if !fn.isClosure() None else {
          val mem = match self._createClosureCaptures(fn) { Ok(v) => v, Err(e) => return Err(e) }
          Some(mem)
        }

        val fnValBase = match self._getOrCompileFunction(fn) { Ok(v) => v, Err(e) => return Err(e) }
        self._compileFunctionValue(node.token.position, fn, fnValBase, targetParamTypes, capturesMem, None)
      }
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if isStatement return unreachable("if-statements are handled elsewhere", node.token.position)
        if elseBlock.isEmpty() return unreachable("if-expressions must not have empty else-blocks", node.token.position)

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        val condVal = match self._compileExpression(cond) { Ok(v) => v, Err(e) => return Err(e) }
        val condExprIsOpt = self._typeIsOption(cond.ty)
        if condExprIsOpt {
          val variantIsOptionSome = match self._emitOptValueIsSomeVariant(condVal) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildJnz(variantIsOptionSome, labelThen, labelElse)
        } else {
          self._currentFn.block.buildJnz(condVal, labelThen, labelElse)
        }

        val phiCases: (Label, Value)[] = []

        self._currentFn.block.registerLabel(labelThen)
        if conditionBinding |_p| {
          // TODO: destructuring
          val _bindingPattern = _p[0]
          val vars = _p[1]

          val bindingVar = if vars[0] |v| v else return unreachable("Binding pattern requires 1 variable", node.token.position)
          val slotName = self._currentFn.block.addVar(variableToVar(bindingVar))
          if condExprIsOpt |innerTy| {
            val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
            val optInnerValue = match self._emitOptValueGetValue(innerQbeType, condVal) { Ok(v) => v, Err(e) => return Err(e) }

            val slot = self._buildStackAllocForQbeType(innerQbeType, Some(slotName))
            self._currentFn.block.buildStore(innerQbeType, optInnerValue, slot)
          } else {
            val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
            val slot = self._buildStackAllocForQbeType(boolTypeQbe, Some(slotName))
            self._currentFn.block.buildStore(boolTypeQbe, Value.Int32(1), slot)
          }
        }
        for node, idx in ifBlock {
          val res = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
          if idx == ifBlock.length - 1 {
            if res |res| {
              val label = self._currentFn.block.currentLabel
              phiCases.push((label, res))
            } else if !ifBlockTerminator {
              return unreachable("last statement in if-expr block has no value and is not a terminator", node.token.position)
            }
          }
        }
        if !ifBlockTerminator {
          self._currentFn.block.buildJmp(labelCont)
        }

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node, idx in elseBlock {
            val res = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
            if idx == elseBlock.length - 1 {
              if res |res| {
                val label = self._currentFn.block.currentLabel
                phiCases.push((label, res))
              } else if !elseBlockTerminator {
                return unreachable("last statement in if-expr else block has no value and is not a terminator", node.token.position)
              }
            }
          }
          if !elseBlockTerminator {
            self._currentFn.block.buildJmp(labelCont)
          }
        }

        self._currentFn.block.registerLabel(labelCont)

        if !phiCases.isEmpty() {
          val res = match self._currentFn.block.buildPhi(phiCases, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
          Ok(res)
        } else {
          self._currentFn.block.buildHalt()
          Ok(Value.Ident("bogus", QbeType.F32))
        }
      }
      TypedAstNodeKind.Match(isStatement, expr, cases) => {
        val res = match self._compileMatch(node, isStatement, expr, cases) { Ok(v) => v, Err(e) => return Err(e) }
        if res |res| Ok(res) else return unreachable("match expression needs a resulting value", node.token.position)
      }
      _ => unreachable("node must be a statement", node.token.position)
    }

    self._currentNode = prevNode

    res
  }

  func _compileLiteral(self, lit: LiteralAstNode): Result<(Value, Type), CompileError> {
    Ok(match lit {
      LiteralAstNode.Int(v) => (Value.Int(v), Type(kind: TypeKind.PrimitiveInt))
      LiteralAstNode.Float(f) => (Value.Float(f), Type(kind: TypeKind.PrimitiveFloat))
      LiteralAstNode.Bool(b) => (Value.Int32(if b 1 else 0), Type(kind: TypeKind.PrimitiveBool))
      LiteralAstNode.String(s) => {
        val dataPtr = self._builder.buildGlobalString(s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"").replaceAll("\n", "\\n"))
        val instancePtr = match self._constructString(dataPtr, Value.Int(s.length)) { Ok(v) => v, Err(e) => return Err(e) }
        (instancePtr, Type(kind: TypeKind.PrimitiveString))
      }
    })
  }

  func _compileMatch(self, node: TypedAstNode, isStatement: Bool, expr: TypedAstNode, cases: TypedMatchCase[]): Result<Value?, CompileError> {
    val exprVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }

    val matchLabelPrefix = "match_${node.token.position.line}_${node.token.position.col}"
    val endLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_end")
    var seenNoneCase = false
    val exprTypeIsOpt = self._typeIsOption(expr.ty)

    val resValSlotCtx = if !isStatement {
      val slotName = "${matchLabelPrefix}_result.slot"
      val nodeTypeQbe = match self._getQbeTypeForTypeExpect(node.ty, "qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
      val slot = self._buildStackAllocForQbeType(nodeTypeQbe, Some(slotName))
      Some((slot, nodeTypeQbe))
    } else None

    for case, idx in cases {
      val _p = match case.kind {
        TypedMatchCaseKind.Literal(lit) => {
          val nextCaseLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__next")

          val _e = if exprTypeIsOpt |innerTy| {
            val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
            if seenNoneCase {
              val optInnerValue = match self._emitOptValueGetValue(innerQbeType, exprVal) { Ok(v) => v, Err(e) => return Err(e) }
              (optInnerValue, innerTy)
            } else {
              val isSomeCond = match self._emitOptValueIsSomeVariant(exprVal) { Ok(v) => v, Err(e) => return Err(e) }
              val isSomeLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__issome")
              self._currentFn.block.buildJnz(isSomeCond, isSomeLabel, nextCaseLabel)
              self._currentFn.block.registerLabel(isSomeLabel)
              val optInnerValue = match self._emitOptValueGetValue(innerQbeType, exprVal) { Ok(v) => v, Err(e) => return Err(e) }
              (optInnerValue, innerTy)
            }
          } else {
            (exprVal, expr.ty)
          }
          // TODO: destructuring
          val exprVal = _e[0]
          val exprType = _e[1]

          val _p = match self._compileLiteral(lit) { Ok(v) => v, Err(e) => return Err(e) }
          // TODO: destructuring
          val litVal = _p[0]
          val litType = _p[1]

          if !self._project.typesAreEquivalent(exprType, litType) return unreachable("equality operators require matching types", node.token.position)

          val cond = match self._compileEqLogic(exprVal, litVal, litType, expr.token.position) { Ok(v) => v, Err(e) => return Err(e) }
          val isEqLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_iseq")

          self._currentFn.block.buildJnz(cond, isEqLabel, nextCaseLabel)
          self._currentFn.block.registerLabel(isEqLabel)

          (Some(nextCaseLabel), exprVal, exprType)
        }
        TypedMatchCaseKind.None_ => {
          seenNoneCase = true

          val isNoneCond = match self._emitOptValueIsSomeVariant(exprVal: exprVal, negate: true) { Ok(v) => v, Err(e) => return Err(e) }
          val isNoneLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_isnone")
          val nextCaseLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_next_$idx")

          self._currentFn.block.buildJnz(isNoneCond, isNoneLabel, nextCaseLabel)
          self._currentFn.block.registerLabel(isNoneLabel)

          (Some(nextCaseLabel), exprVal, expr.ty)
        }
        TypedMatchCaseKind.EnumVariant(enum_, variant, variantIdx, destructuredVariables) => {
          val nextCaseLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__next")
          val _e = if exprTypeIsOpt |innerTy| {
            val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
            if seenNoneCase {
              val optInnerValue = match self._emitOptValueGetValue(innerQbeType, exprVal) { Ok(v) => v, Err(e) => return Err(e) }
              (optInnerValue, innerTy)
            } else {
              val isSomeCond = match self._emitOptValueIsSomeVariant(exprVal) { Ok(v) => v, Err(e) => return Err(e) }
              val isSomeLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__issome")
              self._currentFn.block.buildJnz(isSomeCond, isSomeLabel, nextCaseLabel)
              self._currentFn.block.registerLabel(isSomeLabel)
              val optInnerValue = match self._emitOptValueGetValue(innerQbeType, exprVal) { Ok(v) => v, Err(e) => return Err(e) }
              (optInnerValue, innerTy)
            }
          } else {
            (exprVal, expr.ty)
          }
          // TODO: destructuring
          val exprVal = _e[0]
          val exprType = _e[1]

          val exprValVariantIdxVal = self._emitGetEnumVariantIdx(exprVal)
          val cond = match self._currentFn.block.buildCompareEq(exprValVariantIdxVal, Value.Int(variantIdx)) { Ok(v) => v, Err(e) => return qbeError(e) }
          val isVariantLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_is${variant.label.name}")

          self._currentFn.block.buildJnz(cond, isVariantLabel, nextCaseLabel)
          self._currentFn.block.registerLabel(isVariantLabel)

          if !destructuredVariables.isEmpty() {
            match self._addResolvedGenericsLayerForEnumVariant(exprType, variant.label.name, node.token.position) { Ok(v) => v, Err(e) => return Err(e) }
            val variantFields = match variant.kind {
              EnumVariantKind.Container(fields) => fields
              _ => return unreachable("cannot destructure a non-container enum variant", node.token.position)
            }

            var memCursor = match self._emitGetEnumVariantValueStart(exprVal) { Ok(v) => v, Err(e) => return Err(e) }
            for v, idx in destructuredVariables {
              val field = if variantFields[idx] |f| f else return unreachable("this should be caught during typechecking", node.token.position)
              val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }

              val fieldVal = self._currentFn.block.buildLoad(fieldTy, memCursor)
              val slotName = self._currentFn.block.addVar(variableToVar(v))
              val slot = self._buildStackAllocForQbeType(fieldTy, Some(slotName))
              self._currentFn.block.buildStore(fieldTy, fieldVal, slot)

              if idx != destructuredVariables.length - 1 {
                val offset = fieldTy.size()
                memCursor = match self._currentFn.block.buildAdd(Value.Int(offset), memCursor) { Ok(v) => v, Err(e) => return qbeError(e) }
              }
            }

            self._resolvedGenerics.popLayer()
          }

          (Some(nextCaseLabel), exprVal, exprType)
        }
        TypedMatchCaseKind.Else => {
          val _e = if exprTypeIsOpt |innerTy| {
            if seenNoneCase {
              val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
              val optInnerValue = match self._emitOptValueGetValue(innerQbeType, exprVal) { Ok(v) => v, Err(e) => return Err(e) }

              (optInnerValue, innerTy)
            } else (exprVal, expr.ty)
          } else (exprVal, expr.ty)
          val exprVal = _e[0]
          val exprType = _e[1]

          // No nextCaseLabel, since the `else` case will always be the last case if present
          (None, exprVal, exprType)
        }
        _ => return todo("other match case types", node.token.position)
      }
      // TODO: destructuring
      val nextCaseLabel = _p[0]
      val exprVal = _p[1]
      val exprType = _p[2]

      if case.binding |v| {
        val slotName = self._currentFn.block.addVar(variableToVar(v))
        val bindingTypeQbe = match self._getQbeTypeForTypeExpect(exprType, "qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
        val slot = self._buildStackAllocForQbeType(bindingTypeQbe, Some(slotName))
        self._currentFn.block.buildStore(bindingTypeQbe, exprVal, slot)
      }

      for node, idx in case.body {
        val res = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
        if idx == case.body.length - 1 {
          if resValSlotCtx |_p| {
            if res |res| {
              // TODO: destructuring
              val slot = _p[0]
              val slotTy = _p[1]
              self._currentFn.block.buildStore(slotTy, res, slot)
            }
          }
        }
      }
      if !case.terminator {
        self._currentFn.block.buildJmp(endLabel)
      }

      if nextCaseLabel |nextCaseLabel| {
        self._currentFn.block.registerLabel(nextCaseLabel)
      }
    }

    self._currentFn.block.registerLabel(endLabel)

    val result = if resValSlotCtx |_p| {
      val slot = _p[0]
      val slotTy = _p[1]
      val res = self._currentFn.block.buildLoad(slotTy, slot)
      Some(res)
    } else {
      None
    }

    Ok(result)
  }

  func _getCapturedVarPtr(self, variable: Variable): Result<Value, CompileError> {
    if self._currentFunction |fn| {
      if self._currentFn._env |env| {
        for v, idx in fn.captures {
          if v.label.name == variable.label.name {
            // When loading the captured variable from the closure env, if the captured variable is immutable then we
            // don't need to dereference the value of `env[idx]`; only mutable variables need to be stored using an
            // additional indirection layer to account for reassignment.
            val captureSlot = match self._currentFn.block.buildAdd(Value.Int(idx * QbeType.Pointer.size()), env) { Ok(v) => v, Err(e) => return qbeError(e) }
            var varTy = if variable.mutable {
              self._currentFn.block.addComment("get ptr to captured mutable '${variable.label.name}'")
              QbeType.Pointer
            } else {
              self._currentFn.block.addComment("get captured '${variable.label.name}'")
              val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
              varTy
            }
            val ptrOrValue = self._currentFn.block.buildLoad(varTy, captureSlot)
            return Ok(ptrOrValue)
          }
        }
      }
    }

    // If the captured variable is a parameter but we're not currently referencing it from a closure, then it can be resolved as any ordinary
    // parameter (simply by name) since it's an immutable variable that has not been moved to the heap.
    if variable.isParameter {
      val slotName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else return unreachable("Could not resolve name for variable '${variable.label.name}'")
      val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
      return Ok(Value.Ident(slotName, varTy))
    }

    // If we're not currently in a function body, or if the captured variable is not a capture of the current function, then
    // we may need to undo the extra layer of pointer indirection which comes as a result of being captured by some other function,
    // if the captured variable is mutable. If it's not mutable then it will not have been moved to the heap, so no additional pointer
    // needs to be dereferenced.
    val slotName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else return unreachable("Could not resolve name for variable '${variable.label.name}'")
    val slot = Value.Ident(slotName, QbeType.Pointer)
    var varTy = if variable.mutable {
      self._currentFn.block.addComment("get ptr to captured mutable '${variable.label.name}'")
      QbeType.Pointer
    } else {
      self._currentFn.block.addComment("get captured '${variable.label.name}'")
      val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
      varTy
    }
    val ptrOrValue = self._currentFn.block.buildLoad(varTy, slot)
    Ok(ptrOrValue)
  }

  func _createClosureCaptures(self, fn: Function): Result<Value, CompileError> {
    val size = QbeType.Pointer.size() * (fn.captures.length + fn.capturedClosures.length)
    val capturesMem = match self._currentFn.block.buildCall(Callable.Function(self._malloc), [Value.Int(size)], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }
    var cursor = capturesMem

    for variable in fn.captures {
      val ptr = match self._getCapturedVarPtr(variable) { Ok(v) => v, Err(e) => return Err(e) }
      var varTy = if variable.mutable {
        self._currentFn.block.addComment("store ptr to captured mutable '${variable.label.name}' in captures")
        QbeType.Pointer
      } else {
        self._currentFn.block.addComment("store captured mutable '${variable.label.name}' in captures")
        val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
        varTy
      }
      self._currentFn.block.buildStore(varTy, ptr, cursor)
      if fn.captures.length > 1 || fn.capturedClosures.length > 0 {
        cursor = match self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size()), cursor) { Ok(v) => v, Err(e) => return qbeError(e) }
      }
    }

    for capturedFn in fn.capturedClosures {
      val capturesArr = match self._getCapturesArrForClosure(capturedFn) { Ok(v) => v, Err(e) => return Err(e) }
      self._currentFn.block.buildStore(QbeType.Pointer, capturesArr, cursor)
      if fn.capturedClosures.length > 1 {
        cursor = match self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size()), cursor) { Ok(v) => v, Err(e) => return qbeError(e) }
      }
    }

    Ok(capturesMem)
  }

  func _getCapturesArrForClosure(self, fn: Function): Result<Value, CompileError> {
    val fnInvocationIsAtDeclaredScope = if self._currentFunction |currentFunc| {
      fn.scope.parent == Some(currentFunc.scope)
    } else {
      true
    }

    val res = if !fnInvocationIsAtDeclaredScope {
      val currentFunc = if self._currentFunction |currentFn| currentFn else return unreachable("we must be within a function to enter this case", fn.label.position)

      val _p = if currentFunc.capturedClosures.findIndex(f => f.label.name == fn.label.name) |_p| _p else return unreachable("closure '${fn.label.name}' called within function '${currentFunc.label.name}', but not tracked in its capturedClosures", fn.label.position)
      // TODO: destructuring
      val idx = _p[1]

      val env = if self._currentFn._env |env| env else return unreachable("expected currentFn ('${self._currentFn.name}') to have an `_env`, but it didn't")
      val offset = QbeType.Pointer.size() * (currentFunc.captures.length + idx)

      val ptr = match self._currentFn.block.buildAdd(Value.Int(offset), env) { Ok(v) => v, Err(e) => return qbeError(e) }
      self._currentFn.block.buildLoadL(ptr)
    } else {
      // If the closure is being called in the same scope in which it was declared, then the `*.captures` value is visible as a stack local.
      val prefix = match fn.kind {
        FunctionKind.InstanceMethod(structOrEnum) => {
          val v = if structOrEnum |structOrEnum| {
            val typeName = match structOrEnum {
              StructOrEnum.Struct(struct) => struct.label.name
              StructOrEnum.Enum(enum_) => enum_.label.name
            }
            "$typeName.."
          } else return unreachable("an instance method should have a structOrEnum", fn.label.position)
          v
        }
        FunctionKind.StaticMethod(structOrEnum) => {
          val typeName = match structOrEnum {
            StructOrEnum.Struct(struct) => struct.label.name
            StructOrEnum.Enum(enum_) => enum_.label.name
          }
          "$typeName."
        }
        _ => ""
      }
      val capturesName = "$prefix${fn.label.name}.captures"
      self._currentFn.block.buildLoadL(Value.Ident(capturesName, QbeType.Pointer))
    }

    Ok(res)
  }

  func _compileBinaryOperands(self, left: TypedAstNode, right: TypedAstNode, op: String): Result<(Value, Value), CompileError> {
    var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
    var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

    if !self._project.typesAreEquivalent(left.ty, right.ty) {
      val leftIsFloat = self._typeIsFloat(left.ty)
      val rightIsFloat = self._typeIsFloat(right.ty)
      if leftIsFloat && !rightIsFloat {
        rightVal = self._currentFn.block.buildLToF(rightVal)
      } else if rightIsFloat && !leftIsFloat {
        leftVal = self._currentFn.block.buildLToF(leftVal)
      } else {
        return unreachable("unknown operator '$op' between types '${left.ty.repr()}' and '${right.ty.repr()}'")
      }
    }

    Ok((leftVal, rightVal))
  }

  func _compileBinaryEq(self, left: TypedAstNode, right: TypedAstNode, localName: String? = None, negate = false): Result<Value, CompileError> {
    var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
    var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

    if !self._project.typesAreEquivalent(left.ty, right.ty) return unreachable("equality operators require matching types", right.token.position)

    self._compileEqLogic(leftVal, rightVal, left.ty, left.token.position, localName, negate)
  }

  func _compileEqLogic(self, leftVal: Value, rightVal: Value, ty: Type, position: Position, localName: String? = None, negate = false): Result<Value, CompileError> {
    if self._typeIsInt(ty) || self._typeIsFloat(ty) || self._typeIsBool(ty) {
      val res = if negate {
        val res = match self._currentFn.block.buildCompareNeq(leftVal, rightVal, localName) { Ok(v) => v, Err(e) => return qbeError(e) }
        res
      } else {
        val res = match self._currentFn.block.buildCompareEq(leftVal, rightVal, localName) { Ok(v) => v, Err(e) => return qbeError(e) }
        res
      }
      return Ok(res)
    }

    val instType = match self._addResolvedGenericsLayerForInstanceMethod(ty, "eq", position) { Ok(v) => v, Err(e) => return Err(e) }
    val eqFnVal = match self._getOrCompileEqMethod(instType) { Ok(v) => v, Err(e) => return Err(e) }
    self._resolvedGenerics.popLayer()

    val res = match self._currentFn.block.buildCall(Callable.Function(eqFnVal), [leftVal, rightVal], localName) { Ok(v) => v, Err(e) => return qbeError(e) }
    if negate {
      val plusOneVal = match self._currentFn.block.buildAdd(Value.Int32(1), res) { Ok(v) => v, Err(e) => return qbeError(e) }
      val res = match self._currentFn.block.buildRem(plusOneVal, Value.Int32(2)) { Ok(v) => v, Err(e) => return qbeError(e) }
      Ok(res)
    } else {
      Ok(res)
    }
  }

  func _compileFunctionValue(
    self,
    position: Position,
    fn: Function,
    fnValBase: QbeFunction,
    targetParamTypes: (Type, Bool)[]?,
    capturesPtr: Value?,
    capturedSelf: (Value, Type)?,
  ): Result<Value, CompileError> {
    val closureEnvPtr = capturesPtr ?: Value.Int(0)

    val _s = if capturedSelf |_p| {
      val selfVal = _p[0]
      val selfTy = match self._getQbeTypeForTypeExpect(_p[1], "unacceptable type for param", Some(position)) { Ok(v) => v, Err(e) => return Err(e) }
      (selfVal, Some(selfTy))
    } else {
      (Value.Int(0), None)
    }
    // TODO: destructuring
    val selfVal = _s[0]
    val selfTy = _s[1]

    val numParams = fn.params.length
    var fnNumReqParams = 0
    var fnNumOptParams = 0
    for param in fn.params {
      if !!param.defaultValue {
        fnNumOptParams += 1
      } else {
        fnNumReqParams += 1
      }
    }
    val fnValParamTypes = if targetParamTypes |paramTypes| {
      paramTypes.filter(_p => _p[1]).map(_p => _p[0])
    } else {
      fn.params.filter(p => !p.defaultValue).map(p => p.ty)
    }
    val targetArity = fnValParamTypes.length

    // For the cases below, consider the function
    //   func callFn(fn: (Int) => Int) = ...
    val fnValRes = if fnNumOptParams == 0 {
      if targetArity == numParams {
        // If the referenced function's arity matches the required arity, and it has no optional parameters,
        // then we don't need to create a wrapper for it.
        val res: Result<QbeFunction, CompileError> = Ok(fnValBase)
        res
      } else if targetArity < numParams {
        // In this case, consider the following example:
        //   func foo(a: Int, b: Int): Int = ...
        //   callFn(foo)
        // In this case, typechecking fails since `callFn` won't provide a value for the parameter `b`.
        return unreachable("This should have been caught during typechecking", position)
      } else {
        // In this case, consider the following example:
        //   func foo(): Int = ...
        //   callFn(foo)
        // Create a wrapper of higher arity which discards parameters (and which doesn't consider default-valued parameters, since we
        // know the wrapped function does not have any).
        self._compileParamDiscardingFunctionWrapper(fnValParamTypes, fn, fnValBase, position, false, selfTy)
      }
    } else if targetArity < fnNumReqParams {
      // In this case, consider the following example:
      //   func foo(a: Int, b: Int, c = 12): Int = ...
      //   callFn(foo)
      // In this case, typechecking fails since `callFn` won't provide a value for the parameter `b`.
      // This is similar to the case above, except here we have an optional parameter.
      return unreachable("This should be caught during typechecking", position)
    } else if fnNumReqParams <= targetArity && targetArity <= numParams {
      // In this case, we need to "artificially (monotonically) shrink" the arity of the underlying function.
      // It's "monotonically" because the arity itself might not actually shrink; consider this example:
      //   func foo(x = 12): Int = ...
      //   callFn(foo)
      // In this case, the optional parameter `x` must be treated as if it's a required parameter, and so the
      // arity of the wrapper function becomes 1.
      // Nominally though, the arity must be artificially shrunk in these cases:
      //   func foo1(x: Int, y = 12): Int = ...
      //   callFn(foo1)
      //   func foo2(x = 12, y = 16): Int = ...
      //   callFn(foo2)
      // In the case of `foo1`, the wrapper function has arity 1 and the parameter `y` will receive its default
      // value. In the case of `foo2`, the wrapper function still has arity 1 and the parameter `y` will still
      // receive its default value, but `x` will _not_.
      val firstOptionalParamIdxBeingGivenDefaultValue = targetArity - fnNumReqParams
      val numOptionalParamsBeingGivenDefaultValue = fn.params.length - fnNumReqParams - firstOptionalParamIdxBeingGivenDefaultValue
      val wrapperFnName = self._fnName(fn) + "..wd$numOptionalParamsBeingGivenDefaultValue"

      if self._builder.getFunction(wrapperFnName) |wrapperFnVal| {
        Ok(wrapperFnVal)
      } else {
        val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
        val wrapperFnVal = self._builder.buildFunction(name: wrapperFnName, returnType: returnTypeQbe)

        val prevFn = self._currentFn
        self._currentFn = wrapperFnVal

        val args = if selfTy |selfTy| [wrapperFnVal.addParameter("self", selfTy)] else []
        for paramType, idx in fnValParamTypes {
          val paramTy = match self._getQbeTypeForTypeExpect(paramType, "unacceptable type for param", Some(position)) { Ok(v) => v, Err(e) => return Err(e) }
          if fn.params[idx] |param| {
            args.push(wrapperFnVal.addParameter(param.label.name, paramTy))
          } else {
            wrapperFnVal.addParameter("_$idx", paramTy)
          }
        }

        var defaultMaskFlag = 0
        for paramToDefault, idx in fn.params[targetArity:] {
          val paramTy = match self._getQbeTypeForTypeExpect(paramToDefault.ty, "unacceptable type for param", Some(position)) { Ok(v) => v, Err(e) => return Err(e) }
          args.push(paramTy.zeroValue())
          defaultMaskFlag ||= (1 << (firstOptionalParamIdxBeingGivenDefaultValue + idx))
        }
        args.push(Value.Int32(defaultMaskFlag))

        val ret = if fn.returnType.kind != TypeKind.PrimitiveUnit {
          val res = match self._currentFn.block.buildCall(Callable.Function(fnValBase), args) { Ok(v) => v, Err(e) => return qbeError(e) }
          Some(res)
        } else {
          self._currentFn.block.buildVoidCall(Callable.Function(fnValBase), args)
          None
        }
        wrapperFnVal.block.buildReturn(ret)

        self._currentFn = prevFn

        wrapperFnVal.addComment("Wrapper for ${self._fnName(fn)} in which the last $numOptionalParamsBeingGivenDefaultValue default-valued parameters receive their default value")
        Ok(wrapperFnVal)
      }
    } else if targetArity > numParams {
      // In this case, consider the following example:
      //   func callFn2(fn: (Int, Int, Int) => Int) = ...
      //   func foo(x: Int, y = 12): Int = ...
      //   callFn2(foo)
      // Create a wrapper function of higher arity which discards parameters and _also_ passes 0 to the optional params flag; we know we can do this
      // because in order to reach this case, it must be the case that all of the optional parameters are passed a value.
      self._compileParamDiscardingFunctionWrapper(fnValParamTypes, fn, fnValBase, position, true, selfTy)
    } else {
      return unreachable("All valid cases exhausted above", position)
    }
    val fnVal = match fnValRes { Ok(v) => v, Err(e) => return Err(e) }

    val hasReturn = fn.returnType.kind != TypeKind.PrimitiveUnit
    val struct = self._functionStruct(targetArity, hasReturn)
    val typeArgs = (if hasReturn { [fn.returnType] } else []).concat(fnValParamTypes)
    val selfType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs))

    val resolvedGenerics: Map<String, Type> = {}
    val template = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
    for _p in selfType.extractGenerics(template) {
      resolvedGenerics[_p[0]] = _p[1]
    }
    match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }
    val initFnVal = match self._getOrCompileStructInitializer(struct) { Ok(v) => v, Err(e) => return Err(e) }

    self._resolvedGenerics.popLayer()

    val initArgs = [closureEnvPtr, Value.Global(fnVal.name, QbeType.Pointer), selfVal]
    val res = match self._currentFn.block.buildCall(Callable.Function(initFnVal), initArgs) { Ok(v) => v, Err(e) => return qbeError(e) }
    Ok(res)
  }

  func _compileParamDiscardingFunctionWrapper(
    self,
    fnValParamTypes: Type[],
    fn: Function,
    fnValBase: QbeFunction,
    position: Position,
    passDefaultParamMask: Bool,
    selfInstTy: QbeType?,
  ): Result<QbeFunction, CompileError> {
    var wrapperSuffix = "..w"
    val numParams = fn.params.length
    val discardedParamTypeReprs: String[] = []
    for paramTy, idx in fnValParamTypes[numParams:] {
      discardedParamTypeReprs.push(paramTy.repr())
      val _t = match self._getInstanceTypeForType(paramTy) { Ok(v) => v, Err(e) => return Err(e) }
      // TODO: destructuring
      val instTy = _t[0]
      val typeArgs = _t[1]
      val instType = Type(kind: TypeKind.Instance(instTy, typeArgs))

      val resolvedGenerics: Map<String, Type> = {}
      val typeParams = match instTy {
        StructOrEnum.Struct(s) => s.typeParams
        StructOrEnum.Enum(e) => e.typeParams
      }
      val template = Type(kind: TypeKind.Instance(instTy, typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
      for _p in instType.extractGenerics(template) {
        resolvedGenerics[_p[0]] = _p[1]
      }
      match self._resolvedGenerics.addLayer("discarded param $idx", resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: "discarded param $idx", message: e))) }

      val _paramTypeName = match instTy {
        StructOrEnum.Struct(s) => self._structTypeName(s)
        StructOrEnum.Enum(e) => self._enumTypeName(e)
      }
      val paramTypeName = match _paramTypeName { Ok(v) => v, Err(e) => return Err(e) }
      self._resolvedGenerics.popLayer()

      wrapperSuffix += "D${idx + 1}$paramTypeName"
    }
    // TODO: if `fn` is a method then the wrapper name should include the parent type as well
    val wrapperFnName = self._fnName(fn) + wrapperSuffix

    if self._builder.getFunction(wrapperFnName) |wrapperFnVal| return Ok(wrapperFnVal)

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val wrapperFnVal = self._builder.buildFunction(name: wrapperFnName, returnType: returnTypeQbe)

    val prevFn = self._currentFn
    self._currentFn = wrapperFnVal

    val args = if selfInstTy |selfInstTy| [wrapperFnVal.addParameter("self", selfInstTy)] else []
    for paramType, idx in fnValParamTypes {
      val paramTy = match self._getQbeTypeForTypeExpect(paramType, "unacceptable type for param", Some(position)) { Ok(v) => v, Err(e) => return Err(e) }
      if fn.params[idx] |param| {
        args.push(wrapperFnVal.addParameter(param.label.name, paramTy))
      } else {
        wrapperFnVal.addParameter("_$idx", paramTy)
      }
    }
    if passDefaultParamMask args.push(Value.Int32(0))

    val ret = if fn.returnType.kind != TypeKind.PrimitiveUnit {
      val res = match self._currentFn.block.buildCall(Callable.Function(fnValBase), args) { Ok(v) => v, Err(e) => return qbeError(e) }
      Some(res)
    } else {
      self._currentFn.block.buildVoidCall(Callable.Function(fnValBase), args)
      None
    }
    wrapperFnVal.block.buildReturn(ret)

    self._currentFn = prevFn

    wrapperFnVal.addComment("Parameter-discarding wrapper for ${self._fnName(fn)}, adding discarded params: ${discardedParamTypeReprs.join(", ")}")
    Ok(wrapperFnVal)
  }

  func _constructString(self, ptrVal: Value, lenVal: Value, localName: String? = None): Result<Value, CompileError> {
    val fnVal = match self._getOrCompileStructInitializer(self._project.preludeStringStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val structTy = if fnVal.returnType |ty| ty else return unreachable("initializer functions must have return types specified")

    val res = match self._currentFn.block.buildCall(Callable.Function(fnVal), [lenVal, ptrVal, Value.Int32(0)], localName) { Ok(v) => v, Err(e) => return qbeError(e) }
    self._currentFn.block.addCommentBefore("${res.repr()}: String")
    Ok(res)
  }

  func _getQbeTypeForType(self, ty: Type): Result<QbeType?, CompileError> {
    match ty.kind {
      TypeKind.PrimitiveUnit => Ok(None)
      TypeKind.PrimitiveInt => Ok(Some(QbeType.U64))
      TypeKind.PrimitiveFloat => Ok(Some(QbeType.F64))
      TypeKind.PrimitiveBool => Ok(Some(QbeType.U32))
      TypeKind.PrimitiveString => Ok(Some(QbeType.Pointer))
      TypeKind.Never => Ok(None)
      TypeKind.Any => todo("TypeKind.Any")
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getQbeTypeForType(ty) else unreachable("unexpected generic '$name' at this point")
      }
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => {
            if struct == self._project.preludeIntStruct return Ok(Some(QbeType.U64))
            if struct == self._project.preludeFloatStruct return Ok(Some(QbeType.F64))

            if struct.builtin == Some(BuiltinModule.Intrinsics) {
              if struct.label.name == "Byte" return Ok(Some(QbeType.U64))
              if struct.label.name == "Pointer" return Ok(Some(QbeType.Pointer))
            }
          }
          _ => {}
        }

        Ok(Some(QbeType.Pointer))
      }
      TypeKind.Func(paramTypes, returnType) => Ok(Some(QbeType.Pointer))
      TypeKind.Type(type_) => todo("TypeKind.Type")
      TypeKind.Tuple(_) => Ok(Some(QbeType.Pointer))
      TypeKind.Hole => unreachable("unexpected hole in emitted typed ast")
    }
  }

  func _getQbeTypeForTypeExpect(self, ty: Type, reason: String, position: Position? = None): Result<QbeType, CompileError> {
    val _ty = match self._getQbeTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    if _ty |ty| Ok(ty) else if position |pos| unreachable(reason, pos) else unreachable(reason)
  }

  func _followAccessorPath(self, head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment, loadFinal: Bool, localName: String? = None): Result<Value, CompileError> {
    val segs = middle.concat([tail])
    // val bogusValue = (StructOrEnum.Struct(self._project.preludeBoolStruct), Type(kind: TypeKind.Instance(StructOrEnum.Struct(self._project.preludeBoolStruct), [])), Value.Ident("bogus", QbeType.F32))
    var instTy = StructOrEnum.Struct(self._project.preludeBoolStruct)
    var instType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self._project.preludeBoolStruct), []))
    var curVal = Value.Ident("bogus", QbeType.F32)
    match segs[0] {
      AccessorPathSegment.Field => {
        // TODO: assert that `head.ty` is a pointer type (attempting to do pointer arithmetic later on will fail otherwise)
        val _t = match self._getInstanceTypeForType(head.ty) { Ok(v) => v, Err(e) => return Err(e) }
        // TODO: destructuring
        instTy = _t[0]
        val typeArgs = _t[1]
        instType = Type(kind: TypeKind.Instance(instTy, typeArgs))

        curVal = match self._compileExpression(head) { Ok(v) => v, Err(e) => return Err(e) }
        self._currentFn.block.addCommentBefore("${curVal.repr()}: ${head.ty.repr()}")
      }
      AccessorPathSegment.Method(_, fn, _, _) => {
        match fn.kind {
          FunctionKind.InstanceMethod => {
            // TODO: assert that `head.ty` is a pointer type (attempting to do pointer arithmetic later on will fail otherwise)
            val _t = match self._getInstanceTypeForType(head.ty) { Ok(v) => v, Err(e) => return Err(e) }
            // TODO: destructuring
            instTy = _t[0]
            val typeArgs = _t[1]
            instType = Type(kind: TypeKind.Instance(instTy, typeArgs))

            curVal = match self._compileExpression(head) { Ok(v) => v, Err(e) => return Err(e) }
            self._currentFn.block.addCommentBefore("${curVal.repr()}: ${head.ty.repr()}")
          }
          _ => {}
        }
      }
      _ => {}
    }

    for seg, idx in segs {
      match seg {
        AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => {
          match self._addResolvedGenericsLayerForEnumVariant(ty, variant.label.name, label.position) { Ok(v) => v, Err(e) => return Err(e) }
          val enumVariantFn = match self._getOrCompileEnumVariantFn(enum_, variant) { Ok(v) => v, Err(e) => return Err(e) }
          curVal = match self._currentFn.block.buildCall(Callable.Function(enumVariantFn), []) { Ok(v) => v, Err(e) => return qbeError(e) }
          self._resolvedGenerics.popLayer()

          instTy = StructOrEnum.Enum(enum_)
        }
        AccessorPathSegment.Method(label, fn, isOptSafe, fnAliasTypeHint) => {
          if isOptSafe return todo("opt-safe method accessor", label.position)

          val selfInstType = match fn.kind {
            FunctionKind.InstanceMethod => {
              val selfInstType = match self._addResolvedGenericsLayerForInstanceMethod(instType, fn.label.name, label.position) { Ok(v) => v, Err(e) => return Err(e) }
              Some(selfInstType)
            }
            _ => None
          }
          val fnBaseVal = match self._getOrCompileMethod(instType, fn) { Ok(v) => v, Err(e) => return Err(e) }

          val capturesMem = if fn.isClosure() {
            val capturesArr = match self._getCapturesArrForClosure(fn) { Ok(v) => v, Err(e) => return Err(e) }
            Some(capturesArr)
          } else {
            None
          }

          val targetParamTypes = if fnAliasTypeHint |hint| {
            val paramTypes = match hint.kind {
              TypeKind.Func(paramTypes, _) => Some(paramTypes)
              TypeKind.Any => None // if the function value is being treated as an Any, then no param type info needs to be known later anyway
              _ => return unreachable("fnAliasTypeKind must be TypeKind.Func", label.position)
            }
            paramTypes
          } else {
            None
          }

          self._resolvedGenerics.popLayer()

          val selfVal = if selfInstType |selfInstType| Some((curVal, selfInstType)) else None
          curVal = match self._compileFunctionValue(label.position, fn, fnBaseVal, targetParamTypes, capturesMem, selfVal) { Ok(v) => v, Err(e) => return Err(e) }
        }
        AccessorPathSegment.Field(label, ty, field, isOptSafe) => {
          var optSafeCtx: (Label, Value, QbeFunction, Label)? = None

          if isOptSafe {
            val innerTy = if self._typeIsOption(ty) |innerTy| innerTy else return unreachable("an opt-safe field accessor needs to have an Option type as its lhs")
            val unwrappedInstType = if self._typeIsOption(instType) |innerTy| innerTy else return unreachable("an opt-safe field accessor needs to have an Option type as its lhs")
            instType = unwrappedInstType
            val _t = match self._getInstanceTypeForType(unwrappedInstType) { Ok(v) => v, Err(e) => return Err(e) }
            // TODO: destructuring
            instTy = _t[0]

            val variantIsOptionSome = match self._emitOptValueIsSomeVariant(curVal) { Ok(v) => v, Err(e) => return Err(e) }
            val labelIsSome = self._currentFn.block.addLabel("optsafe_field_is_some")
            val labelIsNone = self._currentFn.block.addLabel("optsafe_field_is_none")
            val labelCont = self._currentFn.block.addLabel("optsafe_field_cont")

            self._currentFn.block.addComment("begin opt-safe field accessor...")
            self._currentFn.block.buildJnz(variantIsOptionSome, labelIsSome, labelIsNone)

            self._currentFn.block.registerLabel(labelIsNone)
            val optNoneVariant = if self._project.preludeOptionEnum.variants.find(v => v.label.name == "None") |v| v else return unreachable("Option.None must exist")
            match self._resolvedGenerics.addLayer("Option.None", { "V": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: label.position, kind: CompileErrorKind.ResolvedGenericsError(context: "Option.None", message: e))) }
            val noneVariantFn = match self._getOrCompileEnumVariantFn(self._project.preludeOptionEnum, optNoneVariant) { Ok(v) => v, Err(e) => return Err(e) }
            self._resolvedGenerics.popLayer()
            val noneRes = match self._currentFn.block.buildCall(Callable.Function(noneVariantFn), []) { Ok(v) => v, Err(e) => return qbeError(e) }
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.registerLabel(labelIsSome)
            val optSomeVariant = if self._project.preludeOptionEnum.variants.find(v => v.label.name == "Some") |v| v else return unreachable("Option.Some must exist")
            match self._resolvedGenerics.addLayer("Option.Some", { "V": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: label.position, kind: CompileErrorKind.ResolvedGenericsError(context: "Option.Some", message: e))) }
            val someVariantFn = match self._getOrCompileEnumVariantFn(self._project.preludeOptionEnum, optSomeVariant) { Ok(v) => v, Err(e) => return Err(e) }
            self._resolvedGenerics.popLayer()

            optSafeCtx = Some((labelIsNone, noneRes, someVariantFn, labelCont))

            val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
            curVal = match self._emitOptValueGetValue(innerQbeType, curVal) { Ok(v) => v, Err(e) => return Err(e) }
          }

          match instTy {
            StructOrEnum.Struct(struct) => {
              var offset = 0
              var fieldTyQbe = QbeType.F32 // placeholder sentinel value
              for f in struct.fields {
                val fieldTy = match self._getQbeTypeForTypeExpect(f.ty, "unacceptable type for field", Some(f.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
                if f.name.name == field.name.name {
                  fieldTyQbe = fieldTy
                  break
                }

                offset += fieldTy.size()
              }
              if fieldTyQbe == QbeType.F32 return unreachable("fieldTyQbe == QbeType.F32")

              val ptr = match self._currentFn.block.buildAdd(Value.Int(offset), curVal) { Ok(v) => v, Err(e) => return qbeError(e) }
              if idx == segs.length - 1 {
                if !loadFinal {
                  curVal = ptr
                } else {
                  val nextVal = self._currentFn.block.buildLoad(fieldTyQbe, ptr, localName)
                  self._currentFn.block.addCommentBefore("${nextVal.repr()}: ${curVal.repr()}.${field.name.name}")
                  curVal = nextVal
                }
              } else {
                val nextVal = self._currentFn.block.buildLoad(fieldTyQbe, ptr)
                self._currentFn.block.addCommentBefore("${nextVal.repr()}: ${curVal.repr()}.${field.name.name}")
                curVal = nextVal
              }
            }
            StructOrEnum.Enum(_enum) => return todo("enum field accessor")
          }

          if optSafeCtx |_ctx| {
            val labelIsNone = _ctx[0]
            val noneRes = _ctx[1]
            val someVariantFn = _ctx[2]
            val labelCont = _ctx[3]

            val labelIsSome = self._currentFn.block.currentLabel
            val someRes = match self._currentFn.block.buildCall(Callable.Function(someVariantFn), [curVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.addComment("...opt-safe field accessor end")
            self._currentFn.block.registerLabel(labelCont)

            val phiCases = [(labelIsNone, noneRes), (labelIsSome, someRes)]
            curVal = match self._currentFn.block.buildPhi(phiCases, localName) { Ok(v) => v, Err(e) => return qbeError(e) }
          }

          val _t = match self._getInstanceTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
          // TODO: destructuring
          instTy = _t[0]
          val typeArgs = _t[1]
          instType = Type(kind: TypeKind.Instance(instTy, typeArgs))
        }
      }
    }

    Ok(curVal)
  }

  func _getOrCompileStructInitializer(self, struct: Struct): Result<QbeFunction, CompileError> {
    val fnName = match self._structInitializerFnName(struct) { Ok(v) => v, Err(e) => return Err(e) }
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: fnName, returnType: Some(QbeType.Pointer))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    fnVal.addCommentMultiline(match self._structSignature(struct) { Ok(v) => v, Err(e) => return Err(e) })

    var defaultValueParamIdx = 0
    var defaultValuesMaskParam: Value? = None
    var addMaskParam = false
    var size = 0
    for field in struct.fields {
      val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
      size += fieldTy.size()

      if field.initializer |initializerNode| {
        val paramLocal = fnVal.addParameter("${field.name.name}_", fieldTy)
        addMaskParam = true
        val maskParam = Value.Ident("__default_params_mask__", QbeType.U32)

        val defaultValueFlag = 1 << defaultValueParamIdx
        defaultValueParamIdx += 1

        val labelUseDefaultValue = self._currentFn.block.addLabel("${field.name.name}_use_default")
        val labelUsePassedValue = self._currentFn.block.addLabel("${field.name.name}_use_passed")
        val labelCont = self._currentFn.block.addLabel("${field.name.name}_cont")

        val paramMaskVal = match self._currentFn.block.buildAnd(maskParam, Value.Int32(defaultValueFlag)) { Ok(v) => v, Err(e) => return qbeError(e) }
        val paramNeedsDefault = match self._currentFn.block.buildCompareEq(paramMaskVal, Value.Int32(defaultValueFlag)) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.buildJnz(paramNeedsDefault, labelUseDefaultValue, labelUsePassedValue)

        self._currentFn.block.registerLabel(labelUseDefaultValue)
        val res = match self._compileExpression(initializerNode) { Ok(v) => v, Err(e) => return Err(e) }
        val resLabel = self._currentFn.block.currentLabel
        self._currentFn.block.buildJmp(labelCont)

        self._currentFn.block.registerLabel(labelUsePassedValue)
        self._currentFn.block.buildJmp(labelCont)

        self._currentFn.block.registerLabel(labelCont)

        val phiCases = [(resLabel, res), (labelUsePassedValue, paramLocal)]
        match self._currentFn.block.buildPhi(phiCases, Some(field.name.name)) { Ok(v) => v, Err(e) => return qbeError(e) }
      } else {
        fnVal.addParameter(field.name.name, fieldTy)
      }
    }
    if addMaskParam {
      fnVal.addParameter("__default_params_mask__", QbeType.U32)
    }

    val memLocal = match fnVal.block.buildCall(Callable.Function(self._malloc), [Value.Int(size)], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

    var offset = 0
    for field in struct.fields {
      val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
      val param = Value.Ident(field.name.name, fieldTy)

      val localName = "mem_offset_${field.name.name}"
      val memCursorLocal = match fnVal.block.buildAdd(Value.Int(offset), memLocal, Some(localName)) { Ok(v) => v, Err(e) => return qbeError(e) }
      fnVal.block.buildStore(fieldTy, param, memCursorLocal)

      offset += fieldTy.size()
    }

    fnVal.block.buildReturn(Some(memLocal))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileEnumVariantFn(self, enum_: Enum, variant: TypedEnumVariant): Result<QbeFunction, CompileError> {
    val variantFnName = match self._enumVariantFnName(enum_, variant) { Ok(v) => v, Err(e) => return Err(e) }
    if self._builder.getFunction(variantFnName) |fn| return Ok(fn)

    // TODO: constant variants shouldn't be a function - it should just be a `data` segment with the proper idx set
    val fn = self._builder.buildFunction(name: variantFnName, returnType: Some(QbeType.Pointer))
    val prevFn = self._currentFn
    self._currentFn = fn
    fn.addComment(match self._enumVariantSignature(enum_, variant) { Ok(v) => v, Err(e) => return Err(e) })

    var size = 0
    size += QbeType.U64.size() // account for space for variant idx slot
    match variant.kind {
      EnumVariantKind.Container(fields) => {
        for field in fields {
          val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
          size += fieldTy.size()
          fn.addParameter(field.name.name, fieldTy)
        }
      }
      _ => {}
    }

    val memLocal = match fn.block.buildCall(Callable.Function(self._malloc), [Value.Int(size)], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

    val variantIdx = if enum_.variants.findIndex(v => v.label.name == variant.label.name) |_v| _v[1] else return unreachable("variant '${variant.label.name}' must exist")
    fn.block.buildStoreW(Value.Int(variantIdx), memLocal) // Store variant idx at designated slot
    var offset = QbeType.U64.size() // begin inserting any fields after that variant idx slot

    match variant.kind {
      EnumVariantKind.Container(fields) => {
        for field in fields {
          val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
          val param = Value.Ident(field.name.name, fieldTy)

          val localName = "mem_offset_${field.name.name}"
          val memCursorLocal = match fn.block.buildAdd(Value.Int(offset), memLocal, Some(localName)) { Ok(v) => v, Err(e) => return qbeError(e) }
          fn.block.buildStore(fieldTy, param, memCursorLocal)

          offset += fieldTy.size()
        }
      }
      _ => {}
    }

    fn.block.buildReturn(Some(memLocal))

    self._currentFn = prevFn

    Ok(fn)
  }

  func _invokePrint(self, arguments: TypedAstNode?[], withNewline = false): Result<Value, CompileError> {
    val fnName = if withNewline "println" else "print"
    self._currentFn.block.addComment("begin $fnName...")
    val varargItems = if arguments[0] |node| {
      if node |node| {
        val items = match node.kind {
          TypedAstNodeKind.Array(items) => items
          _ => return unreachable("`$fnName` receives an array of its variadic arguments")
        }
        items
      } else return unreachable("`$fnName` receives an array of its variadic arguments")
    } else []

    val stdoutWriteFn = if self._project.preludeScope.functions.find(fn => fn.label.name == "stdoutWrite") |fn| fn else return unreachable("`stdoutWrite` must exist in prelude")
    val stdoutWriteFnVal = match self._getOrCompileFunction(stdoutWriteFn) { Ok(v) => v, Err(e) => return Err(e) }

    val space = self._builder.buildGlobalString(" ")
    val spaceStr = match self._constructString(space, Value.Int(1)) { Ok(v) => v, Err(e) => return Err(e) }

    for item, idx in varargItems {
      val itemVal = match self._compileExpression(item) { Ok(v) => v, Err(e) => return Err(e) }

      val itemInstanceType = match self._addResolvedGenericsLayerForInstanceMethod(item.ty, "toString", item.token.position) { Ok(v) => v, Err(e) => return Err(e) }
      val itemToStringFnVal = match self._getOrCompileToStringMethod(itemInstanceType) { Ok(v) => v, Err(e) => return Err(e) }
      self._resolvedGenerics.popLayer()

      val toStringVal = match self._currentFn.block.buildCall(Callable.Function(itemToStringFnVal), [itemVal]) { Ok(v) => v, Err(e) => return qbeError(e) }

      self._currentFn.block.buildVoidCall(Callable.Function(stdoutWriteFnVal), [toStringVal])

      if idx != varargItems.length - 1 {
        self._currentFn.block.buildVoidCall(Callable.Function(stdoutWriteFnVal), [spaceStr])
      }
    }

    if withNewline {
      val newline = self._builder.buildGlobalString("\\n")
      val newlineStr = match self._constructString(newline, Value.Int(1)) { Ok(v) => v, Err(e) => return Err(e) }
      self._currentFn.block.buildVoidCall(Callable.Function(stdoutWriteFnVal), [newlineStr])
    }

    self._currentFn.block.addComment("...$fnName end")

    Ok(Value.Ident("bogus", QbeType.F32))
  }

  func _invokeCBindingFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val cFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => return unreachable("@CBinding decorator requires 1 string argument for the name")
    }

    val args: Value[] = []
    for arg in arguments {
      if arg |node| {
        val arg = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
        args.push(arg)
      } else {
        return unreachable("functions with @CBinding decorator cannot have optional parameters")
      }
    }

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val res = if returnTypeQbe |returnTy| {
      val res = match self._currentFn.block.buildCallRaw(cFnName, returnTy, args) { Ok(v) => v, Err(e) => return qbeError(e) }
      res
    } else {
      self._currentFn.block.buildVoidCallRaw(cFnName, args)
      Value.Ident("bogus", QbeType.F32)
    }
    Ok(res)
  }

  func _pointerSize(self, ty: Type): Result<Int, CompileError> {
    val size = match ty.kind {
      TypeKind.PrimitiveBool => 4
      TypeKind.Generic(name) => return unreachable("unresolved generic '$name'")
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => {
            if struct.builtin == Some(BuiltinModule.Intrinsics) && struct.label.name == "Byte" 1 else 8
          }
          _ => 8
        }
      }
      _ => 8
    }

    Ok(size)
  }

  func _invokeIntrinsicFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val intrinsicFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => return unreachable("@Intrinsic decorator requires 1 string argument for the name")
    }

    match intrinsicFnName {
      "pointer_null" => {
        self._currentFn.block.addComment("begin pointer_null...")

        match self._currentFn.block.buildAdd(Value.Int(0), Value.Int(0), Some("__pointer_null__")) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_null end")

        Ok(Value.Ident("__pointer_null__", QbeType.Pointer))
      }
      "pointer_is_null" => {
        self._currentFn.block.addComment("begin pointer_is_null...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_is_null' has 1 required argument")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_is_null' has 1 required argument")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val labelIsNull = self._currentFn.block.addLabel("ptr_is_null")
        val labelIsNotNull = self._currentFn.block.addLabel("ptr_is_not_null")
        val labelCont = self._currentFn.block.addLabel("ptr_null_cont")

        self._currentFn.block.buildJnz(ptrVal, labelIsNotNull, labelIsNull)

        self._currentFn.block.registerLabel(labelIsNotNull)
        val f = Value.Int32(0)
        self._currentFn.block.buildJmp(labelCont)
        self._currentFn.block.registerLabel(labelIsNull)
        val t = Value.Int32(1)
        self._currentFn.block.buildJmp(labelCont)
        self._currentFn.block.registerLabel(labelCont)

        val phiCases = [(labelIsNotNull, f), (labelIsNull, t)]
        val ptrIsNull = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_is_null end")

        Ok(ptrIsNull)
      }
      "pointer_malloc" => {
        self._currentFn.block.addComment("begin pointer_malloc...")

        val _count = if arguments[0] |arg| arg else return unreachable("'pointer_malloc' has 1 required argument")
        val count = if _count |arg| arg else return unreachable("'pointer_malloc' has 1 required argument")
        val countVal = match self._compileExpression(count) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("(pointer_malloc) could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(innerTySize), countVal) { Ok(v) => v, Err(e) => return qbeError(e) }

        val mem = match self._currentFn.block.buildCall(Callable.Function(self._malloc), [sizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_malloc end")

        Ok(mem)
      }
      "pointer_realloc" => {
        self._currentFn.block.addComment("begin pointer_realloc...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _count = if arguments[1] |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val count = if _count |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val countVal = match self._compileExpression(count) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("(pointer_realloc) could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(innerTySize), countVal) { Ok(v) => v, Err(e) => return qbeError(e) }

        val mem = match self._currentFn.block.buildCall(Callable.Function(self._realloc), [ptrVal, sizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_realloc end")

        Ok(mem)
      }
      "pointer_store" => {
        self._currentFn.block.addComment("begin pointer_store...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _value = if arguments[1] |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val value = if _value |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val valueVal = match self._compileExpression(value) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("(pointer_store) could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
        self._currentFn.block.buildStore(innerQbeType, valueVal, ptrVal)

        self._currentFn.block.addComment("...pointer_store end")

        Ok(Value.Ident("bogus", QbeType.F32))
      }
      "pointer_offset" => {
        self._currentFn.block.addComment("begin pointer_offset...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _offset = if arguments[1] |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val offset = if _offset |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val offsetVal = match self._compileExpression(offset) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("(pointer_offset) could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(innerTySize), offsetVal) { Ok(v) => v, Err(e) => return qbeError(e) }

        val mem = match self._currentFn.block.buildAdd(sizeVal, ptrVal) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_offset end")

        Ok(mem)
      }
      "pointer_load" => {
        self._currentFn.block.addComment("begin pointer_load...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_load' has 1 required argument")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_load' has 1 required argument")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("(pointer_load) could not resolve T for Pointer<T>")

        val isByte = match innerTy.kind {
          TypeKind.Instance(structOrEnum, _) => {
            val r = match structOrEnum {
              StructOrEnum.Struct(struct) => struct.builtin == Some(BuiltinModule.Intrinsics) && struct.label.name == "Byte"
              _ => false
            }
            r
          }
          _ => false
        }
        val innerQbeType = if isByte QbeType.U8 else {
          val res = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
          res
        }

        val v = self._currentFn.block.buildLoad(innerQbeType, ptrVal)

        self._currentFn.block.addComment("...pointer_load end")

        Ok(v)
      }
      "pointer_copy_from" => {
        self._currentFn.block.addComment("begin pointer_copy_from...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _other = if arguments[1] |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val other = if _other |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val otherVal = match self._compileExpression(other) { Ok(v) => v, Err(e) => return Err(e) }

        val _size = if arguments[2] |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val size = if _size |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val sizeArg = match self._compileExpression(size) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("(pointer_copy_from) could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(innerTySize), sizeArg) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [ptrVal, otherVal, sizeVal])

        self._currentFn.block.addComment("...pointer_copy_from end")

        Ok(Value.Ident("bogus", QbeType.F32))
      }
      "errno" => {
        self._currentFn.block.addComment("begin errno...")

        val errnoFnName = match Process.uname().sysname {
          "Linux" => "__errno_location"
          "Darwin" => "__error"
          _ sysname => return todo("[errno] unsupported system " + sysname)
        }
        val errnoPtr = match self._currentFn.block.buildCallRaw(errnoFnName, QbeType.Pointer, []) { Ok(v) => v, Err(e) => return qbeError(e) }
        val errnoVal = self._currentFn.block.buildLoadW(errnoPtr)
        val res = self._currentFn.block.buildExt(value: errnoVal, signed: false)

        self._currentFn.block.addComment("...errno end")

        Ok(res)
      }
      "byte_from_int" => {
        self._currentFn.block.addComment("begin byte_from_int...")

        val _arg = if arguments[0] |arg| arg else return unreachable("'byte_from_int' has 1 required argument")
        val arg = if _arg |arg| arg else return unreachable("'byte_from_int' has 1 required argument")
        val argVal = match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) }

        self._currentFn.block.addComment("...byte_from_int end")

        Ok(argVal)
      }
      "byte_as_int" => {
        self._currentFn.block.addComment("begin byte_as_int...")

        val _arg = if arguments[0] |arg| arg else return unreachable("'byte_as_int' has 1 required argument")
        val arg = if _arg |arg| arg else return unreachable("'byte_as_int' has 1 required argument")
        val argVal = match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) }

        self._currentFn.block.addComment("...byte_as_int end")

        Ok(argVal)
      }
      "int_as_float" => {
        self._currentFn.block.addComment("begin int_as_float...")

        val _arg = if arguments[0] |arg| arg else return unreachable("'int_as_float' has 1 required argument")
        val arg = if _arg |arg| arg else return unreachable("'int_as_float' has 1 required argument")
        val argVal = match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) }

        val res = self._currentFn.block.buildLToF(argVal)

        self._currentFn.block.addComment("...int_as_float end")

        Ok(res)
      }
      "float_as_int" => {
        self._currentFn.block.addComment("begin float_as_int...")

        val _arg = if arguments[0] |arg| arg else return unreachable("'float_as_int' has 1 required argument")
        val arg = if _arg |arg| arg else return unreachable("'float_as_int' has 1 required argument")
        val argVal = match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) }

        val res = self._currentFn.block.buildFToL(argVal)

        self._currentFn.block.addComment("...float_as_int end")

        Ok(res)
      }
      "float_floor" => {
        self._currentFn.block.addComment("begin float_floor...")

        val _arg = if arguments[0] |arg| arg else return unreachable("'float_floor' has 1 required argument")
        val arg = if _arg |arg| arg else return unreachable("'float_floor' has 1 required argument")
        val argVal = match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) }

        val floorRes = match self._currentFn.block.buildCallRaw("floor", QbeType.F64, [argVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
        val res = self._currentFn.block.buildFToL(floorRes)

        self._currentFn.block.addComment("...float_floor end")

        Ok(res)
      }
      "float_ceil" => {
        self._currentFn.block.addComment("begin float_ceil...")

        val _arg = if arguments[0] |arg| arg else return unreachable("'float_ceil' has 1 required argument")
        val arg = if _arg |arg| arg else return unreachable("'float_ceil' has 1 required argument")
        val argVal = match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) }

        val ceilRes = match self._currentFn.block.buildCallRaw("ceil", QbeType.F64, [argVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
        val res = self._currentFn.block.buildFToL(ceilRes)

        self._currentFn.block.addComment("...float_ceil end")

        Ok(res)
      }
      "float_round" => {
        self._currentFn.block.addComment("begin float_round...")

        val _arg = if arguments[0] |arg| arg else return unreachable("'float_round' has 1 required argument")
        val arg = if _arg |arg| arg else return unreachable("'float_round' has 1 required argument")
        val argVal = match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) }

        val roundRes = match self._currentFn.block.buildCallRaw("round", QbeType.F64, [argVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
        val res = self._currentFn.block.buildFToL(roundRes)

        self._currentFn.block.addComment("...float_round end")

        Ok(res)
      }
      "argc" => {
        self._currentFn.block.addComment("begin argc...")
        val res = self._currentFn.block.buildLoadL(self._argcPtr)
        self._currentFn.block.addComment("...argc end")

        Ok(res)
      }
      "argv" => {
        self._currentFn.block.addComment("begin argv...")
        val res = self._currentFn.block.buildLoadL(self._argvPtr)
        self._currentFn.block.addComment("...argv end")

        Ok(res)
      }
      _ => unreachable("unsupported intrinsic '$intrinsicFnName'", fn.label.position)
    }
  }

  func _getOrCompileFunction(self, fn: Function): Result<QbeFunction, CompileError> {
    val fnName = self._fnName(fn)
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val fnVal = self._builder.buildFunction(name: fnName, returnType: returnTypeQbe)
    if fn.isClosure() fnVal.addEnv()

    match self._compileFunc(fnVal, fn) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.addComment(match self._fnSignature(None, fn) { Ok(v) => v, Err(e) => return Err(e) })

    Ok(fnVal)
  }

  func _getOrCompileMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val isInstanceMethod = match fn.kind { FunctionKind.InstanceMethod => true, _ => false }
    if isInstanceMethod && fn.label.name == "toString" && fn.isGenerated return self._getOrCompileToStringMethod(selfType)
    if isInstanceMethod && fn.label.name == "eq" && fn.isGenerated return self._getOrCompileEqMethod(selfType)
    if isInstanceMethod && fn.label.name == "hash" && fn.isGenerated return self._getOrCompileHashMethod(selfType)

    val _t = match self._getInstanceTypeForType(selfType) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val methodName = match self._methodFnName(selfTy, fn) { Ok(v) => v, Err(e) => return Err(e) }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val fnVal = self._builder.buildFunction(name: methodName, returnType: returnTypeQbe)
    if fn.isClosure() fnVal.addEnv()

    if isInstanceMethod {
      val selfTyQbe = match self._getQbeTypeForTypeExpect(selfType, "unacceptable type for self") { Ok(v) => v, Err(e) => return Err(e) }
      fnVal.addParameter("self", selfTyQbe)
      val selfVariable = if fn.scope.variables.find(v => v.label.name == "self") |selfVariable| selfVariable else return unreachable("Function '${fn.label.name}' is an instance method but does not have a variable 'self' in its scope", fn.label.position)
      fnVal.block.addVar(variableToVar(selfVariable), Some("self"))
    }
    match self._compileFunc(fnVal, fn) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.addComment(match self._fnSignature(Some(selfTy), fn) { Ok(v) => v, Err(e) => return Err(e) })

    Ok(fnVal)
  }

  func _compileFunc(self, fnVal: QbeFunction, fn: Function): Result<Int, CompileError> {
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    var defaultValueParamIdx = 0
    var defaultValuesMaskParam: Value? = None
    var addMaskParam = false
    for param in fn.params {
      val paramTy = match self._getQbeTypeForTypeExpect(param.ty, "unacceptable type for param", Some(param.label.position)) { Ok(v) => v, Err(e) => return Err(e) }

      if param.defaultValue |defaultValueNode| {
        val paramLocal = fnVal.addParameter("${param.label.name}_", paramTy)
        addMaskParam = true
        val maskParam = Value.Ident("__default_params_mask__", QbeType.U32)

        val defaultValueFlag = 1 << defaultValueParamIdx
        defaultValueParamIdx += 1

        val labelUseDefaultValue = self._currentFn.block.addLabel("${param.label.name}_use_default")
        val labelUsePassedValue = self._currentFn.block.addLabel("${param.label.name}_use_passed")
        val labelCont = self._currentFn.block.addLabel("${param.label.name}_cont")

        val paramMaskVal = match self._currentFn.block.buildAnd(maskParam, Value.Int32(defaultValueFlag)) { Ok(v) => v, Err(e) => return qbeError(e) }
        val paramNeedsDefault = match self._currentFn.block.buildCompareEq(paramMaskVal, Value.Int32(defaultValueFlag)) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.buildJnz(paramNeedsDefault, labelUseDefaultValue, labelUsePassedValue)

        self._currentFn.block.registerLabel(labelUseDefaultValue)
        val res = match self._compileExpression(defaultValueNode) { Ok(v) => v, Err(e) => return Err(e) }
        val resLabel = self._currentFn.block.currentLabel
        self._currentFn.block.buildJmp(labelCont)

        self._currentFn.block.registerLabel(labelUsePassedValue)
        self._currentFn.block.buildJmp(labelCont)

        self._currentFn.block.registerLabel(labelCont)

        val phiCases = [(resLabel, res), (labelUsePassedValue, paramLocal)]
        match self._currentFn.block.buildPhi(phiCases, Some(param.label.name)) { Ok(v) => v, Err(e) => return qbeError(e) }
      } else {
        fnVal.addParameter(param.label.name, paramTy)
      }

      self._currentFn.block.addVar(variableToVar(param.variable), Some(param.label.name))
    }
    if addMaskParam {
      fnVal.addParameter("__default_params_mask__", QbeType.U32)
    }

    var retVal: Value? = None
    for node, idx in fn.body {
      val res = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
      if idx == fn.body.length - 1 && fn.returnType.kind != TypeKind.PrimitiveUnit {
        retVal = res
      }
    }
    if !fn.scope.terminator {
      fnVal.block.buildReturn(retVal)
    }

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(0)
  }

  func _getOrCompileToStringMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val _t = match self._getInstanceTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val typeArgs = _t[1]

    val _p = match selfTy {
      StructOrEnum.Struct(struct) => {
        if struct == self._project.preludeIntStruct return self._getOrCompileIntToStringMethod()
        if struct == self._project.preludeFloatStruct return self._getOrCompileFloatToStringMethod()
        if struct == self._project.preludeStringStruct return self._getOrCompileStringToStringMethod()
        if struct == self._project.preludeBoolStruct return self._getOrCompileBoolToStringMethod()

        val _fn = struct.instanceMethods.find(m => m.label.name == "toString")
        val fn = if _fn |f| f else return unreachable("every struct has a toString method defined")

        (match self._structMethodFnName(struct, fn) { Ok(v) => v, Err(e) => return Err(e) }, fn)
      }
      StructOrEnum.Enum(enum_) => {
        val _fn = enum_.instanceMethods.find(m => m.label.name == "toString")
        val fn = if _fn |f| f else return unreachable("every enum has a toString method defined")

        (match self._enumMethodFnName(enum_, fn) { Ok(v) => v, Err(e) => return Err(e) }, fn)
      }
    }
    // TODO: destructuring
    val methodName = _p[0]
    val fn = _p[1]
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated return self._compileGeneratedToStringMethod(ty, fn)

    self._getOrCompileMethod(ty, fn)
  }

  func _compileGeneratedToStringMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val _t = match self._getInstanceTypeForType(selfType) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val typeArgs = _t[1]
    val selfInstanceTy = Type(kind: TypeKind.Instance(selfTy, typeArgs))

    val methodName = match self._methodFnName(selfTy, fn) { Ok(v) => v, Err(e) => return Err(e) }

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val selfTyQbe = match self._getQbeTypeForTypeExpect(selfInstanceTy, "unacceptable type for self") { Ok(v) => v, Err(e) => return Err(e) }
    val selfParamVal = fnVal.addParameter("self", selfTyQbe)

    match selfTy {
      StructOrEnum.Struct(struct) => {
        val data: (String, Position, Type)[] = []

        if self._isFunctionStruct(struct) {
          val str = self._builder.buildGlobalString("<#function>")
          val res = match self._constructString(str, Value.Int(11)) { Ok(v) => v, Err(e) => return Err(e) }

          self._currentFn.block.buildReturn(Some(res))
        } else {
          val isTuple = self._isTupleStruct(struct)
          for field in struct.fields {
            val fieldName = if isTuple "" else field.name.name
            data.push((fieldName, field.name.position, field.ty))
          }

          val prefix = if isTuple "" else struct.label.name
          val res = match self._emitToStringLogicForStructuredData(prefix, selfParamVal, data) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildReturn(Some(res))
        }
      }
      StructOrEnum.Enum(enum_) => {
        val variantIdxVal = self._emitGetEnumVariantIdx(selfParamVal)

        var labelElse = self._currentFn.block.addLabel("__initial")
        val labelEnd = self._currentFn.block.addLabel("unreachable")

        for variant, idx in enum_.variants {
          if idx != 0 {
            self._currentFn.block.registerLabel(labelElse)
          }

          val cond = match self._currentFn.block.buildCompareEq(Value.Int(idx), variantIdxVal) { Ok(v) => v, Err(e) => return qbeError(e) }

          val labelThen = self._currentFn.block.addLabel("variant_${variant.label.name}")
          if idx != enum_.variants.length - 1 {
            labelElse = self._currentFn.block.addLabel("next")
            self._currentFn.block.buildJnz(cond, labelThen, labelElse)
          } else {
            self._currentFn.block.buildJnz(cond, labelThen, labelEnd)
          }

          self._currentFn.block.registerLabel(labelThen)
          val variantName = "${enum_.label.name}.${variant.label.name}"
          match variant.kind {
            EnumVariantKind.Constant => {
              val variantNameStr = self._builder.buildGlobalString(variantName)
              val retVal = match self._constructString(variantNameStr, Value.Int(variantName.length)) { Ok(v) => v, Err(e) => return Err(e) }
              self._currentFn.block.buildReturn(Some(retVal))
            }
            EnumVariantKind.Container(fields) => {
              val data: (String, Position, Type)[] = []
              for field in fields {
                data.push((field.name.name, field.name.position, field.ty))
              }
              val ptr = match self._emitGetEnumVariantValueStart(selfParamVal) { Ok(v) => v, Err(e) => return Err(e) }
              val retVal = match self._emitToStringLogicForStructuredData(variantName, ptr, data) { Ok(v) => v, Err(e) => return Err(e) }
              self._currentFn.block.buildReturn(Some(retVal))
            }
          }
        }

        self._currentFn.block.registerLabel(labelEnd)
        self._currentFn.block.buildHalt()
      }
    }

    fnVal.addComment(match self._fnSignature(Some(selfTy), fn) { Ok(v) => v, Err(e) => return Err(e) })

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(fnVal)
  }

  func _emitToStringLogicForStructuredData(self, prefix: String, selfPtr: Value, data: (String, Position, Type)[]): Result<Value, CompileError> {
    val prefixStr = self._builder.buildGlobalString(prefix)
    var len = prefix.length + 2 + (data.length - 1) * 2 // account for '(' and ')', as well as ',' and ' ' between items
    var lenVal = Value.Int(0)

    val reprVals: (String, Value, Bool)[] = []
    var offset = 0
    for _p, idx in data {
      // TODO: destructuring
      val itemName = _p[0]
      val itemPosition = _p[1]
      val itemType = _p[2]

      // If the item label is meant to be output, account for the label as well as ':' and ' ' between the label and the value
      if !itemName.isEmpty() { len += (itemName.length + 2) }

      val itemInstanceType = match self._addResolvedGenericsLayerForInstanceMethod(itemType, "toString", itemPosition) { Ok(v) => v, Err(e) => return Err(e) }
      val itemToStringFnVal = match self._getOrCompileToStringMethod(itemInstanceType) { Ok(v) => v, Err(e) => return Err(e) }
      self._resolvedGenerics.popLayer()

      val itemTy = match self._getQbeTypeForTypeExpect(itemType, "unacceptable type for item", Some(itemPosition)) { Ok(v) => v, Err(e) => return Err(e) }
      val itemIsString = self._typeIsString(itemInstanceType)

      val memCursorLocalName = if itemName.isEmpty() "$idx" else itemName
      val memCursorLocal = match self._currentFn.block.buildAdd(Value.Int(offset), selfPtr, Some("mem_offset_$memCursorLocalName")) { Ok(v) => v, Err(e) => return qbeError(e) }
      val itemVal = self._currentFn.block.buildLoad(itemTy, memCursorLocal)

      offset += itemTy.size()

      val itemToStringVal = match self._currentFn.block.buildCall(Callable.Function(itemToStringFnVal), [itemVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
      val itemToStringLengthVal = self._currentFn.block.buildLoadL(itemToStringVal)
      lenVal = match self._currentFn.block.buildAdd(lenVal, itemToStringLengthVal, Some("length_total")) { Ok(v) => v, Err(e) => return qbeError(e) }
      if itemIsString {
        self._currentFn.block.addComment("account for opening and closing \"'s")
        lenVal = match self._currentFn.block.buildAdd(lenVal, Value.Int(2), Some("length_total")) { Ok(v) => v, Err(e) => return qbeError(e) }
      }

      reprVals.push((itemName, itemToStringVal, itemIsString))
    }

    val totalLengthVal = match self._currentFn.block.buildAdd(Value.Int(len), lenVal) { Ok(v) => v, Err(e) => return qbeError(e) }
    val stringWithLengthFn = if self._project.preludeStringStruct.staticMethods.find(m => m.label.name == "withLength") |fn| fn else return unreachable("String.withLength must exist")
    val stringWithLengthFnVal = match self._getOrCompileMethod(Type(kind: TypeKind.Type(StructOrEnum.Struct(self._project.preludeStringStruct))), stringWithLengthFn) { Ok(v) => v, Err(e) => return Err(e) }
    val newStr = match self._currentFn.block.buildCall(Callable.Function(stringWithLengthFnVal), [totalLengthVal]) { Ok(v) => v, Err(e) => return qbeError(e) }

    var newStrBuf = self._currentFn.block.buildLoadL(match self._currentFn.block.buildAdd(Value.Int(8), newStr) { Ok(v) => v, Err(e) => return qbeError(e) })
    if !prefix.isEmpty() {
      self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newStrBuf, prefixStr, Value.Int(prefix.length)])
    }
    var cursor = match self._currentFn.block.buildAdd(newStrBuf, Value.Int(prefix.length), Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }
    self._currentFn.block.addComment("'('")
    self._currentFn.block.buildStoreB(Value.Int(40), cursor)
    cursor = match self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }

    for _p, idx in reprVals {
      // TODO: destructuring
      val fieldName = _p[0]
      val strVal = _p[1]
      val isString = _p[2]

      if !fieldName.isEmpty() {
        val fieldNameStr = self._builder.buildGlobalString(fieldName)
        self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [cursor, fieldNameStr, Value.Int(fieldName.length)])
        cursor = match self._currentFn.block.buildAdd(cursor, Value.Int(fieldName.length), Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.addComment("\": \"")
        self._currentFn.block.buildStoreB(Value.Int(58), cursor)
        cursor = match self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.buildStoreB(Value.Int(32), cursor)
        cursor = match self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }
      }

      if isString {
        self._currentFn.block.addComment("'\"'")
        self._currentFn.block.buildStoreB(Value.Int(34), cursor)
        cursor = match self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }
      }

      val strValLen = self._currentFn.block.buildLoadL(strVal)
      val strValChars = self._currentFn.block.buildLoadL(match self._currentFn.block.buildAdd(Value.Int(8), strVal) { Ok(v) => v, Err(e) => return qbeError(e) })
      self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [cursor, strValChars, strValLen])
      cursor = match self._currentFn.block.buildAdd(cursor, strValLen, Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }

      if isString {
        self._currentFn.block.addComment("'\"'")
        self._currentFn.block.buildStoreB(Value.Int(34), cursor)
        cursor = match self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }
      }

      if idx != reprVals.length - 1 {
        self._currentFn.block.addComment("\", \"")
        self._currentFn.block.buildStoreB(Value.Int(44), cursor)
        cursor = match self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.buildStoreB(Value.Int(32), cursor)
        cursor = match self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) { Ok(v) => v, Err(e) => return qbeError(e) }
      }
    }

    self._currentFn.block.addComment("')'")
    self._currentFn.block.buildStoreB(Value.Int(41), cursor)

    Ok(newStr)
  }

  func _getOrCompileIntToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
    val intTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = match self._structTypeName(self._project.preludeIntStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Int#toString(self): String")
    val selfParam = fnVal.addParameter("self", intTypeQbe)

    val intFmtPtr = self._builder.buildGlobalString("%d")
    val sizeVal = match fnVal.block.buildCall(Callable.Function(self._snprintf), [Value.Int(0), Value.Int(0), intFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }
    val mallocSizeVal = match fnVal.block.buildAdd(Value.Int(1), sizeVal) { Ok(v) => v, Err(e) => return qbeError(e) }

    val mem = match fnVal.block.buildCall(Callable.Function(self._malloc), [mallocSizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }
    match fnVal.block.buildCall(Callable.Function(self._snprintf), [mem, mallocSizeVal, intFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }

    val str = match self._constructString(mem, sizeVal) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(str))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileFloatToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
    val floatTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = match self._structTypeName(self._project.preludeFloatStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Float#toString(self): String")
    val selfParam = fnVal.addParameter("self", floatTypeQbe)

    val floatFmtPtr = self._builder.buildGlobalString("%g")
    val sizeVal = match fnVal.block.buildCall(Callable.Function(self._snprintf), [Value.Int(0), Value.Int(0), floatFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }
    val mallocSizeVal = match fnVal.block.buildAdd(Value.Int(1), sizeVal) { Ok(v) => v, Err(e) => return qbeError(e) }

    val mem = match fnVal.block.buildCall(Callable.Function(self._malloc), [mallocSizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }
    match fnVal.block.buildCall(Callable.Function(self._snprintf), [mem, mallocSizeVal, floatFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }

    val str = match self._constructString(mem, sizeVal) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(str))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileBoolToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
    val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = match self._structTypeName(self._project.preludeBoolStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Bool#toString(self): String")
    val selfParam = fnVal.addParameter("self", boolTypeQbe)

    val labelIfTrue = fnVal.block.addLabel("if_true")
    val labelIfFalse = fnVal.block.addLabel("if_false")
    fnVal.block.buildJnz(selfParam, labelIfTrue, labelIfFalse)

    fnVal.block.registerLabel(labelIfTrue)
    val trueStrData = self._builder.buildGlobalString("true")
    val trueStr = match self._constructString(trueStrData, Value.Int(4)) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(trueStr))

    fnVal.block.registerLabel(labelIfFalse)
    val falseStrData = self._builder.buildGlobalString("false")
    val falseStr = match self._constructString(falseStrData, Value.Int(5)) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(falseStr))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileStringToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = match self._structTypeName(self._project.preludeStringStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("String#toString(self): String")
    val selfParam = fnVal.addParameter("self", stringTypeQbe)
    fnVal.block.buildReturn(Some(selfParam))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileEqMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val _t = match self._getInstanceTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val _p = match selfTy {
      StructOrEnum.Struct(struct) => {
        val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

        // TODO: surely there's a cleaner way to represent these built-in eq methods
        if struct == self._project.preludeIntStruct {
          val intTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

          val methodName = "Int..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Int#eq(self, other: Int): Bool")
          val selfParam = fnVal.addParameter("self", intTypeQbe)
          val otherParam = fnVal.addParameter("other", intTypeQbe)
          val res = match self._currentFn.block.buildCompareEq(selfParam, otherParam) { Ok(v) => v, Err(e) => return qbeError(e) }
          fnVal.block.buildReturn(Some(res))

          match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeFloatStruct {
          val floatTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

          val methodName = "Float..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Float#eq(self, other: Float): Bool")
          val selfParam = fnVal.addParameter("self", floatTypeQbe)
          val otherParam = fnVal.addParameter("other", floatTypeQbe)
          val res = match self._currentFn.block.buildCompareEq(selfParam, otherParam) { Ok(v) => v, Err(e) => return qbeError(e) }
          fnVal.block.buildReturn(Some(res))

          match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeBoolStruct {
          val methodName = "Bool..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Bool#eq(self, other: Bool): Bool")
          val selfParam = fnVal.addParameter("self", boolTypeQbe)
          val otherParam = fnVal.addParameter("other", boolTypeQbe)
          val res = match self._currentFn.block.buildCompareEq(selfParam, otherParam) { Ok(v) => v, Err(e) => return qbeError(e) }
          fnVal.block.buildReturn(Some(res))

          match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

          self._currentFn = prevFn

          return Ok(fnVal)
        }

        val _fn = struct.instanceMethods.find(m => m.label.name == "eq")
        val fn = if _fn |f| f else return unreachable("every struct has an eq method defined")

        (match self._structMethodFnName(struct, fn) { Ok(v) => v, Err(e) => return Err(e) }, fn)
      }
      StructOrEnum.Enum(enum_) => {
        val _fn = enum_.instanceMethods.find(m => m.label.name == "eq")
        val fn = if _fn |f| f else return unreachable("every enum has an eq method defined")

        (match self._enumMethodFnName(enum_, fn) { Ok(v) => v, Err(e) => return Err(e) }, fn)
      }
    }
    // TODO: destructuring
    val methodName = _p[0]
    val fn = _p[1]
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated return self._compileGeneratedEqMethod(ty, fn)

    self._getOrCompileMethod(ty, fn)
  }

  func _compileGeneratedEqMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val _t = match self._getInstanceTypeForType(selfType) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val typeArgs = _t[1]
    val selfInstanceTy = Type(kind: TypeKind.Instance(selfTy, typeArgs))

    val methodName = match self._methodFnName(selfTy, fn) { Ok(v) => v, Err(e) => return Err(e) }

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val selfTyQbe = match self._getQbeTypeForTypeExpect(selfInstanceTy, "unacceptable type for self") { Ok(v) => v, Err(e) => return Err(e) }
    val selfParamVal = fnVal.addParameter("self", selfTyQbe)
    val otherParamVal = fnVal.addParameter("other", selfTyQbe)

    match selfTy {
      StructOrEnum.Struct(struct) => {
        val data: (String, Position, Type)[] = []

        val isTuple = self._isTupleStruct(struct)
        for field in struct.fields {
          val fieldName = if isTuple "" else field.name.name
          data.push((fieldName, field.name.position, field.ty))
        }

        match self._emitEqLogicForStructuredData(selfParamVal, otherParamVal, data) { Ok(v) => v, Err(e) => return Err(e) }
      }
      StructOrEnum.Enum(enum_) => {
        val selfVariantIdxVal = self._emitGetEnumVariantIdx(selfParamVal)
        val otherVariantIdxVal = self._emitGetEnumVariantIdx(otherParamVal)

        val labelVariantsNeq = self._currentFn.block.addLabel("variants_not_eq")
        val labelVariantsEq = self._currentFn.block.addLabel("variants_eq")

        val cond = match self._currentFn.block.buildCompareEq(selfVariantIdxVal, otherVariantIdxVal) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.buildJnz(cond, labelVariantsEq, labelVariantsNeq)

        self._currentFn.block.registerLabel(labelVariantsNeq)
        self._currentFn.block.addComment("return false")
        self._currentFn.block.buildReturn(Some(Value.Int32(0)))

        self._currentFn.block.registerLabel(labelVariantsEq)

        var labelElse = self._currentFn.block.addLabel("__initial")
        val labelEnd = self._currentFn.block.addLabel("unreachable")

        for variant, idx in enum_.variants {
          if idx != 0 {
            self._currentFn.block.registerLabel(labelElse)
          }

          val cond = match self._currentFn.block.buildCompareEq(Value.Int(idx), selfVariantIdxVal) { Ok(v) => v, Err(e) => return qbeError(e) }

          val labelThen = self._currentFn.block.addLabel("variant_${variant.label.name}")
          if idx != enum_.variants.length - 1 {
            labelElse = self._currentFn.block.addLabel("next")
            self._currentFn.block.buildJnz(cond, labelThen, labelElse)
          } else {
            self._currentFn.block.buildJnz(cond, labelThen, labelEnd)
          }

          self._currentFn.block.registerLabel(labelThen)
          match variant.kind {
            EnumVariantKind.Constant => {
              self._currentFn.block.addComment("return true")
              self._currentFn.block.buildReturn(Some(Value.Int32(1)))
            }
            EnumVariantKind.Container(fields) => {
              val data: (String, Position, Type)[] = []
              for field in fields {
                data.push((field.name.name, field.name.position, field.ty))
              }
              val selfPtr = match self._emitGetEnumVariantValueStart(selfParamVal) { Ok(v) => v, Err(e) => return Err(e) }
              val otherPtr = match self._emitGetEnumVariantValueStart(otherParamVal) { Ok(v) => v, Err(e) => return Err(e) }
              match self._emitEqLogicForStructuredData(selfPtr, otherPtr, data) { Ok(v) => v, Err(e) => return Err(e) }
            }
          }
        }

        self._currentFn.block.registerLabel(labelEnd)
        self._currentFn.block.buildHalt()
      }
    }

    fnVal.addComment(match self._fnSignature(Some(selfTy), fn) { Ok(v) => v, Err(e) => return Err(e) })

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(fnVal)
  }

  func _emitEqLogicForStructuredData(self, selfPtr: Value, otherPtr: Value, data: (String, Position, Type)[]): Result<Int, CompileError> {
    var offset = 0
    for _p in data {
      // TODO: destructuring
      val itemName = _p[0]
      val itemPosition = _p[1]
      val itemType = _p[2]

      val itemTy = match self._getQbeTypeForTypeExpect(itemType, "unacceptable type for item", Some(itemPosition)) { Ok(v) => v, Err(e) => return Err(e) }

      val selfMemCursor = match self._currentFn.block.buildAdd(Value.Int(offset), selfPtr, Some("self_mem_offset_$itemName")) { Ok(v) => v, Err(e) => return qbeError(e) }
      val selfItemVal = self._currentFn.block.buildLoad(itemTy, selfMemCursor)
      val otherMemCursor = match self._currentFn.block.buildAdd(Value.Int(offset), otherPtr, Some("other_mem_offset_$itemName")) { Ok(v) => v, Err(e) => return qbeError(e) }
      val otherItemVal = self._currentFn.block.buildLoad(itemTy, otherMemCursor)

      val labelNeq = self._currentFn.block.addLabel("${itemName}_vals_not_equal")
      val labelEq = self._currentFn.block.addLabel("${itemName}_vals_equal")

      val fieldsEqVal = match self._compileEqLogic(selfItemVal, otherItemVal, itemType, itemPosition) { Ok(v) => v, Err(e) => return Err(e) }
      self._currentFn.block.buildJnz(fieldsEqVal, labelEq, labelNeq)

      self._currentFn.block.registerLabel(labelNeq)
      self._currentFn.block.addComment("return false")
      self._currentFn.block.buildReturn(Some(Value.Int32(0)))

      self._currentFn.block.registerLabel(labelEq)

      offset += itemTy.size()
    }

    self._currentFn.block.addComment("return true")
    self._currentFn.block.buildReturn(Some(Value.Int32(1)))

    Ok(0)
  }

  func _getOrCompileHashMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val _t = match self._getInstanceTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val _p = match selfTy {
      StructOrEnum.Struct(struct) => {
        val intTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

        // TODO: surely there's a cleaner way to represent these built-in hash methods
        if struct == self._project.preludeIntStruct {
          val methodName = "Int..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Int#hash(self): Int")
          val selfParam = fnVal.addParameter("self", intTypeQbe)
          fnVal.block.buildReturn(Some(selfParam))

          match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeFloatStruct {
          val floatTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

          val methodName = "Float..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Float#hash(self): Int")
          val selfParam = fnVal.addParameter("self", floatTypeQbe)
          val res = self._currentFn.block.buildCastD(selfParam)
          fnVal.block.buildReturn(Some(res))

          match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeBoolStruct {
          val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

          val methodName = "Bool..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Bool#hash(self): Int")
          val selfParam = fnVal.addParameter("self", boolTypeQbe)
          val res = self._currentFn.block.buildExt(value: selfParam, signed: false)
          fnVal.block.buildReturn(Some(res))

          match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

          self._currentFn = prevFn

          return Ok(fnVal)
        }

        val _fn = struct.instanceMethods.find(m => m.label.name == "hash")
        val fn = if _fn |f| f else return unreachable("every struct has a hash method defined")

        (match self._structMethodFnName(struct, fn) { Ok(v) => v, Err(e) => return Err(e) }, fn)
      }
      StructOrEnum.Enum(enum_) => {
        val _fn = enum_.instanceMethods.find(m => m.label.name == "hash")
        val fn = if _fn |f| f else return unreachable("every enum has a hash method defined")

        (match self._enumMethodFnName(enum_, fn) { Ok(v) => v, Err(e) => return Err(e) }, fn)
      }
    }
    // TODO: destructuring
    val methodName = _p[0]
    val fn = _p[1]
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated return self._compileGeneratedHashMethod(ty, fn)

    self._getOrCompileMethod(ty, fn)
  }

  func _compileGeneratedHashMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val intTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val _t = match self._getInstanceTypeForType(selfType) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val typeArgs = _t[1]
    val selfInstanceTy = Type(kind: TypeKind.Instance(selfTy, typeArgs))

    val methodName = match self._methodFnName(selfTy, fn) { Ok(v) => v, Err(e) => return Err(e) }

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val selfTyQbe = match self._getQbeTypeForTypeExpect(selfInstanceTy, "unacceptable type for self") { Ok(v) => v, Err(e) => return Err(e) }
    val selfParamVal = fnVal.addParameter("self", selfTyQbe)

    match selfTy {
      StructOrEnum.Struct(struct) => {
        val data: (String, Position, Type)[] = []
        val isTuple = self._isTupleStruct(struct)
        for field in struct.fields {
          val fieldName = if isTuple "" else field.name.name
          data.push((fieldName, field.name.position, field.ty))
        }

        match self._emitHashLogicForStructuredData(selfParamVal, data) { Ok(v) => v, Err(e) => return Err(e) }
      }
      StructOrEnum.Enum(enum_) => {
        val variantIdxVal = self._emitGetEnumVariantIdx(selfParamVal)

        var labelElse = self._currentFn.block.addLabel("__initial")
        val labelEnd = self._currentFn.block.addLabel("unreachable")

        for variant, idx in enum_.variants {
          if idx != 0 {
            self._currentFn.block.registerLabel(labelElse)
          }

          val cond = match self._currentFn.block.buildCompareEq(Value.Int(idx), variantIdxVal) { Ok(v) => v, Err(e) => return qbeError(e) }

          val labelThen = self._currentFn.block.addLabel("variant_${variant.label.name}")
          if idx != enum_.variants.length - 1 {
            labelElse = self._currentFn.block.addLabel("next")
            self._currentFn.block.buildJnz(cond, labelThen, labelElse)
          } else {
            self._currentFn.block.buildJnz(cond, labelThen, labelEnd)
          }

          self._currentFn.block.registerLabel(labelThen)
          match variant.kind {
            EnumVariantKind.Constant => {
              self._currentFn.block.buildReturn(Some(variantIdxVal))
            }
            EnumVariantKind.Container(fields) => {
              val data: (String, Position, Type)[] = []
              for field in fields {
                data.push((field.name.name, field.name.position, field.ty))
              }
              val selfPtr = match self._emitGetEnumVariantValueStart(selfParamVal) { Ok(v) => v, Err(e) => return Err(e) }
              match self._emitHashLogicForStructuredData(selfPtr, data) { Ok(v) => v, Err(e) => return Err(e) }
            }
          }
        }

        self._currentFn.block.registerLabel(labelEnd)
        self._currentFn.block.buildHalt()
      }
    }

    fnVal.addComment(match self._fnSignature(Some(selfTy), fn) { Ok(v) => v, Err(e) => return Err(e) })

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(fnVal)
  }

  func _emitHashLogicForStructuredData(self, selfPtr: Value, data: (String, Position, Type)[]): Result<Int, CompileError> {
    var retVal = Value.Int(1)
    var offset = 0
    for _p in data {
      // TODO: destructuring
      val itemName = _p[0]
      val itemPosition = _p[1]
      val itemType = _p[2]

      val itemTy = match self._getQbeTypeForTypeExpect(itemType, "unacceptable type for item", Some(itemPosition)) { Ok(v) => v, Err(e) => return Err(e) }

      val memCursor = match self._currentFn.block.buildAdd(Value.Int(offset), selfPtr, Some("self_mem_offset_$itemName")) { Ok(v) => v, Err(e) => return qbeError(e) }
      val itemVal = self._currentFn.block.buildLoad(itemTy, memCursor)

      val itemInstanceType = match self._addResolvedGenericsLayerForInstanceMethod(itemType, "hash", itemPosition) { Ok(v) => v, Err(e) => return Err(e) }
      val itemHashFnVal = match self._getOrCompileHashMethod(itemType) { Ok(v) => v, Err(e) => return Err(e) }
      self._resolvedGenerics.popLayer()

      val itemHashVal = match self._currentFn.block.buildCall(Callable.Function(itemHashFnVal), [itemVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
      val newPart = match self._currentFn.block.buildMul(Value.Int(31), itemHashVal) { Ok(v) => v, Err(e) => return qbeError(e) }
      retVal = match self._currentFn.block.buildAdd(retVal, newPart) { Ok(v) => v, Err(e) => return qbeError(e) }

      offset += itemTy.size()
    }

    self._currentFn.block.buildReturn(Some(retVal))

    Ok(0)
  }

  func _buildStackAllocForQbeType(self, ty: QbeType, name: String? = None): Value {
    match ty {
      QbeType.U8 => self._currentFn.block.buildAlloc8(1, name)      // 'b'
      QbeType.U16 => self._currentFn.block.buildAlloc4(1, name)     // 'h'
      QbeType.U32 => self._currentFn.block.buildAlloc4(1, name)     // 'w'
      QbeType.U64 => self._currentFn.block.buildAlloc8(1, name)     // 'l'
      QbeType.Pointer => self._currentFn.block.buildAlloc8(1, name) // 'l'
      QbeType.F32 => self._currentFn.block.buildAlloc4(1, name)     // 's'
      QbeType.F64 => self._currentFn.block.buildAlloc8(1, name)     // 'd'
    }
  }

  func _emitGetEnumVariantIdx(self, enumVariantVal: Value): Value = self._currentFn.block.buildLoadL(enumVariantVal)
  func _emitGetEnumVariantValueStart(self, enumVariantVal: Value): Result<Value, CompileError> {
    val res = match self._currentFn.block.buildAdd(Value.Int(QbeType.U64.size()), enumVariantVal) { Ok(v) => v, Err(e) => return qbeError(e) }
    Ok(res)
  }

  func _emitOptValueIsSomeVariant(self, exprVal: Value, negate = false): Result<Value, CompileError> {
    val variantIdx = self._emitGetEnumVariantIdx(exprVal)
    val optionSomeVariantIdx = if self._project.preludeOptionEnum.variants.findIndex(v => v.label.name == "Some") |_p| _p[1] else return unreachable("Option.Some must exist")
    if negate {
      val res = match self._currentFn.block.buildCompareNeq(variantIdx, Value.Int(optionSomeVariantIdx)) { Ok(v) => v, Err(e) => return qbeError(e) }
      Ok(res)
    } else {
      val res = match self._currentFn.block.buildCompareEq(variantIdx, Value.Int(optionSomeVariantIdx)) { Ok(v) => v, Err(e) => return qbeError(e) }
      Ok(res)
    }
  }

  func _emitOptValueGetValue(self, ty: QbeType, exprVal: Value): Result<Value, CompileError> {
    val valueSlot = match self._emitGetEnumVariantValueStart(exprVal) { Ok(v) => v, Err(e) => return Err(e) }
    val value = self._currentFn.block.buildLoad(ty, valueSlot)

    Ok(value)
  }

  func _addResolvedGenericsLayerForInstanceMethod(self, ty: Type, methodName: String, position: Position, resolvedGenerics: Map<String, Type> = {}): Result<Type, CompileError> {
    val _t = match self._getInstanceTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    val _p = match _t[0] {
      StructOrEnum.Struct(struct) => {
        val template = Type(kind: TypeKind.Instance(_t[0], struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val inst = Type(kind: TypeKind.Instance(_t[0], _t[1]))

        (template, inst)
      }
      StructOrEnum.Enum(enum_) => {
        val template = Type(kind: TypeKind.Instance(_t[0], enum_.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val inst = Type(kind: TypeKind.Instance(_t[0], _t[1]))

        (template, inst)
      }
    }
    // TODO: destructuring
    val template = _p[0]
    val selfInstanceType = _p[1]
    for _p in selfInstanceType.extractGenerics(template) {
      resolvedGenerics[_p[0]] = _p[1]
    }
    // TODO: destructuring
    val layerName = match _t[0] {
      StructOrEnum.Struct(struct) => "${struct.label.name}.$methodName"
      StructOrEnum.Enum(enum_) => "${enum_.label.name}.$methodName"
    }
    match self._resolvedGenerics.addLayer(layerName, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: layerName, message: e))) }

    Ok(selfInstanceType)
  }

  func _addResolvedGenericsLayerForEnumVariant(self, ty: Type, variantName: String, position: Position, resolvedGenerics: Map<String, Type> = {}): Result<Type, CompileError> {
    val _t = match self._getInstanceTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    match _t[0] {
      StructOrEnum.Struct => unreachable("type should always be an enum here")
      StructOrEnum.Enum(enum_) => {
        val template = Type(kind: TypeKind.Instance(_t[0], enum_.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val selfInstanceType = Type(kind: TypeKind.Instance(_t[0], _t[1]))

        for _p in selfInstanceType.extractGenerics(template) {
          resolvedGenerics[_p[0]] = _p[1]
        }

        val layerName = "${enum_.label.name}.$variantName"
        match self._resolvedGenerics.addLayer(layerName, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: layerName, message: e))) }

        Ok(selfInstanceType)
      }
    }
  }

  func _functionStruct(self, arity: Int, hasReturnType: Bool): Struct {
    val name = if hasReturnType "Function$arity" else "UnitFunction$arity"

    if self._functionStructs[name] |struct| struct else {
      val dummyModuleId = 0
      val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      val typeParams = (if hasReturnType { ["_R"] } else []).concat(alphabet[:arity].split(""))
      val fields = [("_env", Type(kind: TypeKind.PrimitiveInt)), ("_ptr", Type(kind: TypeKind.PrimitiveInt)), ("_self", Type(kind: TypeKind.PrimitiveInt))]
      val struct = Struct.makeDummy(moduleId: dummyModuleId, name: name, typeParams: typeParams, fields: fields)

      self._functionStructs[name] = struct

      struct
    }
  }

  func _isFunctionStruct(self, struct: Struct): Bool = if self._functionStructs[struct.label.name] |s| s == struct else false

  func _tupleStruct(self, arity: Int): Struct {
    val name = "Tuple$arity"

    if self._tupleStructs[name] |struct| struct else {
      val dummyModuleId = 0
      val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      val typeParams = alphabet[:arity].split("")
      val fields = typeParams.map((p, idx) => ("_$idx", Type(kind: TypeKind.Generic(name: p))))
      val struct = Struct.makeDummy(moduleId: dummyModuleId, name: name, typeParams: typeParams, fields: fields)

      self._tupleStructs[name] = struct

      struct
    }
  }

  func _isTupleStruct(self, struct: Struct): Bool = if self._tupleStructs[struct.label.name] |s| s == struct else false

  func _getInstanceTypeForType(self, ty: Type): Result<(StructOrEnum, Type[]), CompileError> {
    match ty.kind {
      TypeKind.Any => unreachable("getInstanceTypeForType: Any")
      TypeKind.PrimitiveUnit => unreachable("getInstanceTypeForType: Unit")
      TypeKind.PrimitiveInt => Ok((StructOrEnum.Struct(self._project.preludeIntStruct), []))
      TypeKind.PrimitiveFloat => Ok((StructOrEnum.Struct(self._project.preludeFloatStruct), []))
      TypeKind.PrimitiveBool => Ok((StructOrEnum.Struct(self._project.preludeBoolStruct), []))
      TypeKind.PrimitiveString => Ok((StructOrEnum.Struct(self._project.preludeStringStruct), []))
      TypeKind.Never => unreachable("getInstanceTypeForType: Never")
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getInstanceTypeForType(ty) else unreachable("failed to resolve generic: '$name'")
      }
      TypeKind.Instance(structOrEnum, typeParams) => Ok((structOrEnum, typeParams))
      TypeKind.Tuple(types) => {
        val struct = self._tupleStruct(types.length)
        Ok((StructOrEnum.Struct(struct), types))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val hasReturn = returnType.kind != TypeKind.PrimitiveUnit
        val struct = self._functionStruct(paramTypes.length, hasReturn)

        val typeArgs = (if hasReturn { [returnType] } else []).concat(paramTypes.map(_p => _p[0]))
        Ok((StructOrEnum.Struct(struct), typeArgs))
      }
      TypeKind.Type(structOrEnum) => Ok((structOrEnum, []))
      TypeKind.Hole => unreachable("getInstanceTypeForType: Hole")
    }
  }

  func _getReprForType(self, ty: Type): Result<String, CompileError> {
    match ty.kind {
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getReprForType(ty) else unreachable("failed to resolve generic repr: '$name'")
      }
      TypeKind.Instance(structOrEnum, typeParams) => {
        val n = match structOrEnum {
          StructOrEnum.Struct(struct) => struct.label.name
          StructOrEnum.Enum(_enum) => _enum.label.name
        }
        if !typeParams.isEmpty() {
          val params: String[] = []
          for p in typeParams {
            params.push(match self._getReprForType(p) { Ok(v) => v, Err(e) => return Err(e) })
          }

          Ok("$n<${params.join(", ")}>")
        } else {
          Ok(n)
        }
      }
      TypeKind.Tuple(types) => {
        val struct = self._tupleStruct(types.length)
        self._getReprForType(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), types)))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val hasReturn = returnType.kind != TypeKind.PrimitiveUnit
        val struct = self._functionStruct(paramTypes.length, hasReturn)

        val typeArgs = (if hasReturn { [returnType] } else []).concat(paramTypes.map(_p => _p[0]))
        self._getReprForType(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs)))
      }
      _ => Ok(ty.repr())
    }
  }

  func _getNameForType(self, ty: Type): Result<String, CompileError> {
    match ty.kind {
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getNameForType(ty) else unreachable("failed to resolve generic repr: '$name'")
      }
      TypeKind.Instance(structOrEnum, typeParams) => {
        val n = match structOrEnum {
          StructOrEnum.Struct(struct) => struct.label.name
          StructOrEnum.Enum(_enum) => _enum.label.name
        }
        if !typeParams.isEmpty() {
          val params: String[] = []
          for p in typeParams {
            params.push(match self._getNameForType(p) { Ok(v) => v, Err(e) => return Err(e) })
          }

          Ok("$n.${params.join(".")}")
        } else {
          Ok(n)
        }
      }
      TypeKind.Tuple(types) => {
        val struct = self._tupleStruct(types.length)
        self._getNameForType(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), types)))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val hasReturn = returnType.kind != TypeKind.PrimitiveUnit
        val struct = self._functionStruct(paramTypes.length, hasReturn)

        val typeArgs = (if hasReturn { [returnType] } else []).concat(paramTypes.map(_p => _p[0]))
        self._getNameForType(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs)))
      }
      _ => Ok(ty.repr())
    }
  }

  // Each module's root code is wrapped in a specially-named function; this function name
  // starts with two dots, which is not possible in ordinary Abra source code and will
  // thus introduce no conflicts (qbe doesn't care about function name rules).
  func _moduleWrapperFnName(self, module: TypedModule): String = "..module_${module.id}"

  func _exportedVarName(self, modId: Int, name: String): String = "mod${modId}exp_${name}.slot"

  func _structTypeName(self, struct: Struct): Result<String, CompileError> {
    val base = ".${struct.moduleId}.${struct.label.name}"
    val name = if !struct.typeParams.isEmpty() {
      val parts: String[] = []
      for name in struct.typeParams {
        val repr = if self._resolvedGenerics.resolveGeneric(name) |ty| {
          val r = match self._getNameForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
          r
        } else {
          return unreachable("could not resolve '$name'")
        }
        parts.push(repr)
      }
      "$base.${parts.join(".")}"
    } else {
      base
    }

    // qbe limits its identifiers to 80 chars, so if the resulting type name is long, we instead use a randomly-generated alias
    // in place of the type. 16 chars seems like a good balance between long enough that there won't be any conflicts, but also
    // short enough that there's enough room for this type to be used as a generic in other types without making that type's or
    // function's identifier too long.
    if name.length >= 80 {
      val alias = if self._aliasedTypeNames[name] |alias| alias else {
        val replacement = String.random(16)
        self._aliasedTypeNames[name] = replacement
        replacement
      }
      Ok(alias)
    } else {
      Ok(name)
    }
  }
  func _structInitializerFnName(self, struct: Struct): Result<String, CompileError> {
    val structTypeName = match self._structTypeName(struct) { Ok(v) => v, Err(e) => return Err(e) }
    Ok("$structTypeName.init")
  }

  func _enumTypeName(self, enum_: Enum): Result<String, CompileError> {
    val base = ".${enum_.moduleId}.${enum_.label.name}"
    val name = if !enum_.typeParams.isEmpty() {
      val parts: String[] = []
      for name in enum_.typeParams {
        val repr = if self._resolvedGenerics.resolveGeneric(name) |ty| {
          val r = match self._getNameForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
          r
        } else {
          return unreachable("could not resolve '$name'")
        }
        parts.push(repr)
      }
      "$base.${parts.join(".")}"
    } else {
      base
    }

    // qbe limits its identifiers to 80 chars, so if the resulting type name is long, we instead use a randomly-generated alias
    // in place of the type. 16 chars seems like a good balance between long enough that there won't be any conflicts, but also
    // short enough that there's enough room for this type to be used as a generic in other types without making that type's or
    // function's identifier too long.
    if name.length >= 80 {
      val alias = if self._aliasedTypeNames[name] |alias| alias else {
        val replacement = String.random(40)
        self._aliasedTypeNames[name] = replacement
        replacement
      }
      Ok(alias)
    } else {
      Ok(name)
    }
  }
  func _enumVariantFnName(self, enum_: Enum, variant: TypedEnumVariant): Result<String, CompileError> {
    val enumTypeName = match self._enumTypeName(enum_) { Ok(v) => v, Err(e) => return Err(e) }
    Ok("$enumTypeName.${variant.label.name}")
  }

  func _fnName(self, fn: Function): String = ".${fn.label.name}"
  func _structMethodFnName(self, struct: Struct, fn: Function): Result<String, CompileError> {
    val typeName = match self._structTypeName(struct) { Ok(v) => v, Err(e) => return Err(e) }
    val sep = match fn.kind {
      FunctionKind.InstanceMethod => ".."
      _ => "."
    }
    Ok("${typeName}${sep}${fn.label.name}")
  }
  func _enumMethodFnName(self, enum_: Enum, fn: Function): Result<String, CompileError> {
    val typeName = match self._enumTypeName(enum_) { Ok(v) => v, Err(e) => return Err(e) }
    val sep = match fn.kind {
      FunctionKind.InstanceMethod => ".."
      _ => "."
    }
    Ok("${typeName}${sep}${fn.label.name}")
  }

  func _methodFnName(self, structOrEnum: StructOrEnum, fn: Function): Result<String, CompileError> {
    val methodName = match structOrEnum {
      StructOrEnum.Struct(struct) => match self._structMethodFnName(struct, fn) { Ok(v) => v, Err(e) => return Err(e) }
      StructOrEnum.Enum(enum_) => match self._enumMethodFnName(enum_, fn) { Ok(v) => v, Err(e) => return Err(e) }
    }
    Ok(methodName)
  }

  func _fnSignature(self, structOrEnum: StructOrEnum?, fn: Function): Result<String, CompileError> {
    val parts: String[] = []
    match structOrEnum {
      StructOrEnum.Struct(struct) => {
        parts.push(struct.label.name)
        if !struct.typeParams.isEmpty() {
          parts.push("<")
          for name, idx in struct.typeParams {
            val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else return unreachable("_fnSignature:struct (${struct.label.name}, ${fn.label.name}), could not resolve generic '$name'")
            parts.push(resolvedGeneric.repr())

            if idx != struct.typeParams.length - 1 { parts.push(", ") }
          }
          parts.push(">")
        }
        parts.push(match fn.kind { FunctionKind.InstanceMethod => "#", _ => "." })
      }
      StructOrEnum.Enum(enum_) => {
        parts.push(enum_.label.name)
        if !enum_.typeParams.isEmpty() {
          parts.push("<")
          for name, idx in enum_.typeParams {
            val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else return unreachable("_fnSignature:enum (${enum_.label.name}, ${fn.label.name}), could not resolve generic '$name'")
            parts.push(resolvedGeneric.repr())

            if idx != enum_.typeParams.length - 1 { parts.push(", ") }
          }
          parts.push(">")
        }
        parts.push(match fn.kind { FunctionKind.InstanceMethod => "#", _ => "." })
      }
      None => {}
    }
    parts.push(fn.label.name)
    if !fn.typeParams.isEmpty() {
      parts.push("<")
      for _p, idx in fn.typeParams {
        // TODO: destructuring
        val name = _p[1].name
        val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else return unreachable("_fnSignature:fn, could not resolve generic '$name'")
        parts.push(resolvedGeneric.repr())

        if idx != fn.typeParams.length - 1 { parts.push(", ") }
      }
      parts.push(">")
    }
    parts.push("(")

    val args: String[] = []
    if fn.kind == FunctionKind.InstanceMethod args.push("self")
    for param in fn.params {
      val paramTyRepr = match self._getReprForType(param.ty) { Ok(v) => v, Err(e) => return Err(e) }
      val defaultExpr = if param.defaultValue " = ..." else ""
      args.push("${param.label.name}: $paramTyRepr$defaultExpr")
    }
    parts.push(args.join(", "))
    parts.push(")")

    if fn.returnType.kind != TypeKind.PrimitiveUnit {
      val returnTyRepr = match self._getReprForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
      parts.push(": $returnTyRepr")
    }

    Ok(parts.join())
  }

  func _structSignature(self, struct: Struct): Result<String[], CompileError> {
    val firstLine = ["type ${struct.label.name}"]
    if !struct.typeParams.isEmpty() {
      firstLine.push("<")
      for name, idx in struct.typeParams {
        val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else return unreachable("could not resolve generic '$name'")
        firstLine.push("$name = ${resolvedGeneric.repr()}")

        if idx != struct.typeParams.length - 1 { firstLine.push(", ") }
      }
      firstLine.push(">")
    }
    val parts = ["${firstLine.join()} {"]
    for field in struct.fields {
      parts.push("  ${field.name.name}: ${field.ty.repr()}")
    }
    parts.push("}")

    Ok(parts)
  }

  func _enumVariantSignature(self, enum_: Enum, variant: TypedEnumVariant): Result<String, CompileError> {
    val parts: String[] = [enum_.label.name, ".", variant.label.name]
    match variant.kind {
      EnumVariantKind.Container(fields) => {
        parts.push("(")
        for field, idx in fields {
          val fieldTyRepr = match self._getReprForType(field.ty) { Ok(v) => v, Err(e) => return Err(e) }
          parts.push("${field.name.name}: $fieldTyRepr")
          if idx != fields.length - 1 {
            parts.push(", ")
          }
        }
        parts.push(")")
      }
      _ => {}
    }

    Ok(parts.join())
  }

  func _typeIsInt(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveInt || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeIntStruct), [])
  func _typeIsFloat(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveFloat || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeFloatStruct), [])
  func _typeIsBool(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveBool || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeBoolStruct), [])
  func _typeIsString(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveString || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeStringStruct), [])

  // TODO: this is copied from Typechecker
  func _typeIsOption(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Enum(enum_) => {
            if enum_ != self._project.preludeOptionEnum return None
            if generics[0] |innerTy| {
              Some(innerTy)
            } else {
              None
            }
          }
          _ => None
        }
      }
      _ => None
    }
  }
}

func todo<V>(message: String, position = Position(line: 0, col: 0)): Result<V, CompileError> = Err(CompileError(position: position, kind: CompileErrorKind.NotYetImplemented(message)))
func unreachable<V>(message: String, position = Position(line: 0, col: 0)): Result<V, CompileError> = Err(CompileError(position: position, kind: CompileErrorKind.Unreachable(message)))
