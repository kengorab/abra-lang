import "fs" as fs
import Position from "./lexer"
import LiteralAstNode, UnaryOp, BinaryOp, AssignOp, BindingPattern from "./parser"
import Project, TypedModule, TypedAstNode, TypedAstNodeKind, Type, TypeKind, Struct, StructOrEnum, TypedInvokee, Function, FunctionKind, Decorator, AccessorPathSegment, TypedIdentifierKind, TypedAssignmentMode, Enum, TypedEnumVariant, EnumVariantKind from "./typechecker"
import ModuleBuilder, QbeType, Dest, QbeFunction, Value, Label from "./qbe"

type CompilationError {
  modulePath: String
  error: CompileError

  func getMessage(self): String {
    val contents = match fs.readFile(self.modulePath) {
      Ok(v) => v
      Err => return "Could not read file '${self.modulePath}'"
    }
    self.error.getMessage(self.modulePath, contents)
  }
}

type CompileError {
  position: Position
  kind: CompileErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      CompileErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      CompileErrorKind.Unreachable(message) => {
        lines.push("Unreachable code reached")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Internal error: $message")
      }
      CompileErrorKind.QbeError(message) => {
        // todo: somehow thread the `node` which generated the error through to the error message
        lines.push("Encountered error while generating qbe code:")
        lines.push(message)
      }
      CompileErrorKind.ResolvedGenericsError(context, message) => {
        // todo: somehow thread the `node` which generated the error through to the error message
        lines.push("Encountered error resolving generics for '$context':")
        lines.push(message)
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum CompileErrorKind {
  NotYetImplemented(reason: String)
  Unreachable(message: String)
  QbeError(message: String)
  ResolvedGenericsError(context: String, message: String)
}

func qbeError<V>(message: String): Result<V, CompileError> = Err(CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(message)))

type ResolvedGenerics {
  _layers: (String, Map<String, Type>)[] = []

  func toString(self): String {
    val parts = ["ResolvedGenerics(_layers: ["]
    for layer, idx in self._layers {
      parts.push("(\"${layer[0]}\", { ")
      for _p in layer[1] {
        parts.push("\"${_p[0]}\": \"${_p[1].repr()}\", ")
      }
      parts.push("}")

      if idx != self._layers.length - 1 { parts.push(", ") }
    }
    parts.push("])")

    parts.join()
  }

  func resolveGeneric(self, name: String): Type? {
    var idx = self._layers.length - 1
    while self._layers[idx] |layer| {
      if layer[1][name] |ty| return Some(ty)
      idx -= 1
    }

    None
  }

  func addLayer(self, context: String, given: Map<String, Type>): Result<Int, String> {
    val newLayer: Map<String, Type> = {}
    for _p in given {
      // TODO: destructuring
      val name = _p[0]
      val ty = _p[1]

      match ty.kind {
        TypeKind.Generic(name) => {
          if self.resolveGeneric(name) |resolved| {
            newLayer[name] = resolved
          } else {
            return Err("layer: could not resolve generic '$name'")
          }
        }
        _ => newLayer[name] = ty
      }
    }

    self._layers.push((context, newLayer))

    Ok(0)
  }

  func popLayer(self) {
    self._layers.pop()
  }
}

export type Compiler {
  _project: Project
  _builder: ModuleBuilder
  _currentModule: TypedModule
  _currentFn: QbeFunction
  _currentNode: TypedAstNode?
  _resolvedGenerics: ResolvedGenerics = ResolvedGenerics()
  // cached fns
  _printf: QbeFunction = QbeFunction.spec(name: "printf", returnType: None, parameters: [], variadicIdx: Some(1))
  _snprintf: QbeFunction = QbeFunction.spec(name: "snprintf", returnType: Some(QbeType.U64), parameters: [], variadicIdx: Some(3))
  _memcpy: QbeFunction = QbeFunction.spec(name: "memcpy", returnType: None)
  _malloc: QbeFunction = QbeFunction.spec(name: "malloc", returnType: Some(QbeType.Pointer))
  _realloc: QbeFunction = QbeFunction.spec(name: "realloc", returnType: Some(QbeType.Pointer))

  func compile(project: Project, entry: TypedModule): Result<ModuleBuilder, CompilationError> {
    val builder = ModuleBuilder()

    val fn = builder.buildFunction(name: "main", returnType: Some(QbeType.U32), exported: true)
    fn.addComment("main entrypoint function")
    val mainFnBlock = fn.block

    val compiler = Compiler(_project: project, _builder: builder, _currentModule: entry, _currentNode: None, _currentFn: fn)

    val moduleFn = match compiler._compileModule(entry) { Ok(v) => v, Err(e) => {
      // println(compiler._currentNode?.token)
      return Err(CompilationError(modulePath: entry.name, error: e))
    }}
    val modFnName = compiler._moduleWrapperFnName(entry)
    mainFnBlock.buildVoidCall(moduleFn, [])
    mainFnBlock.buildReturn(Some(Value.Int(0)))

    match mainFnBlock.verify() { Ok(v) => v, Err(e) => return Err(CompilationError(modulePath: entry.name, error: CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(e)))) }

    Ok(builder)
  }

  func _compileModule(self, module: TypedModule): Result<QbeFunction, CompileError> {
    val modFnName = self._moduleWrapperFnName(module)
    self._currentModule = module

    val fn = self._builder.buildFunction(name: modFnName, returnType: None)
    fn.addComment(module.name)

    self._currentFn = fn

    for node, idx in module.code {
      val value = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
      // If the last statement in the module is an expression, call the `toString` method on that expression, and print the result using `printf`.
      if idx == module.code.length - 1 && node.ty.kind != TypeKind.PrimitiveUnit {
        if value |v| {
          self._currentFn.block.addComment("call `toString` on final expression, and `printf` the String's chars")
          val dataPtr = self._builder.buildGlobalString("%s\\n")
          val tostringMethod = match self._getOrCompileToStringMethod(node.ty) { Ok(v) => v, Err(e) => return Err(e) }

          val tostringRepr = match self._currentFn.block.buildCall(tostringMethod, [v], Some("_to_string_repr")) { Ok(v) => v, Err(e) => return qbeError(e) }
          val reprCharsPtr = match self._currentFn.block.buildAdd(Value.Int(8), tostringRepr, Some("_repr_chars_ptr")) { Ok(v) => v, Err(e) => return qbeError(e) }
          val reprChars = self._currentFn.block.buildLoadL(reprCharsPtr, Some("_repr_chars"))
          self._currentFn.block.buildVoidCall(self._printf, [dataPtr, reprChars])
        }
      }
    }

    fn.block.buildReturn()

    match fn.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    Ok(fn)
  }

  func _compileStatement(self, node: TypedAstNode): Result<Value?, CompileError> {
    val prevNode = self._currentNode
    self._currentNode = Some(node)

    val res: Result<Value?, CompileError> = match node.kind {
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if !isStatement {
          val res = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
          return Ok(Some(res))
        }

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        val condVal = match self._compileExpression(cond) { Ok(v) => v, Err(e) => return Err(e) }
        val condExprIsOpt = self._typeIsOption(cond.ty)

        if condExprIsOpt {
          val variantIsOptionSome = match self._emitOptValueIsSomeVariant(condVal) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildJnz(variantIsOptionSome, labelThen, if elseBlock.isEmpty() labelCont else labelElse)
        } else {
          self._currentFn.block.buildJnz(condVal, labelThen, if elseBlock.isEmpty() labelCont else labelElse)
        }

        self._currentFn.block.registerLabel(labelThen)
        if conditionBinding |_p| {
          // TODO: destructuring
          val bindingPattern = _p[0]
          val _vars = _p[1]

          val bindingName = match bindingPattern {
            BindingPattern.Variable(label) => label.name
          }

          if condExprIsOpt |innerTy| {
            val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
            val optInnerValue = match self._emitOptValueGetValue(innerQbeType, condVal) { Ok(v) => v, Err(e) => return Err(e) }

            val slotName = "$bindingName.slot"
            val slot = self._buildStackAllocForQbeType(innerQbeType, Some(slotName))
            self._currentFn.block.buildStore(innerQbeType, optInnerValue, slot)
          } else {
            return todo("boolean cond bindings")
          }
        }
        for node in ifBlock {
          match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
        }
        if !ifBlockTerminator {
          self._currentFn.block.buildJmp(labelCont)
        }

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node in elseBlock {
            match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
          }
          if !elseBlockTerminator {
            self._currentFn.block.buildJmp(labelCont)
          }
        }

        self._currentFn.block.registerLabel(labelCont)

        Ok(None)
      }
      TypedAstNodeKind.Match => todo("compiling match stmt/expr", node.token.position)
      TypedAstNodeKind.While => todo("compiling while-loop", node.token.position)
      TypedAstNodeKind.For(typedIterator, itemBindingPattern, indexBinding, block) => {
        if indexBinding return todo("for-loop index bindings", node.token.position)

        val _t = match self._getInstanceTypeForType(typedIterator.ty) { Ok(v) => v, Err(e) => return Err(e) }
        // TODO: destructuring
        val instTy = _t[0]
        val _typeArgs = _t[1]

        val _p = match instTy {
          StructOrEnum.Struct(s) => {
            if s == self._project.preludeArrayStruct {
              return todo("array as for-loop target") // will probably need to add a ResolvedGenerics layer when doing this
            }
            if s == self._project.preludeSetStruct {
              return todo("set as for-loop target")
            }
            if s == self._project.preludeMapStruct {
              return todo("map as for-loop target")
            }

            val iter = match self._compileExpression(typedIterator) { Ok(v) => v, Err(e) => return Err(e) }
            val nextFn = if s.instanceMethods.find(m => m.label.name == "next") |fn| fn else return unreachable("a type must have a 'next' method if it's to be iterable")

            (iter, nextFn)
          }
          StructOrEnum.Enum(_enum) => return todo("enum as for-loop target")
        }
        // TODO: destructuring
        val iterVal = _p[0]
        val nextFn = _p[1]
        val nextItemTy = if self._typeIsOption(nextFn.returnType) |innerTy| innerTy else return unreachable("a 'next' method must return an Option type")
        val nextItemQbeTy = match self._getQbeTypeForTypeExpect(nextItemTy, "unacceptable type for 'next' method return type") { Ok(v) => v, Err(e) => return Err(e) }

        val nextFnVal = match self._getOrCompileMethod(typedIterator.ty, nextFn) { Ok(v) => v, Err(e) => return Err(e) }

        val loopStartLabel = self._currentFn.block.addLabel("for_loop_start")
        val loopBodyLabel = self._currentFn.block.addLabel("for_loop_body")
        val loopEndLabel = self._currentFn.block.addLabel("for_loop_end")

        self._currentFn.block.registerLabel(loopStartLabel)
        val itemName = match itemBindingPattern[0] {
          BindingPattern.Variable(label) => label.name
        }
        val nextRet = match self._currentFn.block.buildCall(nextFnVal, [iterVal], Some("next_ret")) { Ok(v) => v, Err(e) => return qbeError(e) }

        val variantIsOptionSome = match self._emitOptValueIsSomeVariant(nextRet) { Ok(v) => v, Err(e) => return Err(e) }
        self._currentFn.block.buildJnz(variantIsOptionSome, loopBodyLabel, loopEndLabel)

        self._currentFn.block.registerLabel(loopBodyLabel)
        val itemSlotName = "$itemName.slot"
        val optInnerValue = match self._emitOptValueGetValue(nextItemQbeTy, nextRet) { Ok(v) => v, Err(e) => return Err(e) }
        val itemSlot = self._buildStackAllocForQbeType(nextItemQbeTy, Some(itemSlotName))
        self._currentFn.block.buildStore(nextItemQbeTy, optInnerValue, itemSlot)

        for node in block {
          match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
        }
        self._currentFn.block.buildJmp(loopStartLabel)

        self._currentFn.block.registerLabel(loopEndLabel)

        Ok(None)
      }
      TypedAstNodeKind.BindingDeclaration(bindingDeclNode) => {
        val bindingName = match bindingDeclNode.bindingPattern {
          BindingPattern.Variable(label) => label.name
        }
        val variable = if bindingDeclNode.variables[0] |v| v else return unreachable("binding decl needs at least 1 variable")

        val exprVal = if bindingDeclNode.expr |expr| {
          val res = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
          Some(res)
        } else None

        val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
        val slotName = "${variable.label.name}.slot"
        val slot = self._buildStackAllocForQbeType(varTy, Some(slotName))
        // val slot = match varTy {
        //   QbeType.U8 => self._currentFn.block.buildAlloc8(1, Some(slotName))      // 'b'
        //   QbeType.U16 => self._currentFn.block.buildAlloc4(1, Some(slotName))     // 'h'
        //   QbeType.U32 => self._currentFn.block.buildAlloc4(1, Some(slotName))     // 'w'
        //   QbeType.U64 => self._currentFn.block.buildAlloc8(1, Some(slotName))     // 'l'
        //   QbeType.Pointer => self._currentFn.block.buildAlloc8(1, Some(slotName)) // 'l'
        //   QbeType.F32 => self._currentFn.block.buildAlloc4(1, Some(slotName))     // 's'
        //   QbeType.F64 => self._currentFn.block.buildAlloc8(1, Some(slotName))     // 'd'
        // }

        if bindingDeclNode.expr |expr| {
          val res = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildStore(varTy, res, slot)
        }

        Ok(None)
      }
      TypedAstNodeKind.FunctionDeclaration => Ok(None)
      TypedAstNodeKind.TypeDeclaration => Ok(None)
      TypedAstNodeKind.EnumDeclaration => Ok(None)
      TypedAstNodeKind.Break => todo("compiling break statement", node.token.position)
      TypedAstNodeKind.Continue => todo("compiling continue statement", node.token.position)
      TypedAstNodeKind.Return(expr) => {
        if expr |expr| {
          val retVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildReturn(Some(retVal))
        } else {
          self._currentFn.block.buildReturn(None)
        }

        Ok(None)
      }
      TypedAstNodeKind.Placeholder => unreachable("placeholder ast node emitted from typechecker", node.token.position)
      TypedAstNodeKind.Assignment(mode, op, expr) => {
        val res = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }

        match mode {
          TypedAssignmentMode.Variable(variable) => {
            if variable.isParameter return unreachable("parameters cannot be reassigned to", node.token.position)

            val slotName = "${variable.label.name}.slot"
            val slot = Value.Ident(slotName, QbeType.Pointer)
            self._currentFn.block.buildStoreL(res, slot)
          }
          TypedAssignmentMode.Indexing(_node) => return todo("compiling indexing assignment stmt", node.token.position)
          TypedAssignmentMode.Accessor(head, middle, tail) => {
            val ptr = match self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: false) { Ok(v) => v, Err(e) => return Err(e) }

            // TODO: this only works for int-assignable (ie. Int and Pointer types, not Bool or Float types)
            self._currentFn.block.buildStoreL(res, ptr)
          }
        }

        Ok(None)
      }
      _ => {
        val v = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
        if node.ty.kind == TypeKind.PrimitiveUnit {
          Ok(None)
        } else {
          Ok(Some(v))
        }
      }
    }

    self._currentNode = prevNode

    res
  }

  func _compileExpression(self, node: TypedAstNode, resultLocalName: String? = None): Result<Value, CompileError> {
    val prevNode = self._currentNode
    self._currentNode = Some(node)
    // println(node.token)

    val res: Result<Value, CompileError> = match node.kind {
      TypedAstNodeKind.Literal(lit) => {
        match lit {
          LiteralAstNode.Int(v) => {
            val res = match self._currentFn.block.buildAdd(Value.Int(0), Value.Int(v), resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          LiteralAstNode.Float(f) => {
            val res = match self._currentFn.block.buildAdd(Value.Float(0.0), Value.Float(f), resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          LiteralAstNode.Bool(b) => {
            val res = match self._currentFn.block.buildAdd(Value.Int32(0), Value.Int32(if b 1 else 0), resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            self._currentFn.block.addCommentBefore(b.toString())
            Ok(res)
          }
          LiteralAstNode.String(s) => {
            val dataPtr = self._builder.buildGlobalString(s)
            val instancePtr = match self._constructString(dataPtr, Value.Int(s.length), resultLocalName) { Ok(v) => v, Err(e) => return Err(e) }
            Ok(instancePtr)
          }
        }
      }
      TypedAstNodeKind.StringInterpolation => todo("compiling string interpolation expression", node.token.position)
      TypedAstNodeKind.Unary(op, expr) => {
        match op {
          UnaryOp.Minus => {
            val exprVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildNeg(exprVal) { Ok(v) => v, Err(e) => return qbeError(e) }

            Ok(res)
          }
          UnaryOp.Negate => {
            val exprVal = match self._compileExpression(expr) { Ok(v) => v, Err(e) => return Err(e) }
            val exprIsOpt = self._typeIsOption(expr.ty)
            if exprIsOpt {
              val variantIsNotOptionSome = match self._emitOptValueIsSomeVariant(exprVal: exprVal, negate: true) { Ok(v) => v, Err(e) => return Err(e) }
              Ok(variantIsNotOptionSome)
            } else {
              val plusOneVal = match self._currentFn.block.buildAdd(Value.Int32(1), exprVal) { Ok(v) => v, Err(e) => return qbeError(e) }
              val res = match self._currentFn.block.buildRem(plusOneVal, Value.Int32(2)) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            }
          }
        }
      }
      TypedAstNodeKind.Binary(left, op, right) => {
        match op {
          BinaryOp.Add => {
            if self._typeIsString(left.ty) || self._typeIsString(right.ty) return todo("string concatenation", node.token.position)

            val vals = match self._compileBinaryOperands(left, right, "+") { Ok(v) => v, Err(e) => return Err(e) }
            // TODO: destructuring
            val res = match self._currentFn.block.buildAdd(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Sub => {
            val vals = match self._compileBinaryOperands(left, right, "-") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildSub(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Mul => {
            val vals = match self._compileBinaryOperands(left, right, "*") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildMul(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Div => {
            var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if !self._typeIsFloat(left.ty)
              leftVal = self._currentFn.block.buildLToF(leftVal)
            if !self._typeIsFloat(right.ty)
              rightVal = self._currentFn.block.buildLToF(rightVal)

            val res = match self._currentFn.block.buildDiv(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Mod => {
            var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val res = match self._currentFn.block.buildRem(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              if !self._typeIsFloat(left.ty)
                leftVal = self._currentFn.block.buildLToF(leftVal)
              if !self._typeIsFloat(right.ty)
                rightVal = self._currentFn.block.buildLToF(rightVal)

              val res = match self._currentFn.block.buildCallRaw("fmod", QbeType.F64, [leftVal, rightVal]) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            }
          }
          BinaryOp.Pow => todo("compiling binary expression: Pow", node.token.position)
          BinaryOp.And => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

              val res = match self._currentFn.block.buildAnd(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              val labelThen = self._currentFn.block.addLabel("bool_and_then")
              val labelElse = self._currentFn.block.addLabel("bool_and_else")
              val labelCont = self._currentFn.block.addLabel("bool_and_cont")

              self._currentFn.block.buildJnz(leftVal, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(labelThen, rightVal), (labelElse, leftVal)]
              val res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }

              Ok(res)
            }
          }
          BinaryOp.Or => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

              val res = match self._currentFn.block.buildOr(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              val labelThen = self._currentFn.block.addLabel("bool_or_then")
              val labelElse = self._currentFn.block.addLabel("bool_or_else")
              val labelCont = self._currentFn.block.addLabel("bool_or_cont")

              self._currentFn.block.buildJnz(leftVal, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(labelThen, leftVal), (labelElse, rightVal)]
              val res = match self._currentFn.block.buildPhi(phiCases) { Ok(v) => v, Err(e) => return qbeError(e) }

              Ok(res)
            }
          }
          BinaryOp.Xor => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) || self._typeIsBool(left.ty) && self._typeIsBool(right.ty) {
              val res = match self._currentFn.block.buildXor(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
              Ok(res)
            } else {
              unreachable("unknown operator '^' between types '${left.ty.repr()}' and '${right.ty.repr()}")
            }
          }
          BinaryOp.Coalesce => todo("compiling binary expression: Coalesce", node.token.position)
          BinaryOp.Eq => self._compileBinaryEq(left, right)
          BinaryOp.Neq => self._compileBinaryEq(left: left, right: right, negate: true)
          BinaryOp.LT => {
            val vals = match self._compileBinaryOperands(left, right, "<") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildCompareLt(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.LTE => {
            val vals = match self._compileBinaryOperands(left, right, "<=") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildCompareLte(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Shl => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            val res = match self._currentFn.block.buildShl(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.GT => {
            val vals = match self._compileBinaryOperands(left, right, ">") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildCompareGt(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.GTE => {
            val vals = match self._compileBinaryOperands(left, right, ">=") { Ok(v) => v, Err(e) => return Err(e) }
            val res = match self._currentFn.block.buildCompareGte(vals[0], vals[1], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
          BinaryOp.Shr => {
            val leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
            val rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

            val res = match self._currentFn.block.buildShr(leftVal, rightVal, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
            Ok(res)
          }
        }
      }
      TypedAstNodeKind.Grouped(inner) => self._compileExpression(inner, resultLocalName)
      TypedAstNodeKind.Identifier(kind) => {
        match kind {
          TypedIdentifierKind.Named(name, variable) => {
            // If a variable is function parameter, it can just be referenced by name as a temporary/local, otherwise it can be obtained by
            // loading the value pointed to by the temporary/local with that name.
            // TODO: handle captured variables in closures, global variables, etc).
            val varTy = match self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position)) { Ok(v) => v, Err(e) => return Err(e) }
            if variable.isParameter {
              Ok(Value.Ident(name, varTy))
            } else {
              val slot = Value.Ident("$name.slot", QbeType.Pointer)
              val res = self._currentFn.block.buildLoad(varTy, slot, Some(name))
              Ok(res)
            }
          }
          _ => todo("other identifier kinds (${node.token})", node.token.position)
        }
      }
      TypedAstNodeKind.Accessor(head, middle, tail) => self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: true, localName: resultLocalName)
      TypedAstNodeKind.Invocation(invokee, arguments, resolvedGenerics) => {
        val args: Value[] = []
        var fnHasOptionalParameters = false

        val fnVal = match invokee {
          TypedInvokee.Function(fn) => {
            if fn.label.name == "println" return self._invokePrintln(arguments)

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "Intrinsic")
            if intrinsicDec |dec| return self._invokeIntrinsicFn(dec, fn, arguments)

            val cBindingDec = fn.decorators.find(dec => dec.label.name == "CBinding")
            if cBindingDec |dec| return self._invokeCBindingFn(dec, fn, arguments)

            match self._resolvedGenerics.addLayer(fn.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: fn.label.name, message: e))) }

            fnHasOptionalParameters = fn.params.any(p => !!p.defaultValue)

            val fnVal = match fn.kind {
              FunctionKind.StaticMethod(parentTy) => {
                val fnVal = match self._getOrCompileMethod(Type(kind: TypeKind.Type(parentTy)), fn) { Ok(v) => v, Err(e) => return Err(e) }
                fnVal
              }
              FunctionKind.Standalone => {
                val fnVal = match self._getOrCompileFunction(fn) { Ok(v) => v, Err(e) => return Err(e) }
                fnVal
              }
              FunctionKind.InstanceMethod => return unreachable("instance methods handled elsewhere", node.token.position)
            }

            fnVal
          }
          TypedInvokee.Method(fn, selfVal, isOptSafe) => {
            val selfInstanceType = match self._addResolvedGenericsLayerForInstanceMethod(selfVal.ty, fn.label.name, node.token.position, resolvedGenerics) { Ok(v) => v, Err(e) => return Err(e) }

            fnHasOptionalParameters = fn.params.any(p => !!p.defaultValue)

            if isOptSafe return todo("opt-safe method invocation", node.token.position)

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "Intrinsic")
            if intrinsicDec |dec| {
              val res = self._invokeIntrinsicFn(dec, fn, [Some(selfVal)].concat(arguments))
              self._resolvedGenerics.popLayer()
              return res
            }

            val fnVal = match self._getOrCompileMethod(selfInstanceType, fn) { Ok(v) => v, Err(e) => return Err(e) }

            args.push(match self._compileExpression(selfVal) { Ok(v) => v, Err(e) => return Err(e) })

            fnVal
          }
          TypedInvokee.Struct(struct) => {
            match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }
            fnHasOptionalParameters = struct.fields.any(f => !!f.initializer)
            val fnVal = match self._getOrCompileStructInitializer(struct) { Ok(v) => v, Err(e) => return Err(e) }
            fnVal
          }
          TypedInvokee.EnumVariant(enum_, variant) => {
            match self._resolvedGenerics.addLayer(variant.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: variant.label.name, message: e))) }
            val enumVariantFn = match self._getOrCompileEnumVariantFn(enum_, variant) { Ok(v) => v, Err(e) => return Err(e) }
            enumVariantFn
          }
          TypedInvokee.Expr => return todo("invocation of arbitrary function expression", node.token.position)
        }

        var defaultValueParamIdx = 0
        var defaultValueFlags = 0
        for arg in arguments {
          if arg |node| {
            val arg = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
            args.push(arg)
          } else {
            defaultValueFlags ||= (1 << defaultValueParamIdx)
            defaultValueParamIdx += 1

            val argQbeType = match self._getQbeTypeForTypeExpect(node.ty, "unacceptable type", Some(node.token.position)) { Ok(v) => v, Err(e) => return Err(e) }
            args.push(argQbeType.zeroValue())
          }
        }

        if fnHasOptionalParameters {
          args.push(Value.Int32(defaultValueFlags))
        }

        val res = if fnVal.returnType {
          val res = match self._currentFn.block.buildCall(fnVal, args, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
          res
        } else {
          self._currentFn.block.buildVoidCall(fnVal, args)
          Value.Ident("bogus", QbeType.F32)
        }

        self._resolvedGenerics.popLayer()

        Ok(res)
      }
      TypedAstNodeKind.Array(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val inner = if generics[0] |t| t else return unreachable("Array has 1 required type argument")
            match self._resolvedGenerics.addLayer("array literal", { "T": inner }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "array literal", message: e))) }
          }
          _ => return unreachable("we know it's an array instance here")
        }

        val arrayWithCapacityFn = if self._project.preludeArrayStruct.staticMethods.find(m => m.label.name == "withCapacity") |fn| fn else return unreachable("Array.withCapacity must exist")
        val arrayWithCapacityFnVal = match self._getOrCompileMethod(node.ty, arrayWithCapacityFn) { Ok(v) => v, Err(e) => return Err(e) }

        val sizeVal = Value.Int(items.length.nextPowerOf2())
        val arrayInstance = match self._currentFn.block.buildCall(arrayWithCapacityFnVal, [sizeVal], resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.addCommentBefore("${arrayInstance.repr()}: ${node.ty.repr()}")

        val arrayPushFn = if self._project.preludeArrayStruct.instanceMethods.find(m => m.label.name == "push") |fn| fn else return unreachable("Array#push must exist")
        val arrayPushFnVal = match self._getOrCompileMethod(node.ty, arrayPushFn) { Ok(v) => v, Err(e) => return Err(e) }

        for item in items {
          val itemVal = match self._compileExpression(item) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildVoidCall(arrayPushFnVal, [arrayInstance, itemVal])
        }

        self._resolvedGenerics.popLayer()

        Ok(arrayInstance)
      }
      TypedAstNodeKind.Set => todo("compiling set expression", node.token.position)
      TypedAstNodeKind.Map => todo("compiling map expression", node.token.position)
      TypedAstNodeKind.Tuple => todo("compiling tuple expression", node.token.position)
      TypedAstNodeKind.Indexing => todo("compiling indexing expression", node.token.position)
      TypedAstNodeKind.Lambda => todo("compiling lambda expression", node.token.position)
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if isStatement return unreachable("if-statements are handled elsewhere", node.token.position)
        if elseBlock.isEmpty() return unreachable("if-expressions must not have empty else-blocks", node.token.position)

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        val condVal = match self._compileExpression(cond) { Ok(v) => v, Err(e) => return Err(e) }
        val condExprIsOpt = self._typeIsOption(cond.ty)
        if condExprIsOpt {
          val variantIsOptionSome = match self._emitOptValueIsSomeVariant(condVal) { Ok(v) => v, Err(e) => return Err(e) }
          self._currentFn.block.buildJnz(variantIsOptionSome, labelThen, labelElse)
        } else {
          self._currentFn.block.buildJnz(condVal, labelThen, labelElse)
        }

        val phiCases: (Label, Value)[] = []

        self._currentFn.block.registerLabel(labelThen)
        if conditionBinding |_p| {
          // TODO: destructuring
          val bindingPattern = _p[0]
          val _vars = _p[1]

          val bindingName = match bindingPattern {
            BindingPattern.Variable(label) => label.name
          }

          if condExprIsOpt |innerTy| {
            val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
            val optInnerValue = match self._emitOptValueGetValue(innerQbeType, condVal) { Ok(v) => v, Err(e) => return Err(e) }

            val slotName = "$bindingName.slot"
            val slot = self._buildStackAllocForQbeType(innerQbeType, Some(slotName))
            self._currentFn.block.buildStore(innerQbeType, optInnerValue, slot)
          } else {
            return todo("boolean cond bindings")
          }
        }
        for node, idx in ifBlock {
          if idx == ifBlock.length - 1 {
            val res = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
            phiCases.push((labelThen, res))
          } else {
            match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
          }
        }
        if !ifBlockTerminator {
          self._currentFn.block.buildJmp(labelCont)
        }

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node, idx in elseBlock {
            if idx == elseBlock.length - 1 {
              val res = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
              phiCases.push((labelElse, res))
            } else {
              match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
            }
          }
          if !elseBlockTerminator {
            self._currentFn.block.buildJmp(labelCont)
          }
        }

        self._currentFn.block.registerLabel(labelCont)

        val res = match self._currentFn.block.buildPhi(phiCases, resultLocalName) { Ok(v) => v, Err(e) => return qbeError(e) }

        Ok(res)
      }
      TypedAstNodeKind.Match => todo("compiling match stmt/expr", node.token.position)
      _ => unreachable("node must be a statement", node.token.position)
    }

    self._currentNode = prevNode

    res
  }

  func _compileBinaryOperands(self, left: TypedAstNode, right: TypedAstNode, op: String): Result<(Value, Value), CompileError> {
    var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
    var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

    if left.ty != right.ty {
      val leftIsFloat = self._typeIsFloat(left.ty)
      val rightIsFloat = self._typeIsFloat(right.ty)
      if leftIsFloat && !rightIsFloat {
        rightVal = self._currentFn.block.buildLToF(rightVal)
      } else if rightIsFloat && !leftIsFloat {
        leftVal = self._currentFn.block.buildLToF(leftVal)
      } else {
        return unreachable("unknown operator '$op' between types '${left.ty.repr()}' and '${right.ty.repr()}")
      }
    }

    Ok((leftVal, rightVal))
  }

  func _compileBinaryEq(self, left: TypedAstNode, right: TypedAstNode, localName: String? = None, negate = false): Result<Value, CompileError> {
    var leftVal = match self._compileExpression(left) { Ok(v) => v, Err(e) => return Err(e) }
    var rightVal = match self._compileExpression(right) { Ok(v) => v, Err(e) => return Err(e) }

    if left.ty != right.ty return unreachable("equality operators require matching types", right.token.position)

    if self._typeIsInt(left.ty) || self._typeIsFloat(left.ty) || self._typeIsBool(left.ty) {
      val res = if negate {
        val res = match self._currentFn.block.buildCompareNeq(leftVal, rightVal, localName) { Ok(v) => v, Err(e) => return qbeError(e) }
        res
      } else {
        val res = match self._currentFn.block.buildCompareEq(leftVal, rightVal, localName) { Ok(v) => v, Err(e) => return qbeError(e) }
        res
      }
      return Ok(res)
    }

    val instType = match self._addResolvedGenericsLayerForInstanceMethod(left.ty, "eq", left.token.position) { Ok(v) => v, Err(e) => return Err(e) }
    val eqFnVal = match self._getOrCompileEqMethod(instType) { Ok(v) => v, Err(e) => return Err(e) }
    self._resolvedGenerics.popLayer()

    val res = match self._currentFn.block.buildCall(eqFnVal, [leftVal, rightVal], localName) { Ok(v) => v, Err(e) => return qbeError(e) }
    if negate {
      val plusOneVal = match self._currentFn.block.buildAdd(Value.Int32(1), res) { Ok(v) => v, Err(e) => return qbeError(e) }
      val res = match self._currentFn.block.buildRem(plusOneVal, Value.Int32(2)) { Ok(v) => v, Err(e) => return qbeError(e) }
      Ok(res)
    } else {
      Ok(res)
    }
  }

  func _constructString(self, ptrVal: Value, lenVal: Value, localName: String? = None): Result<Value, CompileError> {
    val fnVal = match self._getOrCompileStructInitializer(self._project.preludeStringStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val structTy = if fnVal.returnType |ty| ty else return unreachable("initializer functions must have return types specified")

    val res = match self._currentFn.block.buildCall(fnVal, [lenVal, ptrVal, Value.Int32(0)], localName) { Ok(v) => v, Err(e) => return qbeError(e) }
    self._currentFn.block.addCommentBefore("${res.repr()}: String")
    Ok(res)
  }

  func _getQbeTypeForType(self, ty: Type): Result<QbeType?, CompileError> {
    match ty.kind {
      TypeKind.PrimitiveUnit => Ok(None)
      TypeKind.PrimitiveInt => Ok(Some(QbeType.U64))
      TypeKind.PrimitiveFloat => Ok(Some(QbeType.F64))
      TypeKind.PrimitiveBool => Ok(Some(QbeType.U32))
      TypeKind.PrimitiveString => Ok(Some(QbeType.Pointer))
      TypeKind.Never => Ok(None)
      TypeKind.Any => todo("TypeKind.Any")
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getQbeTypeForType(ty) else unreachable("unexpected generic '$name' at this point")
      }
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => {
            // moduleId == 1 -> "_intrinsics" module
            if struct.moduleId == 1 {
              if struct.label.name == "Byte" return Ok(Some(QbeType.U64))
              if struct.label.name == "Pointer" return Ok(Some(QbeType.Pointer))
            }
          }
          _ => {}
        }

        Ok(Some(QbeType.Pointer))
      }
      TypeKind.Func(paramTypes, returnType) => todo("TypeKind.Func")
      TypeKind.Type(type_) => todo("TypeKind.Type")
      TypeKind.Tuple(types) => todo("TypeKind.Tuple")
      TypeKind.Hole => unreachable("unexpected hole in emitted typed ast")
    }
  }

  func _getQbeTypeForTypeExpect(self, ty: Type, reason: String, position: Position? = None): Result<QbeType, CompileError> {
    val _ty = match self._getQbeTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    if _ty |ty| Ok(ty) else if position |pos| unreachable(reason, pos) else unreachable(reason)
  }

  func _followAccessorPath(self, head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment, loadFinal: Bool, localName: String? = None): Result<Value, CompileError> {
    val segs = middle.concat([tail])
    val _p = match segs[0] {
      AccessorPathSegment.Field => {
        // TODO: assert that `head.ty` is a pointer type (attempting to do pointer arithmetic later on will fail otherwise)
        val _t = match self._getInstanceTypeForType(head.ty) { Ok(v) => v, Err(e) => return Err(e) }
        // TODO: destructuring
        val instTy = _t[0]
        val _typeArgs = _t[1]

        val curVal = match self._compileExpression(head) { Ok(v) => v, Err(e) => return Err(e) }
        self._currentFn.block.addCommentBefore("${curVal.repr()}: ${head.ty.repr()}")

        (instTy, curVal)
      }
      _ => (StructOrEnum.Struct(self._project.preludeBoolStruct), Value.Ident("bogus", QbeType.F32))
    }
    // TODO: destructuring
    var instTy = _p[0]
    var curVal = _p[1]

    for seg, idx in segs {
      match seg {
        AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => {
          val enumVariantFn = match self._getOrCompileEnumVariantFn(enum_, variant) { Ok(v) => v, Err(e) => return Err(e) }
          curVal = match self._currentFn.block.buildCall(enumVariantFn, []) { Ok(v) => v, Err(e) => return qbeError(e) }

          instTy = StructOrEnum.Enum(enum_)
        }
        AccessorPathSegment.Method(label, fn) => return todo("method accessor")
        AccessorPathSegment.Field(label, ty, field) => {
          match instTy {
            StructOrEnum.Struct(struct) => {
              var offset = 0
              for f in struct.fields {
                if f.name.name == field.name.name break

                val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
                offset += fieldTy.size()
              }

              val ptr = match self._currentFn.block.buildAdd(Value.Int(offset), curVal) { Ok(v) => v, Err(e) => return qbeError(e) }
              if idx == segs.length - 1 {
                if !loadFinal {
                  curVal = ptr
                } else {
                  val nextVal = self._currentFn.block.buildLoadL(ptr, localName)
                  self._currentFn.block.addCommentBefore("${nextVal.repr()}: ${curVal.repr()}.${field.name.name}")
                  curVal = nextVal
                }
              } else {
                val nextVal = self._currentFn.block.buildLoadL(ptr)
                self._currentFn.block.addCommentBefore("${nextVal.repr()}: ${curVal.repr()}.${field.name.name}")
                curVal = nextVal
              }
            }
            StructOrEnum.Enum(_enum) => return todo("enum field accessor")
          }
        }
      }
    }

    Ok(curVal)
  }

  func _getOrCompileStructInitializer(self, struct: Struct): Result<QbeFunction, CompileError> {
    val fnName = match self._structInitializerFnName(struct) { Ok(v) => v, Err(e) => return Err(e) }
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: fnName, returnType: Some(QbeType.Pointer))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    fnVal.addCommentMultiline(match self._structSignature(struct) { Ok(v) => v, Err(e) => return Err(e) })

    var defaultValueParamIdx = 0
    var defaultValuesMaskParam: Value? = None
    var addMaskParam = false
    var size = 0
    for field in struct.fields {
      val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
      size += fieldTy.size()

      if field.initializer |initializerNode| {
        val paramLocal = fnVal.addParameter("${field.name.name}_", fieldTy)
        addMaskParam = true
        val maskParam = Value.Ident("__default_params_mask__", QbeType.U32)

        val defaultValueFlag = 1 << defaultValueParamIdx
        defaultValueParamIdx += 1

        val labelUseDefaultValue = self._currentFn.block.addLabel("${field.name.name}_use_default")
        val labelUsePassedValue = self._currentFn.block.addLabel("${field.name.name}_use_passed")
        val labelCont = self._currentFn.block.addLabel("${field.name.name}_cont")

        val paramMaskVal = match self._currentFn.block.buildAnd(maskParam, Value.Int32(defaultValueFlag)) { Ok(v) => v, Err(e) => return qbeError(e) }
        val paramNeedsDefault = match self._currentFn.block.buildCompareEq(paramMaskVal, Value.Int32(defaultValueFlag)) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.buildJnz(paramNeedsDefault, labelUseDefaultValue, labelUsePassedValue)

        self._currentFn.block.registerLabel(labelUseDefaultValue)
        val res = match self._compileExpression(initializerNode) { Ok(v) => v, Err(e) => return Err(e) }
        self._currentFn.block.buildJmp(labelCont)

        self._currentFn.block.registerLabel(labelUsePassedValue)
        self._currentFn.block.buildJmp(labelCont)

        self._currentFn.block.registerLabel(labelCont)

        val phiCases = [(labelUseDefaultValue, res), (labelUsePassedValue, paramLocal)]
        match self._currentFn.block.buildPhi(phiCases, Some(field.name.name)) { Ok(v) => v, Err(e) => return qbeError(e) }
      } else {
        fnVal.addParameter(field.name.name, fieldTy)
      }
    }
    if addMaskParam {
      fnVal.addParameter("__default_params_mask__", QbeType.U32)
    }

    val memLocal = match fnVal.block.buildCall(self._malloc, [Value.Int(size)], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

    var offset = 0
    for field in struct.fields {
      val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
      val param = Value.Ident(field.name.name, fieldTy)

      val localName = "mem_offset_${field.name.name}"
      val memCursorLocal = match fnVal.block.buildAdd(Value.Int(offset), memLocal, Some(localName)) { Ok(v) => v, Err(e) => return qbeError(e) }
      fnVal.block.buildStore(fieldTy, param, memCursorLocal)

      offset += fieldTy.size()
    }

    fnVal.block.buildReturn(Some(memLocal))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileEnumVariantFn(self, enum_: Enum, variant: TypedEnumVariant): Result<QbeFunction, CompileError> {
    val variantFnName = self._enumVariantFnName(enum_, variant)
    if self._builder.getFunction(variantFnName) |fn| return Ok(fn)

    // TODO: constant variants shouldn't be a function - it should just be a `data` segment with the proper idx set
    val fn = self._builder.buildFunction(name: variantFnName, returnType: Some(QbeType.Pointer))
    val prevFn = self._currentFn
    self._currentFn = fn
    fn.addComment(match self._enumVariantSignature(enum_, variant) { Ok(v) => v, Err(e) => return Err(e) })

    var size = 0
    size += QbeType.U32.size() // account for space for variant idx slot
    match variant.kind {
      EnumVariantKind.Container(fields) => {
        for field in fields {
          val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
          size += fieldTy.size()
          fn.addParameter(field.name.name, fieldTy)
        }
      }
      _ => {}
    }

    val memLocal = match fn.block.buildCall(self._malloc, [Value.Int(size)], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

    val variantIdx = if enum_.variants.findIndex(v => v.label.name == variant.label.name) |_v| _v[1] else return unreachable("variant '${variant.label.name}' must exist")
    fn.block.buildStoreW(Value.Int32(variantIdx), memLocal) // Store variant idx at designated slot
    var offset = QbeType.U32.size() // begin inserting any fields after that variant idx slot

    match variant.kind {
      EnumVariantKind.Container(fields) => {
        for field in fields {
          val fieldTy = match self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position)) { Ok(v) => v, Err(e) => return Err(e) }
          val param = Value.Ident(field.name.name, fieldTy)

          val localName = "mem_offset_${field.name.name}"
          val memCursorLocal = match fn.block.buildAdd(Value.Int(offset), memLocal, Some(localName)) { Ok(v) => v, Err(e) => return qbeError(e) }
          fn.block.buildStore(fieldTy, param, memCursorLocal)

          offset += fieldTy.size()
        }
      }
      _ => {}
    }

    fn.block.buildReturn(Some(memLocal))

    self._currentFn = prevFn

    Ok(fn)
  }

  func _invokePrintln(self, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    self._currentFn.block.addComment("begin println...")
    val varargItems = if arguments[0] |node| {
      if node |node| {
        val items = match node.kind {
          TypedAstNodeKind.Array(items) => items
          _ => return unreachable("`println` receives an array of its variadic arguments")
        }
        items
      } else return unreachable("`println` receives an array of its variadic arguments")
    } else []

    val stdoutWriteFn = if self._project.preludeScope.functions.find(fn => fn.label.name == "stdoutWrite") |fn| fn else return unreachable("`stdoutWrite` must exist in prelude")
    val stdoutWriteFnVal = match self._getOrCompileFunction(stdoutWriteFn) { Ok(v) => v, Err(e) => return Err(e) }

    val space = self._builder.buildGlobalString(" ")
    val spaceStr = match self._constructString(space, Value.Int(1)) { Ok(v) => v, Err(e) => return Err(e) }
    val newline = self._builder.buildGlobalString("\\n")
    val newlineStr = match self._constructString(newline, Value.Int(1)) { Ok(v) => v, Err(e) => return Err(e) }

    for item, idx in varargItems {
      val itemVal = match self._compileExpression(item) { Ok(v) => v, Err(e) => return Err(e) }

      val itemInstanceType = match self._addResolvedGenericsLayerForInstanceMethod(item.ty, "toString", item.token.position) { Ok(v) => v, Err(e) => return Err(e) }
      val itemToStringFnVal = match self._getOrCompileToStringMethod(itemInstanceType) { Ok(v) => v, Err(e) => return Err(e) }
      self._resolvedGenerics.popLayer()

      val toStringVal = match self._currentFn.block.buildCall(itemToStringFnVal, [itemVal]) { Ok(v) => v, Err(e) => return qbeError(e) }

      self._currentFn.block.buildVoidCall(stdoutWriteFnVal, [toStringVal])

      if idx == varargItems.length - 1 {
        self._currentFn.block.buildVoidCall(stdoutWriteFnVal, [newlineStr])
      } else {
        self._currentFn.block.buildVoidCall(stdoutWriteFnVal, [spaceStr])
      }
    }
    self._currentFn.block.addComment("...println end")

    Ok(Value.Ident("bogus", QbeType.F32))
  }

  func _invokeCBindingFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val cFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => return unreachable("@CBinding decorator requires 1 string argument for the name")
    }

    val args: Value[] = []
    for arg in arguments {
      if arg |node| {
        val arg = match self._compileExpression(node) { Ok(v) => v, Err(e) => return Err(e) }
        args.push(arg)
      } else {
        return unreachable("functions with @CBinding decorator cannot have optional parameters")
      }
    }

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val res = if returnTypeQbe |returnTy| {
      val res = match self._currentFn.block.buildCallRaw(cFnName, returnTy, args) { Ok(v) => v, Err(e) => return qbeError(e) }
      res
    } else {
      self._currentFn.block.buildVoidCallRaw(cFnName, args)
      Value.Ident("bogus", QbeType.F32)
    }
    Ok(res)
  }

  func _pointerSize(self, ty: Type): Result<Int, CompileError> {
    val size = match ty.kind {
      TypeKind.PrimitiveBool => 4
      TypeKind.Generic(name) => return unreachable("unresolved generic '$name'")
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => {
            // moduleId == 1 -> "_intrinsics" module
            if struct.moduleId == 1 && struct.label.name == "Byte" 1 else 8
          }
          _ => 8
        }
      }
      _ => 8
    }

    Ok(size)
  }

  func _invokeIntrinsicFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val intrinsicFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => return unreachable("@Intrinsic decorator requires 1 string argument for the name")
    }

    match intrinsicFnName {
      "pointer_null" => {
        self._currentFn.block.addComment("begin pointer_null...")

        match self._currentFn.block.buildAdd(Value.Int(0), Value.Int(0), Some("__pointer_null__")) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_null end")

        Ok(Value.Ident("__pointer_null__", QbeType.Pointer))
      }
      "pointer_malloc" => {
        self._currentFn.block.addComment("begin pointer_malloc...")

        val _count = if arguments[0] |arg| arg else return unreachable("'pointer_malloc' has 1 required argument")
        val count = if _count |arg| arg else return unreachable("'pointer_malloc' has 1 required argument")
        val countVal = match self._compileExpression(count) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(innerTySize), countVal) { Ok(v) => v, Err(e) => return qbeError(e) }

        val mem = match self._currentFn.block.buildCall(self._malloc, [sizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_malloc end")

        Ok(mem)
      }
      "pointer_realloc" => {
        self._currentFn.block.addComment("begin pointer_realloc...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _count = if arguments[1] |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val count = if _count |arg| arg else return unreachable("'pointer_realloc' has 2 required arguments")
        val countVal = match self._compileExpression(count) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(innerTySize), countVal) { Ok(v) => v, Err(e) => return qbeError(e) }

        val mem = match self._currentFn.block.buildCall(self._malloc, [ptrVal, sizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_realloc end")

        Ok(mem)
      }
      "pointer_store" => {
        self._currentFn.block.addComment("begin pointer_store...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _value = if arguments[1] |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val value = if _value |arg| arg else return unreachable("'pointer_store' has 2 required arguments")
        val valueVal = match self._compileExpression(value) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }
        self._currentFn.block.buildStore(innerQbeType, valueVal, ptrVal)

        self._currentFn.block.addComment("...pointer_store end")

        Ok(Value.Ident("bogus", QbeType.F32))
      }
      "pointer_offset" => {
        self._currentFn.block.addComment("begin pointer_offset...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _offset = if arguments[1] |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val offset = if _offset |arg| arg else return unreachable("'pointer_offset' has 2 required arguments")
        val offsetVal = match self._compileExpression(offset) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(innerTySize), offsetVal) { Ok(v) => v, Err(e) => return qbeError(e) }

        val mem = match self._currentFn.block.buildAdd(sizeVal, ptrVal) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.addComment("...pointer_offset end")

        Ok(mem)
      }
      "pointer_load" => {
        self._currentFn.block.addComment("begin pointer_load...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_load' has 1 required argument")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_load' has 1 required argument")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("could not resolve T for Pointer<T>")
        val innerQbeType = match self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None) { Ok(v) => v, Err(e) => return Err(e) }

        val v = self._currentFn.block.buildLoad(innerQbeType, ptrVal)

        self._currentFn.block.addComment("...pointer_load end")

        Ok(v)
      }
      "pointer_copy_from" => {
        self._currentFn.block.addComment("begin pointer_copy_from...")

        val _ptr = if arguments[0] |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val ptr = if _ptr |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val ptrVal = match self._compileExpression(ptr) { Ok(v) => v, Err(e) => return Err(e) }

        val _other = if arguments[1] |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val other = if _other |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val otherVal = match self._compileExpression(other) { Ok(v) => v, Err(e) => return Err(e) }

        val _size = if arguments[2] |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val size = if _size |arg| arg else return unreachable("'pointer_copy_from' has 3 required arguments")
        val sizeArg = match self._compileExpression(size) { Ok(v) => v, Err(e) => return Err(e) }

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else return unreachable("could not resolve T for Pointer<T>")
        val innerTySize = match self._pointerSize(innerTy) { Ok(v) => v, Err(e) => return Err(e) }
        val sizeVal = match self._currentFn.block.buildMul(Value.Int(innerTySize), sizeArg) { Ok(v) => v, Err(e) => return qbeError(e) }

        self._currentFn.block.buildVoidCall(self._memcpy, [ptrVal, otherVal, sizeVal])

        self._currentFn.block.addComment("...pointer_copy_from end")

        Ok(Value.Ident("bogus", QbeType.F32))
      }
      "byte_from_int" => {
        self._currentFn.block.addComment("begin byte_from_int...")

        val _arg = if arguments[0] |arg| arg else return unreachable("'byte_from_int' has 1 required argument")
        val arg = if _arg |arg| arg else return unreachable("'byte_from_int' has 1 required argument")
        val argVal = match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) }

        self._currentFn.block.addComment("...byte_from_int end")

        Ok(argVal)
      }
      "byte_as_int" => {
        self._currentFn.block.addComment("begin byte_as_int...")

        val _arg = if arguments[0] |arg| arg else return unreachable("'byte_as_int' has 1 required argument")
        val arg = if _arg |arg| arg else return unreachable("'byte_as_int' has 1 required argument")
        val argVal = match self._compileExpression(arg) { Ok(v) => v, Err(e) => return Err(e) }

        self._currentFn.block.addComment("...byte_as_int end")

        Ok(argVal)
      }
      _ => unreachable("unsupported intrinsic '$intrinsicFnName'", fn.label.position)
    }
  }

  func _getOrCompileFunction(self, fn: Function): Result<QbeFunction, CompileError> {
    val fnName = self._fnName(fn)
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val fnVal = self._builder.buildFunction(name: fnName, returnType: returnTypeQbe)
    match self._compileFunc(fnVal, fn) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.addComment(match self._fnSignature(None, fn) { Ok(v) => v, Err(e) => return Err(e) })

    Ok(fnVal)
  }

  func _getOrCompileMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val isInstanceMethod = match fn.kind { FunctionKind.InstanceMethod => true, _ => false }
    if isInstanceMethod && fn.label.name == "toString" && fn.isGenerated return self._getOrCompileToStringMethod(selfType)
    if isInstanceMethod && fn.label.name == "eq" && fn.isGenerated return self._getOrCompileEqMethod(selfType)

    val _t = match self._getInstanceTypeForType(selfType) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val methodName = match selfTy {
      StructOrEnum.Struct(struct) => match self._methodFnName(struct, fn) { Ok(v) => v, Err(e) => return Err(e) }
      StructOrEnum.Enum => return todo("enum methods")
    }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val returnTypeQbe = match self._getQbeTypeForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
    val fnVal = self._builder.buildFunction(name: methodName, returnType: returnTypeQbe)

    if isInstanceMethod {
      val selfTyQbe = match self._getQbeTypeForTypeExpect(selfType, "unacceptable type for self") { Ok(v) => v, Err(e) => return Err(e) }
      fnVal.addParameter("self", selfTyQbe)
    }
    match self._compileFunc(fnVal, fn) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.addComment(match self._fnSignature(Some(selfTy), fn) { Ok(v) => v, Err(e) => return Err(e) })

    Ok(fnVal)
  }

  func _compileFunc(self, fnVal: QbeFunction, fn: Function): Result<Int, CompileError> {
    val prevFn = self._currentFn
    self._currentFn = fnVal

    var defaultValueParamIdx = 0
    var defaultValuesMaskParam: Value? = None
    var addMaskParam = false
    for param in fn.params {
      val paramTy = match self._getQbeTypeForTypeExpect(param.ty, "unacceptable type for param", Some(param.label.position)) { Ok(v) => v, Err(e) => return Err(e) }

      if param.defaultValue |defaultValueNode| {
        val paramLocal = fnVal.addParameter("${param.label.name}_", paramTy)
        addMaskParam = true
        val maskParam = Value.Ident("__default_params_mask__", QbeType.U32)

        val defaultValueFlag = 1 << defaultValueParamIdx
        defaultValueParamIdx += 1

        val labelUseDefaultValue = self._currentFn.block.addLabel("${param.label.name}_use_default")
        val labelUsePassedValue = self._currentFn.block.addLabel("${param.label.name}_use_passed")
        val labelCont = self._currentFn.block.addLabel("${param.label.name}_cont")

        val paramMaskVal = match self._currentFn.block.buildAnd(maskParam, Value.Int32(defaultValueFlag)) { Ok(v) => v, Err(e) => return qbeError(e) }
        val paramNeedsDefault = match self._currentFn.block.buildCompareEq(paramMaskVal, Value.Int32(defaultValueFlag)) { Ok(v) => v, Err(e) => return qbeError(e) }
        self._currentFn.block.buildJnz(paramNeedsDefault, labelUseDefaultValue, labelUsePassedValue)

        self._currentFn.block.registerLabel(labelUseDefaultValue)
        val res = match self._compileExpression(defaultValueNode) { Ok(v) => v, Err(e) => return Err(e) }
        self._currentFn.block.buildJmp(labelCont)

        self._currentFn.block.registerLabel(labelUsePassedValue)
        self._currentFn.block.buildJmp(labelCont)

        self._currentFn.block.registerLabel(labelCont)

        val phiCases = [(labelUseDefaultValue, res), (labelUsePassedValue, paramLocal)]
        match self._currentFn.block.buildPhi(phiCases, Some(param.label.name)) { Ok(v) => v, Err(e) => return qbeError(e) }
      } else {
        fnVal.addParameter(param.label.name, paramTy)
      }
    }
    if addMaskParam {
      fnVal.addParameter("__default_params_mask__", QbeType.U32)
    }

    var retVal: Value? = None
    for node, idx in fn.body {
      val res = match self._compileStatement(node) { Ok(v) => v, Err(e) => return Err(e) }
      if idx == fn.body.length - 1 && fn.returnType.kind != TypeKind.PrimitiveUnit {
        retVal = res
      }
    }
    fnVal.block.buildReturn(retVal)

    self._currentFn = prevFn

    Ok(0)
  }

  func _getOrCompileToStringMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val _t = match self._getInstanceTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val _p = match selfTy {
      StructOrEnum.Struct(struct) => {
        if struct == self._project.preludeIntStruct return self._getOrCompileIntToStringMethod()
        if struct == self._project.preludeFloatStruct return self._getOrCompileFloatToStringMethod()
        if struct == self._project.preludeStringStruct return self._getOrCompileStringToStringMethod()
        if struct == self._project.preludeBoolStruct return self._getOrCompileBoolToStringMethod()

        val _fn = struct.instanceMethods.find(m => m.label.name == "toString")
        val fn = if _fn |f| f else return unreachable("every struct has a toString method defined")

        (match self._methodFnName(struct, fn) { Ok(v) => v, Err(e) => return Err(e) }, fn)
      }
      StructOrEnum.Enum => return todo("enum methods")
    }
    // TODO: destructuring
    val methodName = _p[0]
    val fn = _p[1]
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated {
      return todo("_getOrCompileToStringMethod: generated functions")
    }

    self._getOrCompileMethod(ty, fn)
  }

  func _getOrCompileIntToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
    val intTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = match self._structTypeName(self._project.preludeIntStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Int#toString(self): String")
    val selfParam = fnVal.addParameter("self", intTypeQbe)

    val intFmtPtr = self._builder.buildGlobalString("%d")
    val sizeVal = match fnVal.block.buildCall(self._snprintf, [Value.Int(0), Value.Int(0), intFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }
    val mallocSizeVal = match fnVal.block.buildAdd(Value.Int(1), sizeVal) { Ok(v) => v, Err(e) => return qbeError(e) }

    val mem = match fnVal.block.buildCall(self._malloc, [mallocSizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }
    match fnVal.block.buildCall(self._snprintf, [mem, mallocSizeVal, intFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }

    val str = match self._constructString(mem, sizeVal) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(str))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileFloatToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
    val floatTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = match self._structTypeName(self._project.preludeFloatStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Float#toString(self): String")
    val selfParam = fnVal.addParameter("self", floatTypeQbe)

    val floatFmtPtr = self._builder.buildGlobalString("%g")
    val sizeVal = match fnVal.block.buildCall(self._snprintf, [Value.Int(0), Value.Int(0), floatFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }
    val mallocSizeVal = match fnVal.block.buildAdd(Value.Int(1), sizeVal) { Ok(v) => v, Err(e) => return qbeError(e) }

    val mem = match fnVal.block.buildCall(self._malloc, [mallocSizeVal], Some("mem")) { Ok(v) => v, Err(e) => return qbeError(e) }
    match fnVal.block.buildCall(self._snprintf, [mem, mallocSizeVal, floatFmtPtr, selfParam]) { Ok(v) => v, Err(e) => return qbeError(e) }

    val str = match self._constructString(mem, sizeVal) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(str))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileBoolToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }
    val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = match self._structTypeName(self._project.preludeBoolStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Bool#toString(self): String")
    val selfParam = fnVal.addParameter("self", boolTypeQbe)

    val labelIfTrue = fnVal.block.addLabel("if_true")
    val labelIfFalse = fnVal.block.addLabel("if_false")
    fnVal.block.buildJnz(selfParam, labelIfTrue, labelIfFalse)

    fnVal.block.registerLabel(labelIfTrue)
    val trueStrData = self._builder.buildGlobalString("true")
    val trueStr = match self._constructString(trueStrData, Value.Int(4)) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(trueStr))

    fnVal.block.registerLabel(labelIfFalse)
    val falseStrData = self._builder.buildGlobalString("false")
    val falseStr = match self._constructString(falseStrData, Value.Int(5)) { Ok(v) => v, Err(e) => return Err(e) }
    fnVal.block.buildReturn(Some(falseStr))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileStringToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

    val typeName = match self._structTypeName(self._project.preludeStringStruct) { Ok(v) => v, Err(e) => return Err(e) }
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("String#toString(self): String")
    val selfParam = fnVal.addParameter("self", stringTypeQbe)
    fnVal.block.buildReturn(Some(selfParam))

    match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileEqMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val _t = match self._getInstanceTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    // TODO: destructuring
    val selfTy = _t[0]
    val _typeArgs = _t[1]

    val _p = match selfTy {
      StructOrEnum.Struct(struct) => {
        val boolTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

        // TODO: surely there's a cleaner way to represent these built-in eq methods
        if struct == self._project.preludeIntStruct {
          val intTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

          val methodName = "Int..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Int#eq(self, other: Int): Bool")
          val selfParam = fnVal.addParameter("self", intTypeQbe)
          val otherParam = fnVal.addParameter("other", intTypeQbe)
          val res = match self._currentFn.block.buildCompareEq(selfParam, otherParam) { Ok(v) => v, Err(e) => return qbeError(e) }
          fnVal.block.buildReturn(Some(res))

          match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeFloatStruct {
          val floatTypeQbe = match self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist") { Ok(v) => v, Err(e) => return Err(e) }

          val methodName = "Float..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Float#eq(self, other: Float): Bool")
          val selfParam = fnVal.addParameter("self", floatTypeQbe)
          val otherParam = fnVal.addParameter("other", floatTypeQbe)
          val res = match self._currentFn.block.buildCompareEq(selfParam, otherParam) { Ok(v) => v, Err(e) => return qbeError(e) }
          fnVal.block.buildReturn(Some(res))

          match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeBoolStruct {
          val methodName = "Bool..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Bool#eq(self, other: Bool): Bool")
          val selfParam = fnVal.addParameter("self", boolTypeQbe)
          val otherParam = fnVal.addParameter("other", boolTypeQbe)
          val res = match self._currentFn.block.buildCompareEq(selfParam, otherParam) { Ok(v) => v, Err(e) => return qbeError(e) }
          fnVal.block.buildReturn(Some(res))

          match fnVal.block.verify() { Ok(v) => v, Err(e) => return qbeError(e) }

          self._currentFn = prevFn

          return Ok(fnVal)
        }

        val _fn = struct.instanceMethods.find(m => m.label.name == "eq")
        val fn = if _fn |f| f else return unreachable("every struct has a eq method defined")

        (match self._methodFnName(struct, fn) { Ok(v) => v, Err(e) => return Err(e) }, fn)
      }
      StructOrEnum.Enum => return todo("enum methods")
    }
    // TODO: destructuring
    val methodName = _p[0]
    val fn = _p[1]
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated {
      return todo("_getOrCompileEqMethod: generated functions")
    }

    self._getOrCompileMethod(ty, fn)
  }

  func _buildStackAllocForQbeType(self, ty: QbeType, name: String? = None): Value {
    match ty {
      QbeType.U8 => self._currentFn.block.buildAlloc8(1, name)      // 'b'
      QbeType.U16 => self._currentFn.block.buildAlloc4(1, name)     // 'h'
      QbeType.U32 => self._currentFn.block.buildAlloc4(1, name)     // 'w'
      QbeType.U64 => self._currentFn.block.buildAlloc8(1, name)     // 'l'
      QbeType.Pointer => self._currentFn.block.buildAlloc8(1, name) // 'l'
      QbeType.F32 => self._currentFn.block.buildAlloc4(1, name)     // 's'
      QbeType.F64 => self._currentFn.block.buildAlloc8(1, name)     // 'd'
    }
  }

  func _emitOptValueIsSomeVariant(self, exprVal: Value, negate = false): Result<Value, CompileError> {
    val variantIdx = self._currentFn.block.buildLoadW(exprVal)
    val optionSomeVariantIdx = if self._project.preludeOptionEnum.variants.findIndex(v => v.label.name == "Some") |_p| _p[1] else return unreachable("Option.Some must exist")
    if negate {
      val res = match self._currentFn.block.buildCompareNeq(variantIdx, Value.Int32(optionSomeVariantIdx)) { Ok(v) => v, Err(e) => return qbeError(e) }
      Ok(res)
    } else {
      val res = match self._currentFn.block.buildCompareEq(variantIdx, Value.Int32(optionSomeVariantIdx)) { Ok(v) => v, Err(e) => return qbeError(e) }
      Ok(res)
    }
  }

  func _emitOptValueGetValue(self, ty: QbeType, exprVal: Value): Result<Value, CompileError> {
    val valueSlot = match self._currentFn.block.buildAdd(Value.Int(QbeType.U32.size()), exprVal) { Ok(v) => v, Err(e) => return qbeError(e) }
    val optSomeValue = self._currentFn.block.buildLoad(ty, valueSlot)

    Ok(optSomeValue)
  }

  func _addResolvedGenericsLayerForInstanceMethod(self, ty: Type, methodName: String, position: Position, resolvedGenerics: Map<String, Type> = {}): Result<Type, CompileError> {
    val _t = match self._getInstanceTypeForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
    val _p = match _t[0] {
      StructOrEnum.Struct(struct) => {
        val template = Type(kind: TypeKind.Instance(_t[0], struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val inst = Type(kind: TypeKind.Instance(_t[0], _t[1]))

        (template, inst)
      }
      StructOrEnum.Enum => return todo("enum methods")
    }
    // TODO: destructuring
    val template = _p[0]
    val selfInstanceType = _p[1]
    for _p in selfInstanceType.extractGenerics(template) {
      resolvedGenerics[_p[0]] = _p[1]
    }
    // TODO: destructuring
    val layerName = match _t[0] {
      StructOrEnum.Struct(struct) => "${struct.label.name}.$methodName"
      StructOrEnum.Enum => return todo("enum methods")
    }
    match self._resolvedGenerics.addLayer(layerName, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: layerName, message: e))) }

    Ok(selfInstanceType)
  }

  func _getInstanceTypeForType(self, ty: Type): Result<(StructOrEnum, Type[]), CompileError> {
    match ty.kind {
      TypeKind.Any => unreachable("getInstanceTypeForType: Any")
      TypeKind.PrimitiveUnit => unreachable("getInstanceTypeForType: Unit")
      TypeKind.PrimitiveInt => Ok((StructOrEnum.Struct(self._project.preludeIntStruct), []))
      TypeKind.PrimitiveFloat => Ok((StructOrEnum.Struct(self._project.preludeFloatStruct), []))
      TypeKind.PrimitiveBool => Ok((StructOrEnum.Struct(self._project.preludeBoolStruct), []))
      TypeKind.PrimitiveString => Ok((StructOrEnum.Struct(self._project.preludeStringStruct), []))
      TypeKind.Never => unreachable("getInstanceTypeForType: Never")
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getInstanceTypeForType(ty) else unreachable("failed to resolve generic: '$name'")
      }
      TypeKind.Instance(structOrEnum, typeParams) => Ok((structOrEnum, typeParams))
      TypeKind.Tuple(types) => todo("getInstanceTypeForType: Tuple${types.length}")
      TypeKind.Func(_paramTypes, _returnType) => todo("getInstanceTypeForType: Func")
      TypeKind.Type(structOrEnum) => Ok((structOrEnum, []))
      TypeKind.Hole => unreachable("getInstanceTypeForType: Hole")
    }
  }

  func _getReprForType(self, ty: Type): Result<String, CompileError> {
    match ty.kind {
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getReprForType(ty) else unreachable("failed to resolve generic repr: '$name'")
      }
      TypeKind.Instance(structOrEnum, typeParams) => {
        val n = match structOrEnum {
          StructOrEnum.Struct(struct) => struct.label.name
          StructOrEnum.Enum(_enum) => _enum.label.name
        }
        if !typeParams.isEmpty() {
          val params: String[] = []
          for p in typeParams {
            params.push(match self._getReprForType(p) { Ok(v) => v, Err(e) => return Err(e) })
          }

          Ok("$n<${params.join(", ")}>")
        } else {
          Ok(n)
        }
      }
      TypeKind.Tuple(types) => todo("_getReprForType: Tuple${types.length}")
      TypeKind.Func(_paramTypes, _returnType) => todo("_getReprForType: Func")
      _ => Ok(ty.repr())
    }
  }

  func _getNameForType(self, ty: Type): Result<String, CompileError> {
    match ty.kind {
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getNameForType(ty) else unreachable("failed to resolve generic repr: '$name'")
      }
      TypeKind.Instance(structOrEnum, typeParams) => {
        val n = match structOrEnum {
          StructOrEnum.Struct(struct) => struct.label.name
          StructOrEnum.Enum(_enum) => _enum.label.name
        }
        if !typeParams.isEmpty() {
          val params: String[] = []
          for p in typeParams {
            params.push(match self._getNameForType(p) { Ok(v) => v, Err(e) => return Err(e) })
          }

          Ok("$n.${params.join(".")}")
        } else {
          Ok(n)
        }
      }
      TypeKind.Tuple(types) => todo("_getNameForType: Tuple${types.length}")
      TypeKind.Func(_paramTypes, _returnType) => todo("_getNameForType: Func")
      _ => Ok(ty.repr())
    }
  }

  // Each module's root code is wrapped in a specially-named function; this function name
  // starts with two dots, which is not possible in ordinary Abra source code and will
  // thus introduce no conflicts (qbe doesn't care about function name rules).
  func _moduleWrapperFnName(self, module: TypedModule): String = "..module_${module.id}"

  func _structTypeName(self, struct: Struct): Result<String, CompileError> {
    val base = ".${struct.moduleId}.${struct.label.name}"
    if !struct.typeParams.isEmpty() {
      val parts: String[] = []
      for name in struct.typeParams {
        val repr = if self._resolvedGenerics.resolveGeneric(name) |ty| {
          val r = match self._getNameForType(ty) { Ok(v) => v, Err(e) => return Err(e) }
          r
        } else {
          return unreachable("could not resolve '$name'")
        }
        parts.push(repr)
      }
      Ok("$base.${parts.join(".")}")
    } else {
      Ok(base)
    }
  }

  func _structInitializerFnName(self, struct: Struct): Result<String, CompileError> {
    val structTypeName = match self._structTypeName(struct) { Ok(v) => v, Err(e) => return Err(e) }
    Ok("$structTypeName.init")
  }

  func _enumTypeName(self, enum_: Enum): String = ".${enum_.moduleId}.${enum_.label.name}"
  func _enumVariantFnName(self, enum_: Enum, variant: TypedEnumVariant): String = "${self._enumTypeName(enum_)}.${variant.label.name}"

  func _fnName(self, fn: Function): String = ".${fn.label.name}"
  func _methodFnName(self, struct: Struct, fn: Function): Result<String, CompileError> {
    val typeName = match self._structTypeName(struct) { Ok(v) => v, Err(e) => return Err(e) }
    val sep = match fn.kind {
      FunctionKind.InstanceMethod => ".."
      _ => "."
    }
    Ok("${typeName}${sep}${fn.label.name}")
  }

  func _fnSignature(self, structOrEnum: StructOrEnum?, fn: Function): Result<String, CompileError> {
    val parts: String[] = []
    match structOrEnum {
      StructOrEnum.Struct(struct) => {
        parts.push(struct.label.name)
        if !struct.typeParams.isEmpty() {
          parts.push("<")
          for name, idx in struct.typeParams {
            val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else return unreachable("_fnSignature:struct (${struct.label.name}, ${fn.label.name}), could not resolve generic '$name'")
            parts.push(resolvedGeneric.repr())

            if idx != struct.typeParams.length - 1 { parts.push(", ") }
          }
          parts.push(">")
        }
        parts.push(match fn.kind { FunctionKind.InstanceMethod => "#", _ => "." })
      }
      StructOrEnum.Enum => return todo("enum methods")
      None => {}
    }
    parts.push(fn.label.name)
    if !fn.typeParams.isEmpty() {
      parts.push("<")
      for _p, idx in fn.typeParams {
        // TODO: destructuring
        val name = _p[1].name
        val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else return unreachable("_fnSignature:fn, could not resolve generic '$name'")
        parts.push(resolvedGeneric.repr())

        if idx != fn.typeParams.length - 1 { parts.push(", ") }
      }
      parts.push(">")
    }
    parts.push("(")

    val args: String[] = []
    if fn.kind == FunctionKind.InstanceMethod args.push("self")
    for param in fn.params {
      val paramTyRepr = match self._getReprForType(param.ty) { Ok(v) => v, Err(e) => return Err(e) }
      val defaultExpr = if param.defaultValue " = ..." else ""
      args.push("${param.label.name}: $paramTyRepr$defaultExpr")
    }
    parts.push(args.join(", "))
    parts.push(")")

    if fn.returnType.kind != TypeKind.PrimitiveUnit {
      val returnTyRepr = match self._getReprForType(fn.returnType) { Ok(v) => v, Err(e) => return Err(e) }
      parts.push(": $returnTyRepr")
    }

    Ok(parts.join())
  }

  func _structSignature(self, struct: Struct): Result<String[], CompileError> {
    val firstLine = ["type ${struct.label.name}"]
    if !struct.typeParams.isEmpty() {
      firstLine.push("<")
      for name, idx in struct.typeParams {
        val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else return unreachable("could not resolve generic '$name'")
        firstLine.push("$name = ${resolvedGeneric.repr()}")

        if idx != struct.typeParams.length - 1 { firstLine.push(", ") }
      }
      firstLine.push(">")
    }
    val parts = ["${firstLine.join()} {"]
    for field in struct.fields {
      parts.push("  ${field.name.name}: ${field.ty.repr()}")
    }
    parts.push("}")

    Ok(parts)
  }

  func _enumVariantSignature(self, enum_: Enum, variant: TypedEnumVariant): Result<String, CompileError> {
    val parts: String[] = [enum_.label.name, ".", variant.label.name]
    match variant.kind {
      EnumVariantKind.Container(fields) => {
        parts.push("(")
        for field, idx in fields {
          val fieldTyRepr = match self._getReprForType(field.ty) { Ok(v) => v, Err(e) => return Err(e) }
          parts.push("${field.name.name}: $fieldTyRepr")
          if idx != fields.length - 1 {
            parts.push(", ")
          }
        }
        parts.push(")")
      }
      _ => {}
    }

    Ok(parts.join())
  }

  func _typeIsInt(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveInt || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeIntStruct), [])
  func _typeIsFloat(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveFloat || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeFloatStruct), [])
  func _typeIsBool(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveBool || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeBoolStruct), [])
  func _typeIsString(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveString || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeStringStruct), [])

  // TODO: this is copied from Typechecker
  func _typeIsOption(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Enum(enum_) => {
            if enum_ != self._project.preludeOptionEnum return None
            if generics[0] |innerTy| {
              Some(innerTy)
            } else {
              None
            }
          }
          _ => None
        }
      }
      _ => None
    }
  }
}

func todo<V>(message: String, position = Position(line: 0, col: 0)): Result<V, CompileError> = Err(CompileError(position: position, kind: CompileErrorKind.NotYetImplemented(message)))
func unreachable<V>(message: String, position = Position(line: 0, col: 0)): Result<V, CompileError> = Err(CompileError(position: position, kind: CompileErrorKind.Unreachable(message)))
