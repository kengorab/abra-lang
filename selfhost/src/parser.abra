import Token, TokenKind, Position from "./lexer"

export type ParsedModule {
  nodes: AstNode[]
}

export type AstNode {
  token: Token
  kind: AstNodeKind
}

export enum LiteralAstNode {
  Int(value: Int)
  Float(value: Float)
  Bool(value: Bool)
  String(value: String)
}

enum UnaryOp { Minus, Negate }

type UnaryAstNode {
  op: UnaryOp
  expr: AstNode
}

enum BinaryOp {
  Add
  Sub
  Mul
  Div
  Mod
}

type BinaryAstNode {
  left: AstNode
  op: BinaryOp
  right: AstNode
}

export enum IdentifierKind {
  Named(name: String)
  Self
  None_
  Discard
}

export type Label {
  name: String
  position: Position
}

type AccessorAstNode {
  root: AstNode
  path: (Token, Label)[]
}

type InvocationArgument {
  label: Label?
  value: AstNode
}

type InvocationAstNode {
  invokee: AstNode
  arguments: InvocationArgument[]
}

export enum IndexingMode {
  Single(expr: AstNode)
  Range(start: AstNode?, end: AstNode?)
}

export enum TypeIdentifier {
  Normal(name: Label, typeArguments: TypeIdentifier[]?)
  Array(inner: TypeIdentifier)
  Option(inner: TypeIdentifier)
  Tuple(types: TypeIdentifier[])
  Function(args: TypeIdentifier[], ret: TypeIdentifier)
}

type BindingDeclarationNode {
  ident: Label
  typeAnnotation: TypeIdentifier?
  expr: AstNode?
}

type FunctionParam {
  label: Label
  typeAnnotation: TypeIdentifier? = None
  defaultValue: AstNode? = None
}

type LambdaNode {
  params: FunctionParam[]
  body: AstNode[]
}

type FunctionDeclarationNode {
  name: Label
  params: FunctionParam[]
  returnTypeAnnotation: TypeIdentifier?
  body: AstNode[]
}

export enum AstNodeKind {
  Literal(value: LiteralAstNode)
  Unary(value: UnaryAstNode)
  Binary(value: BinaryAstNode)
  Grouped(inner: AstNode)
  Identifier(kind: IdentifierKind)
  Accessor(value: AccessorAstNode)
  Invocation(value: InvocationAstNode)
  Array(items: AstNode[])
  Set(items: AstNode[])
  Map(items: (AstNode, AstNode)[])
  Tuple(items: AstNode[])
  Indexing(expr: AstNode, index: IndexingMode)
  Lambda(value: LambdaNode)
  BindingDeclaration(value: BindingDeclarationNode)
  FunctionDeclaration(value: FunctionDeclarationNode)
}

enum ParseErrorKind {
  UnexpectedToken(token: Token)
  ExpectedToken(expected: TokenKind[], received: TokenKind)
  UnexpectedEof
  NotYetImplemented
  Unreachable
}

type ParseError {
  position: Position
  kind: ParseErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      ParseErrorKind.UnexpectedToken(token) => {
        lines.push("Unexpected token '${token.kind.repr()}':")
        lines.push(self._getCursorLine(self.position, contents))
      }
      ParseErrorKind.ExpectedToken(expected, received) => {

        if expected.length == 1 {
          lines.push("Unexpected token '${received.repr()}', expected '${expected[0]?.repr()}':")
        } else {
          val reprs = expected.map(kind => "'${kind.repr()}'").join(", ")
          lines.push("Unexpected token '${received.repr()}', expected one of $reprs:")
        }
        lines.push(self._getCursorLine(self.position, contents))
      }
      ParseErrorKind.UnexpectedEof => {
        lines.push("Unexpected end of file:")
        lines.push(self._getCursorLine(self.position, contents))
      }
      ParseErrorKind.NotYetImplemented => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
      }
      ParseErrorKind.Unreachable => {
        lines.push("Critical error: reached unreachable location in code!")
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

export type Parser {
  _tokens: Token[]
  _cursor: Int = 0

  func parse(tokens: Token[]): Result<ParsedModule, ParseError> {
    val parser = Parser(_tokens: tokens)

    val nodes: AstNode[] = []

    while parser._peek() |token| {
      match parser._parseStatement() {
        Result.Ok(node) => nodes.push(node)
        Result.Err(e) => return Result.Err(e)
      }
    }

    Result.Ok(ParsedModule(nodes: nodes))
  }

  func _peek(self, ahead = 0): Token? = self._tokens[self._cursor + ahead]

  func _expectPeek(self, ahead = 0): Result<Token, ParseError> {
    if self._peek(ahead) |token| {
      Result.Ok(token)
    } else {
      val position = if self._tokens[self._cursor - 1] |lastToken| {
        lastToken.position
      } else {
        Position(line: 1, col: 0)
      }
      // TODO: This isn't exactly correct (it should point just past the end of the token, and this would only work if
      // the token was of length 1), but it's close enough for now
      position.col += 1
      Result.Err(ParseError(position: position, kind: ParseErrorKind.UnexpectedEof))
    }
  }

  func _advance(self) {
    self._cursor += 1
  }

  func _expectNext(self): Result<Token, ParseError> {
    val tokenRes = self._expectPeek()
    self._advance()
    tokenRes
  }

  func _expectNextLabel(self): Result<Label, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match token.kind {
      TokenKind.Ident(name) => Result.Ok(Label(name: name, position: token.position))
      _ => Result.Err(ParseError(position: token.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Ident("")], token.kind)))
    }
  }

  func _parseStatement(self): Result<AstNode, ParseError> {
    val token = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match token.kind {
      TokenKind.Val => self._parseBindingDeclaration(mutable: false)
      TokenKind.Var => self._parseBindingDeclaration(mutable: true)
      TokenKind.Func => self._parseFunctionDeclaration()
      _ => self._parseExpression()
    }
  }

  func _parseBindingDeclaration(self, mutable: Bool): Result<AstNode, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val label = match self._expectNextLabel() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    if self._cursor >= self._tokens.length {
      val node = BindingDeclarationNode(ident: label, typeAnnotation: None, expr: None)
      return Result.Ok(AstNode(token: token, kind: AstNodeKind.BindingDeclaration(node)))
    }

    var colonToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val typeAnnotation = if colonToken.kind == TokenKind.Colon {
      self._advance() // consume ':' token
      val a = match self._parseTypeIdentifier() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      a
    } else {
      None
    }

    if self._cursor >= self._tokens.length {
      val node = BindingDeclarationNode(ident: label, typeAnnotation: typeAnnotation, expr: None)
      return Result.Ok(AstNode(token: token, kind: AstNodeKind.BindingDeclaration(node)))
    }

    val eqToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val expr = if eqToken.kind == TokenKind.Eq {
      self._advance() // consume '=' token
      val e = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      e
    } else {
      None
    }

    val node = BindingDeclarationNode(ident: label, typeAnnotation: typeAnnotation, expr: expr)
    Result.Ok(AstNode(token: token, kind: AstNodeKind.BindingDeclaration(node)))
  }

  func _parseFunctionDeclaration(self): Result<AstNode, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val label = match self._expectNextLabel() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    var nextToken = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match nextToken.kind {
      TokenKind.LParen => {}
      _ => return Result.Err(ParseError(position: nextToken.position, kind: ParseErrorKind.ExpectedToken([TokenKind.LParen(true)], nextToken.kind)))
    }

    val params = match self._parseFunctionParameters(allowSelf: true) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val returnTypeAnnotation = if nextToken.kind == TokenKind.Colon {
      self._advance() // consume ':' token

      val ann = match self._parseTypeIdentifier() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ann
    } else {
      None
    }

    nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val body = if nextToken.kind == TokenKind.Eq {
      self._advance() // consume '=' token
      val expr = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      [expr]
    } else {
      match self._parseBlockOrSingleExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    }

    val node = FunctionDeclarationNode(name: label, params: params, returnTypeAnnotation: returnTypeAnnotation, body: body)
    Result.Ok(AstNode(token: token, kind: AstNodeKind.FunctionDeclaration(node)))
  }

  func _parseTypeIdentifier(self): Result<TypeIdentifier, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    var typeIdent =  match token.kind {
      TokenKind.Ident(name) => {
        val label = Label(name: name, position: token.position)

        // TODO: This is kind of gross, I should be able to do `if self._peek()?.kind == TokenKind.LT { ... }` here
        val typeArguments = if self._peek()?.kind |kind| {
          if kind == TokenKind.LT {
            self._advance() // consume '<' token
            val nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            if nextToken.kind == TokenKind.GT {
              return Result.Err(ParseError(position: nextToken.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Ident("")], nextToken.kind)))
            }
            val args = self._commaSeparated(TokenKind.GT, () => self._parseTypeIdentifier())
            val a = match args { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            a
          } else {
            None
          }
        } else {
          None
        }

        TypeIdentifier.Normal(name: label, typeArguments: typeArguments)
      }
      TokenKind.LParen => {
        val a = self._commaSeparated(TokenKind.RParen, () => self._parseTypeIdentifier())
        val args = match a { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

        val nextTokenIsArrow = if self._peek()?.kind |kind| kind == TokenKind.Arrow else false
        if nextTokenIsArrow {
          self._advance() // consume '=>' token
          val retType = match self._parseTypeIdentifier() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          TypeIdentifier.Function(args, retType)
        } else if args[0] |first| {
          // TODO: There should be a more ergonomic way of writing this... maybe like
          // `if args.length == 1 && args[0] |first| { ... }` ?
          if args.length == 1 {
            first
          } else {
            TypeIdentifier.Tuple(args)
          }
        } else {
          val nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          return Result.Err(ParseError(position: nextToken.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Arrow], nextToken.kind)))
        }
      }
      _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Ident("")], token.kind)))
    }

    while self._peek() |nextToken| {
      match nextToken.kind {
        TokenKind.LBrack(preceedingNewline) => if preceedingNewline {
          break
        } else {
          self._advance() // consume '[' token
          val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          if token.kind != TokenKind.RBrack {
            return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.ExpectedToken([TokenKind.RBrack], token.kind)))
          }

          typeIdent = TypeIdentifier.Array(inner: typeIdent)
        }
        TokenKind.Question => {
          self._advance() // consume '?' token
          typeIdent = TypeIdentifier.Option(inner: typeIdent)
        }
        _ => break
      }
    }

    Result.Ok(typeIdent)
  }

  func _parseFunctionParameters(self, allowSelf: Bool): Result<FunctionParam[], ParseError> {
    self._commaSeparated(TokenKind.RParen, paramIdx => {
      val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val label = match token.kind {
        TokenKind.Ident(name) => Label(name: name, position: token.position)
        TokenKind.Self => if allowSelf && paramIdx == 0 {
          Label(name: "self", position: token.position)
        } else {
          return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Ident("")], token.kind)))
        }
        _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Ident("")], token.kind)))
      }

      var nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val typeAnnotation = if nextToken.kind == TokenKind.Colon {
        self._advance() // consume ':' token
        val ann = match self._parseTypeIdentifier() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        ann
      } else {
        None
      }

      nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val defaultValue = if nextToken.kind == TokenKind.Eq {
        self._advance() // consume '=' token
        val e = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        e
      } else {
        None
      }

      val param = FunctionParam(label: label, typeAnnotation: typeAnnotation, defaultValue: defaultValue)
      Result.Ok(param)
    })
  }

  func _parseBlockOrSingleExpression(self): Result<AstNode[], ParseError> {
    val token = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val nodes = if token.kind == TokenKind.LBrace {
      self._advance() // consume '{' token
      val nodes: AstNode[] = []
      while true {
        val nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if nextToken.kind == TokenKind.RBrace {
          self._advance() // consume '}' token
          break
        }

        val node = match self._parseStatement() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        nodes.push(node)
      }
      nodes
    } else {
      val node = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      [node]
    }

    Result.Ok(nodes)
  }

  func _parseExpression(self): Result<AstNode, ParseError> {
    self._parsePrecedence(prec: 0)
  }

  func _parsePrecedence(self, prec: Int): Result<AstNode, ParseError> {
    val prefixToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    var leftNode = match self._prefixRule(prefixToken) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    while self._peek() |nextToken| {
      val nextPrec = Precedence.forToken(nextToken)
      if prec < nextPrec {
        leftNode = match self._infixRule(leftNode) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      } else {
        break
      }
    }

    Result.Ok(leftNode)
  }

  func _prefixRule(self, token: Token): Result<AstNode, ParseError> {
    match token.kind {
      TokenKind.Int => self._parseLiteral()
      TokenKind.Float => self._parseLiteral()
      TokenKind.Bool => self._parseLiteral()
      TokenKind.String => self._parseLiteral()
      TokenKind.LParen => self._parseGroupedOrTupleOrLambda()
      TokenKind.Minus => self._parseUnary()
      TokenKind.Bang => self._parseUnary()
      TokenKind.Ident(name) => self._parseIdentifier(kind: if name == "_" IdentifierKind.Discard else IdentifierKind.Named(name))
      TokenKind.None_ => self._parseIdentifier(kind: IdentifierKind.None_)
      TokenKind.Self => self._parseIdentifier(kind: IdentifierKind.Self)
      TokenKind.LBrack => self._parseArray()
      TokenKind.HashBrace => self._parseSet()
      TokenKind.LBrace => self._parseMap()
      _ => Result.Err(ParseError(position: token.position, kind: ParseErrorKind.UnexpectedToken(token)))
    }
  }

  func _infixRule(self, left: AstNode): Result<AstNode, ParseError> {
    val infixToken = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match infixToken.kind {
      TokenKind.Plus => self._parseBinary(infixToken, left)
      TokenKind.Minus => self._parseBinary(infixToken, left)
      TokenKind.Star => self._parseBinary(infixToken, left)
      TokenKind.Slash => self._parseBinary(infixToken, left)
      TokenKind.Percent => self._parseBinary(infixToken, left)
      TokenKind.Dot => self._parseAccessor(infixToken, left)
      TokenKind.QuestionDot => self._parseAccessor(infixToken, left)
      TokenKind.LParen => self._parseInvocation(infixToken, left)
      TokenKind.LBrack => self._parseIndexing(infixToken, left)
      TokenKind.Arrow => self._parseLambda(infixToken, left)
      _ => return Result.Err(ParseError(position: infixToken.position, kind: ParseErrorKind.UnexpectedToken(infixToken)))
    }
  }

  func _parseLiteral(self): Result<AstNode, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val literal = match token.kind {
      TokenKind.Int(value) => LiteralAstNode.Int(value)
      TokenKind.Float(value) => LiteralAstNode.Float(value)
      TokenKind.Bool(value) => LiteralAstNode.Bool(value)
      TokenKind.String(value) => LiteralAstNode.String(value)
      TokenKind.StringInterpolation => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.NotYetImplemented))
      _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.UnexpectedToken(token)))
    }

    Result.Ok(AstNode(token: token, kind: AstNodeKind.Literal(literal)))
  }

  func _parseUnary(self): Result<AstNode, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val op = match token.kind {
      TokenKind.Minus => UnaryOp.Minus
      TokenKind.Bang => UnaryOp.Negate
      _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.NotYetImplemented))
    }

    val expr = match self._parsePrecedence(prec: Precedence.unary()) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    Result.Ok(AstNode(token: token, kind: AstNodeKind.Unary(UnaryAstNode(op: op, expr: expr))))
  }

  func _parseGroupedOrTupleOrLambda(self): Result<AstNode, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    // If the next token is ')' then we must be parsing a no-args lambda
    match nextToken.kind {
      TokenKind.RParen => {
        self._advance() // consume ')' token
        val arrowToken = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if arrowToken.kind != TokenKind.Arrow {
          return Result.Err(ParseError(position: arrowToken.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Arrow], arrowToken.kind)))
        }

        val body = match self._parseBlockOrSingleExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

        return Result.Ok(AstNode(token: arrowToken, kind: AstNodeKind.Lambda(LambdaNode(params: [], body: body))))
      }
      TokenKind.Ident => {
        val nextToken = match self._expectPeek(ahead: 1) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if nextToken.kind == TokenKind.Colon || nextToken.kind == TokenKind.Eq {
          val params = match self._parseFunctionParameters(allowSelf: false) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

          val arrowToken = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          if arrowToken.kind != TokenKind.Arrow {
            return Result.Err(ParseError(position: arrowToken.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Arrow], arrowToken.kind)))
          }

          val body = match self._parseBlockOrSingleExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

          return Result.Ok(AstNode(token: arrowToken, kind: AstNodeKind.Lambda(LambdaNode(params: params, body: body))))
        }
      }
      _ => {}
    }

    val exprs = match self._commaSeparated(TokenKind.RParen, () => self._parseExpression()) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val nodeKind = if exprs.length == 1 {
      // TODO: Again, there needs to be a more ergonomic way of doing this. `if exprs.length == 1 && exprs[0] |inner| { ... }` maybe? or even just `exprs[0].!` to force-unwrap
      if exprs[0] |inner| {
        AstNodeKind.Grouped(inner: inner)
      } else {
        return unreachable()
      }
    } else {
      AstNodeKind.Tuple(items: exprs)
    }
    Result.Ok(AstNode(token: token, kind: nodeKind))
  }

  func _parseIdentifier(self, kind: IdentifierKind): Result<AstNode, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(AstNode(token: token, kind: AstNodeKind.Identifier(kind)))
  }

  func _parseArray(self): Result<AstNode, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val itemsRes = self._commaSeparated(TokenKind.RBrack, () => {
      self._parseExpression()
    })
    val items = match itemsRes { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(AstNode(token: token, kind: AstNodeKind.Array(items)))
  }

  func _parseSet(self): Result<AstNode, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val itemsRes = self._commaSeparated(TokenKind.RBrace, () => {
      self._parseExpression()
    })
    val items = match itemsRes { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(AstNode(token: token, kind: AstNodeKind.Set(items)))
  }

  func _parseMap(self): Result<AstNode, ParseError> {
    val token = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val itemsRes = self._commaSeparated(TokenKind.RBrace, () => {
      val keyToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val keyRes = match keyToken.kind {
        TokenKind.String => self._parseExpression()
        TokenKind.Ident => self._parseExpression()
        TokenKind.LParen => {
          self._advance() // consume '(' token
          val key = self._parseExpression()
          val nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          if nextToken.kind != TokenKind.RParen {
            return Result.Err(ParseError(position: nextToken.position, kind: ParseErrorKind.ExpectedToken([TokenKind.RParen], nextToken.kind)))
          }
          self._advance() // consume ')' token
          key
        }
        _ => {
          return Result.Err(ParseError(position: keyToken.position, kind: ParseErrorKind.ExpectedToken([TokenKind.String(""), TokenKind.Ident(""), TokenKind.LParen(false)], keyToken.kind)))
        }
      }
      val key = match keyRes { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      val nextToken = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if nextToken.kind != TokenKind.Colon {
        return Result.Err(ParseError(position: nextToken.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Colon], nextToken.kind)))
      }

      val value = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      Result.Ok((key, value))
    })
    val items = match itemsRes { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(AstNode(token: token, kind: AstNodeKind.Map(items)))
  }

  func _parseBinary(self, token: Token, left: AstNode): Result<AstNode, ParseError> {
    val prec = Precedence.forToken(token)
    val op = match token.kind {
      TokenKind.Plus => BinaryOp.Add
      TokenKind.Minus => BinaryOp.Sub
      TokenKind.Star => BinaryOp.Mul
      TokenKind.Slash => BinaryOp.Div
      TokenKind.Percent => BinaryOp.Mod
      _ => return todo(token.position)
    }

    val right = match self._parsePrecedence(prec: prec) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    Result.Ok(AstNode(token: token, kind: AstNodeKind.Binary(BinaryAstNode(left: left, op: op, right: right))))
  }

  func _parseAccessor(self, token: Token, left: AstNode): Result<AstNode, ParseError> {
    val label = match self._expectNextLabel() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val node = match left.kind {
      AstNodeKind.Accessor(accessorNode) => accessorNode
      _ => AccessorAstNode(root: left, path: [])
    }
    node.path.push((token, label))
    Result.Ok(AstNode(token: token, kind: AstNodeKind.Accessor(node)))
  }

  func _commaSeparated<T>(self, end: TokenKind, fn: (Int) => Result<T, ParseError>): Result<T[], ParseError> {
    val items: T[] = []

    var endExpected = false
    var idx = 0
    while true {
      val nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if nextToken.kind == end {
        self._advance() // consume end token before exiting
        break
      } else if endExpected {
        val kind = ParseErrorKind.ExpectedToken(expected: [TokenKind.Comma, end], received: nextToken.kind)
        return Result.Err(ParseError(position: nextToken.position, kind: kind))
      }

      val item = match fn(idx) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      items.push(item)

      val peekToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if peekToken.kind == TokenKind.Comma {
        self._advance() // consume ',' token
      } else {
        endExpected = true
      }

      idx += 1
    }

    Result.Ok(items)
  }

  func _parseInvocationArguments(self): Result<InvocationArgument[], ParseError> {
    val argsRes = self._commaSeparated(TokenKind.RParen, () => {
      val expr = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val arg = match expr.kind {
        AstNodeKind.Identifier(identifierKind) => {
          val peekToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          val arg = if peekToken.kind == TokenKind.Colon {
            self._advance() // consume ':' token

            val label = match identifierKind {
              IdentifierKind.Named(name) => Label(name: name, position: expr.token.position)
              _ => {
                val kind = ParseErrorKind.ExpectedToken(expected: [TokenKind.Ident("")], received: expr.token.kind)
                return Result.Err(ParseError(position: expr.token.position, kind: kind))
              }
            }
            val value = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

            InvocationArgument(label: label, value: value)
          } else {
            InvocationArgument(label: None, value: expr)
          }
          arg
        }
        _ => InvocationArgument(label: None, value: expr)
      }

      Result.Ok(arg)
    })
    val arguments = match argsRes { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(arguments)
  }

  func _parseInvocation(self, token: Token, left: AstNode): Result<AstNode, ParseError> {
    val arguments = match self._parseInvocationArguments() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(AstNode(token: token, kind: AstNodeKind.Invocation(InvocationAstNode(invokee: left, arguments: arguments))))
  }

  func _parseIndexing(self, token: Token, left: AstNode): Result<AstNode, ParseError> {
    val nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val index = if nextToken.kind == TokenKind.Colon {
      self._advance() // consume ':' token
      val rangeEnd = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      IndexingMode.Range(start: None, end: rangeEnd)
    } else {
      val expr = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if nextToken.kind == TokenKind.RBrack {
        IndexingMode.Single(expr)
      } else if nextToken.kind == TokenKind.Colon {
        self._advance() // consume ':' token
        val nextToken = match self._expectPeek() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if nextToken.kind == TokenKind.RBrack {
          IndexingMode.Range(start: expr, end: None)
        } else {
          val rangeEnd = match self._parseExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          IndexingMode.Range(start: expr, end: rangeEnd)
        }
      } else {
        return Result.Err(ParseError(position: nextToken.position, kind: ParseErrorKind.ExpectedToken([TokenKind.Colon, TokenKind.RBrack], nextToken.kind)))
      }
    }

    val lastToken = match self._expectNext() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    if lastToken.kind != TokenKind.RBrack {
      return Result.Err(ParseError(position: lastToken.position, kind: ParseErrorKind.UnexpectedToken(lastToken)))
    }

    Result.Ok(AstNode(token: token, kind: AstNodeKind.Indexing(expr: left, index: index)))
  }

  func _parseLambda(self, token: Token, left: AstNode): Result<AstNode, ParseError> {
    val params = match left.kind {
      AstNodeKind.Identifier(identifier) => match identifier {
        IdentifierKind.Named(name) => [FunctionParam(label: Label(name: name, position: left.token.position))]
        _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.UnexpectedToken(token)))
      }
      AstNodeKind.Grouped(inner) => {
        match inner.kind {
          AstNodeKind.Identifier(identifier) => match identifier {
            IdentifierKind.Named(name) => [FunctionParam(label: Label(name: name, position: inner.token.position))]
            _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.UnexpectedToken(token)))
          }
          _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.UnexpectedToken(token)))
        }
      }
      AstNodeKind.Tuple(items) => {
        val params: FunctionParam[] = Array.withCapacity(items.length)
        for item in items {
          match item.kind {
            AstNodeKind.Identifier(identifier) => match identifier {
              IdentifierKind.Named(name) => {
                params.push(FunctionParam(label: Label(name: name, position: item.token.position)))
                0 // <- awkward; this is needed because of an outstanding bug with Unit-returning `match`es (even though this is a statement so it shouldn't matter)
              }
              _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.UnexpectedToken(token)))
            }
            _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.UnexpectedToken(token)))
          }
        }
        params
      }
      _ => return Result.Err(ParseError(position: token.position, kind: ParseErrorKind.UnexpectedToken(token)))
    }

    val body = match self._parseBlockOrSingleExpression() { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    return Result.Ok(AstNode(token: token, kind: AstNodeKind.Lambda(LambdaNode(params: params, body: body))))
  }
}

func todo(position: Position): Result<AstNode, ParseError> {
  Result.Err(ParseError(position: position, kind: ParseErrorKind.NotYetImplemented))
}

func unreachable(): Result<AstNode, ParseError> {
  Result.Err(ParseError(position: Position(line: 0, col: 0), kind: ParseErrorKind.Unreachable))
}

type Precedence {
  // TODO: These are static functions because static constants don't yet exist
  func none(): Int = 0
  func addition(): Int = 1
  func multiplication(): Int = 2
  func unary(): Int = 3
  func call(): Int = 4

  func forToken(token: Token): Int {
    match token.kind {
      TokenKind.Plus => Precedence.addition()
      TokenKind.Minus => Precedence.addition()
      TokenKind.Star => Precedence.multiplication()
      TokenKind.Slash => Precedence.multiplication()
      TokenKind.Percent => Precedence.multiplication()
      TokenKind.Dot => Precedence.call()
      TokenKind.QuestionDot => Precedence.call()
      TokenKind.Arrow => Precedence.call()
      TokenKind.LParen(sawNewline) => if sawNewline Precedence.none() else Precedence.call()
      TokenKind.LBrack(sawNewline) => if sawNewline Precedence.none() else Precedence.call()
      _ => Precedence.none()
    }
  }
}
