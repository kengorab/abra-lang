import "fs" as fs
import getAbsolutePath, resolveRelativePath from "./utils"
import Lexer, LexerError, Token, TokenKind, Position from "./lexer"
import Parser, ParsedModule, ParseError, AstNode, AstNodeKind, LiteralAstNode, UnaryAstNode, UnaryOp, BinaryAstNode, BinaryOp, BindingDeclarationNode, BindingPattern, TypeIdentifier, Label, IdentifierKind, FunctionDeclarationNode, FunctionParam, InvocationAstNode, InvocationArgument, TypeDeclarationNode, EnumDeclarationNode, EnumVariant, AccessorAstNode, IndexingMode, AssignOp, AssignmentMode, ImportNode, ImportKind, DecoratorNode, LambdaNode, MatchCase, MatchCaseKind from "./parser"

enum Either<L, R> {
  Left(left: L)
  Right(right: R)
}

enum TokenizeAndParseError {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
}

export type ModuleLoader {
  stdRoot: String
  parsedModules: Map<String, ParsedModule> = {}

  func resolvePath(self, modulePath: String, relativeTo: String?): String {
    if relativeTo |relativeTo| {
      val pathParts = resolveRelativePath(path: modulePath, relativeTo: relativeTo)
      "/" + pathParts.join("/")
    } else {
      modulePath
    }
  }

  func hasSeenModule(self, modulePathAbs: String): Bool = self.parsedModules.containsKey(modulePathAbs)

  func tokenizeAndParse(self, modulePath: String): Result<ParsedModule, TokenizeAndParseError> {
    if self.parsedModules[modulePath] |m| return Ok(m)

    val parsedModule = match fs.readFile(modulePath) {
      Ok(contents) => {
        val m = match Lexer.tokenize(contents) {
          Ok(tokens) => {
            val m = match Parser.parse(tokens) {
              Ok(parsedModule) => parsedModule
              Err(error) => return Err(TokenizeAndParseError.ParseError(error))
            }
            m
          }
          Err(error) => return Err(TokenizeAndParseError.LexerError(error))
        }
        m
      }
      Err(e) => return Err(TokenizeAndParseError.ReadFileError(modulePath))
    }
    self.parsedModules[modulePath] = parsedModule

    Ok(parsedModule)
  }
}

export enum Export {
  Variable(variable: Variable)
  Function(aliasVar: Variable)
  Type(structOrEnum: StructOrEnum, aliasVar: Variable)
}

export type Import {
  label: Label
  kind: TypedImportKind
}

enum TypedImportKind {
  Variable(variable: Variable)
  Function(aliasVar: Variable)
  Type(structOrEnum: StructOrEnum, aliasVar: Variable)
}

type ImportedModule {
  aliases: Label[] = []
  imports: Map<String, Import> = {}
}

export type TypedModule {
  id: Int
  name: String
  code: TypedAstNode[]
  rootScope: Scope
  complete: Bool = false
  imports: Map<String, ImportedModule> = {}
  exports: Map<String, Export> = {}
}

export enum VariableAlias {
  Function(fn: Function)
  Struct(struct: Struct)
  Enum(enum_: Enum)
}

export type Variable {
  label: Label
  mutable: Bool
  ty: Type
  alias: VariableAlias? = None
  isExported: Bool = false
}

export enum Terminator {
  Returning
  NonReturning

  func combine(t1: Terminator?, t2: Terminator?): Terminator? {
    val t1Returns = if t1 |t1| t1 == Terminator.Returning else false
    val t1NonReturns = if t1 |t1| t1 == Terminator.NonReturning else false
    val t2Returns = if t2 |t2| t2 == Terminator.Returning else false
    val t2NonReturns = if t2 |t2| t2 == Terminator.NonReturning else false

    if t1Returns && t2Returns return Some(Terminator.Returning)

    if (t1NonReturns && !!t2) || (t2NonReturns && !!t1) return Some(Terminator.NonReturning)

    None
  }
}

export enum ScopeKind {
  Root
  Module
  Func
  If
  MatchCase
  While
  For
  Type
}

export type Scope {
  name: String
  variables: Variable[] = []
  functions: Function[] = []
  types: Type[] = []
  structs: Struct[] = []
  enums: Enum[] = []
  kind: ScopeKind = ScopeKind.Root
  parent: Scope? = None
  terminator: Terminator? = None
  numLambdas: Int = 0

  func nextLambdaName(self): String {
    val name = "lambda_${self.numLambdas}"
    self.numLambdas += 1
    name
  }

  func makeChild(self, name: String, kind: ScopeKind): Scope = Scope(name: "${self.name}::$name", kind: kind, parent: Some(self))
}

export type Field {
  name: Label
  ty: Type
  initializer: TypedAstNode?
}

export type Struct {
  moduleId: Int
  label: Label
  scope: Scope
  typeParams: String[] = []
  fields: Field[] = []
  instanceMethods: Function[] = []
  staticMethods: Function[] = []

  // Override eq method since default implementation recurses infinitely (scope -> variables -> TypeKind.Struct)
  func eq(self, other: Struct): Bool = self.moduleId == other.moduleId && self.label == other.label
}

export type TypedEnumVariant {
  label: Label
  kind: EnumVariantKind
}

export enum EnumVariantKind {
  Constant
  Container(fields: Field[])
}

export type Enum {
  moduleId: Int
  label: Label
  scope: Scope
  typeParams: String[] = []
  variants: TypedEnumVariant[] = []
  instanceMethods: Function[] = []
  staticMethods: Function[] = []

  // Override eq method since default implementation recurses infinitely (scope -> variables -> TypeKind.Enum)
  func eq(self, other: Enum): Bool = self.moduleId == other.moduleId && self.label == other.label

  // Enums are used as Map keys when tracking completeness in match cases, and moduleId + label is enough to
  // uniquely identify an Enum and save work recursively hashing all other members
  func hash(self): Int = self.moduleId + self.label.hash() * 17
}

enum Instantiatable {
  Struct(struct: Struct)
  EnumContainerVariant(enum_: Enum, variant: TypedEnumVariant, fields: Field[])
}


export type Project {
  modules: Map<String, TypedModule> = {}
  preludeScope: Scope = Scope(name: "bogus")
  preludeIntStruct: Struct = Struct(moduleId: 0, label: Label(name: "Int", position: Position(line: 0, col: 0)), scope: Scope(name: "Int"))
  preludeFloatStruct: Struct = Struct(moduleId: 0, label: Label(name: "Float", position: Position(line: 0, col: 0)), scope: Scope(name: "Float"))
  preludeBoolStruct: Struct = Struct(moduleId: 0, label: Label(name: "Bool", position: Position(line: 0, col: 0)), scope: Scope(name: "Bool"))
  preludeStringStruct: Struct = Struct(moduleId: 0, label: Label(name: "String", position: Position(line: 0, col: 0)), scope: Scope(name: "String"))
  preludeArrayStruct: Struct = Struct(moduleId: 0, label: Label(name: "Array", position: Position(line: 0, col: 0)), scope: Scope(name: "Array"), typeParams: ["T"])
  preludeMapStruct: Struct = Struct(moduleId: 0, label: Label(name: "Map", position: Position(line: 0, col: 0)), scope: Scope(name: "Array"), typeParams: ["K", "V"])
  preludeSetStruct: Struct = Struct(moduleId: 0, label: Label(name: "Set", position: Position(line: 0, col: 0)), scope: Scope(name: "Set"), typeParams: ["T"])
  preludeOptionEnum: Enum = Enum(moduleId: 0, label: Label(name: "Option", position: Position(line: 0, col: 0)), scope: Scope(name: "Option"), typeParams: ["T"])
}

export type Type {
  kind: TypeKind

  func repr(self): String {
    match self.kind {
      TypeKind.Any => "Any"
      TypeKind.PrimitiveUnit => "Unit"
      TypeKind.PrimitiveInt => "Int"
      TypeKind.PrimitiveFloat => "Float"
      TypeKind.PrimitiveBool => "Bool"
      TypeKind.PrimitiveString => "String"
      TypeKind.Never => "Never"
      TypeKind.Generic(name) => name
      TypeKind.Instance(structOrEnum, typeParams) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => {
            if struct.moduleId == 0 && struct.label.name == "Array" {
              val innerRepr = typeParams[0]?.repr() ?: "<unknown>"
              "$innerRepr[]"
            } else {
              val genericsRepr = if typeParams.isEmpty() "" else {
                val reprs = typeParams.map(t => t.repr()).join(", ")
                "<$reprs>"
              }
              "${struct.label.name}$genericsRepr"
            }
          }
          StructOrEnum.Enum(enum_) => {
            if enum_.moduleId == 0 && enum_.label.name == "Option" {
              val innerRepr = typeParams[0]?.repr() ?: "<unknown>"
              "$innerRepr?"
            } else {
              val genericsRepr = if typeParams.isEmpty() "" else {
                val reprs = typeParams.map(t => t.repr()).join(", ")
                "<$reprs>"
              }
              "${enum_.label.name}$genericsRepr"
            }
          }
        }
      }
      TypeKind.Tuple(types) => "(${types.map(t => t.repr()).join(", ")})"
      TypeKind.Func(paramTypes, returnType) => {
        val paramsRepr = paramTypes.filter(p => p[1]).map(p => p[0].repr()).join(", ")
        val returnTypeRepr = returnType.repr()
        "($paramsRepr) => $returnTypeRepr"
      }
      TypeKind.Type(structOrEnum) => match structOrEnum {
        StructOrEnum.Struct(struct) => "<#type ${struct.label.name}>"
        StructOrEnum.Enum(enum_) => "<#enum ${enum_.label.name}>"
      }
      TypeKind.Hole => "<unknown>"
    }
  }

  func hasUnfilledHoles(self): Bool = match self.kind {
    TypeKind.Any => false
    TypeKind.PrimitiveUnit => false
    TypeKind.PrimitiveInt => false
    TypeKind.PrimitiveFloat => false
    TypeKind.PrimitiveBool => false
    TypeKind.PrimitiveString => false
    TypeKind.Never => false
    TypeKind.Generic => false
    TypeKind.Instance(_, generics) => generics.any(t => t.hasUnfilledHoles())
    TypeKind.Tuple(types) => types.any(t => t.hasUnfilledHoles())
    TypeKind.Func(paramTypes, returnType) => paramTypes.any(t => t[0].hasUnfilledHoles()) || returnType.hasUnfilledHoles()
    TypeKind.Type => false
    TypeKind.Hole => true
  }

  func isInvalidValueType(self): Bool = self.kind == TypeKind.PrimitiveUnit || self.kind == TypeKind.Never || self.hasUnfilledHoles()

  func tryFillHoles(self, other: Type) {
    // TODO: this code is pretty ugly - I really need a way of destructuring multiple values simultaneously in `match`es
    match self.kind {
      TypeKind.Instance(selfStructOrEnum, selfTypeArgs) => {
        match other.kind {
          TypeKind.Instance(otherStructOrEnum, otherTypeArgs) => {
            if selfStructOrEnum != otherStructOrEnum return

            for typeArg, idx in selfTypeArgs {
              typeArg.tryFillHoles(otherTypeArgs[idx] ?: Type(kind: TypeKind.Hole))
            }
          }
          _ => {}
        }
      }
      TypeKind.Tuple(selfTypeArgs) => {
        match other.kind {
          TypeKind.Tuple(otherTypeArgs) => {
            for typeArg, idx in selfTypeArgs {
              typeArg.tryFillHoles(otherTypeArgs[idx] ?: Type(kind: TypeKind.Hole))
            }
          }
          _ => {}
        }
      }
      _ => {
        if self.kind == TypeKind.Hole {
          self.kind = other.kind
        }
      }
    }
  }

  func withSubstitutedGenerics(self, resolvedGenerics: Map<String, Type>, retainUnknown: Bool, genericsInScope: Set<String>): Type {
    val resultType = match self.kind {
      TypeKind.Generic(name) => {
        val t = if resolvedGenerics[name] |substitute| {
          substitute
        } else if retainUnknown || genericsInScope.contains(name) {
          self
        } else {
          Type(kind: TypeKind.Hole)
        }
        t
      }
      TypeKind.Instance(structOrEnum, typeArgs) => {
        val substTypeArgs = typeArgs.map(ty => ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope))
        Type(kind: TypeKind.Instance(structOrEnum, substTypeArgs))
      }
      TypeKind.Tuple(typeArgs) => {
        val substTypeArgs = typeArgs.map(ty => ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope))
        Type(kind: TypeKind.Tuple(substTypeArgs))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val substParamTypes = paramTypes.map(p => {
          val t = p[0].withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)
          (t, p[1])
        })
        val substReturnType = returnType.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)
        Type(kind: TypeKind.Func(substParamTypes, substReturnType))
      }
      _ => self
    }

    resultType
  }
}

export enum StructOrEnum {
  Struct(struct: Struct)
  Enum(enum_: Enum)
}

export enum TypeKind {
  PrimitiveUnit
  PrimitiveInt
  PrimitiveFloat
  PrimitiveBool
  PrimitiveString
  Never
  Any
  Generic(name: String)
  Instance(structOrEnum: StructOrEnum, generics: Type[])
  Func(paramTypes: (Type, Bool)[], returnType: Type)
  Type(type_: StructOrEnum)
  Tuple(types: Type[])
  Hole
}

export type TypedAstNode {
  token: Token
  ty: Type
  kind: TypedAstNodeKind
}

export enum TypedIdentifierKind {
  Named(name: String, variable: Variable)
  None_
  Discard
}

type Decorator {
  label: Label
  arguments: LiteralAstNode[]
}

type TypedBindingDeclarationNode {
  bindingPattern: BindingPattern
  variables: Variable[]
  expr: TypedAstNode?
}

type TypedFunctionParam {
  label: Label
  ty: Type
  defaultValue: TypedAstNode? = None
  isVariadic: Bool = false
}

export enum FunctionKind {
  Standalone
  InstanceMethod
  StaticMethod
}

export type Function {
  label: Label
  scope: Scope
  kind: FunctionKind
  typeParams: (Type, Label)[] = []
  params: TypedFunctionParam[] = []
  returnType: Type
  body: TypedAstNode[] = []
  isGenerated: Bool = false
  isLambda: Bool = false
  decorators: Decorator[] = []

  func generated(
    scope: Scope,
    name: String,
    params: (String, Type)[],
    returnType: Type,
    kind = FunctionKind.InstanceMethod,
    typeParams: (Type, Label)[] = [],
  ): Function {
    val bogusPosition = Position(line: 0, col: 0)

    val label = Label(name: name, position: bogusPosition)
    val fnScope = scope.makeChild(name, ScopeKind.Func)
    val fnParams = params.map(p => TypedFunctionParam(label: Label(name: p[0], position: bogusPosition), ty: p[1]))
    Function(label: label, scope: fnScope, kind: kind, typeParams: typeParams, params: fnParams, returnType: returnType, body: [], isGenerated: true)
  }

  func initializer(
    scope: Scope,
    struct: Struct,
  ): Function {
    val bogusPosition = Position(line: 0, col: 0)

    val fnScope = scope.makeChild(struct.label.name, ScopeKind.Func)
    val structTypeParams = struct.typeParams.map(t => (Type(kind: TypeKind.Generic(t)), Label(name: t, position: bogusPosition)))
    val params = struct.fields.map(f => TypedFunctionParam(label: Label(name: f.name.name, position: bogusPosition), ty: f.ty, defaultValue: f.initializer))
    val typeArgs = struct.typeParams.map(t => Type(kind: TypeKind.Generic(t)))
    val returnType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs))

    Function(label: struct.label, scope: fnScope, kind: FunctionKind.Standalone, typeParams: structTypeParams, params: params, returnType: returnType, body: [], isGenerated: true)
  }

  func forEnumVariant(
    scope: Scope,
    enum_: Enum,
    variantLabel: Label,
    variantFields: Field[],
  ): Function {
    val bogusPosition = Position(line: 0, col: 0)

    val fnScope = scope.makeChild("${enum_.label.name}.${variantLabel.name}", ScopeKind.Func)
    val typeParams = enum_.typeParams.map(t => (Type(kind: TypeKind.Generic(t)), Label(name: t, position: bogusPosition)))
    val params = variantFields.map(f => TypedFunctionParam(label: Label(name: f.name.name, position: bogusPosition), ty: f.ty, defaultValue: f.initializer))
    val typeArgs = enum_.typeParams.map(t => Type(kind: TypeKind.Generic(t)))
    val returnType = Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), typeArgs))

    Function(label: variantLabel, scope: fnScope, kind: FunctionKind.Standalone, typeParams: typeParams, params: params, returnType: returnType, body: [], isGenerated: true)
  }

  func getType(self): Type = Type(kind: TypeKind.Func(paramTypes: self.params.map(p => (p.ty, !p.defaultValue)), returnType: self.returnType))

  func withSubstitutedGenerics(self, resolvedGenerics: Map<String, Type>, retainUnknown: Bool, genericsInScope: Set<String>): Function {
    val params = self.params.map(p => {
      val ty = p.ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)
      TypedFunctionParam(label: p.label, ty: ty, defaultValue: p.defaultValue, isVariadic: p.isVariadic)
    })
    val returnType = self.returnType.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)

    Function(
      label: self.label,
      scope: self.scope,
      kind: self.kind,
      typeParams: self.typeParams,
      params: params,
      returnType: returnType,
      body: self.body,
      isGenerated: self.isGenerated,
      decorators: self.decorators,
    )
  }
}

export enum TypedInvokee {
  Method(fn: Function, selfVal: TypedAstNode, isOptSafe: Bool)
  Function(fn: Function)
  Struct(struct: Struct)
  Expr(expr: TypedAstNode)
  EnumVariant(enum_: Enum, variant: TypedEnumVariant)
}

export enum TypedIndexingNode {
  ArrayLike(expr: TypedAstNode, indexingMode: IndexingMode<TypedAstNode>)
  Map(expr: TypedAstNode, idx: TypedAstNode)
  Tuple(tupleExpr: TypedAstNode, idx: Int)
}

export enum TypedAssignmentMode {
  Variable(variable: Variable)
  Indexing(node: TypedIndexingNode)
  Accessor(head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment)
}

export enum TypedMatchCaseKind {
  Literal(value: LiteralAstNode)
  Type(ty: Type)
  EnumVariant(enum_: Enum, variant: TypedEnumVariant, variantIdx: Int, destructuredVariables: Variable[])
  None_
  Else
}

export type TypedMatchCase {
  kind: TypedMatchCaseKind
  binding: Variable?
  body: TypedAstNode[]
}

export enum TypedAstNodeKind {
  Literal(value: LiteralAstNode)
  StringInterpolation(exprs: TypedAstNode[])
  Unary(op: UnaryOp, expr: TypedAstNode)
  Binary(left: TypedAstNode, op: BinaryOp, right: TypedAstNode)
  Grouped(inner: TypedAstNode)
  Identifier(kind: TypedIdentifierKind)
  Accessor(head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment)
  Invocation(invokee: TypedInvokee, arguments: TypedAstNode?[])
  Array(items: TypedAstNode[])
  Set(items: TypedAstNode[])
  Map(items: (TypedAstNode, TypedAstNode)[])
  Tuple(items: TypedAstNode[])
  Indexing(node: TypedIndexingNode)
  Lambda(fn: Function)
  Assignment(mode: TypedAssignmentMode, op: AssignOp, expr: TypedAstNode)
  If(isStatement: Bool, typedCondition: TypedAstNode, conditionBinding: (BindingPattern, Variable[])?, typedIfBlock: TypedAstNode[], typedElseBlock: TypedAstNode[])
  Match(isStatement: Bool, expr: TypedAstNode, cases: TypedMatchCase[])
  While(typedCondition: TypedAstNode, conditionBinding: (BindingPattern, Variable[])?, block: TypedAstNode[])
  For(typedIterator: TypedAstNode, itemBinding: (BindingPattern, Variable[]), indexBinding: Variable?, block: TypedAstNode[])
  BindingDeclaration(node: TypedBindingDeclarationNode)
  FunctionDeclaration(fn: Function)
  TypeDeclaration(struct: Struct)
  EnumDeclaration(enum_: Enum)
  Break
  Continue
  Return(expr: TypedAstNode?)

  Placeholder
}

export enum AccessorPathSegment {
  EnumVariant(label: Label, ty: Type, enum_: Enum, variant: TypedEnumVariant)
  Method(label: Label, fn: Function)
  Field(label: Label, ty: Type, f: Field)

  func getType(self): Type {
    match self {
      AccessorPathSegment.EnumVariant(_, ty, _, _) => ty
      AccessorPathSegment.Method(_, fn) => fn.getType()
      AccessorPathSegment.Field(_, ty, _) => ty
    }
  }
}

type TypecheckerError {
  modulePath: String
  kind: TypecheckerErrorKind

  func getMessage(self): String {
    match self.kind {
      // TODO: Better error message, once imports are a thing
      TypecheckerErrorKind.ReadFileError(path) => "Could not read file '$path'"
      TypecheckerErrorKind.LexerError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Ok(v) => v
          Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.ParseError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Ok(v) => v
          Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.TypeError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Ok(v) => v
          Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
    }
  }
}

enum TypecheckerErrorKind {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
  TypeError(inner: TypeError)
}

type TypeError {
  position: Position
  kind: TypeErrorKind

  // Note: this is different than `Typechecker#_typeIsOption`, because we don't have access to the Project here to
  // compare against `project.preludeOptionEnum`. However, the functionality should be equivalent since the
  // comparison here is roughly the same as `Enum#eq`.
  func _typeIsOption(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(structOrEnum, generics) => match structOrEnum {
        StructOrEnum.Enum(enum_) => if enum_.moduleId == 0 && enum_.label.name == "Option" {
          generics[0]
        } else {
          None
        }
        _ => None
      }
      _ => None
    }
  }

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      TypeErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      TypeErrorKind.Unreachable(message) => {
        lines.push("Unreachable code reached")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Internal error: $message")
      }
      TypeErrorKind.TypeMismatch(expected, received) => {
        lines.push("Type mismatch")
        lines.push(self._getCursorLine(self.position, contents))

        val expectedReprs = expected.map(t => t.repr()).join(", ")
        if expected.length == 1 {
          lines.push("Expected: " + expectedReprs)
        } else {
          lines.push("Expected one of: " + expectedReprs)
        }
        lines.push("but instead found: " + received.repr())
      }
      TypeErrorKind.DuplicateName(original) => {
        lines.push("Duplicate name '${original.name}'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This name is also declared at (${original.position.line}:${original.position.col})")
        lines.push(self._getCursorLine(original.position, contents))
      }
      TypeErrorKind.UnknownName(name, kind) => {
        lines.push("Unknown $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        if name == "_" {
          lines.push("The '_' identifier is a special name used to discard values, and it cannot be referenced")
        } else {
          lines.push("No $kind with that name is visible in current scope")
        }
      }
      TypeErrorKind.UnknownField(ty, name, specialCase) => {
        lines.push("Unknown field '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        match ty.kind {
          TypeKind.Func => lines.push("Functions don't have any fields or methods")
          _ => {
            match specialCase {
              UnknownFieldSpecialCase.ExistsButTypeIsNullable(isViaOptChaining) => {
                val nonOptVersion = if self._typeIsOption(ty) |ty| ty else {
                  __assertUnreachable("ty should be Option<?> here")
                  Type(kind: TypeKind.Hole)
                }

                if isViaOptChaining {
                  lines.push("Type '${nonOptVersion.repr()}' has field '$name', but lhs here is of type '${ty.repr()}' due to prior '?.'")
                } else {
                  lines.push("Type '${nonOptVersion.repr()}' has field '$name', but lhs is of type '${ty.repr()}'")
                }
                lines.push("(You can use the '?.' operator instead of '.')")
              }
              UnknownFieldSpecialCase.StaticFieldReferencedAsInstance => {
                lines.push("No field '$name' found on instance of type ${ty.repr()}")
                lines.push("'$name' is a static member of ${ty.repr()}, did you mean to write ${ty.repr()}.$name?")
              }
              None =>  {
                lines.push("No field '$name' found on type ${ty.repr()}")
              }
            }
          }
        }
      }
      TypeErrorKind.MissingValExpr(name) => {
        lines.push("Missing initializer for immutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.MissingVarExprAndTypeAnn(name) => {
        lines.push("Could not determine type of mutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("A 'var' must have either an initial value or a type annotation (or both)")
      }
      TypeErrorKind.IllegalNonConstantEnumVariant => {
        lines.push("Forbidden value")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This enum variant is non-constant and must be constructed")
      }
      TypeErrorKind.IllegalValueType(ty, purpose) => {
        match ty.kind {
          TypeKind.PrimitiveUnit => {
            lines.push("Forbidden type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Instances of type ${ty.repr()} cannot be used as $purpose values")
          }
          TypeKind.Never => {
            lines.push("Forbidden type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Expression has type ${ty.repr()}, which can never be used for $purpose")
          }
          TypeKind.Type => {
            lines.push("Forbidden type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Expression has type ${ty.repr()}, which cannot be used as a value")
          }
          _ => {
            lines.push("Could not determine type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Type '${ty.repr()}' has unfilled holes. Please use an explicit type annotation to denote the type")
          }
        }
      }
      TypeErrorKind.IllegalControlFlowType(ty, purpose) => {
        if purpose == "if" || purpose == "while" {
          lines.push("Forbidden type for $purpose-condition")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Conditions must either be Bool or Option types")
          lines.push("but instead found " + ty.repr())
        } else if purpose == "for" {
          lines.push("Forbidden type for for-loop target")
          lines.push(self._getCursorLine(self.position, contents))
          if ty.hasUnfilledHoles() {
            lines.push("Type '${ty.repr()}' has unfilled holes")
          } else {
            lines.push("Type ${ty.repr()} is not iterable")
          }
        }
      }
      TypeErrorKind.MissingRequiredIfExprBlock(clause, missing) => {
        lines.push("Incomplete if-expression")
        lines.push(self._getCursorLine(self.position, contents))
        if missing {
          lines.push("The $clause-block must exist and contain a value")
        } else {
          lines.push("The $clause-block must contain a value")
        }
      }
      TypeErrorKind.DuplicateParameter(name) => {
        lines.push("Duplicate parameter '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.InvalidParamPosition(purpose) => {
        match purpose {
          "vararg" => {
            lines.push("Invalid location for variadic parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Variadic parameters must be the last in the parameter list")
          }
          "required" => {
            lines.push("Invalid location for required parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Required parameters must all be listed before any optional parameters")
          }
          "self" => {
            lines.push("Invalid usage of `self` parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("`self` can only appear within methods on types")
          }
          _ => { /* no other cases */ }
        }
      }
      TypeErrorKind.InvalidVarargType(ty) => {
        lines.push("Invalid type for vararg parameter")
        lines.push(self._getCursorLine(self.position, contents))
        if self._typeIsOption(ty) {
          lines.push("Vararg parameters must be a non-Option Array type, but got ${ty.repr()}")
        } else {
          lines.push("Vararg parameters must be an Array type, but got ${ty.repr()}")
        }
      }
      TypeErrorKind.ReturnTypeMismatch(fnName, expected, received) => {
        if fnName |name| {
          lines.push("Return type mismatch for function '$name'")
        } else {
          lines.push("Return type mismatch for lambda function")
        }

        lines.push(self._getCursorLine(self.position, contents))

        lines.push("Expected ${expected.repr()}")
        if received |received| {
          lines.push("but instead found ${received.repr()}")
        } else {
          lines.push("but function had empty body")
        }
      }
      TypeErrorKind.InvalidTerminatorPosition(terminator) => {
        lines.push("Invalid location for $terminator statement")
        lines.push(self._getCursorLine(self.position, contents))
        match terminator {
          "return" => lines.push("Return statements can only be used within function bodies")
          "break" => lines.push("Break statements can only be used within loop bodies")
          "continue" => lines.push("Continue statements can only be used within loop bodies")
          _ => { /* unreachable */ }
        }
      }
      TypeErrorKind.UnreachableCode => {
        lines.push("Unreachable code")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Control flow exits before this code is reached")
      }
      TypeErrorKind.WrongInvocationArity(expected, given) => {
        val argumentsStr = if expected == 1 "argument" else "arguments"
        val verbStr = if given == 1 "was" else "were"

        if given > expected {
          lines.push("Too many arguments for invocation")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Expected no more than $expected $argumentsStr, but $given $verbStr passed")
        } else {
          lines.push("Not enough arguments for invocation")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("$expected $argumentsStr required, but $given $verbStr passed")
        }
      }
      TypeErrorKind.ParameterLabelMismatch(expected, given) => {
        lines.push("Incorrect label for parameter")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The parameter's name is '$expected', but instead found '$given'")
      }
      TypeErrorKind.IllegalParameterLabel => {
        lines.push("Incorrect use of label for parameter")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Parameter labels are not allowed here because parameters' names cannot be determined")
      }
      TypeErrorKind.MixedArgumentType(label) => {
        lines.push("Cannot mix labeled and positional optional arguments")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This argument requires a label because a prior optional parameter has been labeled:")
        lines.push(self._getCursorLine(label.position, contents))
        lines.push("(Optional parameters may be listed positionally until a label is encountered. After that point, parameter values cannot be unambiguously determined without labels)")
      }
      TypeErrorKind.MissingRequiredArgumentLabel => {
        lines.push("Invalid instantiation")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Calls of type constructors must include argument labels")
      }
      TypeErrorKind.MissingRequiredFields(names) => {
        lines.push("Invalid instantiation")
        lines.push(self._getCursorLine(self.position, contents))

        val maxToShow = 3
        val missing = names[:maxToShow].map(n => "'$n'")
        if names.length > maxToShow {
          missing.push("and ${names.length - maxToShow} more")
        }
        lines.push("The following required fields are missing: ${missing.join(", ")}")
      }
      TypeErrorKind.UnknownParameterName(name) => {
        lines.push("Unknown parameter label")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This function doesn't have a parameter named '$name'")
      }
      TypeErrorKind.UnknownParameterType(name) => {
        lines.push("Could not determine type for parameter '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Consider adding a type annotation")
      }
      TypeErrorKind.ParameterTypeMismatch(name, expected, given) => {
        if name |name| {
          lines.push("Type mismatch for parameter '$name'")
        } else {
          lines.push("Type mismatch for parameter")
        }
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Expected: ${expected.repr()}")
        lines.push("but instead found: ${given.repr()}")
      }
      TypeErrorKind.IllegalCallableType(ty) => {
        lines.push("Cannot invoke target as function")
        lines.push(self._getCursorLine(self.position, contents))
        match ty.kind {
          TypeKind.Instance(structOrEnum, _) => {
            match structOrEnum {
              StructOrEnum.Enum => lines.push("This is a constant enum variant, and it accepts no arguments")
              _ => __assertUnreachable("This should be unreachable")
            }
          }
          _ => lines.push("Type '${ty.repr()}' is not callable")
        }
      }
      TypeErrorKind.WrongTypeArgumentArity(expected, given) => {
        val verbStr = if given == 1 "was" else "were"

        lines.push("Incorrect number of type arguments")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Expected $expected, but $given $verbStr passed")
      }
      TypeErrorKind.NoSuchOperator(leftTy, op, rightTy) => {
        lines.push("Illegal operator")
        lines.push(self._getCursorLine(self.position, contents))
        val isCoalesceError = op == BinaryOp.Coalesce && !self._typeIsOption(leftTy)
        if isCoalesceError {
          lines.push("The '${op.repr()}' operator can only be used on an Option type")
          lines.push("(The lhs value's type here is ${leftTy.repr()}, not Option<${leftTy.repr()}>)")
        } else {
          lines.push("No operator '${op.repr()}' exists between types ${leftTy.repr()} and ${rightTy.repr()}")
        }
      }
      TypeErrorKind.IllegalIndexableType(ty, isRange) => {
        lines.push("Unsupported indexing operation")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Type '${ty.repr()}' is not indexable" + if isRange " as a range" else "")
      }
      TypeErrorKind.IllegalTupleIndexing(ty, reason) => {
        lines.push("Unsupported tuple indexing operation")
        lines.push(self._getCursorLine(self.position, contents))
        match reason {
          IllegalTupleIndexingReason.IndexOutOfBounds => {
            lines.push("No value at index for tuple of type '${ty.repr()}'")
            match ty.kind {
              TypeKind.Tuple(types) => lines.push("(Valid index values are from 0-${types.length - 1}, inclusive)")
              _ => __assertUnreachable("The type here should always be a tuple")
            }
          }
          IllegalTupleIndexingReason.IndexNegative => {
            lines.push("Tuple index values must always be a non-negative integer")
            match ty.kind {
              TypeKind.Tuple(types) => lines.push("(Valid index values are from 0-${types.length - 1}, inclusive)")
              _ => __assertUnreachable("The type here should always be a tuple")
            }
          }
          IllegalTupleIndexingReason.NotIntLiteral => lines.push("Cannot use non-Int literal as index value. Tuple index values must always be Int literals")
          IllegalTupleIndexingReason.NotLiteralNode => lines.push("Cannot use this expression as index value. Tuple index values must always be Int literals")
        }
      }
      TypeErrorKind.UnnecessaryOptSafety => {
        lines.push("Unnecessary use of '?.' operator")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("(The lhs value's type here is known to be a non-Option type)")
      }
      TypeErrorKind.InvalidTraitMethodSignature(givenFn) => {
        lines.push("Invalid signature for method '${givenFn.label.name}'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.IllegalAssignment(kind, name, reason) => {
        lines.push("Cannot assign to $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        match reason {
          IllegalAssignmentReason.ImmutableVariable => lines.push("'$name' is declared as immutable")
          IllegalAssignmentReason.TypeAlias => lines.push("'$name' is a type, which cannot be overwritten")
          IllegalAssignmentReason.FunctionAlias => lines.push("'$name' is a function, which cannot be overwritten")
          IllegalAssignmentReason.EnumVariant => lines.push("'$name' is an enum variant, which cannot be overwritten")
          IllegalAssignmentReason.Method => lines.push("'$name' is a method, which cannot be overwritten")
          IllegalAssignmentReason.StaticMethod => lines.push("'$name' is a static method, which cannot be overwritten")
        }
      }
      TypeErrorKind.UnknownModule(modulePath, isRelativeImport) => {
        lines.push("Could not import module")
        lines.push(self._getCursorLine(self.position, contents))
        if isRelativeImport {
          lines.push("No file exists at path '$modulePath'")
        } else {
          lines.push("Could not find module named '$modulePath'")
        }
      }
      TypeErrorKind.CircularDependency => {
        lines.push("Could not import module due to circular dependency")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The current module is imported by the imported module (or one of its imports), resulting in a cycle")
      }
      TypeErrorKind.IllegalExportScope => {
        lines.push("Invalid export modifier")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Exported values may only appear at the top level scope in a module")
      }
      TypeErrorKind.UnknownImport(moduleName, importName) => {
        lines.push("Invalid import")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("There's no exported value named '$importName' in module '$moduleName'")
      }
      TypeErrorKind.UnknownImportForAlias(importName, alias) => {
        lines.push("Unknown exported name for aliased module")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("There's no exported value named '$importName' in module aliased as '${alias.name}' at:")
        lines.push(self._getCursorLine(alias.position, contents))
      }
      TypeErrorKind.DuplicateMatchCase => {
        lines.push("Duplicate match case")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.UnreachableMatchCase(reason, subjectTy) => {
        lines.push("Unreachable match case")
        lines.push(self._getCursorLine(self.position, contents))
        match reason {
          UnreachableMatchCaseReason.NoOverlap(caseTy) => {
            if caseTy |caseTy| {
              lines.push("No overlap between case type '${caseTy.repr()}' and match target type '${subjectTy.repr()}'")
            } else {
              lines.push("Match target type '${subjectTy.repr()}' can never be None")
            }
          }
          UnreachableMatchCaseReason.AlreadyCovered(exhaustive) => {
            if exhaustive {
              lines.push("The previous case(s) cover all possibilities for match target type '${subjectTy.repr()}'")
            } else {
              lines.push("This case has already been covered by a previous case")
            }
          }
        }
      }
      TypeErrorKind.EmptyMatchBlock => {
        lines.push("Empty block for match case")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Each case in a match expression must result in a value")
      }
      TypeErrorKind.NonExhaustiveMatch(subjectTy) => {
        lines.push("Non-exhaustive match expression")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Match target type '${subjectTy.repr()}' is not covered by all cases")
        lines.push("(You can use a wildcard to capture remaining cases)")
      }
      TypeErrorKind.InvalidMatchCaseDestructuring(reason) => {
        match reason {
          InvalidMatchCaseDestructuringReason.NonEnum => {
            lines.push("Destructuring is not supported for types in match cases (aside from enum variants)")
            lines.push(self._getCursorLine(self.position, contents))
          }
          InvalidMatchCaseDestructuringReason.NonEnumContainer => {
            lines.push("This variant is a constant enum variant, which cannot be destructured")
            lines.push(self._getCursorLine(self.position, contents))
          }
          InvalidMatchCaseDestructuringReason.InvalidArity(expected, given) => {
            val verbStr = if given == 1 "was" else "were"

            lines.push("Incorrect number of destructuring arguments")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Expected $expected, but $given $verbStr passed")
            if given < expected {
              lines.push("(You can use '_' to denote positions that you wish to discard)")
            }
          }
        }
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum UnknownFieldSpecialCase {
  ExistsButTypeIsNullable(isViaOptChaining: Bool)
  StaticFieldReferencedAsInstance
}

enum IllegalTupleIndexingReason {
  IndexOutOfBounds
  IndexNegative
  NotIntLiteral
  NotLiteralNode
}

enum IllegalAssignmentReason {
  ImmutableVariable
  TypeAlias
  FunctionAlias
  EnumVariant
  Method
  StaticMethod
}

enum UnreachableMatchCaseReason {
  NoOverlap(caseTy: Type?)
  AlreadyCovered(exhaustive: Bool)
}

enum InvalidMatchCaseDestructuringReason {
  NonEnum
  NonEnumContainer
  InvalidArity(expected: Int, given: Int)
}

enum TypeErrorKind {
  NotYetImplemented(reason: String)
  Unreachable(message: String)
  TypeMismatch(expected: Type[], received: Type)
  DuplicateName(original: Label)
  UnknownName(name: String, kind: String)
  UnknownField(ty: Type, name: String, specialCase: UnknownFieldSpecialCase?)
  MissingValExpr(name: String)
  MissingVarExprAndTypeAnn(name: String)
  IllegalNonConstantEnumVariant
  IllegalValueType(ty: Type, purpose: String)
  IllegalControlFlowType(ty: Type, purpose: String)
  MissingRequiredIfExprBlock(clause: String, missing: Bool)
  InvalidParamPosition(purpose: String)
  DuplicateParameter(name: String)
  InvalidVarargType(ty: Type)
  ReturnTypeMismatch(fnName: String?, expected: Type, received: Type?)
  InvalidTerminatorPosition(terminator: String)
  UnreachableCode
  WrongInvocationArity(expected: Int, given: Int)
  ParameterLabelMismatch(expected: String, given: String)
  IllegalParameterLabel
  MixedArgumentType(label: Label)
  MissingRequiredArgumentLabel
  MissingRequiredFields(names: String[])
  UnknownParameterName(name: String)
  UnknownParameterType(name: String)
  ParameterTypeMismatch(name: String?, expected: Type, given: Type)
  IllegalCallableType(ty: Type)
  WrongTypeArgumentArity(expected: Int, given: Int)
  NoSuchOperator(leftTy: Type, op: BinaryOp, rightTy: Type)
  IllegalIndexableType(ty: Type, isRange: Bool)
  IllegalTupleIndexing(ty: Type, reason: IllegalTupleIndexingReason)
  UnnecessaryOptSafety
  InvalidTraitMethodSignature(fn: Function)
  IllegalAssignment(kind: String, name: String, reason: IllegalAssignmentReason)
  UnknownModule(modulePath: String, isRelativeImport: Bool)
  CircularDependency
  IllegalExportScope
  UnknownImport(moduleName: String, importName: String)
  UnknownImportForAlias(importName: String, alias: Label)
  DuplicateMatchCase
  UnreachableMatchCase(reason: UnreachableMatchCaseReason, subjectTy: Type)
  EmptyMatchBlock
  NonExhaustiveMatch(subjectTy: Type)
  InvalidMatchCaseDestructuring(reason: InvalidMatchCaseDestructuringReason)
}

type ParamDefaultValueContext {
  exprContainsFunctionCall: Bool = false
  exprContainsVariableRef: Bool = false
}

export type Typechecker {
  moduleLoader: ModuleLoader
  project: Project
  currentModuleId: Int = -1
  currentModuleExports: Map<String, Export> = {} // TODO: this is a little gross, could we instead track the currentModule?
  currentModuleImports: Map<String, ImportedModule> = {} // TODO: see above todo
  currentScope: Scope = Scope(name: "\$root")
  currentTypeDecl: StructOrEnum? = None
  currentFunction: Function? = None
  paramDefaultValueContext: ParamDefaultValueContext? = None
  isStructOrEnumValueAllowed: Bool = false
  isEnumContainerValueAllowed: Bool = false

  func typecheckEntrypoint(self, modulePathAbs: String): Result<TypedModule, TypecheckerError> {
    val preludeModulePathSegs = getAbsolutePath(self.moduleLoader.stdRoot + "/prelude.abra")
    val preludeModulePathAbs = "/" + preludeModulePathSegs.join("/")
    match self._typecheckModule(preludeModulePathAbs) { Ok(v) => v, Err(e) => return Err(e) }

    val preludeStructs = [
      self.project.preludeIntStruct,
      self.project.preludeFloatStruct,
      self.project.preludeBoolStruct,
      self.project.preludeStringStruct,
      self.project.preludeArrayStruct,
      self.project.preludeMapStruct,
      self.project.preludeSetStruct,
    ]
    for struct in preludeStructs {
      if struct.label.position == Position(line: 0, col: 0) {
        val message = "Improperly initialized prelude struct ${struct.label.name}"
        val err = TypeError(position: struct.label.position, kind: TypeErrorKind.Unreachable(message))
        return Err(TypecheckerError(modulePath: preludeModulePathAbs, kind: TypecheckerErrorKind.TypeError(err)))
      }
    }

    val preludeEnums = [
      self.project.preludeOptionEnum,
    ]
    for enum_ in preludeEnums {
      if enum_.label.position == Position(line: 0, col: 0) {
        val message = "Improperly initialized prelude enum ${enum_.label.name}"
        val err = TypeError(position: enum_.label.position, kind: TypeErrorKind.Unreachable(message))
        return Err(TypecheckerError(modulePath: preludeModulePathAbs, kind: TypecheckerErrorKind.TypeError(err)))
      }
    }

    val mod = match self._typecheckModule(modulePathAbs) { Ok(v) => v, Err(e) => return Err(e) }

    Ok(mod)
  }

  func _tokenizeAndParse(self, modulePathAbs: String): Result<ParsedModule, TypecheckerError> {
    match self.moduleLoader.tokenizeAndParse(modulePathAbs) {
      Ok(mod) => Ok(mod)
      Err(e) => {
        val kind = match e {
          TokenizeAndParseError.ReadFileError(path) => TypecheckerErrorKind.ReadFileError(path)
          TokenizeAndParseError.LexerError(inner) => TypecheckerErrorKind.LexerError(inner)
          TokenizeAndParseError.ParseError(inner) => TypecheckerErrorKind.ParseError(inner)
        }

        return Err(TypecheckerError(modulePath: modulePathAbs, kind: kind))
      }
    }
  }

  func _verifyNameUniqueInScope(self, label: Label, scope: Scope): TypeError? {
    for importedModule in self.currentModuleImports.values() {
      for alias in importedModule.aliases {
        if alias.name == label.name {
          return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: alias)))
        }
      }
      for _p in importedModule.imports {
        // TODO: destructuring
        val name = _p[0]
        val imp = _p[1]
        if name == label.name {
          return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: imp.label)))
        }
      }
    }

    for v in scope.variables {
      if v.label.name == label.name {
        return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: v.label)))
      }
    }

    for f in scope.functions {
      if f.label.name == label.name {
        return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: f.label)))
      }
    }

    for s in scope.structs {
      if s.label.name == label.name {
        return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: s.label)))
      }
    }

    None
  }

  func _addVariableToScope(self, variable: Variable, scope = self.currentScope): Result<Int, TypeError> {
    if variable.label.name == "_" return Ok(0) // <- unnecessary 0

    if self._verifyNameUniqueInScope(variable.label, scope) |e| return Err(e)
    scope.variables.push(variable)

    Ok(0) // <- unnecessary 0
  }

  func _addFunctionToScope(self, fn: Function, scope = self.currentScope): Result<Int, TypeError> {
    if self._verifyNameUniqueInScope(fn.label, scope) |e| return Err(e)
    scope.functions.push(fn)

    Ok(0) // <- unnecessary 0
  }

  func _addStructToScope(self, struct: Struct, isExported: Bool, scope = self.currentScope): Result<Int, TypeError> {
    val structTy = Type(kind: TypeKind.Type(type_: StructOrEnum.Struct(struct)))
    match self._addTypeToScope(structTy) { Ok(v) => v, Err(e) => return Err(e) }

    val variable = Variable(label: struct.label, mutable: false, ty: structTy, alias: Some(VariableAlias.Struct(struct)))
    match self._addVariableToScope(variable) { Ok(v) => v, Err(e) => return Err(e) }

    scope.structs.push(struct)

    if isExported {
      variable.isExported = true
      self.currentModuleExports[struct.label.name] = Export.Type(StructOrEnum.Struct(struct), variable)
    }

    Ok(0) // <- unnecessary 0
  }

  func _addEnumToScope(self, enum_: Enum, isExported: Bool, scope = self.currentScope): Result<Int, TypeError> {
    val enumTy = Type(kind: TypeKind.Type(type_: StructOrEnum.Enum(enum_)))
    match self._addTypeToScope(enumTy) { Ok(v) => v, Err(e) => return Err(e) }

    val variable = Variable(label: enum_.label, mutable: false, ty: enumTy, alias: Some(VariableAlias.Enum(enum_)))
    match self._addVariableToScope(variable) { Ok(v) => v, Err(e) => return Err(e) }

    scope.enums.push(enum_)

    if isExported {
      variable.isExported = true
      self.currentModuleExports[enum_.label.name] = Export.Type(StructOrEnum.Enum(enum_), variable)
    }

    Ok(0) // <- unnecessary 0
  }

  func _addTypeToScope(self, ty: Type, scope = self.currentScope): Result<Int, TypeError> {
    scope.types.push(ty)

    Ok(0) // <- unnecessary 0
  }

  func _findModuleByAlias(self, name: String): Result<(TypedModule, Label)?, TypeError> {
    for _m in self.currentModuleImports {
      // TODO: destructuring
      val importModulePath = _m[0]
      val importedModule = _m[1]
      if importedModule.aliases.find(a => a.name == name) |alias| {
        val mod = if self.project.modules[importModulePath] |m| m else return unreachable(alias.position, "unknown module")
        return Ok(Some((mod, alias)))
      }
    }

    Ok(None)
  }

  func _verifyNumTypeArgs(self, position: Position, typeArguments: TypeIdentifier[], num: Int): Result<Type[], TypeError> {
    if typeArguments.length != num {
      return Err(TypeError(position: position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: num, given: typeArguments.length)))
    }

    val types: Type[] = []
    for i in range(0, num) {
      val typeIdent = if typeArguments.get(i) |typeIdent| typeIdent else return unreachable(position, "verified above that typeArguments.length == num")
      val ty = match self._resolveTypeIdentifier(typeIdent) { Ok(v) => v, Err(e) => return Err(e) }
      types.push(ty)
    }

    Ok(types)
  }

  func _resolveInstanceTypeIdentifier(self, structOrEnum: StructOrEnum, label: Label, typeArguments: TypeIdentifier[]): Result<Type?, TypeError> {
    match structOrEnum {
      StructOrEnum.Struct(struct) => {
        if label.name == struct.label.name {
          val instanceTypeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, struct.typeParams.length) { Ok(v) => v, Err(e) => return Err(e) }
          return Ok(Some(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), instanceTypeArgs))))
        }
      }
      StructOrEnum.Enum(enum_) => {
        if label.name == enum_.label.name {
          val instanceTypeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, enum_.typeParams.length) { Ok(v) => v, Err(e) => return Err(e) }
          return Ok(Some(Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), instanceTypeArgs))))
        }
      }
    }

    Ok(None)
  }

  func _findTypeByNameInScope(self, label: Label, startingScope = self.currentScope): Result<Type, TypeError> {
    match label.name {
      "Any" => Ok(Type(kind: TypeKind.Any))
      "Unit" => Ok(Type(kind: TypeKind.PrimitiveUnit))
      "Int" => Ok(Type(kind: TypeKind.PrimitiveInt))
      "Float" => Ok(Type(kind: TypeKind.PrimitiveFloat))
      "Bool" => Ok(Type(kind: TypeKind.PrimitiveBool))
      "String" => Ok(Type(kind: TypeKind.PrimitiveString))
      "Map" => Ok(Type(kind: TypeKind.Type(StructOrEnum.Struct(self.project.preludeMapStruct))))
      "Set" => Ok(Type(kind: TypeKind.Type(StructOrEnum.Struct(self.project.preludeSetStruct))))
      _ => {
        var scope = Some(self.currentScope)
        while scope |sc| {
          for ty in sc.types {
            match ty.kind {
              TypeKind.Generic(name) => { if label.name == name return Ok(ty) }
              TypeKind.Type(structOrEnum) => {
                match structOrEnum {
                  StructOrEnum.Struct(struct) => { if label.name == struct.label.name return Ok(ty) }
                  StructOrEnum.Enum(enum_) => { if label.name == enum_.label.name return Ok(ty) }
                }
              }
              _ => continue
            }
          }
          scope = sc.parent
        }

        for ty in self.project.preludeScope.types {
          match ty.kind {
            TypeKind.Generic(name) => { if label.name == name return Ok(ty) }
            TypeKind.Type(structOrEnum) => {
              match structOrEnum {
                StructOrEnum.Struct(struct) => { if label.name == struct.label.name return Ok(ty) }
                StructOrEnum.Enum(enum_) => { if label.name == enum_.label.name return Ok(ty) }
              }
            }
            _ => continue
          }
        }

        for importedModule in self.currentModuleImports.values() {
          for _p in importedModule.imports {
            // TODO: destructuring
            val name = _p[0]
            val imp = _p[1]
            if name == label.name {
              match imp.kind {
                TypedImportKind.Type(structOrEnum, _) => {
                  val ty = Type(kind: TypeKind.Type(structOrEnum))
                  match structOrEnum {
                    StructOrEnum.Struct(struct) => { if label.name == struct.label.name return Ok(ty) }
                    StructOrEnum.Enum(enum_) => { if label.name == enum_.label.name return Ok(ty) }
                  }
                }
                _ => continue
              }
            }
          }
        }

        return Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
      }
    }
  }

  func _resolveTypeIdentifier(self, typeIdent: TypeIdentifier): Result<Type, TypeError> {
    val ty = match typeIdent {
      TypeIdentifier.Normal(label, typeArguments, path) => {
        if path[0] |firstSeg| {
          val _mod = match self._findModuleByAlias(firstSeg.name) { Ok(v) => v, Err(e) => return Err(e) }
          val _m = if _mod |mod| mod else return Err(TypeError(position: firstSeg.position, kind: TypeErrorKind.UnknownName(firstSeg.name, "module")))
          // TODO: destructuring
          val mod = _m[0]
          val aliasLabel = _m[1]

          if path[1] |seg| return todo(seg.position, "qualified type paths longer than 2")

          val foundTy = match mod.exports[label.name] {
            None => return Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownImportForAlias(label.name, aliasLabel)))
            Export.Type(structOrEnum, _) => {
              val t = match self._resolveInstanceTypeIdentifier(structOrEnum, label, typeArguments) { Ok(v) => v, Err(e) => return Err(e) }
              t
            }
            _ => None
          }

          // TODO: clean this up, it's not ideal
          val res: Result<Type, TypeError> = if foundTy |ty|
            Ok(ty)
          else
            Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
          return res
        }

        val ty = match self._findTypeByNameInScope(label) { Ok(v) => v, Err(e) => return Err(e) }
        val t = match ty.kind {
          TypeKind.Type(structOrEnum) => {
            val t = match structOrEnum {
              StructOrEnum.Struct(struct) => {
                val instanceTypeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, struct.typeParams.length) { Ok(v) => v, Err(e) => return Err(e) }
                Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), instanceTypeArgs))
              }
              StructOrEnum.Enum(enum_) => {
                val instanceTypeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, enum_.typeParams.length) { Ok(v) => v, Err(e) => return Err(e) }
                Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), instanceTypeArgs))
              }
            }
            t
          }
          _ => {
            match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Ok(v) => v, Err(e) => return Err(e) }
            ty
          }
        }
        t
      }
      TypeIdentifier.Array(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Ok(v) => v, Err(e) => return Err(e) }
        Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [innerTy]))
      }
      TypeIdentifier.Option(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Ok(v) => v, Err(e) => return Err(e) }
        Type(kind: TypeKind.Instance(StructOrEnum.Enum(self.project.preludeOptionEnum), [innerTy]))
      }
      TypeIdentifier.Tuple(typeIdents) => {
        val types: Type[] = []
        for typeIdent in typeIdents {
          val ty = match self._resolveTypeIdentifier(typeIdent) { Ok(v) => v, Err(e) => return Err(e) }
          types.push(ty)
        }

        Type(kind: TypeKind.Tuple(types))
      }
      TypeIdentifier.Function(params, ret) => {
        val paramTypes: (Type, Bool)[] = []
        for p in params {
          val t = match self._resolveTypeIdentifier(p) { Ok(v) => v, Err(e) => return Err(e) }
          paramTypes.push((t, true))
        }

        val returnType = match self._resolveTypeIdentifier(ret) { Ok(v) => v, Err(e) => return Err(e) }
        Type(kind: TypeKind.Func(paramTypes, returnType))
      }
    }

    Ok(ty)
  }

  // TODO: At some point, make this work with module alias types (eg. `foo.Bar` and `foo.Baz.Qux` for a module `foo` containing type `Bar` and enum `Baz`)
  //       This can perhaps be called in place of the current body for `TypeIdentifier.Normal` in `_resolveTypeIdentifier` above, and fail if the result
  //       if Right (because enum variants are not (yet?) valid individually-addressable types).
  func _resolveTypeOrEnumVariant(self, path: Label[], last: Label): Result<Either<Type, (Enum, TypedEnumVariant, Int)>, TypeError> {
    match path[0] {
      None => {
        val ty = match self._findTypeByNameInScope(last) { Ok(v) => v, Err(e) => return Err(e) }
        val t = match ty.kind {
          TypeKind.Type(structOrEnum) => Type(kind: TypeKind.Instance(structOrEnum, []))
          _ => ty
        }
        return Ok(Either.Left(t))
      }
      _ first => {
        val mod = match self._findModuleByAlias(first.name) { Ok(v) => v, Err(e) => return Err(e) }
        match mod {
          None => {
            val ty = match self._findTypeByNameInScope(first) { Ok(v) => v, Err(e) => return Err(e) }
            val label = if path[1] |seg| {
              return Err(TypeError(position: seg.position, kind: TypeErrorKind.UnknownName(seg.name, "type")))
            } else {
              last
            }
            val _p = match ty.kind {
              TypeKind.Type(structOrEnum) => {
                val _p = match structOrEnum {
                  StructOrEnum.Enum(enum_) => {
                    val t = if enum_.variants.findIndex(v => v.label.name == label.name) |_p| {
                      // TODO: destructuring
                      Some((enum_, _p))
                    } else {
                      return Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
                    }
                    t
                  }
                  _ => None
                }
                _p
              }
              _ => None
            }

            if _p |_p| {
              // TODO: destructuring
              val enum_ = _p[0]
              val variant = _p[1][0]
              val variantIdx = _p[1][1]
              Ok(Either.Right((enum_, variant, variantIdx)))
            } else {
              Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
            }
          }
          _ => {
            return todo(first.position, "module aliases")
          }
        }
      }
    }
  }

  func _resolveIdentifier(self, ident: String): Variable? {
    var scope: Scope? = Some(self.currentScope)
    while scope |s| {
      for v in s.variables {
        if v.label.name == ident return Some(v)
      }
      scope = s.parent
    }

    for v in self.project.preludeScope.variables {
      if v.label.name == ident return Some(v)
    }

    for importedModule in self.currentModuleImports.values() {
      for _p in importedModule.imports {
        // TODO: destructuring
        val importedName = _p[0]
        val importedValue = _p[1]
        if importedName == ident {
          val v = match importedValue.kind {
            TypedImportKind.Variable(v) => v
            TypedImportKind.Function(aliasVar) => aliasVar
            TypedImportKind.Type(_, aliasVar) => aliasVar
          }
          return Some(v)
        }
      }
    }

    None
  }

  func _typesAreEquivalent(self, ty: Type, other: Type): Bool {
    match ty.kind {
      TypeKind.Hole => other.kind == TypeKind.Hole
      TypeKind.Generic(n1) => match other.kind {
        TypeKind.Generic(n2) => n1 == n2
        _ => false
      }
      TypeKind.PrimitiveInt => match other.kind {
        TypeKind.PrimitiveInt => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeIntStruct)
        _ => false
      }
      TypeKind.PrimitiveFloat => match other.kind {
        TypeKind.PrimitiveFloat => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeFloatStruct)
        _ => false
      }
      TypeKind.PrimitiveBool => match other.kind {
        TypeKind.PrimitiveBool => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeBoolStruct)
        _ => false
      }
      TypeKind.PrimitiveString => match other.kind {
        TypeKind.PrimitiveString => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeStringStruct)
        _ => false
      }
      TypeKind.Func(reqParamTypes, reqRetType) => match ty.kind {
        TypeKind.Func(paramTypes, retType) => {
          if !self._typesAreEquivalent(ty: retType, other: reqRetType) return false

          var idx = 0
          for reqParamType, i in reqParamTypes {
            val paramType = if paramTypes[i] |t| t[0] else { return true }
            if !self._typesAreEquivalent(ty: paramType, other: reqParamType[0]) return false

            idx = i
          }
          if paramTypes[idx + 1] |nextParam| {
            if nextParam[1] return false
          }

          true
        }
        _ => false
      }
      TypeKind.Instance(reqStructOrEnum, reqTypeArgs) => match ty.kind {
        TypeKind.Instance(structOrEnum, typeArgs) => {
          if reqStructOrEnum != structOrEnum return false
          if reqTypeArgs.length != typeArgs.length return false
          for reqTypeArg, i in reqTypeArgs {
            val typeArg = if typeArgs[i] |t| t else { return true }
            if !self._typesAreEquivalent(ty: typeArg, other: reqTypeArg) return false
          }

          true
        }
        TypeKind.PrimitiveInt => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeIntStruct)
        TypeKind.PrimitiveFloat => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeFloatStruct)
        TypeKind.PrimitiveBool => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeBoolStruct)
        TypeKind.PrimitiveString => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeStringStruct)
        _ => false
      }
      TypeKind.Tuple(reqTypes) => match ty.kind {
        TypeKind.Tuple(types) => {
          if reqTypes.length != types.length return false
          for reqTy, i in reqTypes {
            val ty = if types[i] |t| t else { /* unreachable, length verified above to be equal */ return false }
            if !self._typesAreEquivalent(ty: ty, other: reqTy) return false
          }

          true
        }
        _ => false
      }
      _ => false
    }
  }

  func _typeSatisfiesRequired(self, ty: Type, required: Type): Bool {
    if required.kind == TypeKind.Hole return true
    if required.kind == TypeKind.Never || ty.kind == TypeKind.Never return true
    if required.kind == TypeKind.Any return true

    match required.kind {
      TypeKind.PrimitiveInt => match ty.kind {
        TypeKind.PrimitiveInt => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeIntStruct)
        _ => false
      }
      TypeKind.PrimitiveFloat => match ty.kind {
        TypeKind.PrimitiveFloat => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeFloatStruct)
        _ => false
      }
      TypeKind.PrimitiveBool => match ty.kind {
        TypeKind.PrimitiveBool => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeBoolStruct)
        _ => false
      }
      TypeKind.PrimitiveString => match ty.kind {
        TypeKind.PrimitiveString => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeStringStruct)
        _ => false
      }
      TypeKind.Func(reqParamTypes, reqRetType) => match ty.kind {
        TypeKind.Func(paramTypes, retType) => {
          if !self._typeSatisfiesRequired(ty: retType, required: reqRetType) return false

          var idx = 0
          for reqParamType, i in reqParamTypes {
            val paramType = if paramTypes[i] |t| t[0] else { return true }
            if !self._typeSatisfiesRequired(ty: paramType, required: reqParamType[0]) return false

            idx = i
          }
          if paramTypes[idx + 1] |nextParam| {
            if nextParam[1] return false
          }

          true
        }
        _ => false
      }
      TypeKind.Instance(reqStructOrEnum, reqTypeArgs) => match ty.kind {
        TypeKind.Instance(structOrEnum, typeArgs) => {
          if reqStructOrEnum != structOrEnum return false

          if reqTypeArgs.length != typeArgs.length return false
          for reqTypeArg, i in reqTypeArgs {
            val typeArg = if typeArgs[i] |t| t else { return true }
            if !self._typeSatisfiesRequired(ty: typeArg, required: reqTypeArg) return false
          }

          true
        }
        TypeKind.PrimitiveInt => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeIntStruct)
        TypeKind.PrimitiveFloat => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeFloatStruct)
        TypeKind.PrimitiveBool => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeBoolStruct)
        TypeKind.PrimitiveString => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeStringStruct)
        _ => false
      }
      TypeKind.Tuple(reqTypes) => match ty.kind {
        TypeKind.Tuple(types) => {
          if reqTypes.length != types.length return false
          for reqTy, i in reqTypes {
            val ty = if types[i] |t| t else { /* unreachable, length verified above to be equal */ return false }
            if !self._typeSatisfiesRequired(ty: ty, required: reqTy) return false
          }

          true
        }
        _ => false
      }
      _ => {
        ty.kind == required.kind
      }
    }
  }

  func _containsGenerics(self, ty: Type): Bool {
    match ty.kind {
      TypeKind.Generic(name) => true
      TypeKind.Instance(_, typeArgs) => typeArgs.any(t => self._containsGenerics(t))
      TypeKind.Tuple(typeArgs) => typeArgs.any(t => self._containsGenerics(t))
      TypeKind.Func(paramTypes, returnType) => {
        if self._containsGenerics(returnType) return true

        paramTypes.any(p => self._containsGenerics(p[0]))
      }
      _ => false
    }
  }

  func __extractGenerics(self, template: Type, source: Type, extracted: (String, Type)[]) {
    match template.kind {
      TypeKind.Generic(name) => {
        extracted.push((name, source))
      }
      TypeKind.Instance(_, templateTypeArgs) => {
        match source.kind {
          TypeKind.Instance(_, sourceTypeArgs) => {
            if templateTypeArgs.length != sourceTypeArgs.length {
              __assertUnreachable("templateTypeArgs.length != sourceTypeArgs.length")
              return
            }
            for tplTypeArg, idx in templateTypeArgs {
              val srcTypeArg = if sourceTypeArgs[idx] |t| t else {
                __assertUnreachable("templateTypeArgs.length != sourceTypeArgs.length")
                return
              }
              self.__extractGenerics(template: tplTypeArg, source: srcTypeArg, extracted: extracted)
            }
          }
          _ => {}
        }
      }
      TypeKind.Tuple(templateTypes) => {
        match source.kind {
          TypeKind.Tuple(sourceTypes) => {
            for tplType, idx in templateTypes {
              val srcType = if sourceTypes[idx] |t| t else break
              self.__extractGenerics(template: tplType, source: srcType, extracted: extracted)
            }
          }
          _ => {}
        }
      }
      TypeKind.Func(templateParamTypes, templateReturnType) => {
        match source.kind {
          TypeKind.Func(sourceParamTypes, sourceReturnType) => {
            self.__extractGenerics(template: templateReturnType, source: sourceReturnType, extracted: extracted)

            for tplParamType, idx in templateParamTypes {
              val srcParamType = if sourceParamTypes[idx] |t| t else break
              self.__extractGenerics(template: tplParamType[0], source: srcParamType[0], extracted: extracted)
            }
          }
          _ => {}
        }
      }
      _ => {}
    }
  }

  func _extractGenerics(self, template: Type, source: Type): (String, Type)[] {
    val extracted: (String, Type)[] = []
    self.__extractGenerics(template, source, extracted)
    extracted
  }

  func _genericsInScope(self): Set<String> {
    val genericsInScope: Set<String> = #{}
    if self.currentFunction |fn| {
      for _p in fn.typeParams {
        match _p[0].kind {
          TypeKind.Generic(name) => genericsInScope.insert(name)
          _ => {
            __assertUnreachable("typeParam.kind != TypeKind.Generic")
            return #{}
          }
        }
      }

      if fn.kind == FunctionKind.InstanceMethod {
        if self.currentTypeDecl |typeDecl| {
          val genericNames = match typeDecl {
            StructOrEnum.Struct(struct) => struct.typeParams,
            StructOrEnum.Enum(enum_) => enum_.typeParams,
          }
          for name in genericNames {
            genericsInScope.insert(name)
          }
        }
      }
    }

    genericsInScope
  }

  func _typeAsInstance1(self, ty: Type, struct: Struct): Type? {
    match ty.kind {
      TypeKind.Instance(s, generics) => if s == StructOrEnum.Struct(struct) { generics[0] } else None
      _ => None
    }
  }

  func _typeAsInstance2(self, ty: Type, struct: Struct): (Type, Type)? {
    match ty.kind {
      TypeKind.Instance(s, generics) => if s == StructOrEnum.Struct(struct) {
        if generics[0] |g1| (if generics[1] |g2| Some((g1, g2)) else None) else None
      } else None
      _ => None
    }
  }

  func _ensureValidExportScope(self, exportToken: Token): Result<Int, TypeError> {
    if self.currentScope.kind != ScopeKind.Module {
      Err(TypeError(position: exportToken.position, kind: TypeErrorKind.IllegalExportScope))
    } else {
      Ok(0) // <-- unnecessary int
    }
  }

  func _typecheckModule(self, modulePathAbs: String): Result<TypedModule, TypecheckerError> {
    val moduleId = self.project.modules.size
    self.currentModuleId = moduleId

    val moduleScope = self.currentScope.makeChild("module_$moduleId", ScopeKind.Module)
    if moduleId == 0 {
      self.project.preludeScope = moduleScope
    }
    val prevScope = self.currentScope
    self.currentScope = moduleScope
    val mod = TypedModule(id: moduleId, name: modulePathAbs, code: [], rootScope: moduleScope)
    self.project.modules[modulePathAbs] = mod

    val parsedModule = match self._tokenizeAndParse(modulePathAbs) { Ok(v) => v, Err(e) => return Err(e) }
    for importNode in parsedModule.imports {
      var importNodePath = importNode.moduleName.name
      val isRelativeImport = importNodePath.startsWith(".")
      if !importNodePath.endsWith(".abra") importNodePath += ".abra"

      val importPathAbs = if !isRelativeImport {
        self.moduleLoader.stdRoot + "/" + importNodePath
      } else {
        self.moduleLoader.resolvePath(modulePath: importNodePath, relativeTo: Some(modulePathAbs))
      }

      val typedImportModule = if self.project.modules[importPathAbs] |m| {
        if !m.complete {
          val err = TypeError(position: importNode.moduleName.position, kind: TypeErrorKind.CircularDependency)
          return Err(TypecheckerError(modulePath: modulePathAbs, kind: TypecheckerErrorKind.TypeError(err)))
        }

        m
      } else {
        val childTypechecker = Typechecker(moduleLoader: self.moduleLoader, project: self.project)
        val typedImportModule = match childTypechecker._typecheckModule(importPathAbs) {
          Ok(m) => m
          Err(e) => {
            val err = match e.kind {
              TypecheckerErrorKind.ReadFileError => {
                val kind = if isRelativeImport {
                  TypeErrorKind.UnknownModule(importPathAbs, true)
                } else {
                  TypeErrorKind.UnknownModule(importNode.moduleName.name, false)
                }

                val err = TypeError(position: importNode.moduleName.position, kind: kind)
                TypecheckerError(modulePath: modulePathAbs, kind: TypecheckerErrorKind.TypeError(err))
              }
              _ => e
            }

            return Err(err)
          }
        }

        typedImportModule
      }

      match self._typecheckImport(typedImportModule, importNode) {
        Ok(v) => v
        Err(e) => return Err(TypecheckerError(modulePath: modulePathAbs, kind: TypecheckerErrorKind.TypeError(e)))
      }
    }

    mod.code = match self._typecheckBlock(parsedModule.nodes) {
      Ok(v) => v
      Err(e) => return Err(TypecheckerError(modulePath: modulePathAbs, kind: TypecheckerErrorKind.TypeError(e)))
    }

    mod.imports = self.currentModuleImports
    self.currentModuleImports = {} // is this necessary?

    mod.exports = self.currentModuleExports
    self.currentModuleExports = {} // is this necessary?

    self.currentScope = prevScope

    mod.complete = true
    Ok(mod)
  }

  func _typecheckDecoratorNode(self, dec: DecoratorNode): Result<Decorator, TypeError> {
    val args: LiteralAstNode[] = []
    for arg in dec.arguments {
      val typedArg = match self._typecheckExpression(arg.value, None) { Ok(v) => v, Err(e) => return Err(e) }
      match typedArg.kind {
        TypedAstNodeKind.Literal(litNode) => args.push(litNode)
        _ => return unreachable(typedArg.token.position, "should have been caught during parsing")
      }
    }

    Ok(Decorator(label: dec.name, arguments: args))
  }

  func _typecheckFunctionPass1(self, node: FunctionDeclarationNode): Result<Function, TypeError> {
    val decorators: Decorator[] = []
    for d in node.decorators {
      val dec = match self._typecheckDecoratorNode(d) { Ok(v) => v, Err(e) => return Err(e) }
      decorators.push(dec)
    }

    val fnScope = self.currentScope.makeChild(node.name.name, ScopeKind.Func)
    val prevScope = self.currentScope
    self.currentScope = fnScope

    val typeParams: (Type, Label)[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        return Err(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenTypeParams[label.name] = label

      val generic = Type(kind: TypeKind.Generic(label.name))
      match self._addTypeToScope(generic) { Ok(v) => v, Err(e) => return Err(e) }
      typeParams.push((generic, label))
    }

    val returnType = if node.returnTypeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Ok(v) => v, Err(e) => return Err(e) }
      ty
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    self.currentScope = prevScope

    val hasSelf = if node.params[0] |param| param.label.name == "self" else false
    val fnKind = if hasSelf {
      if !self.currentTypeDecl {
        val param = if node.params[0] |p| p else return unreachable(node.name.position, "expected a first parameter to be present")
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))
      }

      FunctionKind.InstanceMethod
    } else if self.currentTypeDecl {
      FunctionKind.StaticMethod
    } else {
      FunctionKind.Standalone
    }

    val fn = Function(label: node.name, scope: fnScope, kind: fnKind, typeParams: typeParams, params: [], returnType: returnType, body: [], decorators: decorators)
    match self._addFunctionToScope(fn) { Ok(v) => v, Err(e) => return Err(e) }

    Ok(fn)
  }

  func _typecheckFunctionParam(self, param: FunctionParam, typeHint: Type?, allowSelf: Bool, isRevisit = false): Result<(TypedFunctionParam, Bool), TypeError> {
    if param.label.name == "self" {
      if !allowSelf return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))

      if self.currentTypeDecl |structOrEnum| {
        val ty = match structOrEnum {
          StructOrEnum.Struct(struct) => {
            val typeArgs = struct.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
            Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs))
          }
          StructOrEnum.Enum(enum_) => {
            val typeArgs = enum_.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
            Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), typeArgs))
          }
        }

        val variable = Variable(label: param.label, mutable: false, ty: ty)
        match self._addVariableToScope(variable) { Ok(v) => v, Err(e) => return Err(e) }

        val typedParam = TypedFunctionParam(label: param.label, ty: ty, defaultValue: None, isVariadic: false)
        return Ok((typedParam, false))
      }

      return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))
    }

    val paramType = if param.typeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Ok(v) => v, Err(e) => return Err(e) }
      if typeHint |hintTy| {
        if !self._typeSatisfiesRequired(ty: ty, required: hintTy) {
          return Err(TypeError(position: param.label.position, kind: TypeErrorKind.TypeMismatch([hintTy], ty)))
        }
      }
      Some(ty)
    } else if typeHint |hintTy| {
      Some(hintTy)
    } else {
      None
    }

    var defaultValue: TypedAstNode? = None
    if param.defaultValue |node| {
      if isRevisit {
        val expr = match self._typecheckExpression(node, paramType) { Ok(v) => v, Err(e) => return Err(e) }
        defaultValue = Some(expr)
      } else {
        // TODO: There has to be a cleaner way of representing this
        val ctx = ParamDefaultValueContext()
        self.paramDefaultValueContext = Some(ctx)
        val expr = match self._typecheckExpression(node, paramType) {
          Ok(v) => v
          Err(e) => {
            self.paramDefaultValueContext = None
            if ctx.exprContainsFunctionCall || ctx.exprContainsVariableRef {
              val placeholder = Some(TypedAstNode(token: node.token, ty: Type(kind: TypeKind.Hole), kind: TypedAstNodeKind.Placeholder))
              val typedParam = TypedFunctionParam(label: param.label, ty: Type(kind: TypeKind.Hole), defaultValue: placeholder, isVariadic: param.isVariadic)
              return Ok((typedParam, true))
            }
            return Err(e)
          }
        }
        self.paramDefaultValueContext = None
        if ctx.exprContainsFunctionCall || ctx.exprContainsVariableRef {
          val typedParam = TypedFunctionParam(label: param.label, ty: paramType ?: expr.ty, defaultValue: Some(expr), isVariadic: param.isVariadic)
          return Ok((typedParam, true))
        }
        defaultValue = Some(expr)
      }
    }

    var ty = if paramType |paramType| {
      if defaultValue |defaultValue| {
        if !self._typeSatisfiesRequired(ty: defaultValue.ty, required: paramType) {
          return Err(TypeError(position: defaultValue.token.position, kind: TypeErrorKind.TypeMismatch([paramType], defaultValue.ty)))
        }
      }

      paramType
    } else {
      if defaultValue |defaultValue| {
        defaultValue.ty
      } else {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.UnknownParameterType(param.label.name)))
      }
    }

    val variable = Variable(label: param.label, mutable: false, ty: ty)
    match self._addVariableToScope(variable) { Ok(v) => v, Err(e) => return Err(e) }

    if param.isVariadic {
      if self._typeAsInstance1(ty, self.project.preludeArrayStruct) |innerType| {
        ty = innerType
      } else {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidVarargType(ty)))
      }
    }

    if ty.hasUnfilledHoles() {
      return Err(TypeError(position: param.label.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "parameter")))
    }

    val typedParam = TypedFunctionParam(label: param.label, ty: ty, defaultValue: defaultValue, isVariadic: param.isVariadic)
    Ok((typedParam, false))
  }

  func _typecheckFunctionPass2(self, fn: Function, allowSelf: Bool, params: FunctionParam[], paramHints: Type[] = []): Result<Int[], TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope

    val paramsNeedingRevisit: Int[] = []
    val seenParamNames: Set<String> = #{}
    var startedOptionalParams = false
    for param, idx in params {
      if param.isVariadic && idx != params.length - 1 {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "vararg")))
      }

      if seenParamNames.contains(param.label.name) {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.DuplicateParameter(param.label.name)))
      }
      seenParamNames.insert(param.label.name)

      if param.defaultValue {
        startedOptionalParams = true
      } else if startedOptionalParams {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "required")))
      }

      val hint = paramHints[idx]
      val _p = match self._typecheckFunctionParam(param, hint, allowSelf) { Ok(v) => v, Err(e) => return Err(e) }
      // TODO: destructuring
      val typedParam = _p[0]
      val needsRevisit = _p[1]
      val paramName = typedParam.label.name
      // This is a bit messy - if param is `self` then don't add here; it's already denoted as an instance method via its FunctionKind
      if paramName != "self" { fn.params.push(typedParam) }
      // Adjust the index value if we're in an instance method, since `self` isn't included in the fn.params array
      if needsRevisit {
        val paramIdx = if fn.kind == FunctionKind.InstanceMethod idx - 1 else idx
        paramsNeedingRevisit.push(paramIdx)
      }
    }

    self.currentScope = prevScope

    Ok(paramsNeedingRevisit)
  }

  func _typecheckFunctionPass3(self, fn: Function, allowSelf: Bool, params: FunctionParam[], body: AstNode[], paramsNeedingRevisit: Int[], paramHints: Type[] = []): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope
    val prevFn = self.currentFunction
    self.currentFunction = Some(fn)

    val hasReturnValue = fn.returnType.kind != TypeKind.PrimitiveUnit
    if hasReturnValue && body.isEmpty() {
      if !fn.decorators.find(dec => dec.label.name == "Stub" || dec.label.name == "Intrinsic" || dec.label.name == "CBinding")
        return Err(TypeError(position: fn.label.position, kind: TypeErrorKind.ReturnTypeMismatch(Some(fn.label.name), fn.returnType, None)))
    }

    for param, idx in fn.params {
      if !paramsNeedingRevisit.contains(idx) continue

      // Since `self` is not included in the fn.params array, but it is in the untyped AST, when referring to the untyped AST, we need to adjust
      val origNodeParamIdx = if fn.kind == FunctionKind.InstanceMethod idx + 1 else idx
      val paramNode = if params[origNodeParamIdx] |p| p else return unreachable(param.label.position, "there should be as many parameter nodes as typed parameters")
      val defaultValueNode = if paramNode.defaultValue |n| n else return unreachable(param.label.position, "the only way a parameter needs revisiting is if it has a default value")

      val hint = paramHints[idx]
      val _p = match self._typecheckFunctionParam(param: paramNode, typeHint: hint, allowSelf: allowSelf, isRevisit: true) { Ok(v) => v, Err(e) => return Err(e) }
      // TODO: destructuring
      val typedParam = _p[0]
      val needsRevisit = _p[1]
      if needsRevisit return unreachable(param.label.position, "parameters should not need to be revisited more than once")
      fn.params[idx] = typedParam
    }

    for node, idx in body {
      if self.currentScope.terminator == Some(Terminator.Returning) return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = if idx == body.length - 1 && hasReturnValue {
        val fnName = if fn.isLambda None else Some(fn.label.name)
        val err = TypeError(position: node.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Some(Type(kind: TypeKind.PrimitiveUnit))))
        match node.kind {
          AstNodeKind.While => return Err(err)
          AstNodeKind.For => return Err(err)
          AstNodeKind.BindingDeclaration => return Err(err)
          AstNodeKind.FunctionDeclaration => return Err(err)
          AstNodeKind.TypeDeclaration => return Err(err)
          AstNodeKind.EnumDeclaration => return Err(err)
          _ => {}
        }

        // Typecheck final expression, passing the function's returnType as the hint if it doesn't have any unfilled holes (when typechecking
        // a lambda function, its returnType will always start off as a Hole). Once we have a typechecked expression, attempt to fill any holes
        // that may exist in the function's returnType as well as the expression; this bidirectional hole-filling is necessary to support this
        // case, for example:
        //   val fn = () => {
        //     if true return Err("hello")
        //     Ok(123)
        //   }
        val hint = if fn.returnType.hasUnfilledHoles() None else Some(fn.returnType)
        val expr = match self._typecheckExpressionOrTerminator(node, hint) { Ok(v) => v, Err(e) => return Err(e) }
        if fn.returnType.hasUnfilledHoles() {
          fn.returnType.tryFillHoles(expr.ty)
        }
        if expr.ty.hasUnfilledHoles() {
          expr.ty.tryFillHoles(fn.returnType)
        }
        if !self._typeSatisfiesRequired(ty: expr.ty, required: fn.returnType) {
          val fnName = if fn.isLambda None else Some(fn.label.name)
          return Err(TypeError(position: expr.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Some(expr.ty))))
        }

        expr
      } else {
        val stmt = match self._typecheckStatement(node, None) { Ok(v) => v, Err(e) => return Err(e) }
        stmt
      }
      fn.body.push(typedNode)
    }

    self.currentFunction = prevFn
    self.currentScope = prevScope

    Ok(0)
  }

  func _typecheckStructPass1(self, node: TypeDeclarationNode): Result<Struct, TypeError> {
    val isExported = if node.exportToken |exportToken| {
      match self._ensureValidExportScope(exportToken) { Ok(v) => v, Err(e) => return Err(e) }
      true
    } else {
      false
    }

    val typeScope = self.currentScope.makeChild(node.name.name, ScopeKind.Type)
    val prevScope = self.currentScope
    self.currentScope = typeScope

    val typeParams: String[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        return Err(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenTypeParams[label.name] = label

      val generic = Type(kind: TypeKind.Generic(label.name))
      match self._addTypeToScope(generic) { Ok(v) => v, Err(e) => return Err(e) }
      typeParams.push(label.name)
    }

    self.currentScope = prevScope

    val struct = Struct(moduleId: self.currentModuleId, label: node.name, scope: typeScope, typeParams: typeParams)
    match self._addStructToScope(struct, isExported) { Ok(v) => v, Err(e) => return Err(e) }

    Ok(struct)
  }

  func _typecheckStructPass2_1(self, struct: Struct, node: TypeDeclarationNode): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(StructOrEnum.Struct(struct))

    val seenFields: Map<String, Label> = {}
    for field in node.fields {
      if seenFields[field.name.name] |original| {
        return Err(TypeError(position: field.name.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenFields[field.name.name] = field.name

      val ty = match self._resolveTypeIdentifier(field.typeAnnotation) { Ok(v) => v, Err(e) => return Err(e) }
      struct.fields.push(Field(name: field.name, ty: ty, initializer: None))
    }

    for funcDeclNode in node.methods {
      val fn = match self._typecheckFunctionPass1(funcDeclNode) { Ok(v) => v, Err(e) => return Err(e) }
      match fn.kind {
        FunctionKind.InstanceMethod => struct.instanceMethods.push(fn)
        FunctionKind.StaticMethod => struct.staticMethods.push(fn)
        FunctionKind.Standalone => return unreachable(fn.label.position, "method has invalid function kind at this point")
      }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(0)
  }

  func _typecheckMethodsPass2(self, structOrEnum: StructOrEnum, funcDeclNodes: FunctionDeclarationNode[]): Result<Map<Label, Int[]>, TypeError> {
    val allParamsNeedingRevisit: Map<Label, Int[]> = {}

    val _p = match structOrEnum {
      StructOrEnum.Struct(struct) => (struct.scope, struct.instanceMethods, struct.staticMethods)
      StructOrEnum.Enum(enum_) => (enum_.scope, enum_.instanceMethods, enum_.staticMethods)
    }
    // TODO: destructuring
    val scope = _p[0]
    val instanceMethods = _p[1]
    val staticMethods = _p[2]

    val selfInstanceType = match structOrEnum {
      StructOrEnum.Struct(struct) => {
        val typeArgs = struct.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
        Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs))
      }
      StructOrEnum.Enum(enum_) => Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), []))
    }

    val instanceMethodsByName = instanceMethods.keyBy(f => f.label)
    val staticMethodsByName = staticMethods.keyBy(f => f.label)
    var toStringFn: Function? = None
    var hashFn: Function? = None
    var eqFn: Function? = None
    for funcDeclNode in funcDeclNodes {
      var isToString = false
      var isHash = false
      var isEq = false
      val fn = if instanceMethodsByName[funcDeclNode.name] |fn| {
        isToString = fn.label.name == "toString"
        isHash = fn.label.name == "hash"
        isEq = fn.label.name == "eq"
        fn
      } else if staticMethodsByName[funcDeclNode.name] |fn| {
        fn
      } else {
        return unreachable(funcDeclNode.name.position, "could not find function among instance/static methods")
      }
      val paramsNeedingRevisit = match self._typecheckFunctionPass2(fn: fn, allowSelf: true, params: funcDeclNode.params) { Ok(v) => v, Err(e) => return Err(e) }
      allParamsNeedingRevisit[fn.label] = paramsNeedingRevisit

      if isToString {
        val required = Type(kind: TypeKind.Func([], Type(kind: TypeKind.PrimitiveString)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        toStringFn = Some(fn)
      }
      if isHash {
        val required = Type(kind: TypeKind.Func([], Type(kind: TypeKind.PrimitiveInt)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        hashFn = Some(fn)
      }
      if isEq {
        val required = Type(kind: TypeKind.Func([(selfInstanceType, true)], Type(kind: TypeKind.PrimitiveBool)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        eqFn = Some(fn)
      }
    }

    // Ensure toString/hash/eq methods exist (include generated stubs if not), and sure the proper order
    val reorderedInstanceMethods = [
      toStringFn ?: Function.generated(scope, "toString", [], Type(kind: TypeKind.PrimitiveString)),
      hashFn ?: Function.generated(scope, "hash", [], Type(kind: TypeKind.PrimitiveInt)),
      eqFn ?: Function.generated(scope, "eq", [("other", selfInstanceType)], Type(kind: TypeKind.PrimitiveBool)),
    ]
    for m in instanceMethods {
      if m.label.name == "toString" || m.label.name == "hash" || m.label.name == "eq" continue
      reorderedInstanceMethods.push(m)
    }

    match structOrEnum {
      StructOrEnum.Struct(struct) => struct.instanceMethods = reorderedInstanceMethods
      StructOrEnum.Enum(enum_) => enum_.instanceMethods = reorderedInstanceMethods
    }

    Ok(allParamsNeedingRevisit)
  }

  func _typecheckStructPass2_2(self, struct: Struct, node: TypeDeclarationNode): Result<Map<Label, Int[]>, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(StructOrEnum.Struct(struct))

    val allParamsNeedingRevisit = match self._typecheckMethodsPass2(StructOrEnum.Struct(struct), node.methods) { Ok(v) => v, Err(e) => return Err(e) }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(allParamsNeedingRevisit)
  }

  func _typecheckStructPass3(self, struct: Struct, node: TypeDeclarationNode, paramsNeedingRevisit: Map<Label, Int[]>): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(StructOrEnum.Struct(struct))

    for field, idx in node.fields {
      val initializer = if field.initializer |v| v else continue
      val structField = if struct.fields[idx] |f| f else return unreachable(struct.label.position, "")

      val typedInitializer = match self._typecheckExpression(initializer, Some(structField.ty)) { Ok(v) => v, Err(e) => return Err(e) }
      if !self._typeSatisfiesRequired(ty: typedInitializer.ty, required: structField.ty) {
        return Err(TypeError(position: initializer.token.position, kind: TypeErrorKind.TypeMismatch([structField.ty], typedInitializer.ty)))
      }
      structField.initializer = Some(typedInitializer)
    }

    val instanceMethods = struct.instanceMethods.keyBy(f => f.label)
    val staticMethods = struct.staticMethods.keyBy(f => f.label)
    for funcDeclNode in node.methods {
      val fnLabel = funcDeclNode.name
      val fn = if instanceMethods[fnLabel] |f| {
        f
      } else if staticMethods[fnLabel] |f| {
        f
      } else {
        return unreachable(funcDeclNode.name.position, "method not visited in prior pass")
      }

      val toRevisit = if paramsNeedingRevisit[fnLabel] |paramIds| paramIds else return unreachable(funcDeclNode.name.position, "params improperly visited in prior pass")
      match self._typecheckFunctionPass3(fn: fn, allowSelf: true, params: funcDeclNode.params, body: funcDeclNode.body, paramsNeedingRevisit: toRevisit) { Ok(v) => v, Err(e) => return Err(e) }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(0)
  }

  func _typecheckEnumPass1(self, node: EnumDeclarationNode): Result<Enum, TypeError> {
    val isExported = if node.exportToken |exportToken| {
      match self._ensureValidExportScope(exportToken) { Ok(v) => v, Err(e) => return Err(e) }
      true
    } else {
      false
    }

    val typeScope = self.currentScope.makeChild(node.name.name, ScopeKind.Type)
    val prevScope = self.currentScope
    self.currentScope = typeScope

    val typeParams: String[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        return Err(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenTypeParams[label.name] = label

      val generic = Type(kind: TypeKind.Generic(label.name))
      match self._addTypeToScope(generic) { Ok(v) => v, Err(e) => return Err(e) }
      typeParams.push(label.name)
    }

    self.currentScope = prevScope

    val enum_ = Enum(moduleId: self.currentModuleId, label: node.name, scope: typeScope, typeParams: typeParams)
    match self._addEnumToScope(enum_, isExported) { Ok(v) => v, Err(e) => return Err(e) }

    Ok(enum_)
  }

  func _typecheckEnumPass2_1(self, enum_: Enum, node: EnumDeclarationNode): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = enum_.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(StructOrEnum.Enum(enum_))

    var allVariantsConstant = true
    val seenVariants: Map<String, Label> = {}
    for variant, idx in node.variants {
      val variantLabel = match variant { EnumVariant.Constant(label) => label, EnumVariant.Container(label, _) => label }
      if seenVariants[variantLabel.name] |original| {
        return Err(TypeError(position: variantLabel.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenVariants[variantLabel.name] = variantLabel

      match variant {
        EnumVariant.Constant(label) => {
          enum_.variants.push(TypedEnumVariant(label: label, kind: EnumVariantKind.Constant))
        }
        EnumVariant.Container(label, fields) => {
          allVariantsConstant = false

          val typedFields: Field[] = []
          val seenFields: Map<String, Label> = {}
          for field in fields {
            if seenFields[field.name.name] |original| {
              return Err(TypeError(position: field.name.position, kind: TypeErrorKind.DuplicateName(original)))
            }
            seenFields[field.name.name] = field.name

            val ty = match self._resolveTypeIdentifier(field.typeAnnotation) { Ok(v) => v, Err(e) => return Err(e) }
            // The initializer (if present) will be filled in during the next pass
            typedFields.push(Field(name: field.name, ty: ty, initializer: None))
          }

          enum_.variants.push(TypedEnumVariant(label: label, kind: EnumVariantKind.Container(typedFields)))
        }
      }
    }

    for funcDeclNode in node.methods {
      val fn = match self._typecheckFunctionPass1(funcDeclNode) { Ok(v) => v, Err(e) => return Err(e) }
      match fn.kind {
        FunctionKind.InstanceMethod => enum_.instanceMethods.push(fn)
        FunctionKind.StaticMethod => enum_.staticMethods.push(fn)
        FunctionKind.Standalone => return unreachable(fn.label.position, "method has invalid function kind at this point")
      }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(0)
  }

  func _typecheckEnumPass2_2(self, enum_: Enum, node: EnumDeclarationNode): Result<Map<Label, Int[]>, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = enum_.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(StructOrEnum.Enum(enum_))

    for typedVariant, idx in enum_.variants {
      match typedVariant.kind {
        EnumVariantKind.Constant => continue
        EnumVariantKind.Container(typedFields) => {
          val fields = match node.variants[idx] {
            EnumVariant.Container(_, fields) => fields
            _ => return unreachable(typedVariant.label.position, "the untyped enum variant must exist at index, and must also be a Container")
          }

          for typedField, idx in typedFields {
            val field = if fields[idx] |f| f else return unreachable(typedField.name.position, "the untyped field must exist at index")
            if field.initializer |initializer| {
              val typedInitializer = match self._typecheckExpression(initializer, Some(typedField.ty)) { Ok(v) => v, Err(e) => return Err(e) }
              if !self._typeSatisfiesRequired(ty: typedInitializer.ty, required: typedField.ty) {
                return Err(TypeError(position: typedInitializer.token.position, kind: TypeErrorKind.TypeMismatch([typedField.ty], typedInitializer.ty)))
              }

              typedField.initializer = Some(typedInitializer)
            } else {
              continue
            }
          }
        }
      }
    }

    val allParamsNeedingRevisit = match self._typecheckMethodsPass2(StructOrEnum.Enum(enum_), node.methods) { Ok(v) => v, Err(e) => return Err(e) }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(allParamsNeedingRevisit)
  }

  func _typecheckEnumPass3(self, enum_: Enum, node: EnumDeclarationNode, paramsNeedingRevisit: Map<Label, Int[]>): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = enum_.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(StructOrEnum.Enum(enum_))

    val instanceMethods = enum_.instanceMethods.keyBy(f => f.label)
    val staticMethods = enum_.staticMethods.keyBy(f => f.label)
    for funcDeclNode in node.methods {
      val fnLabel = funcDeclNode.name
      val fn = if instanceMethods[fnLabel] |f| {
        f
      } else if staticMethods[fnLabel] |f| {
        f
      } else {
        return unreachable(funcDeclNode.name.position, "method not visited in prior pass")
      }

      val toRevisit = if paramsNeedingRevisit[fnLabel] |paramIds| paramIds else return unreachable(funcDeclNode.name.position, "params improperly visited in prior pass")
      match self._typecheckFunctionPass3(fn: fn, allowSelf: true, params: funcDeclNode.params, body: funcDeclNode.body, paramsNeedingRevisit: toRevisit) { Ok(v) => v, Err(e) => return Err(e) }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(0)
  }

  func _typecheckImport(self, mod: TypedModule, node: ImportNode): Result<Int, TypeError> {
    val importedModule = if self.currentModuleImports[mod.name] |importedModule| importedModule else {
      // TODO: better API for this
      val importedModule = ImportedModule()
      self.currentModuleImports[mod.name] = importedModule
      importedModule
    }

    match node.kind {
      ImportKind.List(importNames) => {
        for imp in importNames {
          for importedModule in self.currentModuleImports.values() {
            for _p in importedModule.imports {
              // TODO: destructuring
              val importedName = _p[0]
              val importedValue = _p[1]
              if importedName == imp.name {
                return Err(TypeError(position: imp.position, kind: TypeErrorKind.DuplicateName(original: importedValue.label)))
              }
            }
          }

          val typedImportKind = match mod.exports[imp.name] {
            Export.Variable(v) => TypedImportKind.Variable(v)
            Export.Function(v) => TypedImportKind.Function(v)
            Export.Type(structOrEnum, v) => TypedImportKind.Type(structOrEnum, v)
            None => return Err(TypeError(position: imp.position, kind: TypeErrorKind.UnknownImport(moduleName: node.moduleName.name, importName: imp.name)))
          }

          importedModule.imports[imp.name] = Import(label: imp, kind: typedImportKind)
        }
      }
      ImportKind.Alias(alias) => {
        if self._verifyNameUniqueInScope(alias, self.currentScope) |e| return Err(e)

        importedModule.aliases.push(alias)
      }
    }

    Ok(0)
  }

  func _typecheckBlock(self, nodes: AstNode[]): Result<TypedAstNode[], TypeError> {
    val funcDecls: FunctionDeclarationNode[] = []
    val typeDecls: TypeDeclarationNode[] = []
    val enumDecls: EnumDeclarationNode[] = []
    for node in nodes {
      match node.kind {
        AstNodeKind.FunctionDeclaration(node) => funcDecls.push(node)
        AstNodeKind.TypeDeclaration(node) => typeDecls.push(node)
        AstNodeKind.EnumDeclaration(node) => enumDecls.push(node)
        _ => {}
      }
    }

    // --- Pass 1 for types, enums, and functions

    val structsPass1: (Struct, TypeDeclarationNode)[] = []
    for node in typeDecls {
      val struct = match self._typecheckStructPass1(node) { Ok(v) => v, Err(e) => return Err(e) }
      if self.currentModuleId == 0 {
        match struct.label.name {
          "Int" => self.project.preludeIntStruct = struct
          "Float" => self.project.preludeFloatStruct = struct
          "Bool" => self.project.preludeBoolStruct = struct
          "String" => self.project.preludeStringStruct = struct
          "Array" => self.project.preludeArrayStruct = struct
          "Set" => self.project.preludeSetStruct = struct
          "Map" => self.project.preludeMapStruct = struct
          _ => {}
        }
      }
      structsPass1.push((struct, node))
    }

    val enumsPass1: (Enum, EnumDeclarationNode)[] = []
    for node in enumDecls {
      val enum_ = match self._typecheckEnumPass1(node) { Ok(v) => v, Err(e) => return Err(e) }
      if self.currentModuleId == 0 {
        match enum_.label.name {
          "Option" => self.project.preludeOptionEnum = enum_
          _ => {}
        }
      }
      enumsPass1.push((enum_, node))
    }

    val functionsPass1: (Function, Variable, FunctionDeclarationNode)[] = []
    for node in funcDecls {
      val isExported = if node.exportToken |exportToken| {
        match self._ensureValidExportScope(exportToken) { Ok(v) => v, Err(e) => return Err(e) }
        true
      } else {
        false
      }

      val fn = match self._typecheckFunctionPass1(node) { Ok(v) => v, Err(e) => return Err(e) }
      val aliasVar = Variable(label: fn.label, mutable: false, ty: fn.getType(), alias: Some(VariableAlias.Function(fn)))
      self.currentScope.variables.push(aliasVar)
      functionsPass1.push((fn, aliasVar, node))
      if isExported {
        aliasVar.isExported = true
        self.currentModuleExports[fn.label.name] = Export.Function(aliasVar)
      }
    }

    // --- Pass 2 for types, enums, and functions

    val structsPass2_1: (Struct, TypeDeclarationNode)[] = []
    for pair in structsPass1 {
      val struct = pair[0]
      val node = pair[1]
      match self._typecheckStructPass2_1(struct, node) { Ok(v) => v, Err(e) => return Err(e) }

      structsPass2_1.push((struct, node))
    }

    val enumsPass2_1: (Enum, EnumDeclarationNode)[] = []
    for pair in enumsPass1 {
      val enum_ = pair[0]
      val node = pair[1]
      match self._typecheckEnumPass2_1(enum_, node) { Ok(v) => v, Err(e) => return Err(e) }

      enumsPass2_1.push((enum_, node))
    }

    val structsPass2_2: (Struct, TypeDeclarationNode, Map<Label, Int[]>)[] = []
    for pair in structsPass1 {
      val struct = pair[0]
      val node = pair[1]
      val toRevisit = match self._typecheckStructPass2_2(struct, node) { Ok(v) => v, Err(e) => return Err(e) }

      structsPass2_2.push((struct, node, toRevisit))
    }

    val enumsPass2_2: (Enum, EnumDeclarationNode, Map<Label, Int[]>)[] = []
    for pair in enumsPass2_1 {
      val enum_ = pair[0]
      val node = pair[1]
      val toRevisit = match self._typecheckEnumPass2_2(enum_, node) { Ok(v) => v, Err(e) => return Err(e) }

      enumsPass2_2.push((enum_, node, toRevisit))
    }

    val functionsPass2: (Function, FunctionDeclarationNode, Int[])[] = []
    for fnPair in functionsPass1 {
      val fn = fnPair[0]
      val aliasVar = fnPair[1]
      val node = fnPair[2]
      val paramsNeedingRevisit = match self._typecheckFunctionPass2(fn: fn, allowSelf: false, params: node.params) { Ok(v) => v, Err(e) => return Err(e) }

      aliasVar.ty = fn.getType()
      functionsPass2.push((fn, node, paramsNeedingRevisit))
    }

    val functionsIter = functionsPass2.iterator()
    val structsIter = structsPass2_2.iterator()
    val enumsIter = enumsPass2_2.iterator()

    val typedNodes: TypedAstNode[] = []
    for node in nodes {
      val res = match node.kind {
        AstNodeKind.FunctionDeclaration => {
          val typedNode = if functionsIter.next() |pair| {
            val fn = pair[0]
            val fnDeclNode = pair[1]
            val paramsNeedingRevisit = pair[2]
            match self._typecheckFunctionPass3(fn: fn, allowSelf: false, params: fnDeclNode.params, body: fnDeclNode.body, paramsNeedingRevisit: paramsNeedingRevisit) { Ok(v) => v, Err(e) => return Err(e) }
            TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.FunctionDeclaration(fn))
          } else {
            return unreachable(node.token.position, "there should be as many functions as there are functiondecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        AstNodeKind.TypeDeclaration => {
          val typedNode = if structsIter.next() |pair| {
            val struct = pair[0]
            val typeDeclNode = pair[1]
            val toRevisit = pair[2]

            match self._typecheckStructPass3(struct, typeDeclNode, toRevisit) { Ok(v) => v, Err(e) => return Err(e) }
            TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.TypeDeclaration(struct))
          } else {
            return unreachable(node.token.position, "there should be as many types as there are typedecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        AstNodeKind.EnumDeclaration => {
          val typedNode = if enumsIter.next() |pair| {
            val enum_ = pair[0]
            val enumDeclNode = pair[1]
            val toRevisit = pair[2]

            match self._typecheckEnumPass3(enum_, enumDeclNode, toRevisit) { Ok(v) => v, Err(e) => return Err(e) }
            TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.EnumDeclaration(enum_))
          } else {
            return unreachable(node.token.position, "there should be as many enums as there are enumdecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        _ => self._typecheckStatement(node: node, typeHint: None)
      }

      val typedNode = match res { Ok(v) => v, Err(e) => return Err(e) }
      typedNodes.push(typedNode)
    }

    return Ok(typedNodes)
  }

  func _typecheckStatement(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token

    match node.kind {
      AstNodeKind.Assignment(expr, op, mode) => self._typecheckAssignment(token, expr, op, mode)
      AstNodeKind.While(condition, conditionBinding, block) => self._typecheckWhile(token, condition, conditionBinding, block)
      AstNodeKind.For(itemPattern, indexPattern, iterator, block) => self._typecheckFor(token, itemPattern, indexPattern, iterator, block)
      AstNodeKind.BindingDeclaration(node) => self._typecheckBindingDeclaration(token, node)
      AstNodeKind.Break => self._typecheckBreak(token)
      AstNodeKind.Continue => self._typecheckContinue(token)
      AstNodeKind.Return(expr) => self._typecheckReturn(token, expr)
      _ => self._typecheckExpression(node, Some(Type(kind: TypeKind.PrimitiveUnit)))
    }
  }

  func _typecheckBindingPattern(self, mutable: Bool, pattern: BindingPattern, ty: Type): Result<Variable[], TypeError> {
    match pattern {
      BindingPattern.Variable(label) => {
        val variable = Variable(label: label, mutable: mutable, ty: ty)
        match self._addVariableToScope(variable) { Ok(v) => v, Err(e) => return Err(e) }

        Ok([variable])
      }
    }
  }

  func _typecheckBindingDeclaration(self, token: Token, node: BindingDeclarationNode): Result<TypedAstNode, TypeError> {
    val isMutable = token.kind == TokenKind.Var
    val isExported = if node.exportToken |exportToken| {
      match self._ensureValidExportScope(exportToken) { Ok(v) => v, Err(e) => return Err(e) }
      true
    } else {
      false
    }

    val annType = if node.typeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Ok(v) => v, Err(e) => return Err(e) }
      Some(ty)
    } else {
      None
    }

    val _pair = if node.expr |expr| {
      val typedExpr = match self._typecheckExpression(expr, annType) { Ok(v) => v, Err(e) => return Err(e) }
      val ty = if annType |annotatedType| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: annotatedType) {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([annotatedType], typedExpr.ty)))
        }

        annotatedType
      } else {
        typedExpr.ty
      }

      if ty.isInvalidValueType() {
        return Err(TypeError(position: expr.token.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "assignment")))
      }

      (Some(typedExpr), ty)
    } else if !isMutable {
      val label = match node.bindingPattern {
        BindingPattern.Variable(label) => label
        // _ => return Err(TypeError(position: token.position, kind: TypeErrorKind.MissingValExpr(None)))
      }
      return Err(TypeError(position: label.position, kind: TypeErrorKind.MissingValExpr(label.name)))
    } else if annType |ty| {
      (None, ty)
    } else {
      val label = match node.bindingPattern {
        BindingPattern.Variable(label) => label
        // _ => return Err(TypeError(position: token.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(None)))
      }
      return Err(TypeError(position: label.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(label.name)))
    }
    // TODO: destructuring
    val expr = _pair[0]
    val ty = _pair[1]

    val variables = match self._typecheckBindingPattern(isMutable, node.bindingPattern, ty) { Ok(v) => v, Err(e) => return Err(e) }
    for v in variables {
      if isExported {
        v.isExported = true
        self.currentModuleExports[v.label.name] = Export.Variable(v)
      }
    }

    val typedNode = TypedBindingDeclarationNode(bindingPattern: node.bindingPattern, variables: variables, expr: expr)
    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.BindingDeclaration(typedNode)))
  }

  func _typecheckAssignment(self, token: Token, expr: AstNode, op: AssignOp, mode: AssignmentMode): Result<TypedAstNode, TypeError> {
    match mode {
      AssignmentMode.Variable(name, varToken) => {
        val pos = varToken.position

        val variable = if self._resolveIdentifier(name) |variable| variable else {
          return Err(TypeError(position: pos, kind: TypeErrorKind.UnknownName(name, "variable")))
        }
        match variable.alias {
          VariableAlias.Function => return Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.FunctionAlias)))
          VariableAlias.Struct => return Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.TypeAlias)))
          _ => {
            if !variable.mutable return Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.ImmutableVariable)))
          }
        }

        val typedExpr = match self._typecheckExpression(expr, Some(variable.ty)) { Ok(v) => v, Err(e) => return Err(e) }
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: variable.ty) {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([variable.ty], typedExpr.ty)))
        }

        val mode = TypedAssignmentMode.Variable(variable)
        return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.Assignment(mode, op, typedExpr)))
      }
      AssignmentMode.Indexing(targetExpr, indexExpr) => {
        val typedLhs = match self._typecheckIndexing(token, targetExpr, IndexingMode.Single(indexExpr), None) { Ok(v) => v, Err(e) => return Err(e) }
        val typedIndexingNode = match typedLhs.kind {
          TypedAstNodeKind.Indexing(node) => node
          _ => return unreachable(typedLhs.token.position, "_typecheckIndexing returned unexpected TypedAstNodeKind")
        }
        val assignmentTy = if self._typeIsOption(typedLhs.ty) |inner| inner else typedLhs.ty

        val typedExpr = match self._typecheckExpression(expr, Some(assignmentTy)) { Ok(v) => v, Err(e) => return Err(e) }
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: assignmentTy) {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([assignmentTy], typedExpr.ty)))
        }

        val mode = TypedAssignmentMode.Indexing(typedIndexingNode)
        return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.Assignment(mode, op, typedExpr)))
      }
      AssignmentMode.Accessor(accessorNode) => {
        val typedLhs = match self._typecheckAccessor(token, accessorNode, None) { Ok(v) => v, Err(e) => return Err(e) }
        val _p = match typedLhs.kind {
          TypedAstNodeKind.Accessor(head, mid, tail) => {
            val t = match tail {
              AccessorPathSegment.EnumVariant(label, _, _, variant) => {
                return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAssignment("enum variant", variant.label.name, IllegalAssignmentReason.EnumVariant)))
              }
              AccessorPathSegment.Method(label, fn) => {
                val _p = if fn.kind == FunctionKind.StaticMethod {
                  ("static method", IllegalAssignmentReason.StaticMethod)
                } else {
                  ("method", IllegalAssignmentReason.Method)
                }
                // TODO: destructuring
                val kind = _p[0]
                val reason = _p[1]

                return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAssignment(kind, fn.label.name, reason)))
              }
              AccessorPathSegment.Field(label, _, field) => {
                val mode = TypedAssignmentMode.Accessor(head, mid, tail)
                (mode, label, field)
              }
            }
            t
          }
          _ => return unreachable(typedLhs.token.position, "_typecheckAccessor returned unexpected TypedAstNodeKind")
        }
        // TODO: destructuring
        val mode = _p[0]
        val fieldLabel = _p[1]
        val field = _p[2]

        val typedExpr = match self._typecheckExpression(expr, Some(field.ty)) { Ok(v) => v, Err(e) => return Err(e) }
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: field.ty) {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([field.ty], typedExpr.ty)))
        }

        return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.Assignment(mode, op, typedExpr)))
      }
    }
  }

  func _typecheckWhile(self, token: Token, condition: AstNode, conditionBinding: BindingPattern?, block: AstNode[]): Result<TypedAstNode, TypeError> {
    val typedCondition = match self._typecheckExpression(condition, None) { Ok(v) => v, Err(e) => return Err(e) }
    val condOptInnerTy = self._typeIsOption(typedCondition.ty)
    if !condOptInnerTy && !self._typeSatisfiesRequired(ty: typedCondition.ty, required: Type(kind: TypeKind.PrimitiveBool)) {
      return Err(TypeError(position: typedCondition.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedCondition.ty, purpose: "while")))
    }

    val prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("while", ScopeKind.While)

    val conditionBindingPattern = if conditionBinding |pattern| {
      val ty = condOptInnerTy ?: typedCondition.ty

      val vars = match self._typecheckBindingPattern(false, pattern, ty) { Ok(v) => v, Err(e) => return Err(e) }
      Some((pattern, vars))
    } else {
      None
    }

    val typedNodes: TypedAstNode[] = []
    for node in block {
      if self.currentScope.terminator return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = match self._typecheckStatement(node, None) { Ok(v) => v, Err(e) => return Err(e) }
      typedNodes.push(typedNode)
    }
    val terminator = self.currentScope.terminator

    self.currentScope = prevScope
    self.currentScope.terminator = terminator

    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.While(typedCondition, conditionBindingPattern, typedNodes)))
  }

  func _typeIsOption(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Enum(enum_) => {
            if enum_ != self.project.preludeOptionEnum return None
            if generics[0] |innerTy| {
              Some(innerTy)
            } else {
              __assertUnreachable("Option instance lacks inner type")
              None
            }
          }
          _ => None
        }
      }
      _ => None
    }
  }

  func _typeIsIterable(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(structOrEnum, generics) => {
        val instanceMethods = match structOrEnum {
          StructOrEnum.Struct(struct) => {
            if struct == self.project.preludeArrayStruct return generics[0]
            if struct == self.project.preludeSetStruct return generics[0]
            if struct == self.project.preludeMapStruct {
              val keyTy = generics[0] ?: Type(kind: TypeKind.Hole)
              val valTy = generics[1] ?: Type(kind: TypeKind.Hole)
              return Some(Type(kind: TypeKind.Tuple([keyTy, valTy])))
            }

            struct.instanceMethods
          }
          StructOrEnum.Enum(enum_) => enum_.instanceMethods
        }
        for m in instanceMethods {
          if m.label.name == "next" {
            if !m.params.isEmpty() return None
            val iterItemType = m.returnType
            return self._typeIsOption(iterItemType)
          }
        }

        None
      }
      _ => None
    }
  }

  func _typecheckFor(self, token: Token, itemPattern: BindingPattern, indexPattern: BindingPattern?, iterator: AstNode, block: AstNode[]): Result<TypedAstNode, TypeError> {
    val typedIterator = match self._typecheckExpression(iterator, None) { Ok(v) => v, Err(e) => return Err(e) }
    val itemType = if self._typeIsIterable(typedIterator.ty) |innerTy| innerTy else {
      return Err(TypeError(position: typedIterator.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedIterator.ty, purpose: "for")))
    }
    if itemType.kind == TypeKind.Hole {
      return Err(TypeError(position: typedIterator.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedIterator.ty, purpose: "for")))
    }

    val prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("for", ScopeKind.For)

    val variables = match self._typecheckBindingPattern(false, itemPattern, itemType) { Ok(v) => v, Err(e) => return Err(e) }
    val indexBinding = if indexPattern |pat| {
      val variables = match self._typecheckBindingPattern(false, pat, Type(kind: TypeKind.PrimitiveInt)) { Ok(v) => v, Err(e) => return Err(e) }
      variables[0]
    } else {
      None
    }

    val typedNodes: TypedAstNode[] = []
    for node in block {
      if self.currentScope.terminator return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = match self._typecheckStatement(node, None) { Ok(v) => v, Err(e) => return Err(e) }
      typedNodes.push(typedNode)
    }
    val terminator = self.currentScope.terminator

    self.currentScope = prevScope
    self.currentScope.terminator = terminator

    val kind = TypedAstNodeKind.For(typedIterator, (itemPattern, variables), indexBinding, typedNodes)
    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: kind))
  }

  func _typecheckBreak(self, token: Token): Result<TypedAstNode, TypeError> = self._typecheckBreakContinue(token, "break", TypedAstNodeKind.Break)

  func _typecheckContinue(self, token: Token): Result<TypedAstNode, TypeError> = self._typecheckBreakContinue(token, "continue", TypedAstNodeKind.Continue)

  func _typecheckBreakContinue(self, token: Token, terminator: String, kind: TypedAstNodeKind): Result<TypedAstNode, TypeError> {
    var scope = Some(self.currentScope)
    while scope |sc| {
      val isValid = match sc.kind {
        ScopeKind.Root => false
        ScopeKind.Module => false
        ScopeKind.Type => false
        ScopeKind.Func => false
        ScopeKind.If => {
          scope = sc.parent
          continue
        }
        ScopeKind.MatchCase => {
          scope = sc.parent
          continue
        }
        ScopeKind.While => true
        ScopeKind.For => true
      }

      if !isValid return Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTerminatorPosition(terminator)))
      break
    }
    self.currentScope.terminator = Some(Terminator.NonReturning)

    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.Never), kind: kind))
  }

  func _typecheckReturn(self, token: Token, expr: AstNode?): Result<TypedAstNode, TypeError> {
    val fn = if self.currentFunction |fn| fn else {
      return Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTerminatorPosition("return")))
    }

    val typedExpr = if expr |expr| {
      val typedExpr = match self._typecheckExpression(expr, Some(fn.returnType)) { Ok(v) => v, Err(e) => return Err(e) }
      if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: fn.returnType) {
        val fnName = if fn.isLambda None else Some(fn.label.name)
        return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Some(typedExpr.ty))))
      }

      Some(typedExpr)
    } else {
      if fn.returnType.kind != TypeKind.PrimitiveUnit {
        val fnName = if fn.isLambda None else Some(fn.label.name)
        return Err(TypeError(position: token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Some(Type(kind: TypeKind.PrimitiveUnit)))))
      }

      None
    }

    if fn.isLambda && fn.returnType.kind == TypeKind.Hole {
      fn.returnType = typedExpr?.ty ?: Type(kind: TypeKind.PrimitiveUnit)
    }

    self.currentScope.terminator = Some(Terminator.Returning)

    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.Never), kind: TypedAstNodeKind.Return(typedExpr)))
  }

  func _typecheckIf(
    self,
    token: Token,
    condition: AstNode,
    conditionBinding: BindingPattern?,
    ifBlock: AstNode[],
    elseBlock: AstNode[]?,
    typeHint: Type?,
  ): Result<TypedAstNode, TypeError> {
    val isStatement = if typeHint |hint| hint.kind == TypeKind.PrimitiveUnit else false

    val typedCondition = match self._typecheckExpression(condition, None) { Ok(v) => v, Err(e) => return Err(e) }
    val condOptInnerTy = self._typeIsOption(typedCondition.ty)
    if !condOptInnerTy && !self._typeSatisfiesRequired(ty: typedCondition.ty, required: Type(kind: TypeKind.PrimitiveBool)) {
      return Err(TypeError(position: typedCondition.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedCondition.ty, purpose: "if")))
    }

    val typedIfBlock: TypedAstNode[] = []
    var prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("if_then", ScopeKind.If)

    val conditionBindingPattern = if conditionBinding |pattern| {
      val ty = condOptInnerTy ?: typedCondition.ty

      val vars = match self._typecheckBindingPattern(false, pattern, ty) { Ok(v) => v, Err(e) => return Err(e) }
      Some((pattern, vars))
    } else {
      None
    }

    for node, idx in ifBlock {
      if self.currentScope.terminator == Some(Terminator.Returning) return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      if idx == ifBlock.length - 1 && !isStatement {
        val typedNode = match self._typecheckExpressionOrTerminator(node, typeHint) { Ok(v) => v, Err(e) => return Err(e) }
        typedIfBlock.push(typedNode)
      } else {
        val typedNode = match self._typecheckStatement(node, None) { Ok(v) => v, Err(e) => return Err(e) }
        typedIfBlock.push(typedNode)
      }
    }
    val ifType = typedIfBlock[-1]?.ty
    val ifBlockTerminator = self.currentScope.terminator
    self.currentScope = prevScope

    var hasElseBlock = false
    val typedElseBlock: TypedAstNode[] = []
    prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("if_else", ScopeKind.If)
    if elseBlock |elseBlock| {
      hasElseBlock = true
      for node, idx in elseBlock {
        if self.currentScope.terminator == Some(Terminator.Returning) return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

        if idx == elseBlock.length - 1 && !isStatement {
          val hint = if ifType |t| (if t.hasUnfilledHoles() None else ifType) else None
          val typedNode = match self._typecheckExpressionOrTerminator(node, hint) { Ok(v) => v, Err(e) => return Err(e) }
          typedElseBlock.push(typedNode)
        } else {
          val typedNode = match self._typecheckStatement(node, None) { Ok(v) => v, Err(e) => return Err(e) }
          typedElseBlock.push(typedNode)
        }
      }
    }
    val elseBlockTerminator = self.currentScope.terminator
    self.currentScope = prevScope

    self.currentScope.terminator = Terminator.combine(ifBlockTerminator, elseBlockTerminator)

    val ty = if !isStatement {
      val t = if ifType |ifType| {
        if typedElseBlock[-1] |lastElseNode| {
          val elseType = lastElseNode.ty

          if ifType.hasUnfilledHoles() {
            ifType.tryFillHoles(elseType)
          }
          if elseType.hasUnfilledHoles() {
            elseType.tryFillHoles(ifType)
          }

          if !self._typeSatisfiesRequired(ty: elseType, required: ifType) {
            return Err(TypeError(position: lastElseNode.token.position, kind: TypeErrorKind.TypeMismatch([ifType], elseType)))
          }

          val t = if ifType.kind == TypeKind.Never { elseType } else { ifType }
          t
        } else {
          return Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredIfExprBlock(clause: "else", missing: !hasElseBlock)))
        }
      } else {
        return Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredIfExprBlock(clause: "if", missing: false)))
      }
      t
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    val kind = TypedAstNodeKind.If(isStatement, typedCondition, conditionBindingPattern, typedIfBlock, typedElseBlock)
    Ok(TypedAstNode(token: token, ty: ty, kind: kind))
  }

  func _typecheckMatch(self, token: Token, expr: AstNode, cases: MatchCase[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    val isStatement = if typeHint |hint| hint.kind == TypeKind.PrimitiveUnit else false
    val typedExpr = match self._typecheckExpression(expr, None) { Ok(v) => v, Err(e) => return Err(e) }

    var subjectTy = typedExpr.ty
    val typedCases: TypedMatchCase[] = []
    var resultTy: Type? = None
    var seenElseCase = false
    var seenNoneCase = false
    var seenLiteralCases: Set<LiteralAstNode> = #{}
    val seenEnumVariants: Map<Enum, Set<Int>> = {}
    val seenTypes: Set<Type> = #{}

    val allCasesHandled: () => Bool = () => {
      if seenElseCase return true

      for _p in seenEnumVariants {
        // TODO: destructuring
        val enum_ = _p[0]
        val seenVariantIdxs = _p[1]
        val enumVariantIdxs = enum_.variants.map((_, i) => i).asSet()
        if seenVariantIdxs == enumVariantIdxs {
          if self._typeIsOption(typedExpr.ty) {
            if seenNoneCase return true
          } else return true
        }
      }

      if self._typesAreEquivalent(ty: Type(kind: TypeKind.PrimitiveBool), other: typedExpr.ty) {
        if seenLiteralCases == #{LiteralAstNode.Bool(true), LiteralAstNode.Bool(false)} return true
      }

      if !seenTypes.isEmpty() {
        if self._typeIsOption(typedExpr.ty) {
          if seenNoneCase return true
        } else return true
      }

      false
    }

    for case in cases {
      if allCasesHandled() {
        return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.AlreadyCovered(exhaustive: true), typedExpr.ty)))
      }

      val typedBody: TypedAstNode[] = []
      var prevScope = self.currentScope

      var caseVar: Variable? = None
      val typedMatchCaseKind = match case.kind {
        MatchCaseKind.Type(path, last, args) => {
          val typeOrEnumVariant = match self._resolveTypeOrEnumVariant(path, last) { Ok(v) => v, Err(e) => return Err(e) }
          val typedCaseKind = match typeOrEnumVariant {
            Either.Left(caseTy) => {
              if seenTypes.contains(caseTy) return Err(TypeError(position: case.position, kind: TypeErrorKind.DuplicateMatchCase))
              seenTypes.insert(caseTy)

              if args[0] |firstArg| {
                return Err(TypeError(position: firstArg.position, kind: TypeErrorKind.InvalidMatchCaseDestructuring(InvalidMatchCaseDestructuringReason.NonEnum)))
              }

              val subjectTy = if self._typeIsOption(subjectTy) |innerTy| innerTy else subjectTy
              if !self._typeSatisfiesRequired(ty: caseTy, required: subjectTy) {
                return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.NoOverlap(caseTy: Some(caseTy)), typedExpr.ty)))
              }

              self.currentScope = self.currentScope.makeChild("matchcase_${caseTy.repr()}", ScopeKind.MatchCase)
              if case.binding |binding| {
                // TODO: generics in ty
                caseVar = Some(Variable(label: binding, mutable: false, ty: caseTy))
              }

              TypedMatchCaseKind.Type(caseTy)
            }
            Either.Right(_p) => {
              // TODO: destructuring
              val enum_ = _p[0]
              val variant = _p[1]
              val variantIdx = _p[2]
              if seenEnumVariants[enum_] |seenVariants| {
                if seenVariants.contains(variantIdx) return Err(TypeError(position: case.position, kind: TypeErrorKind.DuplicateMatchCase))
                seenVariants.insert(variantIdx)
              } else {
                seenEnumVariants[enum_] = #{variantIdx}
              }

              val subjectTy = if self._typeIsOption(subjectTy) |innerTy| innerTy else subjectTy
              val template = Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), enum_.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
              val extractedGenerics = self._extractGenerics(template: template, source: subjectTy)
              val resolvedGenerics: Map<String, Type> = {}
              for _p in extractedGenerics {
                resolvedGenerics[_p[0]] = _p[1]
              }

              val caseTy = template.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
              if !self._typeSatisfiesRequired(ty: caseTy, required: subjectTy) {
                return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.NoOverlap(caseTy: Some(caseTy)), typedExpr.ty)))
              }

              self.currentScope = self.currentScope.makeChild("matchcase_${enum_.label.name}_$variantIdx", ScopeKind.MatchCase)

              val variables: Variable[] = []
              if args[0] |firstArg| {
                match variant.kind {
                  EnumVariantKind.Constant => return Err(TypeError(position: firstArg.position, kind: TypeErrorKind.InvalidMatchCaseDestructuring(InvalidMatchCaseDestructuringReason.NonEnumContainer)))
                  EnumVariantKind.Container(fields) => {
                    if args[fields.length] |invalidArg| {
                      val kind = TypeErrorKind.InvalidMatchCaseDestructuring(InvalidMatchCaseDestructuringReason.InvalidArity(expected: fields.length, given: args.length))
                      return Err(TypeError(position: invalidArg.position, kind: kind))
                    }

                    for field, idx in fields {
                      val arg = if args[idx] |arg| arg else {
                        val kind = TypeErrorKind.InvalidMatchCaseDestructuring(InvalidMatchCaseDestructuringReason.InvalidArity(expected: fields.length, given: args.length))
                        return Err(TypeError(position: case.position, kind: kind))
                      }
                      val variableTy = if self._containsGenerics(field.ty) {
                        field.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
                      } else {
                        field.ty
                      }
                      val variable = Variable(label: arg, mutable: false, ty: variableTy)
                      match self._addVariableToScope(variable) { Ok(v) => v, Err(e) => return Err(e) }
                      variables.push(variable)
                    }
                  }
                }
              }

              if case.binding |binding| {
                caseVar = Some(Variable(label: binding, mutable: false, ty: caseTy))
              }

              TypedMatchCaseKind.EnumVariant(enum_, variant, variantIdx, variables)
            }
          }

          typedCaseKind
        }
        MatchCaseKind.Literal(value) => {
          if seenLiteralCases.contains(value) return Err(TypeError(position: case.position, kind: TypeErrorKind.DuplicateMatchCase))
          seenLiteralCases.insert(value)

          val literalTy = match value {
            LiteralAstNode.Int => Type(kind: TypeKind.PrimitiveInt)
            LiteralAstNode.Float => Type(kind: TypeKind.PrimitiveFloat)
            LiteralAstNode.Bool => Type(kind: TypeKind.PrimitiveBool)
            LiteralAstNode.String => Type(kind: TypeKind.PrimitiveString)
          }

          self.currentScope = self.currentScope.makeChild("matchcase_$value", ScopeKind.MatchCase)
          if case.binding |binding| {
            caseVar = Some(Variable(label: binding, mutable: false, ty: literalTy))
          }

          val subjectTy = if self._typeIsOption(subjectTy) |innerTy| innerTy else subjectTy
          if !self._typeSatisfiesRequired(ty: literalTy, required: subjectTy) {
            return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.NoOverlap(caseTy: Some(literalTy)), typedExpr.ty)))
          }

          if seenTypes.contains(literalTy) return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.AlreadyCovered(exhaustive: false), typedExpr.ty)))

          TypedMatchCaseKind.Literal(value)
        }
        MatchCaseKind.None_ => {
          if seenNoneCase return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.AlreadyCovered(exhaustive: false), typedExpr.ty)))
          seenNoneCase = true

          self.currentScope = self.currentScope.makeChild("matchcase_None", ScopeKind.MatchCase)
          if case.binding |binding| {
            caseVar = Some(Variable(label: binding, mutable: false, ty: subjectTy))
          }

          if self._typeIsOption(subjectTy) |ty| {
            subjectTy = ty
          } else {
            return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.NoOverlap(caseTy: None), typedExpr.ty)))
          }

          TypedMatchCaseKind.None_
        }
        MatchCaseKind.Else => {
          seenElseCase = true

          self.currentScope = self.currentScope.makeChild("matchcase_else", ScopeKind.MatchCase)
          if case.binding |binding| {
            caseVar = Some(Variable(label: binding, mutable: false, ty: subjectTy))
          }

          TypedMatchCaseKind.Else
        }
      }

      if caseVar |v| {
        match self._addVariableToScope(v) { Ok(v) => v, Err(e) => return Err(e) }
      }

      for node, idx in case.body {
        if self.currentScope.terminator return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

        if idx == case.body.length - 1 && !isStatement {
          val typedNode = match self._typecheckExpressionOrTerminator(node, typeHint) { Ok(v) => v, Err(e) => return Err(e) }
          typedBody.push(typedNode)
        } else {
          val typedNode = match self._typecheckStatement(node, None) { Ok(v) => v, Err(e) => return Err(e) }
          typedBody.push(typedNode)
        }
      }

      if !isStatement {
        val lastBodyNode = if typedBody[-1] |node| node else {
          return Err(TypeError(position: case.position, kind: TypeErrorKind.EmptyMatchBlock))
        }
        val bodyTy = lastBodyNode.ty

        if resultTy |resTy| {
          if resTy.hasUnfilledHoles() {
            resTy.tryFillHoles(bodyTy)
          } else if bodyTy.hasUnfilledHoles() {
            bodyTy.tryFillHoles(resTy)
          }

          if !self._typeSatisfiesRequired(ty: bodyTy, required: resTy) {
            return Err(TypeError(position: lastBodyNode.token.position, kind: TypeErrorKind.TypeMismatch([resTy], bodyTy)))
          }

          if resTy.kind == TypeKind.Never {
            resultTy = Some(bodyTy)
          }
        } else {
          resultTy = typedBody[-1]?.ty
        }
      }

      val terminator = self.currentScope.terminator
      self.currentScope = prevScope

      typedCases.push(TypedMatchCase(kind: typedMatchCaseKind, binding: caseVar, body: typedBody))
    }

    if !isStatement && !allCasesHandled() {
      return Err(TypeError(position: token.position, kind: TypeErrorKind.NonExhaustiveMatch(typedExpr.ty)))
    }

    val ty = if resultTy |ty| ty else {
      if !isStatement {
        return unreachable(token.position, "match expression without result type")
      }
      Type(kind: TypeKind.PrimitiveUnit)
    }

    val kind = TypedAstNodeKind.Match(isStatement, typedExpr, typedCases)
    Ok(TypedAstNode(token: token, ty: ty, kind: kind))
  }

  func _typecheckExpression(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token
    val typedExprRes: Result<TypedAstNode, TypeError> = match node.kind {
      AstNodeKind.Literal(literal) => {
        val kind = match literal {
          LiteralAstNode.Int => TypeKind.PrimitiveInt
          LiteralAstNode.Float => TypeKind.PrimitiveFloat
          LiteralAstNode.Bool => TypeKind.PrimitiveBool
          LiteralAstNode.String => TypeKind.PrimitiveString
        }

        Ok(TypedAstNode(token: token, ty: Type(kind: kind), kind: TypedAstNodeKind.Literal(literal)))
      }
      AstNodeKind.StringInterpolation(exprs) => self._typecheckStringInterpolation(token, exprs)
      AstNodeKind.Unary(node) => self._typecheckUnary(token, node)
      AstNodeKind.Binary(node) => self._typecheckBinary(token, node)
      AstNodeKind.Grouped(inner) => {
        val expr = match self._typecheckExpression(inner, None) { Ok(v) => v, Err(e) => return Err(e) }
        Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Grouped(expr)))
      }
      AstNodeKind.Identifier(kind) => self._typecheckIdentifier(token, kind, typeHint)
      AstNodeKind.Accessor(node) => self._typecheckAccessor(token, node, typeHint)
      AstNodeKind.Invocation(node) => self._typecheckInvocation(token, node, typeHint)
      AstNodeKind.Array(items) => self._typecheckArray(token, items, typeHint)
      AstNodeKind.Set(items) => self._typecheckSet(token, items, typeHint)
      AstNodeKind.Map(items) => self._typecheckMap(token, items, typeHint)
      AstNodeKind.Tuple(items) => self._typecheckTuple(token, items, typeHint)
      AstNodeKind.Indexing(expr, index) => self._typecheckIndexing(token, expr, index, typeHint)
      AstNodeKind.Lambda(value) => self._typecheckLambda(token, value, typeHint)
      AstNodeKind.If(condition, conditionBinding, ifBlock, elseBlock) => self._typecheckIf(token, condition, conditionBinding, ifBlock, elseBlock, typeHint)
      AstNodeKind.Match(subject, cases) => self._typecheckMatch(token, subject, cases, typeHint)
      _ => unreachable(node.token.position, "all other node types should have already been handled")
    }

    val typedExpr = match typedExprRes { Ok(v) => v, Err(e) => return Err(e) }

    match typedExpr.ty.kind {
      TypeKind.Type => {
        if !self.isStructOrEnumValueAllowed {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalValueType(typedExpr.ty, "value")))
        }
      }
      _ => {}
    }

    Ok(typedExpr)
  }

  func _typecheckExpressionOrTerminator(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    match node.kind {
      AstNodeKind.Break => self._typecheckBreak(node.token)
      AstNodeKind.Continue => self._typecheckContinue(node.token)
      AstNodeKind.Return(expr) => self._typecheckReturn(node.token, expr)
      _ => self._typecheckExpression(node, typeHint)
    }
  }

  func _typecheckStringInterpolation(self, token: Token, exprs: AstNode[]): Result<TypedAstNode, TypeError> {
    val typedExprs: TypedAstNode[] = []
    for expr in exprs {
      val typedExpr = match self._typecheckExpression(expr, None) { Ok(v) => v, Err(e) => return Err(e) }
      typedExprs.push(typedExpr)
    }

    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.StringInterpolation(exprs: typedExprs)))
  }

  func _typecheckUnary(self, token: Token, node: UnaryAstNode): Result<TypedAstNode, TypeError> {
    val expr = match self._typecheckExpression(node: node.expr, typeHint: None) { Ok(v) => v, Err(e) => return Err(e) }
    val ty = match node.op {
      UnaryOp.Minus => {
        if !self._typeSatisfiesRequired(ty: expr.ty, required: Type(kind: TypeKind.PrimitiveInt)) &&
          !self._typeSatisfiesRequired(ty: expr.ty, required: Type(kind: TypeKind.PrimitiveFloat)) {
          val expected = [Type(kind: TypeKind.PrimitiveInt), Type(kind: TypeKind.PrimitiveFloat)]
          return Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch(expected, expr.ty)))
        }
        expr.ty
      }
      UnaryOp.Negate => {
        if !self._typeIsOption(expr.ty) && !self._typeSatisfiesRequired(ty: expr.ty, required: Type(kind: TypeKind.PrimitiveBool)) {
          return Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveBool)], expr.ty)))
        }
        Type(kind: TypeKind.PrimitiveBool)
      }
    }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Unary(op: node.op, expr: expr)))
  }

  func _typecheckBinary(self, token: Token, node: BinaryAstNode): Result<TypedAstNode, TypeError> {
    val handleCases: ((TypeKind, TypeKind, TypeKind)[]) => Result<TypedAstNode, TypeError> = (cases) => {
      val left = match self._typecheckExpression(node.left, None) { Ok(v) => v, Err(e) => return Err(e) }
      val right = match self._typecheckExpression(node.right, None) { Ok(v) => v, Err(e) => return Err(e) }
      for _case in cases {
        // TODO: destructuring
        val lTy = _case[0]
        val rTy = _case[1]
        val outTy = _case[2]

        if (lTy == TypeKind.Hole || self._typeSatisfiesRequired(ty: left.ty, required: Type(kind: lTy))) &&
          ((rTy == TypeKind.Hole || self._typeSatisfiesRequired(ty: right.ty, required: Type(kind: rTy)))) {
          return Ok(TypedAstNode(token: token, ty: Type(kind: outTy), kind: TypedAstNodeKind.Binary(left, node.op, right)))
        }
      }

      return Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, right.ty)))
    }

    val handleEquality: () => Result<TypedAstNode, TypeError> = () => {
      val left = match self._typecheckExpression(node.left, None) { Ok(v) => v, Err(e) => return Err(e) }
      val right = match self._typecheckExpression(node.right, Some(left.ty)) { Ok(v) => v, Err(e) => return Err(e) }

      if !self._typeSatisfiesRequired(ty: right.ty, required: left.ty) {
        return Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([left.ty], right.ty)))
      }

      Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveBool), kind: TypedAstNodeKind.Binary(left, node.op, right)))
    }

    val standardArithmeticCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
    ]
    val allFloatArithmeticCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
    ]
    val boolOpCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
      (TypeKind.PrimitiveBool, TypeKind.PrimitiveBool, TypeKind.PrimitiveBool),
    ]
    val comparisonCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveBool),
    ]

    // TODO: combine match cases, this can be cleaned up a lot
    match node.op {
      BinaryOp.Add => {
        handleCases([
          (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
          (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
          (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
          (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
          (TypeKind.Hole, TypeKind.PrimitiveString, TypeKind.PrimitiveString),
          (TypeKind.PrimitiveString, TypeKind.Hole, TypeKind.PrimitiveString),
        ])
      }
      BinaryOp.Sub => handleCases(standardArithmeticCases)
      BinaryOp.Mul => handleCases(standardArithmeticCases)
      BinaryOp.Div => handleCases(allFloatArithmeticCases)
      BinaryOp.Mod => handleCases(standardArithmeticCases)
      BinaryOp.Pow => handleCases(allFloatArithmeticCases)
      BinaryOp.And => handleCases(boolOpCases)
      BinaryOp.Or => handleCases(boolOpCases)
      BinaryOp.Xor => handleCases(boolOpCases)
      BinaryOp.Coalesce => {
        // If the lhs isn't a nullable type then we can short-circuit and don't even typecheck the rhs
        val left = match self._typecheckExpression(node.left, None) { Ok(v) => v, Err(e) => return Err(e) }
        val right = if self._typeIsOption(left.ty) |innerTy| {
          val right = match self._typecheckExpression(node.right, Some(innerTy)) { Ok(v) => v, Err(e) => return Err(e) }
          if !self._typeSatisfiesRequired(ty: right.ty, required: innerTy) {
            return Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([innerTy], right.ty)))
          }

          right
        } else {
          // Pass Hole as rhs type because it doesn't matter - there's special logic within NoSuchOperator for `?:` used with non-Option types
          return Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, Type(kind: TypeKind.Hole))))
        }

        Ok(TypedAstNode(token: token, ty: right.ty, kind: TypedAstNodeKind.Binary(left, node.op, right)))
      }
      BinaryOp.Eq => handleEquality()
      BinaryOp.Neq => handleEquality()
      BinaryOp.LT => handleCases(comparisonCases)
      BinaryOp.LTE => handleCases(comparisonCases)
      BinaryOp.Shl => handleCases([(TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt)])
      BinaryOp.GT => handleCases(comparisonCases)
      BinaryOp.GTE => handleCases(comparisonCases)
      BinaryOp.Shr => handleCases([(TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt)])
    }
  }

  func _typecheckIdentifier(self, token: Token, kind: IdentifierKind, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val _p = match kind {
      IdentifierKind.Named(name) => {
        val variable = if self._resolveIdentifier(name) |variable| variable else {
          if self.paramDefaultValueContext |ctx| {
            ctx.exprContainsVariableRef = true
          }
          return Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName(name, "variable")))
        }
        (variable.ty, TypedIdentifierKind.Named(name, variable))
      }
      IdentifierKind.Discard => return Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("_", "variable")))
      IdentifierKind.None_ => {
        val replacement = AstNode(
          token: token,
          kind: AstNodeKind.Accessor(AccessorAstNode(
            root: AstNode(token: Token(position: token.position, kind: TokenKind.Ident("Option")), kind: AstNodeKind.Identifier(IdentifierKind.Named("Option"))),
            path: [(Token(position: token.position, kind: TokenKind.Dot), Label(name: "None", position: token.position))]
          ))
        )

        return self._typecheckExpression(replacement, typeHint)
      }
      IdentifierKind.Self => {
        val variable = if self._resolveIdentifier("self") |variable| variable else {
          if self.paramDefaultValueContext |ctx| {
            ctx.exprContainsVariableRef = true
          }
          return Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("self", "variable")))
        }
        (variable.ty, TypedIdentifierKind.Named("self", variable))
      }
    }

    // TODO: destructuring
    Ok(TypedAstNode(token: token, ty: _p[0], kind: TypedAstNodeKind.Identifier(_p[1])))
  }

  func _resolveAccessorPathSegmentAny(self, label: Label): AccessorPathSegment? {
    val scope = self.project.preludeScope.makeChild("Any", ScopeKind.Type)
    val method: Function? = if label.name == "toString" {
      Some(Function.generated(scope, "toString", [], Type(kind: TypeKind.PrimitiveString)))
    } else if label.name == "hash" {
      Some(Function.generated(scope, "hash", [], Type(kind: TypeKind.PrimitiveInt)))
    } else if label.name == "eq" {
      Some(Function.generated(scope, "eq", [("other", Type(kind: TypeKind.Any))], Type(kind: TypeKind.PrimitiveBool)))
    } else {
      None
    }

    if method |method| {
      Some(AccessorPathSegment.Method(label, method))
    } else {
      None
    }
  }

  func _resolveAccessorPathSegment(self, ty: Type, label: Label, typeHint: Type?): Result<AccessorPathSegment?, TypeError> {
    val foundSegment = match ty.kind {
      TypeKind.Any => self._resolveAccessorPathSegmentAny(label)
      TypeKind.PrimitiveUnit => None
      TypeKind.PrimitiveInt => return self._resolveAccessorPathSegment(Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeIntStruct), [])), label, None)
      TypeKind.PrimitiveFloat => return self._resolveAccessorPathSegment(Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeFloatStruct), [])), label, None)
      TypeKind.PrimitiveBool => return self._resolveAccessorPathSegment(Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeBoolStruct), [])), label, None)
      TypeKind.PrimitiveString => return self._resolveAccessorPathSegment(Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeStringStruct), [])), label, None)
      TypeKind.Never => None
      TypeKind.Generic => self._resolveAccessorPathSegmentAny(label)
      TypeKind.Instance(structOrEnum, generics) => {
        val _p = match structOrEnum {
          StructOrEnum.Struct(struct) => {
            for field in struct.fields {
              if field.name.name == label.name {
                val resolvedGenerics: Map<String, Type> = {}
                for name, idx in struct.typeParams {
                  resolvedGenerics[name] = if generics[idx] |g| g else return unreachable(label.position, "typeParams.length != generics.length")
                }
                val ty = field.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
                return Ok(Some(AccessorPathSegment.Field(label, ty, field)))
              }
            }

            (struct.instanceMethods, struct.typeParams)
          }
          StructOrEnum.Enum(enum_) => (enum_.instanceMethods, enum_.typeParams)
        }
        // TODO: destructuring
        val instanceMethods = _p[0]
        val typeParams = _p[1]

        for fn in instanceMethods {
          if fn.label.name == label.name {
            val resolvedGenerics: Map<String, Type> = {}
            for name, idx in typeParams {
              resolvedGenerics[name] = if generics[idx] |g| g else return unreachable(label.position, "typeParams.length != generics.length")
            }
            val method = if resolvedGenerics.isEmpty() fn else fn.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: true, genericsInScope: #{})
            return Ok(Some(AccessorPathSegment.Method(label, method)))
          }
        }

        None
      }
      TypeKind.Tuple => None
      TypeKind.Func => None
      TypeKind.Type(structOrEnum) => {
        // TODO: static fields

        val staticMethods = match structOrEnum {
          StructOrEnum.Struct(struct) => struct.staticMethods
          StructOrEnum.Enum(enum_) => {
            for variant in enum_.variants {
              if variant.label.name == label.name {
                val typeArgs = enum_.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
                val ty = if typeHint |hint| {
                  val template = Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), typeArgs))
                  val extractedGenerics = self._extractGenerics(template: template, source: hint)
                  val resolvedGenerics: Map<String, Type> = {}
                  for _p in extractedGenerics {
                    resolvedGenerics[_p[0]] = _p[1]
                  }

                  template.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
                } else {
                  val t = match variant.kind {
                    EnumVariantKind.Container => {
                      Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), typeArgs))
                    }
                    EnumVariantKind.Constant => {
                      Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), enum_.typeParams.map(() => Type(kind: TypeKind.Hole))))
                    }
                  }
                  t
                }

                match variant.kind {
                  EnumVariantKind.Container => {
                    if !self.isEnumContainerValueAllowed return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalNonConstantEnumVariant))
                  }
                  _ => {}
                }

                return Ok(Some(AccessorPathSegment.EnumVariant(label, ty, enum_, variant)))
              }
            }

            enum_.staticMethods
          }
        }

        for method in staticMethods {
          if method.label.name == label.name return Ok(Some(AccessorPathSegment.Method(label, method)))
        }

        None
      }
      TypeKind.Hole => None
    }

    Ok(foundSegment)
  }

  func _resolveModuleAliasAccessor(self, root: AstNode, field: (Token, Label)): Result<TypedAstNode?, TypeError> {
    val _mod = match root.kind {
      AstNodeKind.Identifier(identKind) => {
        val m = match identKind {
          IdentifierKind.Named(name) => {
            val m = match self._findModuleByAlias(name) { Ok(v) => v, Err(e) => return Err(e) }
            m
          }
          _ => None
        }
        m
      }
      _ => None
    }

    val identifierNode = if _mod |_mod| {
      // TODO: destructuring
      val mod = _mod[0]
      val aliasLabel = _mod[1]

      // TODO: destructuring
      val dotTok = field[0]
      val label = field[1]
      if dotTok.kind == TokenKind.QuestionDot return Err(TypeError(position: dotTok.position, kind: TypeErrorKind.UnnecessaryOptSafety))

      val exportVar = match mod.exports[label.name] {
        None => return Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownImportForAlias(label.name, aliasLabel)))
        Export.Variable(v) => v
        Export.Function(v) => v
        Export.Type(_, v) => v
      }

      val token = Token(position: label.position, kind: TokenKind.Ident(label.name))
      val identifierKind = TypedIdentifierKind.Named(label.name, exportVar)
      Some(TypedAstNode(token: token, ty: exportVar.ty, kind: TypedAstNodeKind.Identifier(identifierKind)))
    } else {
      None
    }

    Ok(identifierNode)
  }

  func _typecheckAccessor(self, token: Token, node: AccessorAstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    var accessorPath = node.path

    val _firstSeg = if accessorPath[0] |p| p else return unreachable(token.position, "path should have at least 1 segment")
    val maybeModuleAccessor = match self._resolveModuleAliasAccessor(node.root, _firstSeg) { Ok(v) => v, Err(e) => return Err(e) }
    val typedRoot = if maybeModuleAccessor |n| {
      if accessorPath.length == 1 return Ok(n)

      accessorPath = accessorPath[1:]
      n
    } else {
      self.isStructOrEnumValueAllowed = true
      val typedNode = match self._typecheckExpression(node.root, None) { Ok(v) => v, Err(e) => return Err(e) }
      self.isStructOrEnumValueAllowed = false
      typedNode
    }

    val path: AccessorPathSegment[] = []
    var ty = typedRoot.ty
    var seenOptSafeDot = false
    for _p, idx in accessorPath {
      // TODO: destructuring
      val token = _p[0]
      val label = _p[1]
      val isOptSafe = token.kind == TokenKind.QuestionDot
      seenOptSafeDot ||= isOptSafe
      val optInnerTy = self._typeIsOption(ty)

      val subjTy = if isOptSafe {
        if optInnerTy |innerTy| {
          innerTy
        } else {
          return Err(TypeError(position: token.position, kind: TypeErrorKind.UnnecessaryOptSafety))
        }
      } else {
        ty
      }

      val seg = match self._resolveAccessorPathSegment(subjTy, label, typeHint) { Ok(v) => v, Err(e) => return Err(e) }
      if seg |seg| {
        // TODO: destructuring
        // val seg = _s[0]
        val nextTy = seg.getType()

        path.push(seg)
        ty = if isOptSafe {
          Type(kind: TypeKind.Instance(StructOrEnum.Enum(self.project.preludeOptionEnum), [nextTy]))
        } else {
          nextTy
        }
      } else {
        val specialCase = if optInnerTy |innerTy| {
          val seg = match self._resolveAccessorPathSegment(innerTy, label, typeHint) { Ok(v) => v, Err(e) => return Err(e) }
          if seg {
            Some(UnknownFieldSpecialCase.ExistsButTypeIsNullable(seenOptSafeDot))
          } else {
            None
          }
        } else {
          match ty.kind {
            TypeKind.Instance(structOrEnum, _) => {
              val seg = match structOrEnum {
                StructOrEnum.Struct(struct) => {
                  val seg = match self._resolveAccessorPathSegment(Type(kind: TypeKind.Type(StructOrEnum.Struct(struct))), label, typeHint) { Ok(v) => v, Err(e) => return Err(e) }
                  seg
                }
                StructOrEnum.Enum(enum_) => {
                  val seg = match self._resolveAccessorPathSegment(Type(kind: TypeKind.Type(StructOrEnum.Enum(enum_))), label, typeHint) { Ok(v) => v, Err(e) => return Err(e) }
                  seg
                }
              }

              if seg {
                Some(UnknownFieldSpecialCase.StaticFieldReferencedAsInstance)
              } else {
                None
              }
            }
            _ => None
          }
        }

        return Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownField(ty, label.name, specialCase)))
      }
    }

    val finalField = if path.pop() |f| f else return unreachable(node.root.token.position, "the accessor path should not be empty")

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Accessor(typedRoot, path, finalField)))
  }

  func _typecheckInvocation(self, token: Token, node: InvocationAstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    self.isStructOrEnumValueAllowed = true
    self.isEnumContainerValueAllowed = true
    val invokee = match self._typecheckExpression(node.invokee, None) { Ok(v) => v, Err(e) => return Err(e) }
    self.isEnumContainerValueAllowed = false
    self.isStructOrEnumValueAllowed = false

    match invokee.kind {
      TypedAstNodeKind.Identifier(identKind) => match identKind {
        TypedIdentifierKind.Named(name, variable) => {
          match variable.alias {
            VariableAlias.Function(fn) => self._typecheckInvocationOfFunction(token, invokee, fn, node, typeHint)
            VariableAlias.Struct(struct) => {
              val initializerFn = Function.initializer(self.currentScope, struct)
              self._typecheckInvocationOfFunction(token, invokee, initializerFn, node, typeHint, None, Some(Instantiatable.Struct(struct)))
            }
            VariableAlias.Enum(enum_) => return Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.IllegalCallableType(Type(kind: TypeKind.Type(StructOrEnum.Enum(enum_))))))
            None => self._typecheckInvocationOfExpression(token, invokee, invokee.token.position, node)
          }
        }
        TypedIdentifierKind.None_ => return Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.IllegalCallableType(Type(kind: TypeKind.Hole, /*nullable: true*/))))
        TypedIdentifierKind.Discard => return unreachable(invokee.token.position, "resolving '_' should fail before reaching here")
      }
      TypedAstNodeKind.Accessor(head, mid, tail) => {
        match tail {
          AccessorPathSegment.EnumVariant(label, _, enum_, variant) => {
            val fields = match variant.kind {
              EnumVariantKind.Constant => return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalCallableType(invokee.ty)))
              EnumVariantKind.Container(fields) => fields
            }

            val enumVariantAsFn = Function.forEnumVariant(self.currentScope, enum_, variant.label, fields)

            self._typecheckInvocationOfFunction(token, invokee, enumVariantAsFn, node, typeHint, None, Some(Instantiatable.EnumContainerVariant(enum_, variant, fields)))
          }
          AccessorPathSegment.Method(l, fn) => {
            val selfVal = if mid[-1] |newTail| {
              TypedAstNode(token: token, ty: newTail.getType(), kind: TypedAstNodeKind.Accessor(head, mid[:-1], newTail))
            } else {
              head
            }

            if self._typeIsOption(invokee.ty) {
              val typedNode = match self._typecheckInvocationOfFunction(token, invokee, fn, node, typeHint, Some((selfVal, true))) { Ok(v) => v, Err(e) => return Err(e) }
              typedNode.ty = Type(kind: TypeKind.Instance(StructOrEnum.Enum(self.project.preludeOptionEnum), [typedNode.ty]))
              Ok(typedNode)
            } else {
              self._typecheckInvocationOfFunction(token, invokee, fn, node, typeHint, Some((selfVal, false)))
            }
          }
          AccessorPathSegment.Field(label, _) => self._typecheckInvocationOfExpression(token, invokee, label.position, node)
        }
      }
      _ => self._typecheckInvocationOfExpression(token, invokee, invokee.token.position, node)
    }
  }

  func _typecheckInvocationOfExpression(self, token: Token, invokeeExpr: TypedAstNode, exprPos: Position, invocationNode: InvocationAstNode): Result<TypedAstNode, TypeError> {
    val _pair = match invokeeExpr.ty.kind {
      TypeKind.Func(paramTypes, returnType) => (paramTypes.map(p => p[0]), returnType)
      _ => return Err(TypeError(position: exprPos, kind: TypeErrorKind.IllegalCallableType(invokeeExpr.ty)))
    }
    // TODO: destructuring
    val paramTypes = _pair[0]
    val returnType = _pair[1]

    if self.paramDefaultValueContext |ctx| {
      ctx.exprContainsFunctionCall = true
      return Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Placeholder))
    }

    val typedArguments: TypedAstNode?[] = []
    for arg, idx in invocationNode.arguments {
      if arg.label |label| {
        return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalParameterLabel))
      }

      var paramType = if paramTypes[idx] |t| t else {
        return Err(TypeError(position: arg.position(), kind: TypeErrorKind.WrongInvocationArity(expected: paramTypes.length, given: invocationNode.arguments.length)))
      }

      val typedArg = match self._typecheckExpression(arg.value, Some(paramType)) { Ok(v) => v, Err(e) => return Err(e) }
      if !self._typeSatisfiesRequired(ty: typedArg.ty, required: paramType) {
        return Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(None, paramType, typedArg.ty)))
      }
      typedArguments.push(Some(typedArg))
    }

    if typedArguments.length < paramTypes.length {
      return Err(TypeError(position: token.position, kind: TypeErrorKind.WrongInvocationArity(expected: paramTypes.length, given: typedArguments.length)))
    }

    val typedInvokee = TypedInvokee.Expr(invokeeExpr)
    Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Invocation(typedInvokee, typedArguments)))
  }

  func _typecheckInvocationOfFunction(
    self,
    token: Token,
    invokee: TypedAstNode,
    fn: Function,
    invocationNode: InvocationAstNode,
    typeHint: Type?,
    selfVal: (TypedAstNode, Bool)? = None,
    instantiationOf: Instantiatable? = None
  ): Result<TypedAstNode, TypeError> {
    // Function invocation is position-based for required parameters, with optional parameter labels to express call-site intent (ie. for Bool params), and it's
    // an error if a positional parameter's label is incorrect. Once we reach any optional parameters in the argument list, parameters can either be positional
    // OR labeled, but once a labeled optional parameter is seen, all subsequent arguments in the argument list must also be labeled.
    val paramsByName = fn.params.keyBy(p => p.label.name)
    val typedArgumentsByName: Map<String, TypedAstNode> = {}
    val resolvedGenerics: Map<String, Type> = {}

    if !invocationNode.typeArguments.isEmpty() {
      for generic, idx in fn.typeParams {
        val typeArg = if invocationNode.typeArguments[idx] |typeArg| typeArg else {
          return Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: fn.typeParams.length, given: invocationNode.typeArguments.length)))
        }
        val typeArgTy = match self._resolveTypeIdentifier(typeArg) { Ok(v) => v, Err(e) => return Err(e) }
        resolvedGenerics[generic[1].name] = typeArgTy
      }
      if invocationNode.typeArguments.length > fn.typeParams.length {
        return Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: fn.typeParams.length, given: invocationNode.typeArguments.length)))
      }
    }

    if typeHint |hint| {
      if hint.kind != TypeKind.PrimitiveUnit && self._containsGenerics(fn.returnType) {
        val extractedGenerics = self._extractGenerics(template: fn.returnType, source: hint)

        for _p in extractedGenerics {
          if resolvedGenerics[_p[0]] |original| {
            if original != _p[1] {
              val returnType = fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
              return Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.TypeMismatch([hint], returnType)))
            }
            continue
          }
          resolvedGenerics[_p[0]] = _p[1]
        }
      }
    }

    if self.paramDefaultValueContext |ctx| {
      ctx.exprContainsFunctionCall = true

      val returnType = if self._containsGenerics(fn.returnType) {
        fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
      } else {
        fn.returnType
      }
      return Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Placeholder))
    }

    val genericsInScope = self._genericsInScope()
    var hasBegunOptionalParams = false
    var variadicParam: (TypedFunctionParam, Int)? = None
    val variadicArgs: TypedAstNode[] = []
    var mostRecentLabeledOptionalParam: Label? = None
    val argumentsQueue = invocationNode.arguments.map((arg, idx) => (arg, idx, 0))
    for _a in argumentsQueue {
      // TODO: destructuring
      val arg = _a[0]
      val idx = if variadicParam |p| p[1] else _a[1]
      val numAttempts = _a[2]

      var param = if fn.params[idx] |param| param else {
        return Err(TypeError(position: arg.position(), kind: TypeErrorKind.WrongInvocationArity(expected: fn.params.length, given: invocationNode.arguments.length)))
      }
      if (!!param.defaultValue) || param.isVariadic { hasBegunOptionalParams = true }

      var paramTy = param.ty
      if arg.label |label| {
        if label.name != param.label.name {
          if !hasBegunOptionalParams {
            return Err(TypeError(position: label.position, kind: TypeErrorKind.ParameterLabelMismatch(expected: param.label.name, given: label.name)))
          }

          param = if paramsByName[label.name] |p| p else {
            return Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownParameterName(label.name)))
          }
          paramTy = param.ty
        }
        if hasBegunOptionalParams && !mostRecentLabeledOptionalParam {
          mostRecentLabeledOptionalParam = Some(label)
        }
        if param.isVariadic {
          paramTy = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [paramTy]))
        }
      } else if instantiationOf |instantiatable| {
        match instantiatable {
          Instantiatable.EnumContainerVariant(_, _, _) => {}
          _ => return Err(TypeError(position: arg.position(), kind: TypeErrorKind.MissingRequiredArgumentLabel))
        }
      } else if mostRecentLabeledOptionalParam |label| {
        return Err(TypeError(position: arg.position(), kind: TypeErrorKind.MixedArgumentType(label)))
      } else {
        if param.isVariadic { variadicParam = Some((param, idx)) }
      }

      val _p = if self._containsGenerics(param.ty) {
        var paramType = paramTy.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)

        val typedArg = match self._typecheckExpression(arg.value, Some(paramType)) { Ok(v) => v, Err(e) => return Err(e) }
        if numAttempts < 1 && typedArg.ty.hasUnfilledHoles() {
          argumentsQueue.push((_a[0], _a[1], numAttempts + 1))
          continue
        }

        val extractedGenerics = self._extractGenerics(template: paramTy, source: typedArg.ty)

        for _p in extractedGenerics {
          if resolvedGenerics[_p[0]] |original| {
            match original.kind {
              TypeKind.Generic => {
                resolvedGenerics[_p[0]] = _p[1]
                continue
              }
              TypeKind.Hole => {
                resolvedGenerics[_p[0]] = _p[1]
                continue
              }
              _ => {}
            }
            if !self._typesAreEquivalent(ty: original, other: _p[1]) {
              return Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(Some(param.label.name), original, typedArg.ty)))
            }
            continue
          }
          resolvedGenerics[_p[0]] = _p[1]
        }

        paramType = paramTy.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)
        (typedArg, paramType)
      } else {
        val typedArg = match self._typecheckExpression(arg.value, Some(paramTy)) { Ok(v) => v, Err(e) => return Err(e) }
        (typedArg, paramTy)
      }
      // TODO: destructuring
      val typedArg = _p[0]
      val paramType = _p[1]
      if !self._typeSatisfiesRequired(ty: typedArg.ty, required: paramType) {
        return Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(Some(param.label.name), paramType, typedArg.ty)))
      }

      if variadicParam {
        variadicArgs.push(typedArg)
      } else {
        typedArgumentsByName[param.label.name] = typedArg
      }
    }

    if variadicParam |_p| {
      val param = _p[0]
      var innerType = param.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)
      val paramType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [innerType]))
      typedArgumentsByName[param.label.name] = TypedAstNode(token: token, ty: paramType, kind: TypedAstNodeKind.Array(variadicArgs))
    }

    val typedArguments: TypedAstNode?[] = []
    for param in fn.params {
      if typedArgumentsByName[param.label.name] |argValue| {
        typedArguments.push(Some(argValue))
      } else if param.defaultValue {
        typedArguments.push(None)
      } else if param.isVariadic {
        var innerType = param.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)
        val paramType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [innerType]))
        typedArguments.push(Some(TypedAstNode(token: token, ty: paramType, kind: TypedAstNodeKind.Array([]))))
      } else {
        val errorKind = if instantiationOf |i| {
          val missing = match i {
            Instantiatable.Struct(struct) => {
              struct.fields
                .filter(f => !f.initializer && !typedArgumentsByName.containsKey(f.name.name))
                .map(f => f.name.name)
            }
            Instantiatable.EnumContainerVariant(_, _, fields) => {
              fields
                .filter(f => !f.initializer && !typedArgumentsByName.containsKey(f.name.name))
                .map(f => f.name.name)
            }
          }
          TypeErrorKind.MissingRequiredFields(missing)
        } else {
          val numRequired = fn.params.filter(p => !p.defaultValue).length
          TypeErrorKind.WrongInvocationArity(expected: numRequired, given: invocationNode.arguments.length)
        }

        return Err(TypeError(position: token.position, kind: errorKind))
      }
    }

    val returnType = if self._containsGenerics(fn.returnType) {
      fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)
    } else {
      fn.returnType
    }

    val typedInvokee = if instantiationOf |i| {
      val v = match i {
        Instantiatable.Struct(struct) => TypedInvokee.Struct(struct)
        Instantiatable.EnumContainerVariant(enum_, variant, _) => TypedInvokee.EnumVariant(enum_, variant)
      }
      v
    } else if selfVal |_p| {
      // TODO: destructuring
      val selfVal = _p[0]
      val isOptSafe = _p[1]
      TypedInvokee.Method(fn, selfVal, isOptSafe)
    } else {
      TypedInvokee.Function(fn)
    }

    Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Invocation(typedInvokee, typedArguments)))
  }

  func _typecheckArray(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerType: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance1(hint, self.project.preludeArrayStruct) |inner| {
        if inner.kind != TypeKind.Hole {
          innerType = Some(inner)
        }
      }
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = match self._typecheckExpression(node: node, typeHint: innerType) { Ok(v) => v, Err(e) => return Err(e) }
      if innerType |ty| {
        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          return Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
        }
      } else if !typedItem.ty.hasUnfilledHoles() {
        innerType = Some(typedItem.ty)
      }
      typedItems.push(typedItem)
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [inner]))
    val innerHasUnfilledHoles = inner.hasUnfilledHoles()

    for item in typedItems {
      if !innerHasUnfilledHoles && item.ty.hasUnfilledHoles() {
        item.ty.tryFillHoles(inner)
        if !self._typeSatisfiesRequired(ty: item.ty, required: inner) {
          return Err(TypeError(position: item.token.position, kind: TypeErrorKind.TypeMismatch([inner], item.ty)))
        }
      }
    }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Array(typedItems)))
  }

  func _typecheckSet(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerType: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance1(hint, self.project.preludeSetStruct) |inner| {
        if inner.kind != TypeKind.Hole {
          innerType = Some(inner)
        }
      }
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = match self._typecheckExpression(node: node, typeHint: innerType) { Ok(v) => v, Err(e) => return Err(e) }
      if innerType |ty| {
        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          return Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
        }
      } else if !typedItem.ty.hasUnfilledHoles() {
        innerType = Some(typedItem.ty)
      }
      typedItems.push(typedItem)
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeSetStruct), [inner]))
    val innerHasUnfilledHoles = inner.hasUnfilledHoles()

    for item in typedItems {
      if !innerHasUnfilledHoles && item.ty.hasUnfilledHoles() {
        item.ty.tryFillHoles(inner)
        if !self._typeSatisfiesRequired(ty: item.ty, required: inner) {
          return Err(TypeError(position: item.token.position, kind: TypeErrorKind.TypeMismatch([inner], item.ty)))
        }
      }
    }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Set(typedItems)))
  }

  func _typecheckMap(self, token: Token, items: (AstNode, AstNode)[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var keyTy: Type? = None
    var valTy: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance2(hint, self.project.preludeMapStruct) |_p| {
        // TODO: destructuring
        val keyHintTy = _p[0]
        val valHintTy = _p[1]
        if keyHintTy.kind != TypeKind.Hole {
          keyTy = Some(keyHintTy)
        }
        if valHintTy.kind != TypeKind.Hole {
          valTy = Some(valHintTy)
        }
      }
    }

    val typedItems: (TypedAstNode, TypedAstNode)[] = []
    for _p in items {
      // TODO: destructuring
      val keyNode = _p[0]
      val valNode = _p[1]

      val typedKey = match keyNode.kind {
        AstNodeKind.Identifier(identKind) => match identKind {
          IdentifierKind.Named(name) => TypedAstNode(token: keyNode.token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.Literal(LiteralAstNode.String(name)))
          IdentifierKind.Discard => TypedAstNode(token: keyNode.token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.Literal(LiteralAstNode.String("_")))
          IdentifierKind.Self => {
            val e = match self._typecheckExpression(node: keyNode, typeHint: keyTy) { Ok(v) => v, Err(e) => return Err(e) }
            e
          }
          IdentifierKind.None_ => {
            val e = match self._typecheckExpression(node: keyNode, typeHint: keyTy) { Ok(v) => v, Err(e) => return Err(e) }
            e
          }
        }
        _ => {
          val e = match self._typecheckExpression(node: keyNode, typeHint: keyTy) { Ok(v) => v, Err(e) => return Err(e) }
          e
        }
      }

      if keyTy |ty| {
        if !self._typeSatisfiesRequired(ty: typedKey.ty, required: ty) {
          return Err(TypeError(position: typedKey.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedKey.ty)))
        }
      } else if !typedKey.ty.hasUnfilledHoles() {
        keyTy = Some(typedKey.ty)
      }

      val typedVal = match self._typecheckExpression(node: valNode, typeHint: valTy) { Ok(v) => v, Err(e) => return Err(e) }
      if valTy |ty| {
        if !self._typeSatisfiesRequired(ty: typedVal.ty, required: ty) {
          return Err(TypeError(position: typedVal.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedVal.ty)))
        }
      } else if !typedVal.ty.hasUnfilledHoles() {
        valTy = Some(typedVal.ty)
      }

      typedItems.push((typedKey, typedVal))
    }

    val kTy = keyTy ?: Type(kind: TypeKind.Hole)
    val vTy = valTy ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeMapStruct), [kTy, vTy]))
    val keyTyHasUnfilledHoles = kTy.hasUnfilledHoles()
    val valTyHasUnfilledHoles = vTy.hasUnfilledHoles()

    for _p in typedItems {
      // TODO: destructuring
      val typedKey = _p[0]
      val typedVal = _p[1]

      if !keyTyHasUnfilledHoles && typedKey.ty.hasUnfilledHoles() { typedKey.ty.tryFillHoles(kTy) }
      if !valTyHasUnfilledHoles && typedVal.ty.hasUnfilledHoles() { typedVal.ty.tryFillHoles(vTy) }
     }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Map(typedItems)))
  }

  func _typecheckTuple(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var typeHints: Type[]? = None
    if typeHint |hint| {
      match hint.kind {
        TypeKind.Tuple(types) => typeHints = Some(types)
        _ => {}
      }
    }

    val typedItems: TypedAstNode[] = []
    for node, idx in items {
      val typeHint = if typeHints |typeHints| typeHints[idx] else None
      val typedExpr = match self._typecheckExpression(node, typeHint) { Ok(v) => v, Err(e) => return Err(e) }
      if typeHint |hint| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: hint) {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([hint], typedExpr.ty)))
        }
      }
      typedItems.push(typedExpr)
    }
    val ty = Type(kind: TypeKind.Tuple(typedItems.map(item => item.ty)))
    if typeHints |typeHints| {
      val hintTy = Type(kind: TypeKind.Tuple(typeHints))
      if !self._typeSatisfiesRequired(ty: ty, required: hintTy) {
        return Err(TypeError(position: token.position, kind: TypeErrorKind.TypeMismatch([hintTy], ty)))
      }
    }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Tuple(typedItems)))
  }

  func _typecheckIndexing(self, token: Token, expr: AstNode, indexMode: IndexingMode<AstNode>, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val typedExpr = match self._typecheckExpression(expr, None) { Ok(v) => v, Err(e) => return Err(e) }
    if self._typeIsOption(typedExpr.ty) {
      return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
    }

    val res = match typedExpr.ty.kind {
      TypeKind.PrimitiveString => {
        val resTy = Type(kind: TypeKind.PrimitiveString)
        self._typecheckIndexingArraylike(token: token, typedExpr: typedExpr, indexMode: indexMode, singleModeType: resTy, rangeModeType: resTy)
      }
      TypeKind.Tuple(types) => self._typecheckIndexingTuple(token, types, typedExpr, indexMode)
      TypeKind.Instance(struct, typeArgs) => {
        if self._typeAsInstance1(typedExpr.ty, self.project.preludeArrayStruct) |inner| {
          val innerAsOpt = Type(kind: TypeKind.Instance(StructOrEnum.Enum(self.project.preludeOptionEnum), [inner]))
          self._typecheckIndexingArraylike(token: token, typedExpr: typedExpr, indexMode: indexMode, singleModeType: innerAsOpt, rangeModeType: typedExpr.ty)
        } else if self._typeAsInstance2(typedExpr.ty, self.project.preludeMapStruct) |_p| {
          // TODO: destructuring
          val keyTy = _p[0]
          val valTy = _p[1]

          match indexMode {
            IndexingMode.Single(idxExpr) => {
              val typedIdxExpr = match self._typecheckExpression(idxExpr, Some(keyTy)) { Ok(v) => v, Err(e) => return Err(e) }
              if !self._typeSatisfiesRequired(ty: typedIdxExpr.ty, required: keyTy) {
                return Err(TypeError(position: typedIdxExpr.token.position, kind: TypeErrorKind.TypeMismatch([keyTy], typedIdxExpr.ty)))
              }

              val ty = Type(kind: TypeKind.Instance(StructOrEnum.Enum(self.project.preludeOptionEnum), [Type(kind: valTy.kind, )]))//nullable: true)
              Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.Map(typedExpr, typedIdxExpr))))
            }
            IndexingMode.Range => return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: true)))
          }
        } else {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
        }
      }
      _ => return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
    }

    res
  }

  func _typecheckIndexingArraylike(self, token: Token, typedExpr: TypedAstNode, indexMode: IndexingMode<AstNode>, singleModeType: Type, rangeModeType: Type): Result<TypedAstNode, TypeError> {
    match indexMode {
      IndexingMode.Single(idxExpr) => {
        val typedIdxExpr = match self._typecheckExpression(idxExpr, None) { Ok(v) => v, Err(e) => return Err(e) }
        val idxTy = typedIdxExpr.ty
        if idxTy.kind != TypeKind.PrimitiveInt || !!self._typeIsOption(idxTy) {
          return Err(TypeError(position: typedIdxExpr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], idxTy)))
        }

        val typedIndexMode = IndexingMode.Single(typedIdxExpr)
        return Ok(TypedAstNode(token: token, ty: singleModeType, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.ArrayLike(typedExpr, typedIndexMode))))
      }
      IndexingMode.Range(startExpr, endExpr) => {
        val typedStartExpr = if startExpr |expr| {
          val e = match self._typecheckExpression(expr, None) { Ok(v) => v, Err(e) => return Err(e) }
          if e.ty.kind != TypeKind.PrimitiveInt || !!self._typeIsOption(e.ty) {
            return Err(TypeError(position: e.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], e.ty)))
          }
          Some(e)
        } else None
        val typedEndExpr = if endExpr |expr| {
          val e = match self._typecheckExpression(expr, None) { Ok(v) => v, Err(e) => return Err(e) }
          if e.ty.kind != TypeKind.PrimitiveInt || !!self._typeIsOption(e.ty) {
            return Err(TypeError(position: e.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], e.ty)))
          }
          Some(e)
        } else None
        val typedIndexMode = IndexingMode.Range(typedStartExpr, typedEndExpr)
        return Ok(TypedAstNode(token: token, ty: rangeModeType, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.ArrayLike(typedExpr, typedIndexMode))))
      }
    }
  }

  func _typecheckIndexingTuple(self, token: Token, tupleItemTypes: Type[], tupleExpr: TypedAstNode, indexMode: IndexingMode<AstNode>): Result<TypedAstNode, TypeError> {
    match indexMode {
      IndexingMode.Single(idxExpr) => {
        match idxExpr.kind {
          AstNodeKind.Literal(lit) => {
            match lit {
              LiteralAstNode.Int(i) => {
                val itemTy = if i < 0
                  return Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.IndexNegative)))
                else if tupleItemTypes[i] |ty|
                  ty
                else
                  return Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.IndexOutOfBounds)))

                Ok(TypedAstNode(token: token, ty: itemTy, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.Tuple(tupleExpr, i))))
              }
              _ => Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.NotIntLiteral)))
            }
          }
          _ => Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.NotLiteralNode)))
        }
      }
      // TODO: should tuples be indexable as a range? it could just create a sub-tuple copy? is that useful at all? seems silly to forbid it
      IndexingMode.Range => Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalIndexableType(ty: tupleExpr.ty, isRange: true)))
    }
  }

  func _typecheckLambda(self, token: Token, node: LambdaNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    var paramHints: Type[] = []
    var retHint: Type? = None
    if typeHint |hint| {
      match hint.kind {
        TypeKind.Func(paramTypes, retType) => {
          for _p in paramTypes {
            val ty = _p[0]
            val isRequired = _p[1]
            if !isRequired return unreachable(token.position, "unexpected non-required param in lambda param type hint")

            paramHints.push(ty)
          }
          retHint = Some(retType)
        }
        _ => {}
      }
    }

    val lambdaName = self.currentScope.nextLambdaName()
    val fnScope = self.currentScope.makeChild(lambdaName, ScopeKind.Func)
    var returnType = retHint ?: Type(kind: TypeKind.Hole)
    if self._containsGenerics(returnType) {
      // If the return type of a lambda contains generics that have not yet been resolved by the time we get here, then
      // they must be "out" generics rather than "in" generics - this means that they should be treated as Holes which will
      // be filled once the return type is discovered, during _typecheckFunctionPass3.
      returnType = returnType.withSubstitutedGenerics(resolvedGenerics: {}, retainUnknown: false, genericsInScope: #{})
    }
    val fn = Function(
      label: Label(name: lambdaName, position: token.position),
      scope: fnScope,
      kind: FunctionKind.Standalone,
      returnType: returnType,
      isLambda: true,
    )

    val paramsNeedingRevisit = match self._typecheckFunctionPass2(fn: fn, allowSelf: false, params: node.params, paramHints: paramHints) { Ok(v) => v, Err(e) => return Err(e) }
    match self._typecheckFunctionPass3(fn: fn, allowSelf: false, params: node.params, body: node.body, paramsNeedingRevisit: paramsNeedingRevisit) { Ok(v) => v, Err(e) => return Err(e) }

    val lambdaTy = fn.getType()

    Ok(TypedAstNode(token: token, ty: lambdaTy, kind: TypedAstNodeKind.Lambda(fn)))
  }
}

func todo<V>(position: Position, reason = ""): Result<V, TypeError> {
  Err(TypeError(position: position, kind: TypeErrorKind.NotYetImplemented(reason)))
}

func unreachable<V>(position: Position, message: String): Result<V, TypeError> {
  Err(TypeError(position: position, kind: TypeErrorKind.Unreachable(message)))
}

// There's currently no notion of asserts in the language but the message here will show up in output files
// which will result in test failures, so in theory it won't go unnoticed. This should only be used in places
// where the above `unreachable` function can't be used (ie. in a non-Result context).
func __assertUnreachable(message: String) {
  println("[ASSERT FAILED]:", message)
}
