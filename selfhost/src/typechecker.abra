import "libc" as libc
import "fs" as fs
import Lexer, LexerError, Token, Position from "./lexer"
import Parser, ParsedModule, ParseError, AstNode, AstNodeKind, LiteralAstNode, UnaryAstNode, UnaryOp from "./parser"

enum TokenizeAndParseError {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
}

export type ModuleLoader {
  rootDirPath: String

  // TODO: This of course does nothing right now
  func resolvePath(self, modulePath: String, relativeTo: String?): String = modulePath

  func tokenizeAndParse(self, modulePath: String): Result<ParsedModule, TokenizeAndParseError> {
    println("modulePath:", modulePath, "|")

    val pathBufferLen = libc.strlen(modulePath._buffer)
    println("[fs::readFile] strlen(modulePath._buffer) = ", pathBufferLen)

    match fs.readFile(modulePath) {
      Result.Ok(contents) => {
        match Lexer.tokenize(contents) {
          Result.Ok(tokens) => {
            match Parser.parse(tokens) {
              Result.Ok(parsedModule) => Result.Ok(parsedModule)
              Result.Err(error) => Result.Err(TokenizeAndParseError.ParseError(error))
            }
          }
          Result.Err(error) => Result.Err(TokenizeAndParseError.LexerError(error))
        }
      }
      Result.Err(e) => Result.Err(TokenizeAndParseError.ReadFileError(modulePath))
    }
  }
}

export type TypedModule {
  id: Int
  name: String
  code: TypedAstNode[]
}

export type Project {
  modules: TypedModule[] = []
}

export enum PrimitiveKind { Int, Float, Bool, String }

export enum Type {
  Primitive(kind: PrimitiveKind)

  func repr(self): String {
    match self {
      Type.Primitive(kind) => match kind {
        PrimitiveKind.Int => "Int"
        PrimitiveKind.Float => "Float"
        PrimitiveKind.Bool => "Bool"
        PrimitiveKind.String => "String"
      }
    }
  }
}

export type TypedAstNode {
  token: Token
  ty: Type
  kind: TypedAstNodeKind
}

export enum TypedAstNodeKind {
  Literal(value: LiteralAstNode)
  Unary(op: UnaryOp, expr: TypedAstNode)
  // Binary(...)
  Grouped(inner: TypedAstNode)
}

type TypecheckerError {
  modulePath: String
  kind: TypecheckerErrorKind

  func getMessage(self): String {
    match self.kind {
      // TODO: Better error message, once imports are a thing
      TypecheckerErrorKind.ReadFileError(path) => "Could not read file '$path'"
      TypecheckerErrorKind.LexerError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.ParseError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.TypeError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
    }
  }
}

enum TypecheckerErrorKind {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
  TypeError(inner: TypeError)
}

type TypeError {
  position: Position
  kind: TypeErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      TypeErrorKind.TypeMismatch(expected, received) => {
        lines.push("Type mismatch")
        lines.push(self._getCursorLine(self.position, contents))

        val expectedReprs = expected.map(t => t.repr()).join(", ")
        if expected.length == 1 {
          lines.push("Expected: " + expectedReprs)
        } else {
          lines.push("Expected one of: " + expectedReprs)
        }
        lines.push("but instead found: " + received.repr())
      }
      TypeErrorKind.NotYetImplemented => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum TypeErrorKind {
  NotYetImplemented
  TypeMismatch(expected: Type[], received: Type)
}

export type Typechecker {
  moduleLoader: ModuleLoader
  project: Project

  func typecheckEntrypoint(self, modulePathAbs: String): Result<Int, TypecheckerError> {
    self._typecheckModule(modulePathAbs)
  }

  func _tokenizeAndParse(self, modulePath: String, relativeTo: String? = None): Result<ParsedModule, TypecheckerError> {
    val absPath = self.moduleLoader.resolvePath(modulePath, relativeTo)
    match self.moduleLoader.tokenizeAndParse(absPath) {
      Result.Ok(mod) => Result.Ok(mod)
      Result.Err(e) => {
        val kind = match e {
          TokenizeAndParseError.ReadFileError(path) => TypecheckerErrorKind.ReadFileError(path)
          TokenizeAndParseError.LexerError(inner) => TypecheckerErrorKind.LexerError(inner)
          TokenizeAndParseError.ParseError(inner) => TypecheckerErrorKind.ParseError(inner)
        }

        return Result.Err(TypecheckerError(modulePath: modulePath, kind: kind))
      }
    }
  }

  func _typecheckModule(self, modulePath: String): Result<Int, TypecheckerError> {
    val moduleId = self.project.modules.length

    val mod = TypedModule(id: moduleId, name: modulePath, code: [])
    self.project.modules.push(mod)

    val parsedModule = match self._tokenizeAndParse(modulePath) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    for importNode in parsedModule.imports { /* todo */ }

    mod.code = match self._typecheckBlock(parsedModule.nodes) {
      Result.Ok(v) => v
      Result.Err(e) => return Result.Err(TypecheckerError(modulePath: modulePath, kind: TypecheckerErrorKind.TypeError(e)))
    }

    Result.Ok(moduleId)
  }

  func _typecheckBlock(self, nodes: AstNode[]): Result<TypedAstNode[], TypeError> {
    // TODO: handle incremental passes for func/type/enum declaration

    val typedNodes: TypedAstNode[] = []

    for node in nodes {
      val res = match node.kind {
        AstNodeKind.FunctionDeclaration => return todo(node.token.position)
        AstNodeKind.TypeDeclaration => return todo(node.token.position)
        AstNodeKind.EnumDeclaration => return todo(node.token.position)
        _ => self._typecheckStatement(node: node, typeHint: None)
      }

      val typedNode = match res { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }

    return Result.Ok(typedNodes)
  }

  func _typecheckStatement(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    match node.kind {
      // TODO: switch on node type
      _ => self._typecheckExpression(node, typeHint)
    }
  }

  func _typecheckExpression(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token
    match node.kind {
      AstNodeKind.Literal(literal) => {
        val primitiveKind = match literal {
          LiteralAstNode.Int => PrimitiveKind.Int
          LiteralAstNode.Float => PrimitiveKind.Float
          LiteralAstNode.Bool => PrimitiveKind.Bool
          LiteralAstNode.String => PrimitiveKind.String
        }
        val ty = Type.Primitive(primitiveKind)
        Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Literal(literal)))
      }
      AstNodeKind.Unary(node) => self._typecheckUnary(token, node)
      AstNodeKind.Binary => todo(node.token.position)
      AstNodeKind.Grouped(inner) => {
        val expr = match self._typecheckExpression(inner, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Grouped(expr)))
      }
      _ => todo(node.token.position)
    }
  }

  func _typecheckUnary(self, token: Token, node: UnaryAstNode): Result<TypedAstNode, TypeError> {
    val expr = match self._typecheckExpression(node: node.expr, typeHint: None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match node.op {
      UnaryOp.Minus => {
        if expr.ty != Type.Primitive(PrimitiveKind.Int) && expr.ty != Type.Primitive(PrimitiveKind.Float) {
          val expected = [Type.Primitive(PrimitiveKind.Int), Type.Primitive(PrimitiveKind.Float)]
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch(expected, expr.ty)))
        }
      }
      UnaryOp.Negate => {
        if expr.ty != Type.Primitive(PrimitiveKind.Bool) {
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch([Type.Primitive(PrimitiveKind.Bool)], expr.ty)))
        }
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Unary(op: node.op, expr: expr)))
  }
}

func todo<V>(position: Position): Result<V, TypeError> {
  Result.Err(TypeError(position: position, kind: TypeErrorKind.NotYetImplemented))
}