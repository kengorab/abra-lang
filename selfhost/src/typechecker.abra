import "fs" as fs
import Lexer, LexerError, Token, TokenKind, Position from "./lexer"
import Parser, ParsedModule, ParseError, AstNode, AstNodeKind, LiteralAstNode, UnaryAstNode, UnaryOp, BindingDeclarationNode, BindingPattern, TypeIdentifier, Label, IdentifierKind, FunctionDeclarationNode from "./parser"

enum TokenizeAndParseError {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
}

export type ModuleLoader {
  rootDirPath: String

  // TODO: This of course does nothing right now
  func resolvePath(self, modulePath: String, relativeTo: String?): String = modulePath

  func tokenizeAndParse(self, modulePath: String): Result<ParsedModule, TokenizeAndParseError> {
    match fs.readFile(modulePath) {
      Result.Ok(contents) => {
        match Lexer.tokenize(contents) {
          Result.Ok(tokens) => {
            match Parser.parse(tokens) {
              Result.Ok(parsedModule) => Result.Ok(parsedModule)
              Result.Err(error) => Result.Err(TokenizeAndParseError.ParseError(error))
            }
          }
          Result.Err(error) => Result.Err(TokenizeAndParseError.LexerError(error))
        }
      }
      Result.Err(e) => Result.Err(TokenizeAndParseError.ReadFileError(modulePath))
    }
  }
}

export type TypedModule {
  id: Int
  name: String
  code: TypedAstNode[]
  rootScope: Scope
}

export enum VariableAlias {
  Function(fn: Function)
}

export type Variable {
  label: Label
  mutable: Bool
  ty: Type
  alias: VariableAlias? = None
}

export type Scope {
  name: String
  variables: Variable[] = []
  functions: Function[] = []
  parent: Scope? = None

  func makeChild(self, name: String): Scope = Scope(name: "${self.name}::$name", parent: self)
}

export type Project {
  modules: TypedModule[] = []
  preludeArrayStruct: Struct = Struct(moduleId: 0, name: "Array", generics: ["T"])
}

type Struct {
  moduleId: Int
  name: String
  generics: String[] = []
}

export type Type {
  kind: TypeKind
  nullable: Bool = false

  func clone(self): Type = Type(kind: self.kind, nullable: self.nullable)

  func repr(self): String {
    val repr = match self.kind {
      TypeKind.PrimitiveUnit => "Unit"
      TypeKind.PrimitiveInt => "Int"
      TypeKind.PrimitiveFloat => "Float"
      TypeKind.PrimitiveBool => "Bool"
      TypeKind.PrimitiveString => "String"
      TypeKind.Instance(struct, typeParams) => {
        if struct.moduleId == 0 && struct.name == "Array" {
          val innerRepr = typeParams[0]?.repr() ?: "<unknown>"
          "$innerRepr[]"
        } else {
          val genericsRepr = if typeParams.isEmpty() "" else {
            val reprs = typeParams.map(t => t.repr()).join(", ")
            "<$reprs>"
          }
          "${struct.name}$genericsRepr"
        }
      }
      TypeKind.Func(paramTypes, returnType) => {
        val paramsRepr = paramTypes.map(t => t.repr()).join(", ")
        val returnTypeRepr = returnType.repr()
        val repr = "($paramsRepr) => $returnTypeRepr"

        if self.nullable return "($repr)?"
        repr
      }
      TypeKind.Hole => "<unknown>"
    }

    if self.nullable "$repr?" else repr
  }

  func hasUnfilledHoles(self): Bool = match self.kind {
    TypeKind.PrimitiveUnit => false
    TypeKind.PrimitiveInt => false
    TypeKind.PrimitiveFloat => false
    TypeKind.PrimitiveBool => false
    TypeKind.PrimitiveString => false
    TypeKind.Instance(_, generics) => generics.any(t => t.hasUnfilledHoles())
    TypeKind.Func(paramTypes, returnType) => paramTypes.any(t => t.hasUnfilledHoles()) || returnType.hasUnfilledHoles()
    TypeKind.Hole => true
  }

  func tryFillHoles(self, other: Type) {
    // TODO: this code is pretty ugly - I really need a way of destructuring multiple values simultaneously in `match`es
    match self.kind {
      TypeKind.Instance(selfStruct, selfGenerics) => {
        match other.kind {
          TypeKind.Instance(otherStruct, otherGenerics) => {
            if selfStruct != otherStruct return

            for generic, idx in selfGenerics {
              generic.tryFillHoles(otherGenerics[idx] ?: Type(kind: TypeKind.Hole))
            }
          }
          _ => {}
        }
      }
      _ => {
        if self.kind == TypeKind.Hole {
          self.kind = other.kind
        }
      }
    }
  }
}

export enum TypeKind {
  PrimitiveUnit
  PrimitiveInt
  PrimitiveFloat
  PrimitiveBool
  PrimitiveString
  Instance(struct: Struct, generics: Type[])
  Func(paramTypes: Type[], returnType: Type)
  Hole
}

export type TypedAstNode {
  token: Token
  ty: Type
  kind: TypedAstNodeKind
}

type TypedBindingDeclarationNode {
  bindingPattern: BindingPattern
  variables: Variable[]
  expr: TypedAstNode?
}

type TypedFunctionParam {
  label: Label
  ty: Type
  defaultValue: TypedAstNode?
  isVariadic: Bool = false
}

export type Function {
  label: Label
  scope: Scope
  params: TypedFunctionParam[]
  returnType: Type
  body: TypedAstNode[]
}

export enum TypedAstNodeKind {
  Literal(value: LiteralAstNode)
  Unary(op: UnaryOp, expr: TypedAstNode)
  // Binary(...)
  Grouped(inner: TypedAstNode)
  Identifier(kind: IdentifierKind)
  Array(items: TypedAstNode[])
  If(isStatement: Bool, typedCondition: TypedAstNode, typedIfBlock: TypedAstNode[], typedElseBlock: TypedAstNode[])

  BindingDeclaration(node: TypedBindingDeclarationNode)
  FunctionDeclaration(fn: Function)
}

type TypecheckerError {
  modulePath: String
  kind: TypecheckerErrorKind

  func getMessage(self): String {
    match self.kind {
      // TODO: Better error message, once imports are a thing
      TypecheckerErrorKind.ReadFileError(path) => "Could not read file '$path'"
      TypecheckerErrorKind.LexerError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.ParseError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.TypeError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
    }
  }
}

enum TypecheckerErrorKind {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
  TypeError(inner: TypeError)
}

type TypeError {
  position: Position
  kind: TypeErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      TypeErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      TypeErrorKind.Unreachable(message) => {
        lines.push("Unreachable code reached")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Internal error: $message")
      }
      TypeErrorKind.TypeMismatch(expected, received) => {
        lines.push("Type mismatch")
        lines.push(self._getCursorLine(self.position, contents))

        val expectedReprs = expected.map(t => t.repr()).join(", ")
        if expected.length == 1 {
          lines.push("Expected: " + expectedReprs)
        } else {
          lines.push("Expected one of: " + expectedReprs)
        }
        lines.push("but instead found: " + received.repr())
      }
      TypeErrorKind.DuplicateName(original) => {
        lines.push("Duplicate name '${original.name}'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This name is also declared at (${original.position.line}:${original.position.col})")
        lines.push(self._getCursorLine(original.position, contents))
      }
      TypeErrorKind.UnknownName(name, kind) => {
        lines.push("Unknown $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        if name == "_" {
          lines.push("The '_' identifier is a special name used to discard values, and it cannot be referenced")
        } else {
          lines.push("No $kind with that name is visible in current scope")
        }
      }
      TypeErrorKind.MissingValExpr(name) => {
        lines.push("Missing initializer for immutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.MissingVarExprAndTypeAnn(name) => {
        lines.push("Could not determine type of mutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("A 'var' must have either an initial value or a type annotation (or both)")
      }
      TypeErrorKind.IllegalValueType(ty, purpose) => {
        if ty.kind == TypeKind.PrimitiveUnit {
          lines.push("Forbidden type for $purpose")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Instances of type ${ty.repr()} cannot be used as $purpose values")
        } else {
          lines.push("Could not determine type for $purpose")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Type '${ty.repr()}' has unfilled holes. Please use an explicit type annotation to denote the type")
        }
      }
      TypeErrorKind.IllegalConditionType(ty, purpose) => {
        lines.push("Forbidden type for $purpose-condition")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Conditions must either be Bool or Option types")
        lines.push("but instead found " + ty.repr())
      }
      TypeErrorKind.MissingRequiredIfExprBlock(clause, missing) => {
        lines.push("Incomplete if-expression")
        lines.push(self._getCursorLine(self.position, contents))
        if missing {
          lines.push("The $clause-block must exist and contain a value")
        } else {
          lines.push("The $clause-block must contain a value")
        }
      }
      TypeErrorKind.DuplicateParameter(name) => {
        lines.push("Duplicate parameter '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.InvalidParamPosition(purpose) => {
        match purpose {
          "vararg" => {
            lines.push("Invalid position for variadic parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Variadic parameters must be the last in the parameter list")
          }
          "required" => {
            lines.push("Invalid position for required parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Required parameters must all be listed before any optional parameters")
          }
          _ => { /* no other cases */ }
        }
      }
      TypeErrorKind.InvalidVarargType(ty) => {
        lines.push("Invalid type for vararg parameter")
        lines.push(self._getCursorLine(self.position, contents))
        if ty.nullable {
          lines.push("Vararg parameters must be a non-Option Array type, but got ${ty.repr()}")
        } else {
          lines.push("Vararg parameters must be an Array type, but got ${ty.repr()}")
        }
      }
      TypeErrorKind.ReturnTypeMismatch(fnName, expected, received) => {
        if fnName |name| {
          lines.push("Return type mismatch for function '$name'")
        } else {
          lines.push("Return type mismatch for lambda function")
        }

        lines.push(self._getCursorLine(self.position, contents))

        lines.push("Expected ${expected.repr()}")
        if received |received| {
          lines.push("but instead found ${received.repr()}")
        } else {
          lines.push("but function had empty body")
        }
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum TypeErrorKind {
  NotYetImplemented(reason: String)
  Unreachable(message: String)
  TypeMismatch(expected: Type[], received: Type)
  DuplicateName(original: Label)
  UnknownName(name: String, kind: String)
  MissingValExpr(name: String)
  MissingVarExprAndTypeAnn(name: String)
  IllegalValueType(ty: Type, purpose: String)
  IllegalConditionType(ty: Type, purpose: String)
  MissingRequiredIfExprBlock(clause: String, missing: Bool)
  InvalidParamPosition(purpose: String)
  DuplicateParameter(name: String)
  InvalidVarargType(ty: Type)
  ReturnTypeMismatch(fnName: String?, expected: Type, received: Type?)
}

export type Typechecker {
  moduleLoader: ModuleLoader
  project: Project
  currentScope: Scope = Scope(name: "\$root")

  func typecheckEntrypoint(self, modulePathAbs: String): Result<Int, TypecheckerError> {
    val mod = TypedModule(id: 0, name: "prelude", code: [], rootScope: self.currentScope.makeChild("module_0"))
    self.project.modules.push(mod)

    self._typecheckModule(modulePathAbs)
  }

  func _tokenizeAndParse(self, modulePath: String, relativeTo: String? = None): Result<ParsedModule, TypecheckerError> {
    val absPath = self.moduleLoader.resolvePath(modulePath, relativeTo)
    match self.moduleLoader.tokenizeAndParse(absPath) {
      Result.Ok(mod) => Result.Ok(mod)
      Result.Err(e) => {
        val kind = match e {
          TokenizeAndParseError.ReadFileError(path) => TypecheckerErrorKind.ReadFileError(path)
          TokenizeAndParseError.LexerError(inner) => TypecheckerErrorKind.LexerError(inner)
          TokenizeAndParseError.ParseError(inner) => TypecheckerErrorKind.ParseError(inner)
        }

        return Result.Err(TypecheckerError(modulePath: modulePath, kind: kind))
      }
    }
  }

  func _verifyNameUniqueInScope(self, label: Label, scope: Scope): TypeError? {
    for v in scope.variables {
      if v.label.name == label.name {
        return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: v.label))
      }
    }

    for f in scope.functions {
      if f.label.name == label.name {
        return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: f.label))
      }
    }

    None
  }

  func _addVariableToScope(self, variable: Variable, scope = self.currentScope): Result<Int, TypeError> {
    if variable.label.name == "_" return Result.Ok(0) // <- unnecessary 0

    if self._verifyNameUniqueInScope(variable.label, scope) |e| return Result.Err(e)
    scope.variables.push(variable)

    Result.Ok(0) // <- unnecessary 0
  }

  func _addFunctionToScope(self, fn: Function, scope = self.currentScope): Result<Int, TypeError> {
    if self._verifyNameUniqueInScope(fn.label, scope) |e| return Result.Err(e)
    scope.functions.push(fn)

    Result.Ok(0) // <- unnecessary 0
  }

  func _resolveTypeIdentifier(self, typeIdent: TypeIdentifier): Result<Type, TypeError> {
    val ty = match typeIdent {
      TypeIdentifier.Normal(label) => match label.name {
        "Int" => Type(kind: TypeKind.PrimitiveInt)
        "Float" => Type(kind: TypeKind.PrimitiveFloat)
        "Bool" => Type(kind: TypeKind.PrimitiveBool)
        "String" => Type(kind: TypeKind.PrimitiveString)
        _ => return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
      }
      TypeIdentifier.Array(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Type(kind: TypeKind.Instance(self.project.preludeArrayStruct, [innerTy]))
      }
      TypeIdentifier.Option(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        innerTy.nullable = true
        innerTy
      }
      TypeIdentifier.Tuple => return todo(Position(line: 0, col: 0))
      TypeIdentifier.Function(params, ret) => {
        val paramTypes: Type[] = []
        for p in params {
          val t = match self._resolveTypeIdentifier(p) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          paramTypes.push(t)
        }

        val returnType = match self._resolveTypeIdentifier(ret) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Type(kind: TypeKind.Func(paramTypes, returnType))
      }
    }

    Result.Ok(ty)
  }

  func _resolveIdentifier(self, ident: String): Variable? {
    var scope: Scope? = self.currentScope
    while scope |s| {
      for v in s.variables {
        if v.label.name == ident return v
      }
      scope = s.parent
    }

    None
  }

  func _typeSatisfiesRequired(self, ty: Type, required: Type): Bool {
    if ty.nullable && !required.nullable return false

    if required.kind == TypeKind.Hole return true

    ty.kind == required.kind
  }

  func _typeAsArray(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(struct, generics) => if struct == self.project.preludeArrayStruct { generics[0] } else None
      _ => None
    }
  }

  func _typecheckModule(self, modulePath: String): Result<Int, TypecheckerError> {
    val moduleId = self.project.modules.length

    val moduleScope = self.currentScope.makeChild("module_$moduleId")
    val prevScope = self.currentScope
    self.currentScope = moduleScope
    val mod = TypedModule(id: moduleId, name: modulePath, code: [], rootScope: moduleScope)
    self.project.modules.push(mod)

    val parsedModule = match self._tokenizeAndParse(modulePath) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    for importNode in parsedModule.imports { /* todo */ }

    mod.code = match self._typecheckBlock(parsedModule.nodes) {
      Result.Ok(v) => v
      Result.Err(e) => return Result.Err(TypecheckerError(modulePath: modulePath, kind: TypecheckerErrorKind.TypeError(e)))
    }

    self.currentScope = prevScope
    Result.Ok(moduleId)
  }

  func _typecheckFunctionPass1(self, node: FunctionDeclarationNode): Result<Function, TypeError> {
    val returnType = if node.returnTypeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    val fnScope = self.currentScope.makeChild(node.name.name)
    val fn = Function(label: node.name, scope: fnScope, params: [], returnType: returnType, body: [])
    match self._addFunctionToScope(fn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(fn)
  }

  func _typecheckFunctionPass2(self, fn: Function, node: FunctionDeclarationNode): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope

    val seenParamNames: Set<String> = #{}
    var startedOptionalParams = false
    for param, idx in node.params {
      if param.isVariadic && idx != node.params.length - 1 {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "vararg")))
      }
      if param.label.name == "self" return todo(param.label.position, "methods not yet implemented")
      if seenParamNames.contains(param.label.name) {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.DuplicateParameter(param.label.name)))
      }
      seenParamNames.insert(param.label.name)

      val paramType = if param.typeAnnotation |typeAnn| {
        val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        ty
      } else {
        None
      }

      var defaultValue: TypedAstNode? = None
      if param.defaultValue |node| {
        startedOptionalParams = true
        val expr = match self._typecheckExpression(node, paramType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        defaultValue = expr
      } else if startedOptionalParams {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "required")))
      }

      var ty = if paramType |paramType| {
        if defaultValue |defaultValue| {
          if !self._typeSatisfiesRequired(ty: defaultValue.ty, required: paramType) {
            return Result.Err(TypeError(position: defaultValue.token.position, kind: TypeErrorKind.TypeMismatch([paramType], defaultValue.ty)))
          }
        }

        paramType
      } else {
        if defaultValue |defaultValue| {
          defaultValue.ty
        } else {
          return unreachable(param.label.position, "parser requires at least a type annotation or default value")
        }
      }

      val variable = Variable(label: param.label, mutable: false, ty: ty)
      match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      if param.isVariadic {
        if ty.nullable {
          return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidVarargType(ty)))
        } else if self._typeAsArray(ty) |innerType| {
          ty = innerType
        } else {
          return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidVarargType(ty)))
        }
      }

      if ty.hasUnfilledHoles() {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "parameter")))
      }

      fn.params.push(TypedFunctionParam(label: param.label, ty: ty, defaultValue: defaultValue, isVariadic: param.isVariadic))
    }

    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckFunctionPass3(self, fn: Function, fnDeclNode: FunctionDeclarationNode): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope

    val hasReturnValue = fn.returnType.kind != TypeKind.PrimitiveUnit
    if hasReturnValue && fnDeclNode.body.isEmpty() {
      return Result.Err(TypeError(position: fn.label.position, kind: TypeErrorKind.ReturnTypeMismatch(fn.label.name, fn.returnType, None)))
    }

    for node, idx in fnDeclNode.body {
      val typedNode = if idx == fnDeclNode.body.length - 1 && hasReturnValue {
        val expr = match self._typecheckExpression(node, fn.returnType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if !self._typeSatisfiesRequired(ty: expr.ty, required: fn.returnType) {
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fn.label.name, fn.returnType, expr.ty)))
        }
        expr
      } else {
        val stmt = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        stmt
      }
      fn.body.push(typedNode)
    }

    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckBlock(self, nodes: AstNode[]): Result<TypedAstNode[], TypeError> {
    val functions: (Function, Variable, FunctionDeclarationNode)[] = []
    for node in nodes {
      match node.kind {
        AstNodeKind.FunctionDeclaration(node) => {
          val fn = match self._typecheckFunctionPass1(node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          val fnType = Type(kind: TypeKind.Func(paramTypes: [], returnType: fn.returnType))
          val aliasVar = Variable(label: fn.label, mutable: false, ty: fnType, alias: VariableAlias.Function(fn))
          self.currentScope.variables.push(aliasVar)
          functions.push((fn, aliasVar, node))
        }
        _ => {}
      }
    }

    for fnPair in functions {
      val fn = fnPair[0]
      val aliasVar = fnPair[1]
      val node = fnPair[2]
      match self._typecheckFunctionPass2(fn, node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      val fnType = Type(kind: TypeKind.Func(paramTypes: fn.params.map(p => p.ty), returnType: fn.returnType))
      aliasVar.ty = fnType
    }

    val functionsIter = functions.iterator()

    val typedNodes: TypedAstNode[] = []

    for node in nodes {
      val res = match node.kind {
        AstNodeKind.FunctionDeclaration => {
          val typedNode = if functionsIter.next() |pair| {
            val fn = pair[0]
            val fnDeclNode = pair[2]
            match self._typecheckFunctionPass3(fn, fnDeclNode) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.FunctionDeclaration(fn))
          } else {
            return unreachable(node.token.position, "there should be as many functions as there are functiondecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        AstNodeKind.TypeDeclaration => return todo(node.token.position)
        AstNodeKind.EnumDeclaration => return todo(node.token.position)
        _ => self._typecheckStatement(node: node, typeHint: None)
      }

      val typedNode = match res { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }

    return Result.Ok(typedNodes)
  }

  func _typecheckStatement(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token

    match node.kind {
      AstNodeKind.BindingDeclaration(node) => self._typecheckBindingDeclaration(token, node)
      _ => self._typecheckExpression(node, Type(kind: TypeKind.PrimitiveUnit))
    }
  }

  func _typecheckBindingDeclaration(self, token: Token, node: BindingDeclarationNode): Result<TypedAstNode, TypeError> {
    val isMutable = token.kind == TokenKind.Var

    val label = match node.bindingPattern {
      BindingPattern.Variable(label) => label
    }

    val annType = if node.typeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty
    } else {
      None
    }

    val _pair = if node.expr |expr| {
      val typedExpr = match self._typecheckExpression(expr, annType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val ty = if annType |annotatedType| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: annotatedType) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([annotatedType], typedExpr.ty)))
        }

        annotatedType
      } else {
        typedExpr.ty
      }

      if ty.kind == TypeKind.PrimitiveUnit || ty.hasUnfilledHoles() {
        return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "assignment")))
      }

      // TODO: type could not be auto-coerced to `TypedAstNode?` on its own
      val typedExpr_: TypedAstNode? = typedExpr
      (typedExpr_, ty)
    } else if !isMutable {
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingValExpr(label.name)))
    } else if annType |ty| {
      (None, ty)
    } else {
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(label.name)))
    }
    // TODO: destructuring
    val expr = _pair[0]
    val ty = _pair[1]

    val variable = Variable(label: label, mutable: isMutable, ty: ty)
    match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val typedNode = TypedBindingDeclarationNode(bindingPattern: node.bindingPattern, variables: [variable], expr: expr)
    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.BindingDeclaration(typedNode)))
  }

  func _typecheckIf(
    self,
    token: Token,
    condition: AstNode,
    conditionBinding: BindingPattern?,
    ifBlock: AstNode[],
    elseBlock: AstNode[]?,
    typeHint: Type?,
  ): Result<TypedAstNode, TypeError> {
    val isStatement = if typeHint |hint| hint.kind == TypeKind.PrimitiveUnit else false

    val typedCondition = match self._typecheckExpression(condition, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    if typedCondition.ty.kind != TypeKind.PrimitiveBool && !typedCondition.ty.nullable {
      return Result.Err(TypeError(position: typedCondition.token.position, kind: TypeErrorKind.IllegalConditionType(ty: typedCondition.ty, purpose: "if")))
    }

    val typedIfBlock: TypedAstNode[] = []
    var prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("if_then")
    for node, idx in ifBlock {
      if idx == ifBlock.length - 1 && !isStatement {
        val typedNode = match self._typecheckExpression(node, typeHint) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        typedIfBlock.push(typedNode)
      } else {
        val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        typedIfBlock.push(typedNode)
      }
    }
    val ifType = typedIfBlock[-1]?.ty
    self.currentScope = prevScope

    var hasElseBlock = false
    val typedElseBlock: TypedAstNode[] = []
    prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("if_else")
    if elseBlock |elseBlock| {
      hasElseBlock = true
      for node, idx in elseBlock {
        if idx == elseBlock.length - 1 && !isStatement {
          val typedNode = match self._typecheckExpression(node, ifType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          typedElseBlock.push(typedNode)
        } else {
          val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          typedElseBlock.push(typedNode)
        }
      }
    }
    self.currentScope = prevScope

    val ty = if !isStatement {
      val t = if ifType |ifType| {
        if typedElseBlock[-1] |lastElseNode| {
          val elseType = lastElseNode.ty

          if ifType.hasUnfilledHoles() {
            ifType.tryFillHoles(elseType)
          }
          if elseType.nullable && !ifType.nullable {
            ifType.nullable = true
          }

          if !self._typeSatisfiesRequired(ty: elseType, required: ifType) {
            return Result.Err(TypeError(position: lastElseNode.token.position, kind: TypeErrorKind.TypeMismatch([ifType], elseType)))
          }

          ifType.clone()
        } else {
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredIfExprBlock(clause: "else", missing: !hasElseBlock)))
        }
      } else {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredIfExprBlock(clause: "if", missing: false)))
      }
      t
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    val kind = TypedAstNodeKind.If(isStatement, typedCondition, typedIfBlock, typedElseBlock)
    Result.Ok(TypedAstNode(token: token, ty: ty, kind: kind))
  }

  func _typecheckExpression(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token
    val typedExprRes: Result<TypedAstNode, TypeError> = match node.kind {
      AstNodeKind.Literal(literal) => {
        val kind = match literal {
          LiteralAstNode.Int => TypeKind.PrimitiveInt
          LiteralAstNode.Float => TypeKind.PrimitiveFloat
          LiteralAstNode.Bool => TypeKind.PrimitiveBool
          LiteralAstNode.String => TypeKind.PrimitiveString
        }

        Result.Ok(TypedAstNode(token: token, ty: Type(kind: kind), kind: TypedAstNodeKind.Literal(literal)))
      }
      AstNodeKind.Unary(node) => self._typecheckUnary(token, node)
      AstNodeKind.Binary => todo(node.token.position, "binary expression")
      AstNodeKind.Grouped(inner) => {
        val expr = match self._typecheckExpression(inner, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Grouped(expr)))
      }
      AstNodeKind.Identifier(kind) => self._typecheckIdentifier(token, kind, typeHint)
      AstNodeKind.Array(items) => self._typecheckArray(token, items, typeHint)
      AstNodeKind.If(condition, conditionBinding, ifBlock, elseBlock) => self._typecheckIf(token, condition, conditionBinding, ifBlock, elseBlock, typeHint)
      _ => todo(node.token.position, "all other expressions")
    }

    val typedExpr = match typedExprRes { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    // If we're parsing an expression in a context where we have a type hint and where that type hint is nullable, we
    // may want to make the expression's type nullable as well, if the types' kinds are equivalent. If the types' kinds
    // are _not_ equivalent, don't do anything because this mismatch will be raised at the callsite.
    if typeHint |hint| {
      if (hint.kind == typedExpr.ty.kind || hint.kind == TypeKind.Hole) && hint.nullable {
        typedExpr.ty.nullable = true
      }
    }

    Result.Ok(typedExpr)
  }

  func _typecheckUnary(self, token: Token, node: UnaryAstNode): Result<TypedAstNode, TypeError> {
    val expr = match self._typecheckExpression(node: node.expr, typeHint: None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match node.op {
      UnaryOp.Minus => {
        if expr.ty.kind != TypeKind.PrimitiveInt && expr.ty.kind != TypeKind.PrimitiveFloat {
          val expected = [Type(kind: TypeKind.PrimitiveInt), Type(kind: TypeKind.PrimitiveFloat)]
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch(expected, expr.ty)))
        }
      }
      UnaryOp.Negate => {
        if expr.ty.kind != TypeKind.PrimitiveBool {
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveBool)], expr.ty)))
        }
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Unary(op: node.op, expr: expr)))
  }

  func _typecheckIdentifier(self, token: Token, kind: IdentifierKind, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val ty = match kind {
      IdentifierKind.Named(name) => {
        val t = if self._resolveIdentifier(name) |variable| {
          variable.ty
        } else {
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName(name, "variable")))
        }
        t
      }
      IdentifierKind.Discard => return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("_", "variable")))
      IdentifierKind.None_ => {
        val kind = typeHint?.kind ?: TypeKind.Hole
        Type(kind: kind, nullable: true)
      }
      IdentifierKind.Self => return todo(token.position)
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Identifier(kind)))
  }

  func _typecheckArray(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerType = if typeHint |hint| {
      if self._typeAsArray(hint) |inner| if inner.kind == TypeKind.Hole None else inner
    } else {
      None
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = match self._typecheckExpression(node: node, typeHint: innerType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if innerType |ty| {
        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          if typedItem.ty.nullable && !ty.nullable {
            ty.nullable = true
            makeItemsNullable = true
          } else {
            return Result.Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
          }
        }
      } else {
        innerType = typedItem.ty
      }
      typedItems.push(typedItem)
    }

    if makeItemsNullable {
      for item in typedItems {
        item.ty.nullable = true
      }
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(self.project.preludeArrayStruct, [inner]))

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Array(typedItems)))
  }
}

func todo<V>(position: Position, reason = ""): Result<V, TypeError> {
  Result.Err(TypeError(position: position, kind: TypeErrorKind.NotYetImplemented(reason)))
}

func unreachable<V>(position: Position, message: String): Result<V, TypeError> {
  Result.Err(TypeError(position: position, kind: TypeErrorKind.Unreachable(message)))
}