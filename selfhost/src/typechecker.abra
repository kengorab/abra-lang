import "fs" as fs
import Lexer, LexerError, Token, TokenKind, Position from "./lexer"
import Parser, ParsedModule, ParseError, AstNode, AstNodeKind, LiteralAstNode, UnaryAstNode, UnaryOp, BindingDeclarationNode, BindingPattern, TypeIdentifier, Label, IdentifierKind from "./parser"

enum TokenizeAndParseError {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
}

export type ModuleLoader {
  rootDirPath: String

  // TODO: This of course does nothing right now
  func resolvePath(self, modulePath: String, relativeTo: String?): String = modulePath

  func tokenizeAndParse(self, modulePath: String): Result<ParsedModule, TokenizeAndParseError> {
    match fs.readFile(modulePath) {
      Result.Ok(contents) => {
        match Lexer.tokenize(contents) {
          Result.Ok(tokens) => {
            match Parser.parse(tokens) {
              Result.Ok(parsedModule) => Result.Ok(parsedModule)
              Result.Err(error) => Result.Err(TokenizeAndParseError.ParseError(error))
            }
          }
          Result.Err(error) => Result.Err(TokenizeAndParseError.LexerError(error))
        }
      }
      Result.Err(e) => Result.Err(TokenizeAndParseError.ReadFileError(modulePath))
    }
  }
}

export type TypedModule {
  id: Int
  name: String
  code: TypedAstNode[]
  rootScope: Scope
}

export type Variable {
  label: Label
  mutable: Bool
  ty: Type
}

type Scope {
  name: String
  variables: Variable[] = []
  parent: Scope? = None

  func makeChild(self, name: String): Scope = Scope(name: "${self.name}::$name", parent: self)
}

export type Project {
  modules: TypedModule[] = []
  preludeArrayStruct: Struct = Struct(moduleId: 0, name: "Array", generics: ["T"])
}

export enum PrimitiveKind { Unit, Int, Float, Bool, String }

type Struct {
  moduleId: Int
  name: String
  generics: String[] = []
}

export enum Type {
  Primitive(kind: PrimitiveKind)
  Option(inner: Type)
  Instance(struct: Struct, generics: Type[])
  Hole

  func repr(self): String {
    match self {
      Type.Primitive(kind) => match kind {
        PrimitiveKind.Unit => "Unit"
        PrimitiveKind.Int => "Int"
        PrimitiveKind.Float => "Float"
        PrimitiveKind.Bool => "Bool"
        PrimitiveKind.String => "String"
      }
      Type.Option(inner) => "${inner.repr()}?"
      Type.Instance(struct, typeParams) => {
        if struct.moduleId == 0 && struct.name == "Array" {
          val repr = (typeParams[0] ?: Type.Hole).repr()
          return "$repr[]"
        }

        val generics = if typeParams.isEmpty() "" else {
          val reprs = typeParams.map(t => t.repr()).join(", ")
          "<$reprs>"
        }
        "${struct.name}$generics"
      }
      Type.Hole => "<unknown>"
    }
  }

  func hasUnfilledHoles(self): Bool = match self {
    Type.Primitive => false
    Type.Option(inner) => inner == Type.Hole
    Type.Instance(_, generics) => generics.any(t => t.hasUnfilledHoles())
    Type.Hole => true
  }
}

export type TypedAstNode {
  token: Token
  ty: Type
  kind: TypedAstNodeKind
}

type TypedBindingDeclarationNode {
  bindingPattern: BindingPattern
  variables: Variable[]
  expr: TypedAstNode?
}

export enum TypedAstNodeKind {
  Literal(value: LiteralAstNode)
  Unary(op: UnaryOp, expr: TypedAstNode)
  // Binary(...)
  Grouped(inner: TypedAstNode)
  Identifier(kind: IdentifierKind)
  Array(items: TypedAstNode[])

  BindingDeclaration(node: TypedBindingDeclarationNode)
}

type TypecheckerError {
  modulePath: String
  kind: TypecheckerErrorKind

  func getMessage(self): String {
    match self.kind {
      // TODO: Better error message, once imports are a thing
      TypecheckerErrorKind.ReadFileError(path) => "Could not read file '$path'"
      TypecheckerErrorKind.LexerError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.ParseError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.TypeError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
    }
  }
}

enum TypecheckerErrorKind {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
  TypeError(inner: TypeError)
}

type TypeError {
  position: Position
  kind: TypeErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      TypeErrorKind.TypeMismatch(expected, received) => {
        lines.push("Type mismatch")
        lines.push(self._getCursorLine(self.position, contents))

        val expectedReprs = expected.map(t => t.repr()).join(", ")
        if expected.length == 1 {
          lines.push("Expected: " + expectedReprs)
        } else {
          lines.push("Expected one of: " + expectedReprs)
        }
        lines.push("but instead found: " + received.repr())
      }
      TypeErrorKind.DuplicateName(original, kind) => {
        lines.push("Duplicate $kind '${original.name}'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This $kind is already declared at (${original.position.line}:${original.position.col})")
        lines.push(self._getCursorLine(original.position, contents))
      }
      TypeErrorKind.UnknownName(name, kind) => {
        lines.push("Unknown $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        if name == "_" {
          lines.push("The '_' identifier is a special name used to discard values, and it cannot be referenced")
        } else {
          lines.push("No $kind with that name is visible in current scope")
        }
      }
      TypeErrorKind.MissingValExpr(name) => {
        lines.push("Missing initializer for immutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.MissingVarExprAndTypeAnn(name) => {
        lines.push("Could not determine type of mutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("A 'var' must have either an initial value or a type annotation (or both)")
      }
      TypeErrorKind.IllegalValueType(ty, purpose) => {
        if ty == Type.Primitive(PrimitiveKind.Unit) {
          lines.push("Forbidden type for $purpose")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Instances of type ${ty.repr()} cannot be used as $purpose values")
        } else {
          lines.push("Could not determine type for $purpose")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Type '${ty.repr()}' has unfilled holes. Please use an explicit type annotation to denote the type")
        }
      }
      TypeErrorKind.NotYetImplemented => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum TypeErrorKind {
  NotYetImplemented
  TypeMismatch(expected: Type[], received: Type)
  DuplicateName(original: Label, kind: String)
  UnknownName(name: String, kind: String)
  MissingValExpr(name: String)
  MissingVarExprAndTypeAnn(name: String)
  IllegalValueType(ty: Type, purpose: String)
}

export type Typechecker {
  moduleLoader: ModuleLoader
  project: Project
  currentScope: Scope = Scope(name: "\$root")

  func typecheckEntrypoint(self, modulePathAbs: String): Result<Int, TypecheckerError> {
    val mod = TypedModule(id: 0, name: "prelude", code: [], rootScope: self.currentScope.makeChild("module_0"))
    self.project.modules.push(mod)

    self._typecheckModule(modulePathAbs)
  }

  func _tokenizeAndParse(self, modulePath: String, relativeTo: String? = None): Result<ParsedModule, TypecheckerError> {
    val absPath = self.moduleLoader.resolvePath(modulePath, relativeTo)
    match self.moduleLoader.tokenizeAndParse(absPath) {
      Result.Ok(mod) => Result.Ok(mod)
      Result.Err(e) => {
        val kind = match e {
          TokenizeAndParseError.ReadFileError(path) => TypecheckerErrorKind.ReadFileError(path)
          TokenizeAndParseError.LexerError(inner) => TypecheckerErrorKind.LexerError(inner)
          TokenizeAndParseError.ParseError(inner) => TypecheckerErrorKind.ParseError(inner)
        }

        return Result.Err(TypecheckerError(modulePath: modulePath, kind: kind))
      }
    }
  }

  func _addVariableToScope(self, variable: Variable, scope = self.currentScope): Result<Int, TypeError> {
    if variable.label.name == "_" return Result.Ok(0) // <- unnecessary 0

    for v in scope.variables {
      if v.label.name == variable.label.name {
        val kind = TypeErrorKind.DuplicateName(original: v.label, kind: "name")
        return Result.Err(TypeError(position: variable.label.position, kind: kind))
      }
    }

    scope.variables.push(variable)

    Result.Ok(0) // <- unnecessary 0
  }

  func _resolveTypeIdentifier(self, typeIdent: TypeIdentifier): Result<Type, TypeError> {
    val ty = match typeIdent {
      TypeIdentifier.Normal(label) => match label.name {
        "Int" => Type.Primitive(PrimitiveKind.Int)
        "Float" => Type.Primitive(PrimitiveKind.Float)
        "Bool" => Type.Primitive(PrimitiveKind.Bool)
        "String" => Type.Primitive(PrimitiveKind.String)
        _ => return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
      }
      TypeIdentifier.Array(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Type.Instance(self.project.preludeArrayStruct, [innerTy])
      }
      TypeIdentifier.Option(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Type.Option(innerTy)
      }
      TypeIdentifier.Tuple => return todo(Position(line: 0, col: 0))
      TypeIdentifier.Function => return todo(Position(line: 0, col: 0))
    }

    Result.Ok(ty)
  }

  func _resolveIdentifier(self, ident: String): Variable? {
    var scope: Scope? = self.currentScope
    while scope |s| {
      for v in s.variables {
        if v.label.name == ident return v
      }
      scope = s.parent
    }

    None
  }

  func _typeSatisfiesRequired(self, ty: Type, required: Type): Bool {
    match required {
      Type.Option(inner) => match ty { Type.Option => ty == required, _ => ty == inner }
      _ => ty == required
    }
  }

  func _typecheckModule(self, modulePath: String): Result<Int, TypecheckerError> {
    val moduleId = self.project.modules.length

    val moduleScope = self.currentScope.makeChild("module_$moduleId")
    val prevScope = self.currentScope
    self.currentScope = moduleScope
    val mod = TypedModule(id: moduleId, name: modulePath, code: [], rootScope: moduleScope)
    self.project.modules.push(mod)

    val parsedModule = match self._tokenizeAndParse(modulePath) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    for importNode in parsedModule.imports { /* todo */ }

    mod.code = match self._typecheckBlock(parsedModule.nodes) {
      Result.Ok(v) => v
      Result.Err(e) => return Result.Err(TypecheckerError(modulePath: modulePath, kind: TypecheckerErrorKind.TypeError(e)))
    }

    self.currentScope = prevScope
    Result.Ok(moduleId)
  }

  func _typecheckBlock(self, nodes: AstNode[]): Result<TypedAstNode[], TypeError> {
    // TODO: handle incremental passes for func/type/enum declaration

    val typedNodes: TypedAstNode[] = []

    for node in nodes {
      val res = match node.kind {
        AstNodeKind.FunctionDeclaration => return todo(node.token.position)
        AstNodeKind.TypeDeclaration => return todo(node.token.position)
        AstNodeKind.EnumDeclaration => return todo(node.token.position)
        _ => self._typecheckStatement(node: node, typeHint: None)
      }

      val typedNode = match res { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }

    return Result.Ok(typedNodes)
  }

  func _typecheckStatement(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token

    match node.kind {
      AstNodeKind.BindingDeclaration(node) => self._typecheckBindingDeclaration(token, node)
      _ => self._typecheckExpression(node, typeHint)
    }
  }

  func _typecheckBindingDeclaration(self, token: Token, node: BindingDeclarationNode): Result<TypedAstNode, TypeError> {
    val isMutable = token.kind == TokenKind.Var

    val label = match node.bindingPattern {
      BindingPattern.Variable(label) => label
    }

    val annType = if node.typeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty
    } else {
      None
    }

    val _pair = if node.expr |expr| {
      val typedExpr = match self._typecheckExpression(expr, annType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val ty = if annType |annotatedType| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: annotatedType) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([annotatedType], typedExpr.ty)))
        }

        annotatedType
      } else {
        typedExpr.ty
      }

      if ty == Type.Primitive(PrimitiveKind.Unit) || ty.hasUnfilledHoles() {
        return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "assignment")))
      }

      // TODO: type could not be auto-coerced to `TypedAstNode?` on its own
      val typedExpr_: TypedAstNode? = typedExpr
      (typedExpr_, ty)
    } else if !isMutable {
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingValExpr(label.name)))
    } else if annType |ty| {
      (None, ty)
    } else {
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(label.name)))
    }
    // TODO: destructuring
    val expr = _pair[0]
    val ty = _pair[1]

    val variable = Variable(label: label, mutable: isMutable, ty: ty)
    match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val typedNode = TypedBindingDeclarationNode(bindingPattern: node.bindingPattern, variables: [variable], expr: expr)
    Result.Ok(TypedAstNode(token: token, ty: Type.Primitive(PrimitiveKind.Unit), kind: TypedAstNodeKind.BindingDeclaration(typedNode)))
  }

  func _typecheckExpression(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token
    match node.kind {
      AstNodeKind.Literal(literal) => {
        val primitiveKind = match literal {
          LiteralAstNode.Int => PrimitiveKind.Int
          LiteralAstNode.Float => PrimitiveKind.Float
          LiteralAstNode.Bool => PrimitiveKind.Bool
          LiteralAstNode.String => PrimitiveKind.String
        }
        val ty = Type.Primitive(primitiveKind)
        Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Literal(literal)))
      }
      AstNodeKind.Unary(node) => self._typecheckUnary(token, node)
      AstNodeKind.Binary => todo(node.token.position)
      AstNodeKind.Grouped(inner) => {
        val expr = match self._typecheckExpression(inner, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Grouped(expr)))
      }
      AstNodeKind.Identifier(kind) => self._typecheckIdentifier(token, kind, typeHint)
      AstNodeKind.Array(items) => self._typecheckArray(token, items, typeHint)
      _ => todo(node.token.position)
    }
  }

  func _typecheckUnary(self, token: Token, node: UnaryAstNode): Result<TypedAstNode, TypeError> {
    val expr = match self._typecheckExpression(node: node.expr, typeHint: None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match node.op {
      UnaryOp.Minus => {
        if expr.ty != Type.Primitive(PrimitiveKind.Int) && expr.ty != Type.Primitive(PrimitiveKind.Float) {
          val expected = [Type.Primitive(PrimitiveKind.Int), Type.Primitive(PrimitiveKind.Float)]
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch(expected, expr.ty)))
        }
      }
      UnaryOp.Negate => {
        if expr.ty != Type.Primitive(PrimitiveKind.Bool) {
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch([Type.Primitive(PrimitiveKind.Bool)], expr.ty)))
        }
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Unary(op: node.op, expr: expr)))
  }

  func _typecheckIdentifier(self, token: Token, kind: IdentifierKind, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val ty = match kind {
      IdentifierKind.Named(name) => {
        val t = if self._resolveIdentifier(name) |variable| {
          variable.ty
        } else {
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName(name, "variable")))
        }
        t
      }
      IdentifierKind.Discard => return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("_", "variable")))
      IdentifierKind.None_ => {
        match typeHint {
          Type.Option t => t
          _ => Type.Option(Type.Hole)
        }
      }
      IdentifierKind.Self => return todo(token.position)
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Identifier(kind)))
  }

  func _typecheckArray(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerType = match typeHint {
      Type.Instance(struct, generics) => if struct == self.project.preludeArrayStruct { generics[0] } else None
      _ => None
    }

    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = match self._typecheckExpression(node: node, typeHint: innerType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if innerType |ty| {
        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          // if typedItem.ty == Type.Option(Type.Hole) {
          //   innerType = Type.Option(ty)
          // } else {
            return Result.Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
          // }
        }
      } else {
        innerType = typedItem.ty
      }
      typedItems.push(typedItem)
    }

    val ty = if innerType |ty| {
      Type.Instance(self.project.preludeArrayStruct, [ty])
    } else {
      Type.Instance(self.project.preludeArrayStruct, [Type.Hole])
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Array(typedItems)))
  }
}

func todo<V>(position: Position): Result<V, TypeError> {
  Result.Err(TypeError(position: position, kind: TypeErrorKind.NotYetImplemented))
}