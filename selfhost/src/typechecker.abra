import "fs" as fs
import Lexer, LexerError, Token, TokenKind, Position from "./lexer"
import Parser, ParsedModule, ParseError, AstNode, AstNodeKind, LiteralAstNode, UnaryAstNode, UnaryOp, BindingDeclarationNode, BindingPattern, TypeIdentifier, Label, IdentifierKind from "./parser"

enum TokenizeAndParseError {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
}

export type ModuleLoader {
  rootDirPath: String

  // TODO: This of course does nothing right now
  func resolvePath(self, modulePath: String, relativeTo: String?): String = modulePath

  func tokenizeAndParse(self, modulePath: String): Result<ParsedModule, TokenizeAndParseError> {
    match fs.readFile(modulePath) {
      Result.Ok(contents) => {
        match Lexer.tokenize(contents) {
          Result.Ok(tokens) => {
            match Parser.parse(tokens) {
              Result.Ok(parsedModule) => Result.Ok(parsedModule)
              Result.Err(error) => Result.Err(TokenizeAndParseError.ParseError(error))
            }
          }
          Result.Err(error) => Result.Err(TokenizeAndParseError.LexerError(error))
        }
      }
      Result.Err(e) => Result.Err(TokenizeAndParseError.ReadFileError(modulePath))
    }
  }
}

export type TypedModule {
  id: Int
  name: String
  code: TypedAstNode[]
  rootScope: Scope
}

export type Variable {
  label: Label
  mutable: Bool
  ty: Type
}

type Scope {
  name: String
  variables: Variable[] = []
  parent: Scope? = None

  func makeChild(self, name: String): Scope = Scope(name: "${self.name}::$name", parent: self)
}

export type Project {
  modules: TypedModule[] = []
  preludeArrayStruct: Struct = Struct(moduleId: 0, name: "Array", generics: ["T"])
}

type Struct {
  moduleId: Int
  name: String
  generics: String[] = []
}

export type Type {
  kind: TypeKind
  nullable: Bool = false

  func repr(self): String {
    val repr = match self.kind {
      TypeKind.PrimitiveUnit => "Unit"
      TypeKind.PrimitiveInt => "Int"
      TypeKind.PrimitiveFloat => "Float"
      TypeKind.PrimitiveBool => "Bool"
      TypeKind.PrimitiveString => "String"
      TypeKind.Instance(struct, typeParams) => {
        if struct.moduleId == 0 && struct.name == "Array" {
          val innerRepr = typeParams[0]?.repr() ?: "<unknown>"
          "$innerRepr[]"
        } else {
          val genericsRepr = if typeParams.isEmpty() "" else {
            val reprs = typeParams.map(t => t.repr()).join(", ")
            "<$reprs>"
          }
          "${struct.name}$genericsRepr"
        }
      }
      TypeKind.Hole => "<unknown>"
    }

    if self.nullable "$repr?" else repr
  }

  func hasUnfilledHoles(self): Bool = match self.kind {
    TypeKind.PrimitiveUnit => false
    TypeKind.PrimitiveInt => false
    TypeKind.PrimitiveFloat => false
    TypeKind.PrimitiveBool => false
    TypeKind.PrimitiveString => false
    TypeKind.Instance(_, generics) => generics.any(t => t.hasUnfilledHoles())
    TypeKind.Hole => true
  }
}

export enum TypeKind {
  PrimitiveUnit
  PrimitiveInt
  PrimitiveFloat
  PrimitiveBool
  PrimitiveString
  Instance(struct: Struct, generics: Type[])
  Hole
}

export type TypedAstNode {
  token: Token
  ty: Type
  kind: TypedAstNodeKind
}

type TypedBindingDeclarationNode {
  bindingPattern: BindingPattern
  variables: Variable[]
  expr: TypedAstNode?
}

export enum TypedAstNodeKind {
  Literal(value: LiteralAstNode)
  Unary(op: UnaryOp, expr: TypedAstNode)
  // Binary(...)
  Grouped(inner: TypedAstNode)
  Identifier(kind: IdentifierKind)
  Array(items: TypedAstNode[])

  BindingDeclaration(node: TypedBindingDeclarationNode)
}

type TypecheckerError {
  modulePath: String
  kind: TypecheckerErrorKind

  func getMessage(self): String {
    match self.kind {
      // TODO: Better error message, once imports are a thing
      TypecheckerErrorKind.ReadFileError(path) => "Could not read file '$path'"
      TypecheckerErrorKind.LexerError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.ParseError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.TypeError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
    }
  }
}

enum TypecheckerErrorKind {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
  TypeError(inner: TypeError)
}

type TypeError {
  position: Position
  kind: TypeErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      TypeErrorKind.TypeMismatch(expected, received) => {
        lines.push("Type mismatch")
        lines.push(self._getCursorLine(self.position, contents))

        val expectedReprs = expected.map(t => t.repr()).join(", ")
        if expected.length == 1 {
          lines.push("Expected: " + expectedReprs)
        } else {
          lines.push("Expected one of: " + expectedReprs)
        }
        lines.push("but instead found: " + received.repr())
      }
      TypeErrorKind.DuplicateName(original, kind) => {
        lines.push("Duplicate $kind '${original.name}'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This $kind is already declared at (${original.position.line}:${original.position.col})")
        lines.push(self._getCursorLine(original.position, contents))
      }
      TypeErrorKind.UnknownName(name, kind) => {
        lines.push("Unknown $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        if name == "_" {
          lines.push("The '_' identifier is a special name used to discard values, and it cannot be referenced")
        } else {
          lines.push("No $kind with that name is visible in current scope")
        }
      }
      TypeErrorKind.MissingValExpr(name) => {
        lines.push("Missing initializer for immutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.MissingVarExprAndTypeAnn(name) => {
        lines.push("Could not determine type of mutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("A 'var' must have either an initial value or a type annotation (or both)")
      }
      TypeErrorKind.IllegalValueType(ty, purpose) => {
        if ty.kind == TypeKind.PrimitiveUnit {
          lines.push("Forbidden type for $purpose")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Instances of type ${ty.repr()} cannot be used as $purpose values")
        } else {
          lines.push("Could not determine type for $purpose")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Type '${ty.repr()}' has unfilled holes. Please use an explicit type annotation to denote the type")
        }
      }
      TypeErrorKind.NotYetImplemented => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum TypeErrorKind {
  NotYetImplemented
  TypeMismatch(expected: Type[], received: Type)
  DuplicateName(original: Label, kind: String)
  UnknownName(name: String, kind: String)
  MissingValExpr(name: String)
  MissingVarExprAndTypeAnn(name: String)
  IllegalValueType(ty: Type, purpose: String)
}

export type Typechecker {
  moduleLoader: ModuleLoader
  project: Project
  currentScope: Scope = Scope(name: "\$root")

  func typecheckEntrypoint(self, modulePathAbs: String): Result<Int, TypecheckerError> {
    val mod = TypedModule(id: 0, name: "prelude", code: [], rootScope: self.currentScope.makeChild("module_0"))
    self.project.modules.push(mod)

    self._typecheckModule(modulePathAbs)
  }

  func _tokenizeAndParse(self, modulePath: String, relativeTo: String? = None): Result<ParsedModule, TypecheckerError> {
    val absPath = self.moduleLoader.resolvePath(modulePath, relativeTo)
    match self.moduleLoader.tokenizeAndParse(absPath) {
      Result.Ok(mod) => Result.Ok(mod)
      Result.Err(e) => {
        val kind = match e {
          TokenizeAndParseError.ReadFileError(path) => TypecheckerErrorKind.ReadFileError(path)
          TokenizeAndParseError.LexerError(inner) => TypecheckerErrorKind.LexerError(inner)
          TokenizeAndParseError.ParseError(inner) => TypecheckerErrorKind.ParseError(inner)
        }

        return Result.Err(TypecheckerError(modulePath: modulePath, kind: kind))
      }
    }
  }

  func _addVariableToScope(self, variable: Variable, scope = self.currentScope): Result<Int, TypeError> {
    if variable.label.name == "_" return Result.Ok(0) // <- unnecessary 0

    for v in scope.variables {
      if v.label.name == variable.label.name {
        val kind = TypeErrorKind.DuplicateName(original: v.label, kind: "name")
        return Result.Err(TypeError(position: variable.label.position, kind: kind))
      }
    }

    scope.variables.push(variable)

    Result.Ok(0) // <- unnecessary 0
  }

  func _resolveTypeIdentifier(self, typeIdent: TypeIdentifier): Result<Type, TypeError> {
    val ty = match typeIdent {
      TypeIdentifier.Normal(label) => match label.name {
        "Int" => Type(kind: TypeKind.PrimitiveInt)
        "Float" => Type(kind: TypeKind.PrimitiveFloat)
        "Bool" => Type(kind: TypeKind.PrimitiveBool)
        "String" => Type(kind: TypeKind.PrimitiveString)
        _ => return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
      }
      TypeIdentifier.Array(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Type(kind: TypeKind.Instance(self.project.preludeArrayStruct, [innerTy]))
      }
      TypeIdentifier.Option(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        innerTy.nullable = true
        innerTy
      }
      TypeIdentifier.Tuple => return todo(Position(line: 0, col: 0))
      TypeIdentifier.Function => return todo(Position(line: 0, col: 0))
    }

    Result.Ok(ty)
  }

  func _resolveIdentifier(self, ident: String): Variable? {
    var scope: Scope? = self.currentScope
    while scope |s| {
      for v in s.variables {
        if v.label.name == ident return v
      }
      scope = s.parent
    }

    None
  }

  func _typeSatisfiesRequired(self, ty: Type, required: Type): Bool {
    if ty.nullable && !required.nullable return false

    ty.kind == required.kind
  }

  func _typecheckModule(self, modulePath: String): Result<Int, TypecheckerError> {
    val moduleId = self.project.modules.length

    val moduleScope = self.currentScope.makeChild("module_$moduleId")
    val prevScope = self.currentScope
    self.currentScope = moduleScope
    val mod = TypedModule(id: moduleId, name: modulePath, code: [], rootScope: moduleScope)
    self.project.modules.push(mod)

    val parsedModule = match self._tokenizeAndParse(modulePath) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    for importNode in parsedModule.imports { /* todo */ }

    mod.code = match self._typecheckBlock(parsedModule.nodes) {
      Result.Ok(v) => v
      Result.Err(e) => return Result.Err(TypecheckerError(modulePath: modulePath, kind: TypecheckerErrorKind.TypeError(e)))
    }

    self.currentScope = prevScope
    Result.Ok(moduleId)
  }

  func _typecheckBlock(self, nodes: AstNode[]): Result<TypedAstNode[], TypeError> {
    // TODO: handle incremental passes for func/type/enum declaration

    val typedNodes: TypedAstNode[] = []

    for node in nodes {
      val res = match node.kind {
        AstNodeKind.FunctionDeclaration => return todo(node.token.position)
        AstNodeKind.TypeDeclaration => return todo(node.token.position)
        AstNodeKind.EnumDeclaration => return todo(node.token.position)
        _ => self._typecheckStatement(node: node, typeHint: None)
      }

      val typedNode = match res { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }

    return Result.Ok(typedNodes)
  }

  func _typecheckStatement(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token

    match node.kind {
      AstNodeKind.BindingDeclaration(node) => self._typecheckBindingDeclaration(token, node)
      _ => self._typecheckExpression(node, typeHint)
    }
  }

  func _typecheckBindingDeclaration(self, token: Token, node: BindingDeclarationNode): Result<TypedAstNode, TypeError> {
    val isMutable = token.kind == TokenKind.Var

    val label = match node.bindingPattern {
      BindingPattern.Variable(label) => label
    }

    val annType = if node.typeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty
    } else {
      None
    }

    val _pair = if node.expr |expr| {
      val typedExpr = match self._typecheckExpression(expr, annType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val ty = if annType |annotatedType| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: annotatedType) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([annotatedType], typedExpr.ty)))
        }

        annotatedType
      } else {
        typedExpr.ty
      }

      if ty.kind == TypeKind.PrimitiveUnit || ty.hasUnfilledHoles() {
        return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "assignment")))
      }

      // TODO: type could not be auto-coerced to `TypedAstNode?` on its own
      val typedExpr_: TypedAstNode? = typedExpr
      (typedExpr_, ty)
    } else if !isMutable {
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingValExpr(label.name)))
    } else if annType |ty| {
      (None, ty)
    } else {
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(label.name)))
    }
    // TODO: destructuring
    val expr = _pair[0]
    val ty = _pair[1]

    val variable = Variable(label: label, mutable: isMutable, ty: ty)
    match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val typedNode = TypedBindingDeclarationNode(bindingPattern: node.bindingPattern, variables: [variable], expr: expr)
    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.BindingDeclaration(typedNode)))
  }

  func _typecheckExpression(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token
    val typedExprRes: Result<TypedAstNode, TypeError> = match node.kind {
      AstNodeKind.Literal(literal) => {
        val kind = match literal {
          LiteralAstNode.Int => TypeKind.PrimitiveInt
          LiteralAstNode.Float => TypeKind.PrimitiveFloat
          LiteralAstNode.Bool => TypeKind.PrimitiveBool
          LiteralAstNode.String => TypeKind.PrimitiveString
        }

        Result.Ok(TypedAstNode(token: token, ty: Type(kind: kind), kind: TypedAstNodeKind.Literal(literal)))
      }
      AstNodeKind.Unary(node) => self._typecheckUnary(token, node)
      AstNodeKind.Binary => todo(node.token.position)
      AstNodeKind.Grouped(inner) => {
        val expr = match self._typecheckExpression(inner, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Grouped(expr)))
      }
      AstNodeKind.Identifier(kind) => self._typecheckIdentifier(token, kind, typeHint)
      AstNodeKind.Array(items) => self._typecheckArray(token, items, typeHint)
      _ => todo(node.token.position)
    }

    val typedExpr = match typedExprRes { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    // If we're parsing an expression in a context where we have a type hint and where that type hint is nullable, we
    // may want to make the expression's type nullable as well, if the types' kinds are equivalent. If the types' kinds
    // are _not_ equivalent, don't do anything because this mismatch will be raised at the callsite.
    if typeHint |hint| {
      if hint.kind == typedExpr.ty.kind && hint.nullable {
        typedExpr.ty.nullable = true
      }
    }

    Result.Ok(typedExpr)
  }

  func _typecheckUnary(self, token: Token, node: UnaryAstNode): Result<TypedAstNode, TypeError> {
    val expr = match self._typecheckExpression(node: node.expr, typeHint: None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match node.op {
      UnaryOp.Minus => {
        if expr.ty.kind != TypeKind.PrimitiveInt && expr.ty.kind != TypeKind.PrimitiveFloat {
          val expected = [Type(kind: TypeKind.PrimitiveInt), Type(kind: TypeKind.PrimitiveFloat)]
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch(expected, expr.ty)))
        }
      }
      UnaryOp.Negate => {
        if expr.ty.kind != TypeKind.PrimitiveBool {
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveBool)], expr.ty)))
        }
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Unary(op: node.op, expr: expr)))
  }

  func _typecheckIdentifier(self, token: Token, kind: IdentifierKind, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val ty = match kind {
      IdentifierKind.Named(name) => {
        val t = if self._resolveIdentifier(name) |variable| {
          variable.ty
        } else {
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName(name, "variable")))
        }
        t
      }
      IdentifierKind.Discard => return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("_", "variable")))
      IdentifierKind.None_ => {
        val kind = typeHint?.kind ?: TypeKind.Hole
        Type(kind: kind, nullable: true)
      }
      IdentifierKind.Self => return todo(token.position)
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Identifier(kind)))
  }

  func _typecheckArray(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerType = match typeHint?.kind {
      TypeKind.Instance(struct, generics) => if struct == self.project.preludeArrayStruct { generics[0] } else None
      _ => None
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = match self._typecheckExpression(node: node, typeHint: innerType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if innerType |ty| {
        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          if typedItem.ty.nullable && !ty.nullable {
            ty.nullable = true
            makeItemsNullable = true
          } else {
            return Result.Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
          }
        }
      } else {
        innerType = typedItem.ty
      }
      typedItems.push(typedItem)
    }

    if makeItemsNullable {
      for item in typedItems {
        item.ty.nullable = true
      }
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(self.project.preludeArrayStruct, [inner]))

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Array(typedItems)))
  }
}

func todo<V>(position: Position): Result<V, TypeError> {
  Result.Err(TypeError(position: position, kind: TypeErrorKind.NotYetImplemented))
}