import "fs" as fs
import Lexer, LexerError, Token, TokenKind, Position from "./lexer"
import Parser, ParsedModule, ParseError, AstNode, AstNodeKind, LiteralAstNode, UnaryAstNode, UnaryOp, BinaryAstNode, BinaryOp, BindingDeclarationNode, BindingPattern, TypeIdentifier, Label, IdentifierKind, FunctionDeclarationNode, FunctionParam, InvocationAstNode, InvocationArgument, TypeDeclarationNode, AccessorAstNode, IndexingMode from "./parser"

enum TokenizeAndParseError {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
}

export type ModuleLoader {
  rootDirPath: String

  // TODO: This of course does nothing right now
  func resolvePath(self, modulePath: String, relativeTo: String?): String = modulePath

  func tokenizeAndParse(self, modulePath: String): Result<ParsedModule, TokenizeAndParseError> {
    match fs.readFile(modulePath) {
      Result.Ok(contents) => {
        match Lexer.tokenize(contents) {
          Result.Ok(tokens) => {
            match Parser.parse(tokens) {
              Result.Ok(parsedModule) => Result.Ok(parsedModule)
              Result.Err(error) => Result.Err(TokenizeAndParseError.ParseError(error))
            }
          }
          Result.Err(error) => Result.Err(TokenizeAndParseError.LexerError(error))
        }
      }
      Result.Err(e) => Result.Err(TokenizeAndParseError.ReadFileError(modulePath))
    }
  }
}

export type TypedModule {
  id: Int
  name: String
  code: TypedAstNode[]
  rootScope: Scope
}

export enum VariableAlias {
  Function(fn: Function)
  Struct(struct: Struct)
}

export type Variable {
  label: Label
  mutable: Bool
  ty: Type
  alias: VariableAlias? = None
}

export enum Terminator {
  Returning
  NonReturning

  func combine(t1: Terminator?, t2: Terminator?): Terminator? {
    val t1Returns = if t1 |t1| t1 == Terminator.Returning else false
    val t1NonReturns = if t1 |t1| t1 == Terminator.NonReturning else false
    val t2Returns = if t2 |t2| t2 == Terminator.Returning else false
    val t2NonReturns = if t2 |t2| t2 == Terminator.NonReturning else false

    if t1Returns && t2Returns return Terminator.Returning

    if (t1NonReturns && !!t2) || (t2NonReturns && !!t1) return Terminator.NonReturning

    None
  }
}

export enum ScopeKind {
  Root
  Module
  Func
  If
  While
  For
  Type
}

export type Scope {
  name: String
  variables: Variable[] = []
  functions: Function[] = []
  types: Type[] = []
  structs: Struct[] = []
  kind: ScopeKind = ScopeKind.Root
  parent: Scope? = None
  terminator: Terminator? = None

  func makeChild(self, name: String, kind: ScopeKind): Scope = Scope(name: "${self.name}::$name", kind: kind, parent: self)
}

type Field {
  name: Label
  ty: Type
  initializer: TypedAstNode?
}

export type Struct {
  moduleId: Int
  label: Label
  scope: Scope
  typeParams: String[]
  fields: Field[] = []
  instanceMethods: Function[] = []
  staticMethods: Function[] = []

  // Override eq method since default implementation recurses infinitely (scope -> variables -> TypeKind.Struct)
  func eq(self, other: Struct): Bool = self.moduleId == other.moduleId && self.label == other.label
}

export type Project {
  modules: TypedModule[] = []
  preludeArrayStruct: Struct = Struct(moduleId: 0, label: Label(name: "Array", position: Position(line: 0, col: 0)), scope: Scope(name: "Array"), typeParams: ["T"])
  preludeMapStruct: Struct = Struct(moduleId: 0, label: Label(name: "Map", position: Position(line: 0, col: 0)), scope: Scope(name: "Array"), typeParams: ["K", "V"])
  preludeSetStruct: Struct = Struct(moduleId: 0, label: Label(name: "Set", position: Position(line: 0, col: 0)), scope: Scope(name: "Set"), typeParams: ["T"])
}

export type Type {
  kind: TypeKind
  nullable: Bool = false

  func clone(self): Type = Type(kind: self.kind, nullable: self.nullable)

  func repr(self): String {
    val repr = match self.kind {
      TypeKind.PrimitiveUnit => "Unit"
      TypeKind.PrimitiveInt => "Int"
      TypeKind.PrimitiveFloat => "Float"
      TypeKind.PrimitiveBool => "Bool"
      TypeKind.PrimitiveString => "String"
      TypeKind.Never => "Never"
      TypeKind.Generic(name) => name
      TypeKind.Instance(struct, typeParams) => {
        if struct.moduleId == 0 && struct.label.name == "Array" {
          val innerRepr = typeParams[0]?.repr() ?: "<unknown>"
          "$innerRepr[]"
        } else {
          val genericsRepr = if typeParams.isEmpty() "" else {
            val reprs = typeParams.map(t => t.repr()).join(", ")
            "<$reprs>"
          }
          "${struct.label.name}$genericsRepr"
        }
      }
      TypeKind.Tuple(types) => "(${types.map(t => t.repr()).join(", ")})"
      TypeKind.Func(paramTypes, returnType) => {
        val paramsRepr = paramTypes.filter(p => p[1]).map(p => p[0].repr()).join(", ")
        val returnTypeRepr = returnType.repr()
        val repr = "($paramsRepr) => $returnTypeRepr"

        if self.nullable return "($repr)?"
        repr
      }
      TypeKind.Struct(struct) => "<#type ${struct.label.name}>"
      TypeKind.Hole => "<unknown>"
    }

    if self.nullable "$repr?" else repr
  }

  func hasUnfilledHoles(self): Bool = match self.kind {
    TypeKind.PrimitiveUnit => false
    TypeKind.PrimitiveInt => false
    TypeKind.PrimitiveFloat => false
    TypeKind.PrimitiveBool => false
    TypeKind.PrimitiveString => false
    TypeKind.Never => false
    TypeKind.Generic => false
    TypeKind.Instance(_, generics) => generics.any(t => t.hasUnfilledHoles())
    TypeKind.Tuple(types) => types.any(t => t.hasUnfilledHoles())
    TypeKind.Func(paramTypes, returnType) => paramTypes.any(t => t[0].hasUnfilledHoles()) || returnType.hasUnfilledHoles()
    TypeKind.Struct => false
    TypeKind.Hole => true
  }

  func isInvalidValueType(self): Bool = self.kind == TypeKind.PrimitiveUnit || self.kind == TypeKind.Never || self.hasUnfilledHoles()

  func tryFillHoles(self, other: Type) {
    // TODO: this code is pretty ugly - I really need a way of destructuring multiple values simultaneously in `match`es
    match self.kind {
      TypeKind.Instance(selfStruct, selfTypeArgs) => {
        match other.kind {
          TypeKind.Instance(otherStruct, otherTypeArgs) => {
            if selfStruct != otherStruct return

            for typeArg, idx in selfTypeArgs {
              typeArg.tryFillHoles(otherTypeArgs[idx] ?: Type(kind: TypeKind.Hole))
            }
          }
          _ => {}
        }
      }
      TypeKind.Tuple(selfTypeArgs) => {
        match other.kind {
          TypeKind.Tuple(otherTypeArgs) => {
            for typeArg, idx in selfTypeArgs {
              typeArg.tryFillHoles(otherTypeArgs[idx] ?: Type(kind: TypeKind.Hole))
            }
          }
          _ => {}
        }
      }
      _ => {
        if self.kind == TypeKind.Hole {
          self.kind = other.kind
        }
      }
    }
  }

  func withSubstitutedGenerics(self, resolvedGenerics: Map<String, Type>, retainUnknown: Bool): Type {
    val resultType = match self.kind {
      TypeKind.Generic(name) => resolvedGenerics[name]?.clone() ?: (if retainUnknown self else Type(kind: TypeKind.Hole))
      TypeKind.Instance(struct, typeArgs) => {
        val substTypeArgs = typeArgs.map(ty => ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown))
        Type(kind: TypeKind.Instance(struct, substTypeArgs))
      }
      TypeKind.Tuple(typeArgs) => {
        val substTypeArgs = typeArgs.map(ty => ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown))
        Type(kind: TypeKind.Tuple(substTypeArgs))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val substParamTypes = paramTypes.map(p => {
          val t = p[0].withSubstitutedGenerics(resolvedGenerics, retainUnknown)
          (t, p[1])
        })
        val substReturnType = returnType.withSubstitutedGenerics(resolvedGenerics, retainUnknown)
        Type(kind: TypeKind.Func(substParamTypes, substReturnType))
      }
      _ => self
    }
    resultType.nullable = self.nullable

    resultType
  }
}

export enum TypeKind {
  PrimitiveUnit
  PrimitiveInt
  PrimitiveFloat
  PrimitiveBool
  PrimitiveString
  Never
  Generic(name: String)
  Instance(struct: Struct, generics: Type[])
  Func(paramTypes: (Type, Bool)[], returnType: Type)
  Struct(struct: Struct)
  Tuple(types: Type[])
  Hole
}

export type TypedAstNode {
  token: Token
  ty: Type
  kind: TypedAstNodeKind
}

export enum TypedIdentifierKind {
  Named(name: String, variable: Variable)
  None_
  Discard
}

type TypedBindingDeclarationNode {
  bindingPattern: BindingPattern
  variables: Variable[]
  expr: TypedAstNode?
}

type TypedFunctionParam {
  label: Label
  ty: Type
  defaultValue: TypedAstNode? = None
  isVariadic: Bool = false
}

enum FunctionKind {
  Standalone
  InstanceMethod
  StaticMethod
}

export type Function {
  label: Label
  scope: Scope
  kind: FunctionKind
  typeParams: (Type, Label)[]
  params: TypedFunctionParam[]
  returnType: Type
  body: TypedAstNode[]
  isGenerated: Bool = false

  func generated(
    scope: Scope,
    name: String,
    params: (String, Type)[],
    returnType: Type,
    kind = FunctionKind.InstanceMethod,
    typeParams: (Type, Label)[] = [],
  ): Function {
    val bogusPosition = Position(line: 0, col: 0)

    val label = Label(name: name, position: bogusPosition)
    val fnScope = scope.makeChild(name, ScopeKind.Func)
    val fnParams = params.map(p => TypedFunctionParam(label: Label(name: p[0], position: bogusPosition), ty: p[1]))
    Function(label: label, scope: fnScope, kind: kind, typeParams: typeParams, params: fnParams, returnType: returnType, body: [], isGenerated: true)
  }

  func initializer(
    scope: Scope,
    struct: Struct,
  ): Function {
    val bogusPosition = Position(line: 0, col: 0)

    val fnScope = scope.makeChild(struct.label.name, ScopeKind.Func)
    val structTypeParams = struct.typeParams.map(t => (Type(kind: TypeKind.Generic(t)), Label(name: t, position: bogusPosition)))
    val params = struct.fields.map(f => TypedFunctionParam(label: Label(name: f.name.name, position: bogusPosition), ty: f.ty, defaultValue: f.initializer))
    val typeArgs = struct.typeParams.map(t => Type(kind: TypeKind.Generic(t)))
    val returnType = Type(kind: TypeKind.Instance(struct, typeArgs))

    Function(label: struct.label, scope: fnScope, kind: FunctionKind.Standalone, typeParams: structTypeParams, params: params, returnType: returnType, body: [], isGenerated: true)
  }

  func getType(self): Type = Type(kind: TypeKind.Func(paramTypes: self.params.map(p => (p.ty, !p.defaultValue)), returnType: self.returnType))

  func withSubstitutedGenerics(self, resolvedGenerics: Map<String, Type>, retainUnknown: Bool): Function {
    val params = self.params.map(p => {
      val ty = p.ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown)
      TypedFunctionParam(label: p.label, ty: ty, defaultValue: p.defaultValue, isVariadic: p.isVariadic)
    })
    val returnType = self.returnType.withSubstitutedGenerics(resolvedGenerics, retainUnknown)

    Function(
      label: self.label,
      scope: self.scope,
      kind: self.kind,
      typeParams: self.typeParams,
      params: params,
      returnType: returnType,
      body: self.body,
      isGenerated: self.isGenerated,
    )
  }
}

export enum TypedInvokee {
  Struct(struct: Struct)
  Expr(expr: TypedAstNode)
}

export enum TypedIndexingNode {
  ArrayLike(expr: TypedAstNode, indexingMode: IndexingMode<TypedAstNode>)
  Map(expr: TypedAstNode, idx: TypedAstNode)
  Tuple(tupleExpr: TypedAstNode, idx: Int)
}

export enum TypedAstNodeKind {
  Literal(value: LiteralAstNode)
  Unary(op: UnaryOp, expr: TypedAstNode)
  Binary(left: TypedAstNode, op: BinaryOp, right: TypedAstNode)
  Grouped(inner: TypedAstNode)
  Identifier(kind: TypedIdentifierKind)
  Accessor(head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment)
  Invocation(invokee: TypedInvokee, arguments: TypedAstNode?[])
  Array(items: TypedAstNode[])
  Set(items: TypedAstNode[])
  Map(items: (TypedAstNode, TypedAstNode)[])
  Tuple(items: TypedAstNode[])
  Indexing(node: TypedIndexingNode)
  If(isStatement: Bool, typedCondition: TypedAstNode, conditionBinding: (BindingPattern, Variable[])?, typedIfBlock: TypedAstNode[], typedElseBlock: TypedAstNode[])
  While(typedCondition: TypedAstNode, conditionBinding: (BindingPattern, Variable[])?, block: TypedAstNode[])
  For(typedIterator: TypedAstNode, itemBinding: (BindingPattern, Variable[]), indexBinding: Variable?, block: TypedAstNode[])
  BindingDeclaration(node: TypedBindingDeclarationNode)
  FunctionDeclaration(fn: Function)
  TypeDeclaration(struct: Struct)
  Break
  Continue
  Return(expr: TypedAstNode?)

  Placeholder
}

export enum AccessorPathSegment {
  Method(label: Label, fn: Function)
  Field(label: Label, f: Field)
}

type TypecheckerError {
  modulePath: String
  kind: TypecheckerErrorKind

  func getMessage(self): String {
    match self.kind {
      // TODO: Better error message, once imports are a thing
      TypecheckerErrorKind.ReadFileError(path) => "Could not read file '$path'"
      TypecheckerErrorKind.LexerError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.ParseError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.TypeError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
    }
  }
}

enum TypecheckerErrorKind {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
  TypeError(inner: TypeError)
}

type TypeError {
  position: Position
  kind: TypeErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      TypeErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      TypeErrorKind.Unreachable(message) => {
        lines.push("Unreachable code reached")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Internal error: $message")
      }
      TypeErrorKind.TypeMismatch(expected, received) => {
        lines.push("Type mismatch")
        lines.push(self._getCursorLine(self.position, contents))

        val expectedReprs = expected.map(t => t.repr()).join(", ")
        if expected.length == 1 {
          lines.push("Expected: " + expectedReprs)
        } else {
          lines.push("Expected one of: " + expectedReprs)
        }
        lines.push("but instead found: " + received.repr())
      }
      TypeErrorKind.DuplicateName(original) => {
        lines.push("Duplicate name '${original.name}'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This name is also declared at (${original.position.line}:${original.position.col})")
        lines.push(self._getCursorLine(original.position, contents))
      }
      TypeErrorKind.UnknownName(name, kind) => {
        lines.push("Unknown $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        if name == "_" {
          lines.push("The '_' identifier is a special name used to discard values, and it cannot be referenced")
        } else {
          lines.push("No $kind with that name is visible in current scope")
        }
      }
      TypeErrorKind.UnknownField(ty, name, specialCase) => {
        lines.push("Unknown field '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        match ty.kind {
          TypeKind.Func => lines.push("Functions don't have any fields or methods")
          _ => {
            match specialCase {
              UnknownFieldSpecialCase.ExistsButTypeIsNullable => {
                if ty.nullable {
                  val nonNullableVersion = Type(kind: ty.kind, nullable: false)
                  lines.push("Type '${nonNullableVersion.repr()}' has field '$name', but lhs is of type '${ty.repr()}'")
                } else {
                  val nullableVersion = Type(kind: ty.kind, nullable: true)
                  lines.push("Type '${ty.repr()}' has field '$name', but lhs here is of type '${nullableVersion.repr()}' due to prior '?.'")
                }
                lines.push("(You can use the '?.' operator instead of '.')")
              }
              UnknownFieldSpecialCase.StaticFieldReferencedAsInstance => {
                lines.push("No field '$name' found on instance of type ${ty.repr()}")
                lines.push("'$name' is a static member of ${ty.repr()}, did you mean to write ${ty.repr()}.$name?")
              }
              None =>  {
                lines.push("No field '$name' found on type ${ty.repr()}")
              }
            }
          }
        }
      }
      TypeErrorKind.MissingValExpr(name) => {
        lines.push("Missing initializer for immutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.MissingVarExprAndTypeAnn(name) => {
        lines.push("Could not determine type of mutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("A 'var' must have either an initial value or a type annotation (or both)")
      }
      TypeErrorKind.IllegalValueType(ty, purpose) => {
        if ty.kind == TypeKind.PrimitiveUnit {
          lines.push("Forbidden type for $purpose")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Instances of type ${ty.repr()} cannot be used as $purpose values")
        } else if ty.kind == TypeKind.Never {
          lines.push("Forbidden type for $purpose")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Expression has type ${ty.repr()}, which can never be used for $purpose")
        } else {
          lines.push("Could not determine type for $purpose")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Type '${ty.repr()}' has unfilled holes. Please use an explicit type annotation to denote the type")
        }
      }
      TypeErrorKind.IllegalControlFlowType(ty, purpose) => {
        if purpose == "if" || purpose == "while" {
          lines.push("Forbidden type for $purpose-condition")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Conditions must either be Bool or Option types")
          lines.push("but instead found " + ty.repr())
        } else if purpose == "for" {
          lines.push("Forbidden type for for-loop target")
          lines.push(self._getCursorLine(self.position, contents))
          if ty.hasUnfilledHoles() {
            lines.push("Type '${ty.repr()}' has unfilled holes")
          } else {
            lines.push("Type ${ty.repr()} is not iterable")
          }
        }
      }
      TypeErrorKind.MissingRequiredIfExprBlock(clause, missing) => {
        lines.push("Incomplete if-expression")
        lines.push(self._getCursorLine(self.position, contents))
        if missing {
          lines.push("The $clause-block must exist and contain a value")
        } else {
          lines.push("The $clause-block must contain a value")
        }
      }
      TypeErrorKind.DuplicateParameter(name) => {
        lines.push("Duplicate parameter '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.InvalidParamPosition(purpose) => {
        match purpose {
          "vararg" => {
            lines.push("Invalid location for variadic parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Variadic parameters must be the last in the parameter list")
          }
          "required" => {
            lines.push("Invalid location for required parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Required parameters must all be listed before any optional parameters")
          }
          "self" => {
            lines.push("Invalid usage of `self` parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("`self` can only appear within methods on types")
          }
          _ => { /* no other cases */ }
        }
      }
      TypeErrorKind.InvalidVarargType(ty) => {
        lines.push("Invalid type for vararg parameter")
        lines.push(self._getCursorLine(self.position, contents))
        if ty.nullable {
          lines.push("Vararg parameters must be a non-Option Array type, but got ${ty.repr()}")
        } else {
          lines.push("Vararg parameters must be an Array type, but got ${ty.repr()}")
        }
      }
      TypeErrorKind.ReturnTypeMismatch(fnName, expected, received) => {
        if fnName |name| {
          lines.push("Return type mismatch for function '$name'")
        } else {
          lines.push("Return type mismatch for lambda function")
        }

        lines.push(self._getCursorLine(self.position, contents))

        lines.push("Expected ${expected.repr()}")
        if received |received| {
          lines.push("but instead found ${received.repr()}")
        } else {
          lines.push("but function had empty body")
        }
      }
      TypeErrorKind.InvalidTerminatorPosition(terminator) => {
        lines.push("Invalid location for $terminator statement")
        lines.push(self._getCursorLine(self.position, contents))
        match terminator {
          "return" => lines.push("Return statements can only be used within function bodies")
          "break" => lines.push("Break statements can only be used within loop bodies")
          "continue" => lines.push("Continue statements can only be used within loop bodies")
          _ => { /* unreachable */ }
        }
      }
      TypeErrorKind.UnreachableCode => {
        lines.push("Unreachable code")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Control flow exits before this code is reached")
      }
      TypeErrorKind.WrongInvocationArity(expected, given) => {
        val argumentsStr = if expected == 1 "argument" else "arguments"
        val verbStr = if given == 1 "was" else "were"

        if given > expected {
          lines.push("Too many arguments for invocation")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Expected no more than $expected $argumentsStr, but $given $verbStr passed")
        } else {
          lines.push("Not enough arguments for invocation")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("$expected $argumentsStr required, but $given $verbStr passed")
        }
      }
      TypeErrorKind.ParameterLabelMismatch(expected, given) => {
        lines.push("Incorrect label for parameter")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The parameter's name is '$expected', but instead found '$given'")
      }
      TypeErrorKind.IllegalParameterLabel => {
        lines.push("Incorrect use of label for parameter")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Parameter labels are not allowed here because parameters' names cannot be determined")
      }
      TypeErrorKind.MixedArgumentType(label) => {
        lines.push("Cannot mix labeled and positional optional arguments")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This argument requires a label because a prior optional parameter has been labeled:")
        lines.push(self._getCursorLine(label.position, contents))
        lines.push("(Optional parameters may be listed positionally until a label is encountered. After that point, parameter values cannot be unambiguously determined without labels)")
      }
      TypeErrorKind.MissingRequiredArgumentLabel => {
        lines.push("Invalid instantiation")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Calls of type constructors must include argument labels")
      }
      TypeErrorKind.MissingRequiredFields(names) => {
        lines.push("Invalid instantiation")
        lines.push(self._getCursorLine(self.position, contents))

        val maxToShow = 3
        val missing = names[:maxToShow].map(n => "'$n'")
        if names.length > maxToShow {
          missing.push("and ${names.length - maxToShow} more")
        }
        lines.push("The following required fields are missing: ${missing.join(", ")}")
      }
      TypeErrorKind.UnknownParameterName(name) => {
        lines.push("Unknown parameter label")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This function doesn't have a parameter named '$name'")
      }
      TypeErrorKind.ParameterTypeMismatch(name, expected, given) => {
        if name |name| {
          lines.push("Type mismatch for parameter '$name'")
        } else {
          lines.push("Type mismatch for parameter")
        }
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Expected: ${expected.repr()}")
        lines.push("but instead found: ${given.repr()}")
      }
      TypeErrorKind.IllegalCallableType(ty) => {
        lines.push("Cannot invoke target as function")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Type '${ty.repr()}' is not callable")
      }
      TypeErrorKind.WrongTypeArgumentArity(expected, given) => {
        val verbStr = if given == 1 "was" else "were"

        lines.push("Incorrect number of type arguments")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Expected $expected, but $given $verbStr passed")
      }
      TypeErrorKind.NoSuchOperator(leftTy, op, rightTy) => {
        lines.push("Illegal operator")
        lines.push(self._getCursorLine(self.position, contents))
        if op == BinaryOp.Coalesce && !leftTy.nullable {
          val nullableVersion = Type(kind: leftTy.kind, nullable: true)
          lines.push("The '${op.repr()}' operator can only be used on an Option type")
          lines.push("(The lhs value's type here is ${leftTy.repr()}, not ${nullableVersion.repr()})")
        } else {
          lines.push("No operator '${op.repr()}' exists between types ${leftTy.repr()} and ${rightTy.repr()}")
        }
      }
      TypeErrorKind.IllegalIndexableType(ty, isRange) => {
        lines.push("Unsupported indexing operation")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Type '${ty.repr()}' is not indexable" + if isRange " as a range" else "")
      }
      TypeErrorKind.IllegalTupleIndexing(ty, reason) => {
        lines.push("Unsupported tuple indexing operation")
        lines.push(self._getCursorLine(self.position, contents))
        match reason {
          IllegalTupleIndexingReason.IndexOutOfBounds => {
            lines.push("No value at index for tuple of type '${ty.repr()}'")
            match ty.kind {
              TypeKind.Tuple(types) => lines.push("(Valid index values are from 0-${types.length - 1}, inclusive)")
              _ => println("The type here should always be a tuple")
            }
          }
          IllegalTupleIndexingReason.IndexNegative => {
            lines.push("Tuple index values must always be a non-negative integer")
            match ty.kind {
              TypeKind.Tuple(types) => lines.push("(Valid index values are from 0-${types.length - 1}, inclusive)")
              _ => println("The type here should always be a tuple")
            }
          }
          IllegalTupleIndexingReason.NotIntLiteral => lines.push("Cannot use non-Int literal as index value. Tuple index values must always be Int literals")
          IllegalTupleIndexingReason.NotLiteralNode => lines.push("Cannot use this expression as index value. Tuple index values must always be Int literals")
        }
      }
      TypeErrorKind.UnnecessaryOptSafety => {
        lines.push("Unnecessary use of '?.' operator")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("(The lhs value's type here is known to be a non-Option type)")
      }
      TypeErrorKind.InvalidTraitMethodSignature(givenFn) => {
        lines.push("Invalid signature for method '${givenFn.label.name}'")
        lines.push(self._getCursorLine(self.position, contents))
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum UnknownFieldSpecialCase {
  ExistsButTypeIsNullable
  StaticFieldReferencedAsInstance
}

enum IllegalTupleIndexingReason {
  IndexOutOfBounds
  IndexNegative
  NotIntLiteral
  NotLiteralNode
}

enum TypeErrorKind {
  NotYetImplemented(reason: String)
  Unreachable(message: String)
  TypeMismatch(expected: Type[], received: Type)
  DuplicateName(original: Label)
  UnknownName(name: String, kind: String)
  UnknownField(ty: Type, name: String, specialCase: UnknownFieldSpecialCase?)
  MissingValExpr(name: String)
  MissingVarExprAndTypeAnn(name: String)
  IllegalValueType(ty: Type, purpose: String)
  IllegalControlFlowType(ty: Type, purpose: String)
  MissingRequiredIfExprBlock(clause: String, missing: Bool)
  InvalidParamPosition(purpose: String)
  DuplicateParameter(name: String)
  InvalidVarargType(ty: Type)
  ReturnTypeMismatch(fnName: String?, expected: Type, received: Type?)
  InvalidTerminatorPosition(terminator: String)
  UnreachableCode
  WrongInvocationArity(expected: Int, given: Int)
  ParameterLabelMismatch(expected: String, given: String)
  IllegalParameterLabel
  MixedArgumentType(label: Label)
  MissingRequiredArgumentLabel
  MissingRequiredFields(names: String[])
  UnknownParameterName(name: String)
  ParameterTypeMismatch(name: String?, expected: Type, given: Type)
  IllegalCallableType(ty: Type)
  WrongTypeArgumentArity(expected: Int, given: Int)
  NoSuchOperator(leftTy: Type, op: BinaryOp, rightTy: Type)
  IllegalIndexableType(ty: Type, isRange: Bool)
  IllegalTupleIndexing(ty: Type, reason: IllegalTupleIndexingReason)
  UnnecessaryOptSafety
  InvalidTraitMethodSignature(fn: Function)
}

type ParamDefaultValueContext {
  exprContainsFunctionCall: Bool = false
  exprContainsVariableRef: Bool = false
}

export type Typechecker {
  moduleLoader: ModuleLoader
  project: Project
  currentModuleId: Int = -1
  currentScope: Scope = Scope(name: "\$root")
  currentTypeDecl: Struct? = None
  currentFunction: Function? = None
  paramDefaultValueContext: ParamDefaultValueContext? = None

  func typecheckEntrypoint(self, modulePathAbs: String): Result<Int, TypecheckerError> {
    val mod = TypedModule(id: 0, name: "prelude", code: [], rootScope: self.currentScope.makeChild("module_0", ScopeKind.Module))
    self.project.modules.push(mod)

    self._typecheckModule(modulePathAbs)
  }

  func _tokenizeAndParse(self, modulePath: String, relativeTo: String? = None): Result<ParsedModule, TypecheckerError> {
    val absPath = self.moduleLoader.resolvePath(modulePath, relativeTo)
    match self.moduleLoader.tokenizeAndParse(absPath) {
      Result.Ok(mod) => Result.Ok(mod)
      Result.Err(e) => {
        val kind = match e {
          TokenizeAndParseError.ReadFileError(path) => TypecheckerErrorKind.ReadFileError(path)
          TokenizeAndParseError.LexerError(inner) => TypecheckerErrorKind.LexerError(inner)
          TokenizeAndParseError.ParseError(inner) => TypecheckerErrorKind.ParseError(inner)
        }

        return Result.Err(TypecheckerError(modulePath: modulePath, kind: kind))
      }
    }
  }

  func _verifyNameUniqueInScope(self, label: Label, scope: Scope): TypeError? {
    for v in scope.variables {
      if v.label.name == label.name {
        return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: v.label))
      }
    }

    for f in scope.functions {
      if f.label.name == label.name {
        return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: f.label))
      }
    }

    for s in scope.structs {
      if s.label.name == label.name {
        return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: s.label))
      }
    }

    None
  }

  func _addVariableToScope(self, variable: Variable, scope = self.currentScope): Result<Int, TypeError> {
    if variable.label.name == "_" return Result.Ok(0) // <- unnecessary 0

    if self._verifyNameUniqueInScope(variable.label, scope) |e| return Result.Err(e)
    scope.variables.push(variable)

    Result.Ok(0) // <- unnecessary 0
  }

  func _addFunctionToScope(self, fn: Function, scope = self.currentScope): Result<Int, TypeError> {
    if self._verifyNameUniqueInScope(fn.label, scope) |e| return Result.Err(e)
    scope.functions.push(fn)

    Result.Ok(0) // <- unnecessary 0
  }

  func _addStructToScope(self, struct: Struct, scope = self.currentScope): Result<Int, TypeError> {
    val structTy = Type(kind: TypeKind.Struct(struct))
    match self._addTypeToScope(structTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val variable = Variable(label: struct.label, mutable: false, ty: structTy, alias: VariableAlias.Struct(struct))
    match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    scope.structs.push(struct)

    Result.Ok(0) // <- unnecessary 0
  }

  func _addTypeToScope(self, ty: Type, scope = self.currentScope): Result<Int, TypeError> {
    scope.types.push(ty)

    Result.Ok(0) // <- unnecessary 0
  }

  func _verifyNumTypeArgs(self, position: Position, typeArguments: TypeIdentifier[]?, num: Int): Result<Type[], TypeError> {
    if typeArguments |typeArguments| {
      if typeArguments.length != num {
        return Result.Err(TypeError(position: position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: num, given: typeArguments.length)))
      }

      val types: Type[] = []
      for i in range(0, num) {
        val typeIdent = if typeArguments.get(i) |typeIdent| typeIdent else return unreachable(position, "verified above that typeArguments.length == num")
        val ty = match self._resolveTypeIdentifier(typeIdent) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        types.push(ty)
      }

      Result.Ok(types)
    } else if num != 0 {
      Result.Err(TypeError(position: position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: num, given: 0)))
    } else {
      Result.Ok([])
    }
  }

  func _resolveTypeIdentifier(self, typeIdent: TypeIdentifier): Result<Type, TypeError> {
    val ty = match typeIdent {
      TypeIdentifier.Normal(label, typeArguments) => match label.name {
        "Int" => {
          match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          Type(kind: TypeKind.PrimitiveInt)
        }
        "Float" => {
          match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          Type(kind: TypeKind.PrimitiveFloat)
        }
        "Bool" => {
          match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          Type(kind: TypeKind.PrimitiveBool)
        }
        "String" => {
          match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          Type(kind: TypeKind.PrimitiveString)
        }
        "Map" => {
          val typeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, 2) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          Type(kind: TypeKind.Instance(self.project.preludeMapStruct, typeArgs))
        }
        "Set" => {
          val typeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, 1) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          Type(kind: TypeKind.Instance(self.project.preludeSetStruct, typeArgs))
        }
        _ => {
          var scope: Scope? = self.currentScope
          while scope |sc| {
            for ty in sc.types {
              match ty.kind {
                TypeKind.Generic(name) => { if label.name == name return Result.Ok(ty) }
                TypeKind.Struct(struct) => {
                  if label.name == struct.label.name {
                    val instanceTypeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, struct.typeParams.length) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
                    return Result.Ok(Type(kind: TypeKind.Instance(struct, instanceTypeArgs)))
                  }
                }
                _ => continue
              }
            }
            scope = sc.parent
          }
          return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
        }
      }
      TypeIdentifier.Array(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Type(kind: TypeKind.Instance(self.project.preludeArrayStruct, [innerTy]))
      }
      TypeIdentifier.Option(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        innerTy.nullable = true
        innerTy
      }
      TypeIdentifier.Tuple(typeIdents) => {
        val types: Type[] = []
        for typeIdent in typeIdents {
          val ty = match self._resolveTypeIdentifier(typeIdent) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          types.push(ty)
        }

        Type(kind: TypeKind.Tuple(types))
      }
      TypeIdentifier.Function(params, ret) => {
        val paramTypes: (Type, Bool)[] = []
        for p in params {
          val t = match self._resolveTypeIdentifier(p) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          paramTypes.push((t, true))
        }

        val returnType = match self._resolveTypeIdentifier(ret) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Type(kind: TypeKind.Func(paramTypes, returnType))
      }
    }

    Result.Ok(ty)
  }

  func _resolveIdentifier(self, ident: String): Variable? {
    var scope: Scope? = self.currentScope
    while scope |s| {
      for v in s.variables {
        if v.label.name == ident return v
      }
      scope = s.parent
    }

    None
  }

  func _typeSatisfiesRequired(self, ty: Type, required: Type): Bool {
    if ty.nullable && !required.nullable return false

    if required.kind == TypeKind.Hole return true
    if required.kind == TypeKind.Never || ty.kind == TypeKind.Never return true

    match required.kind {
      TypeKind.Func(reqParamTypes, reqRetType) => match ty.kind {
        TypeKind.Func(paramTypes, retType) => {
          if !self._typeSatisfiesRequired(ty: retType, required: reqRetType) return false

          var idx = 0
          for reqParamType, i in reqParamTypes {
            val paramType = if paramTypes[i] |t| t[0] else { return true }
            if !self._typeSatisfiesRequired(ty: paramType, required: reqParamType[0]) return false

            idx = i
          }
          if paramTypes[idx + 1] |nextParam| {
            if nextParam[1] return false
          }

          true
        }
        _ => false
      }
      TypeKind.Instance(reqStruct, reqTypeArgs) => match ty.kind {
        TypeKind.Instance(struct, typeArgs) => {
          if reqStruct.moduleId != struct.moduleId || reqStruct.label != struct.label return false

          if reqTypeArgs.length != typeArgs.length return false
          for reqTypeArg, i in reqTypeArgs {
            val typeArg = if typeArgs[i] |t| t else { return true }
            if !self._typeSatisfiesRequired(ty: typeArg, required: reqTypeArg) return false
          }

          true
        }
        _ => false
      }
      TypeKind.Tuple(reqTypes) => match ty.kind {
        TypeKind.Tuple(types) => {
          if reqTypes.length != types.length return false
          for reqTy, i in reqTypes {
            val ty = if types[i] |t| t else { /* unreachable, length verified above to be equal */ return false }
            if !self._typeSatisfiesRequired(ty: ty, required: reqTy) return false
          }

          true
        }
        _ => false
      }
      _ => {
        ty.kind == required.kind
      }
    }
  }

  func _containsGenerics(self, ty: Type): Bool {
    match ty.kind {
      TypeKind.Generic(name) => true
      TypeKind.Instance(_, typeArgs) => typeArgs.any(t => self._containsGenerics(t))
      TypeKind.Tuple(typeArgs) => typeArgs.any(t => self._containsGenerics(t))
      TypeKind.Func(paramTypes, returnType) => {
        if self._containsGenerics(returnType) return true

        paramTypes.any(p => self._containsGenerics(p[0]))
      }
      _ => false
    }
  }

  func __extractGenerics(self, template: Type, source: Type, extracted: (String, Type)[]) {
    match template.kind {
      TypeKind.Generic(name) => {
        extracted.push((name, source))
      }
      TypeKind.Instance(_, templateTypeArgs) => {
        match source.kind {
          TypeKind.Instance(_, sourceTypeArgs) => {
            if templateTypeArgs.length != sourceTypeArgs.length {
              // There's currently no notion of asserts, but this will show up in output files and fail tests so it won't go unnoticed.
              println("templateTypeArgs.length != sourceTypeArgs.length")
              return
            }
            for tplTypeArg, idx in templateTypeArgs {
              val srcTypeArg = if sourceTypeArgs[idx] |t| t else {
                println("templateTypeArgs.length != sourceTypeArgs.length")
                return
              }
              self.__extractGenerics(template: tplTypeArg, source: srcTypeArg, extracted: extracted)
            }
          }
          _ => {}
        }
      }
      TypeKind.Tuple(templateTypes) => {
        match source.kind {
          TypeKind.Tuple(sourceTypes) => {
            for tplType, idx in templateTypes {
              val srcType = if sourceTypes[idx] |t| t else break
              self.__extractGenerics(template: tplType, source: srcType, extracted: extracted)
            }
          }
          _ => {}
        }
      }
      TypeKind.Func(templateParamTypes, templateReturnType) => {
        match source.kind {
          TypeKind.Func(sourceParamTypes, sourceReturnType) => {
            self.__extractGenerics(template: templateReturnType, source: sourceReturnType, extracted: extracted)

            for tplParamType, idx in templateParamTypes {
              val srcParamType = if sourceParamTypes[idx] |t| t else break
              self.__extractGenerics(template: tplParamType[0], source: srcParamType[0], extracted: extracted)
            }
          }
          _ => {}
        }
      }
      _ => {}
    }
  }

  func _extractGenerics(self, template: Type, source: Type): (String, Type)[] {
    val extracted: (String, Type)[] = []
    self.__extractGenerics(template, source, extracted)
    extracted
  }

  func _typeAsInstance1(self, ty: Type, struct: Struct): Type? {
    match ty.kind {
      TypeKind.Instance(s, generics) => if s == struct { generics[0] } else None
      _ => None
    }
  }

  func _typeAsInstance2(self, ty: Type, struct: Struct): (Type, Type)? {
    match ty.kind {
      TypeKind.Instance(s, generics) => if s == struct {
        if generics[0] |g1| (if generics[1] |g2| (g1, g2) else None) else None
      } else None
      _ => None
    }
  }

  func _typecheckModule(self, modulePath: String): Result<Int, TypecheckerError> {
    val moduleId = self.project.modules.length
    self.currentModuleId = moduleId

    val moduleScope = self.currentScope.makeChild("module_$moduleId", ScopeKind.Module)
    val prevScope = self.currentScope
    self.currentScope = moduleScope
    val mod = TypedModule(id: moduleId, name: modulePath, code: [], rootScope: moduleScope)
    self.project.modules.push(mod)

    val parsedModule = match self._tokenizeAndParse(modulePath) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    for importNode in parsedModule.imports { /* todo */ }

    mod.code = match self._typecheckBlock(parsedModule.nodes) {
      Result.Ok(v) => v
      Result.Err(e) => return Result.Err(TypecheckerError(modulePath: modulePath, kind: TypecheckerErrorKind.TypeError(e)))
    }

    self.currentScope = prevScope
    Result.Ok(moduleId)
  }

  func _typecheckFunctionPass1(self, node: FunctionDeclarationNode): Result<Function, TypeError> {
    val fnScope = self.currentScope.makeChild(node.name.name, ScopeKind.Func)
    val prevScope = self.currentScope
    self.currentScope = fnScope

    val typeParams: (Type, Label)[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenTypeParams[label.name] = label

      val generic = Type(kind: TypeKind.Generic(label.name))
      match self._addTypeToScope(generic) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typeParams.push((generic, label))
    }

    val returnType = if node.returnTypeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    self.currentScope = prevScope

    val hasSelf = if node.params[0] |param| param.label.name == "self" else false
    val fnKind = if hasSelf {
      if !self.currentTypeDecl {
        val param = if node.params[0] |p| p else return unreachable(node.name.position, "expected a first parameter to be present")
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))
      }

      FunctionKind.InstanceMethod
    } else if self.currentTypeDecl {
      FunctionKind.StaticMethod
    } else {
      FunctionKind.Standalone
    }

    val fn = Function(label: node.name, scope: fnScope, kind: fnKind, typeParams: typeParams, params: [], returnType: returnType, body: [])
    match self._addFunctionToScope(fn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(fn)
  }

  func _typecheckFunctionParam(self, param: FunctionParam, isRevisit = false): Result<(TypedFunctionParam, Bool), TypeError> {
    if param.label.name == "self" {
      val ty = if self.currentTypeDecl |struct| {
        val typeArgs = struct.typeParams.map(p => Type(kind: TypeKind.Generic(p)))

        Type(kind: TypeKind.Instance(struct, typeArgs))
      } else {
        // Should be unreachable since _typecheckFunctionPass2 already emits this error, but better safe than sorry
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))
      }

      val variable = Variable(label: param.label, mutable: false, ty: ty)
      match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      val typedParam = TypedFunctionParam(label: param.label, ty: ty, defaultValue: None, isVariadic: false)
      return Result.Ok((typedParam, false))
    }

    val paramType = if param.typeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty
    } else {
      None
    }

    var defaultValue: TypedAstNode? = None
    if param.defaultValue |node| {
      if isRevisit {
        val expr = match self._typecheckExpression(node, paramType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        defaultValue = expr
      } else {
        // TODO: There has to be a cleaner way of representing this
        val ctx = ParamDefaultValueContext()
        self.paramDefaultValueContext = ctx
        val expr = match self._typecheckExpression(node, paramType) {
          Result.Ok(v) => v
          Result.Err(e) => {
            self.paramDefaultValueContext = None
            if ctx.exprContainsFunctionCall || ctx.exprContainsVariableRef {
              val typedParam = TypedFunctionParam(label: param.label, ty: Type(kind: TypeKind.Hole), defaultValue: TypedAstNode(token: node.token, ty: Type(kind: TypeKind.Hole), kind: TypedAstNodeKind.Placeholder), isVariadic: param.isVariadic)
              return Result.Ok((typedParam, true))
            }
            return Result.Err(e)
          }
        }
        self.paramDefaultValueContext = None
        if ctx.exprContainsFunctionCall || ctx.exprContainsVariableRef {
          val typedParam = TypedFunctionParam(label: param.label, ty: paramType ?: expr.ty, defaultValue: expr, isVariadic: param.isVariadic)
          return Result.Ok((typedParam, true))
        }
        defaultValue = expr
      }
    }

    var ty = if paramType |paramType| {
      if defaultValue |defaultValue| {
        if !self._typeSatisfiesRequired(ty: defaultValue.ty, required: paramType) {
          return Result.Err(TypeError(position: defaultValue.token.position, kind: TypeErrorKind.TypeMismatch([paramType], defaultValue.ty)))
        }
      }

      paramType
    } else {
      if defaultValue |defaultValue| {
        defaultValue.ty
      } else {
        return unreachable(param.label.position, "parser requires at least a type annotation or default value")
      }
    }

    val variable = Variable(label: param.label, mutable: false, ty: ty)
    match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    if param.isVariadic {
      if ty.nullable {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidVarargType(ty)))
      } else if self._typeAsInstance1(ty, self.project.preludeArrayStruct) |innerType| {
        ty = innerType
      } else {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidVarargType(ty)))
      }
    }

    if ty.hasUnfilledHoles() {
      return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "parameter")))
    }

    val typedParam = TypedFunctionParam(label: param.label, ty: ty, defaultValue: defaultValue, isVariadic: param.isVariadic)
    Result.Ok((typedParam, false))
  }

  func _typecheckFunctionPass2(self, fn: Function, node: FunctionDeclarationNode): Result<Int[], TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope

    val paramsNeedingRevisit: Int[] = []
    val seenParamNames: Set<String> = #{}
    var startedOptionalParams = false
    for param, idx in node.params {
      if param.isVariadic && idx != node.params.length - 1 {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "vararg")))
      }

      if seenParamNames.contains(param.label.name) {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.DuplicateParameter(param.label.name)))
      }
      seenParamNames.insert(param.label.name)

      if param.defaultValue {
        startedOptionalParams = true
      } else if startedOptionalParams {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "required")))
      }

      val _p = match self._typecheckFunctionParam(param) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      // TODO: destructuring
      val typedParam = _p[0]
      val needsRevisit = _p[1]
      val paramName = typedParam.label.name
      // This is a bit messy - if param is `self` then don't add here; it's already denoted as an instance method via its FunctionKind
      if paramName != "self" { fn.params.push(typedParam) }
      // Adjust the index value if we're in an instance method, since `self` isn't included in the fn.params array
      if needsRevisit {
        val paramIdx = if fn.kind == FunctionKind.InstanceMethod idx - 1 else idx
        paramsNeedingRevisit.push(paramIdx)
      }
    }

    self.currentScope = prevScope

    Result.Ok(paramsNeedingRevisit)
  }

  func _typecheckFunctionPass3(self, fn: Function, fnDeclNode: FunctionDeclarationNode, paramsNeedingRevisit: Int[]): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope
    val prevFn = self.currentFunction
    self.currentFunction = fn

    val hasReturnValue = fn.returnType.kind != TypeKind.PrimitiveUnit
    if hasReturnValue && fnDeclNode.body.isEmpty() {
      return Result.Err(TypeError(position: fn.label.position, kind: TypeErrorKind.ReturnTypeMismatch(fn.label.name, fn.returnType, None)))
    }

    for param, idx in fn.params {
      if !paramsNeedingRevisit.contains(idx) continue

      // Since `self` is not included in the fn.params array, but it is in the untyped AST, when referring to the untyped AST, we need to adjust
      val origNodeParamIdx = if fn.kind == FunctionKind.InstanceMethod idx + 1 else idx
      val paramNode = if fnDeclNode.params[origNodeParamIdx] |p| p else return unreachable(param.label.position, "there should be as many parameter nodes as typed parameters")
      val defaultValueNode = if paramNode.defaultValue |n| n else return unreachable(param.label.position, "the only way a parameter needs revisiting is if it has a default value")

      val _p = match self._typecheckFunctionParam(param: paramNode, isRevisit: true) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      // TODO: destructuring
      val typedParam = _p[0]
      val needsRevisit = _p[1]
      if needsRevisit return unreachable(param.label.position, "parameters should not need to be revisited more than once")
      fn.params[idx] = typedParam
    }

    for node, idx in fnDeclNode.body {
      if self.currentScope.terminator return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = if idx == fnDeclNode.body.length - 1 && hasReturnValue {
        val err = TypeError(position: node.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fn.label.name, fn.returnType, Type(kind: TypeKind.PrimitiveUnit)))
        match node.kind {
          AstNodeKind.While => return Result.Err(err)
          AstNodeKind.For => return Result.Err(err)
          AstNodeKind.BindingDeclaration => return Result.Err(err)
          AstNodeKind.FunctionDeclaration => return Result.Err(err)
          AstNodeKind.TypeDeclaration => return Result.Err(err)
          AstNodeKind.EnumDeclaration => return Result.Err(err)
          _ => {}
        }

        val expr = match self._typecheckExpressionOrTerminator(node, fn.returnType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if !self._typeSatisfiesRequired(ty: expr.ty, required: fn.returnType) {
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fn.label.name, fn.returnType, expr.ty)))
        }
        expr
      } else {
        val stmt = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        stmt
      }
      fn.body.push(typedNode)
    }

    self.currentFunction = prevFn
    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckStructPass1(self, node: TypeDeclarationNode): Result<Struct, TypeError> {
    val typeScope = self.currentScope.makeChild(node.name.name, ScopeKind.Type)
    val prevScope = self.currentScope
    self.currentScope = typeScope

    val typeParams: String[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenTypeParams[label.name] = label

      val generic = Type(kind: TypeKind.Generic(label.name))
      match self._addTypeToScope(generic) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typeParams.push(label.name)
    }

    self.currentScope = prevScope

    val struct = Struct(moduleId: self.currentModuleId, label: node.name, scope: typeScope, typeParams: typeParams)
    match self._addStructToScope(struct) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(struct)
  }

  func _typecheckStructPass2_1(self, struct: Struct, node: TypeDeclarationNode): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = struct

    val seenFields: Map<String, Label> = {}
    for field in node.fields {
      if seenFields[field.name.name] |original| {
        return Result.Err(TypeError(position: field.name.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenFields[field.name.name] = field.name

      val ty = match self._resolveTypeIdentifier(field.typeAnnotation) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      struct.fields.push(Field(name: field.name, ty: ty, initializer: None))
    }

    for funcDeclNode in node.methods {
      val fn = match self._typecheckFunctionPass1(funcDeclNode) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      match fn.kind {
        FunctionKind.InstanceMethod => struct.instanceMethods.push(fn)
        FunctionKind.StaticMethod => struct.staticMethods.push(fn)
        FunctionKind.Standalone => return unreachable(fn.label.position, "method has invalid function kind at this point")
      }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckStructPass2_2(self, struct: Struct, node: TypeDeclarationNode): Result<Map<String, Int[]>, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = struct

    val allParamsNeedingRevisit: Map<String, Int[]> = {}

    val instanceMethodsByName = struct.instanceMethods.keyBy(f => f.label)
    val staticMethodsByName = struct.staticMethods.keyBy(f => f.label)
    var toStringFn: Function? = None
    var hashFn: Function? = None
    var eqFn: Function? = None
    for funcDeclNode in node.methods {
      var isToString = false
      var isHash = false
      var isEq = false
      val fn = if instanceMethodsByName[funcDeclNode.name] |fn| {
        isToString = fn.label.name == "toString"
        isHash = fn.label.name == "hash"
        isEq = fn.label.name == "eq"
        fn
      } else if staticMethodsByName[funcDeclNode.name] |fn| {
        fn
      } else {
        return unreachable(funcDeclNode.name.position, "could not find function among instance/static methods")
      }
      val paramsNeedingRevisit = match self._typecheckFunctionPass2(fn, funcDeclNode) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      allParamsNeedingRevisit[fn.label.name] = paramsNeedingRevisit

      if isToString {
        val required = Type(kind: TypeKind.Func([], Type(kind: TypeKind.PrimitiveString)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Result.Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        toStringFn = fn
      }
      if isHash {
        val required = Type(kind: TypeKind.Func([], Type(kind: TypeKind.PrimitiveInt)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Result.Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        hashFn = fn
      }
      if isEq {
        val required = Type(kind: TypeKind.Func([(Type(kind: TypeKind.Instance(struct, [])), true)], Type(kind: TypeKind.PrimitiveBool)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Result.Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        eqFn = fn
      }
    }

    // Ensure toString/hash/eq methods exist (include generated stubs if not), and sure the proper order
    val instanceMethods = struct.instanceMethods
    struct.instanceMethods = [
      toStringFn ?: Function.generated(struct.scope, "toString", [], Type(kind: TypeKind.PrimitiveString)),
      hashFn ?: Function.generated(struct.scope, "hash", [], Type(kind: TypeKind.PrimitiveInt)),
      eqFn ?: Function.generated(struct.scope, "eq", [("other", Type(kind: TypeKind.Instance(struct, [])))], Type(kind: TypeKind.PrimitiveBool)),
    ]
    for m in instanceMethods {
      if m.label.name == "toString" || m.label.name == "hash" || m.label.name == "eq" continue
      struct.instanceMethods.push(m)
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Result.Ok(allParamsNeedingRevisit)
  }

  func _typecheckStructPass3(self, struct: Struct, node: TypeDeclarationNode, paramsNeedingRevisit: Map<String, Int[]>): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = struct

    for field, idx in node.fields {
      val initializer = if field.initializer |v| v else continue
      val structField = if struct.fields[idx] |f| f else return unreachable(struct.label.position, "")

      val typedInitializer = match self._typecheckExpression(initializer, structField.ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if !self._typeSatisfiesRequired(ty: typedInitializer.ty, required: structField.ty) {
        return Result.Err(TypeError(position: initializer.token.position, kind: TypeErrorKind.TypeMismatch([structField.ty], typedInitializer.ty)))
      }
      structField.initializer = typedInitializer
    }

    val instanceMethods = struct.instanceMethods.keyBy(f => f.label)
    val staticMethods = struct.staticMethods.keyBy(f => f.label)
    for funcDeclNode in node.methods {
      val fnLabel = funcDeclNode.name
      val fn = if instanceMethods[fnLabel] |f| {
        f
      } else if staticMethods[fnLabel] |f| {
        f
      } else {
        return unreachable(funcDeclNode.name.position, "method not visited in prior pass")
      }

      // TODO: index paramsneedingrevisit by label rather than by string to prevent against name collisions between static/instance methods
      val toRevisit = if paramsNeedingRevisit[fnLabel.name] |paramIds| paramIds else {
        return unreachable(funcDeclNode.name.position, "params improperly visited in prior pass")
      }
      match self._typecheckFunctionPass3(fn, funcDeclNode, toRevisit) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckBlock(self, nodes: AstNode[]): Result<TypedAstNode[], TypeError> {
    val funcDecls: FunctionDeclarationNode[] = []
    val typeDecls: TypeDeclarationNode[] = []
    for node in nodes {
      match node.kind {
        AstNodeKind.FunctionDeclaration(node) => funcDecls.push(node)
        AstNodeKind.TypeDeclaration(node) => typeDecls.push(node)
        _ => {}
      }
    }

    // --- Pass 1 for types, (todo: enums), and functions

    val structsPass1: (Struct, TypeDeclarationNode)[] = []
    for node in typeDecls {
      val struct = match self._typecheckStructPass1(node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      structsPass1.push((struct, node))
    }

    val functionsPass1: (Function, Variable, FunctionDeclarationNode)[] = []
    for node in funcDecls {
      val fn = match self._typecheckFunctionPass1(node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val aliasVar = Variable(label: fn.label, mutable: false, ty: fn.getType(), alias: VariableAlias.Function(fn))
      self.currentScope.variables.push(aliasVar)
      functionsPass1.push((fn, aliasVar, node))
    }

    // --- Pass 2 for types, (todo: enums), and functions

    val structsPass2_1: (Struct, TypeDeclarationNode)[] = []
    for pair in structsPass1 {
      val struct = pair[0]
      val node = pair[1]
      match self._typecheckStructPass2_1(struct, node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      structsPass2_1.push((struct, node))
    }

    val structsPass2_2: (Struct, TypeDeclarationNode, Map<String, Int[]>)[] = []
    for pair in structsPass1 {
      val struct = pair[0]
      val node = pair[1]
      val toRevisit = match self._typecheckStructPass2_2(struct, node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      structsPass2_2.push((struct, node, toRevisit))
    }

    val functionsPass2: (Function, FunctionDeclarationNode, Int[])[] = []
    for fnPair in functionsPass1 {
      val fn = fnPair[0]
      val aliasVar = fnPair[1]
      val node = fnPair[2]
      val paramsNeedingRevisit = match self._typecheckFunctionPass2(fn, node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      aliasVar.ty = fn.getType()
      functionsPass2.push((fn, node, paramsNeedingRevisit))
    }

    val functionsIter = functionsPass2.iterator()
    val structsIter = structsPass2_2.iterator()

    val typedNodes: TypedAstNode[] = []
    for node in nodes {
      val res = match node.kind {
        AstNodeKind.FunctionDeclaration => {
          val typedNode = if functionsIter.next() |pair| {
            val fn = pair[0]
            val fnDeclNode = pair[1]
            val paramsNeedingRevisit = pair[2]
            match self._typecheckFunctionPass3(fn, fnDeclNode, paramsNeedingRevisit) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.FunctionDeclaration(fn))
          } else {
            return unreachable(node.token.position, "there should be as many functions as there are functiondecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        AstNodeKind.TypeDeclaration => {
          val typedNode = if structsIter.next() |pair| {
            val struct = pair[0]
            val typeDeclNode = pair[1]
            val toRevisit = pair[2]

            match self._typecheckStructPass3(struct, typeDeclNode, toRevisit) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.TypeDeclaration(struct))
          } else {
            return unreachable(node.token.position, "there should be as many types as there are typedecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        AstNodeKind.EnumDeclaration => return todo(node.token.position)
        _ => self._typecheckStatement(node: node, typeHint: None)
      }

      val typedNode = match res { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }

    return Result.Ok(typedNodes)
  }

  func _typecheckStatement(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token

    match node.kind {
      AstNodeKind.Assignment(expr, mode) => todo(token.position, "assignment statement")
      AstNodeKind.While(condition, conditionBinding, block) => self._typecheckWhile(token, condition, conditionBinding, block)
      AstNodeKind.For(itemPattern, indexPattern, iterator, block) => self._typecheckFor(token, itemPattern, indexPattern, iterator, block)
      AstNodeKind.BindingDeclaration(node) => self._typecheckBindingDeclaration(token, node)
      AstNodeKind.Break => self._typecheckBreak(token)
      AstNodeKind.Continue => self._typecheckContinue(token)
      AstNodeKind.Return(expr) => self._typecheckReturn(token, expr)
      _ => self._typecheckExpression(node, Type(kind: TypeKind.PrimitiveUnit))
    }
  }

  func _typecheckBindingPattern(self, mutable: Bool, pattern: BindingPattern, ty: Type): Result<Variable[], TypeError> {
    match pattern {
      BindingPattern.Variable(label) => {
        val variable = Variable(label: label, mutable: mutable, ty: ty)
        match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

        Result.Ok([variable])
      }
    }
  }

  func _typecheckBindingDeclaration(self, token: Token, node: BindingDeclarationNode): Result<TypedAstNode, TypeError> {
    val isMutable = token.kind == TokenKind.Var

    val annType = if node.typeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty
    } else {
      None
    }

    val _pair = if node.expr |expr| {
      val typedExpr = match self._typecheckExpression(expr, annType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val ty = if annType |annotatedType| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: annotatedType) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([annotatedType], typedExpr.ty)))
        }

        annotatedType
      } else {
        typedExpr.ty
      }

      if ty.isInvalidValueType() {
        return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "assignment")))
      }

      // TODO: type could not be auto-coerced to `TypedAstNode?` on its own
      val typedExpr_: TypedAstNode? = typedExpr
      (typedExpr_, ty)
    } else if !isMutable {
      val label = match node.bindingPattern {
        BindingPattern.Variable(label) => label
        // _ => return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingValExpr(None)))
      }
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingValExpr(label.name)))
    } else if annType |ty| {
      (None, ty)
    } else {
      val label = match node.bindingPattern {
        BindingPattern.Variable(label) => label
        // _ => return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(None)))
      }
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(label.name)))
    }
    // TODO: destructuring
    val expr = _pair[0]
    val ty = _pair[1]

    val variables = match self._typecheckBindingPattern(isMutable, node.bindingPattern, ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val typedNode = TypedBindingDeclarationNode(bindingPattern: node.bindingPattern, variables: variables, expr: expr)
    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.BindingDeclaration(typedNode)))
  }

  func _typecheckWhile(self, token: Token, condition: AstNode, conditionBinding: BindingPattern?, block: AstNode[]): Result<TypedAstNode, TypeError> {
    val typedCondition = match self._typecheckExpression(condition, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    if typedCondition.ty.kind != TypeKind.PrimitiveBool && !typedCondition.ty.nullable {
      return Result.Err(TypeError(position: typedCondition.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedCondition.ty, purpose: "while")))
    }

    val prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("while", ScopeKind.While)

    val conditionBindingPattern = if conditionBinding |pattern| {
      val ty = typedCondition.ty.clone()
      if ty.nullable {
        ty.nullable = false
      }

      val vars = match self._typecheckBindingPattern(false, pattern, ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      (pattern, vars)
    } else {
      None
    }

    val typedNodes: TypedAstNode[] = []
    for node in block {
      if self.currentScope.terminator return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }
    val terminator = self.currentScope.terminator

    self.currentScope = prevScope
    self.currentScope.terminator = terminator

    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.While(typedCondition, conditionBindingPattern, typedNodes)))
  }

  func _typecheckFor(self, token: Token, itemPattern: BindingPattern, indexPattern: BindingPattern?, iterator: AstNode, block: AstNode[]): Result<TypedAstNode, TypeError> {
    val typedIterator = match self._typecheckExpression(iterator, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val itemType = if self._typeAsInstance1(typedIterator.ty, self.project.preludeArrayStruct) |innerTy| innerTy else {
      return Result.Err(TypeError(position: typedIterator.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedIterator.ty, purpose: "for")))
    }
    if itemType.kind == TypeKind.Hole {
      return Result.Err(TypeError(position: typedIterator.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedIterator.ty, purpose: "for")))
    }

    val prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("for", ScopeKind.For)

    val variables = match self._typecheckBindingPattern(false, itemPattern, itemType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val indexBinding = if indexPattern |pat| {
      val variables = match self._typecheckBindingPattern(false, pat, Type(kind: TypeKind.PrimitiveInt)) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      variables[0]
    } else {
      None
    }

    val typedNodes: TypedAstNode[] = []
    for node in block {
      if self.currentScope.terminator return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }
    val terminator = self.currentScope.terminator

    self.currentScope = prevScope
    self.currentScope.terminator = terminator

    val kind = TypedAstNodeKind.For(typedIterator, (itemPattern, variables), indexBinding, typedNodes)
    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: kind))
  }

  func _typecheckBreak(self, token: Token): Result<TypedAstNode, TypeError> = self._typecheckBreakContinue(token, "break", TypedAstNodeKind.Break)

  func _typecheckContinue(self, token: Token): Result<TypedAstNode, TypeError> = self._typecheckBreakContinue(token, "continue", TypedAstNodeKind.Continue)

  func _typecheckBreakContinue(self, token: Token, terminator: String, kind: TypedAstNodeKind): Result<TypedAstNode, TypeError> {
    var scope: Scope? = self.currentScope
    while scope |sc| {
      val isValid = match sc.kind {
        ScopeKind.Root => false
        ScopeKind.Module => false
        ScopeKind.Type => false
        ScopeKind.Func => false
        ScopeKind.If => {
          scope = sc.parent
          continue
        }
        ScopeKind.While => true
        ScopeKind.For => true
      }

      if !isValid return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTerminatorPosition(terminator)))
      break
    }
    self.currentScope.terminator = Terminator.NonReturning

    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.Never), kind: kind))
  }

  func _typecheckReturn(self, token: Token, expr: AstNode?): Result<TypedAstNode, TypeError> {
    val fn = if self.currentFunction |fn| fn else {
      return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTerminatorPosition("return")))
    }

    val typedExpr = if expr |expr| {
      val typedExpr = match self._typecheckExpression(expr, fn.returnType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: fn.returnType) {
        return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fn.label.name, fn.returnType, typedExpr.ty)))
      }

      typedExpr
    } else {
      if fn.returnType.kind != TypeKind.PrimitiveUnit {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.ReturnTypeMismatch(fn.label.name, fn.returnType, Type(kind: TypeKind.PrimitiveUnit))))
      }

      None
    }

    self.currentScope.terminator = Terminator.Returning

    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.Never), kind: TypedAstNodeKind.Return(typedExpr)))
  }

  func _typecheckIf(
    self,
    token: Token,
    condition: AstNode,
    conditionBinding: BindingPattern?,
    ifBlock: AstNode[],
    elseBlock: AstNode[]?,
    typeHint: Type?,
  ): Result<TypedAstNode, TypeError> {
    val isStatement = if typeHint |hint| hint.kind == TypeKind.PrimitiveUnit else false

    val typedCondition = match self._typecheckExpression(condition, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    if typedCondition.ty.kind != TypeKind.PrimitiveBool && !typedCondition.ty.nullable {
      return Result.Err(TypeError(position: typedCondition.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedCondition.ty, purpose: "if")))
    }

    val typedIfBlock: TypedAstNode[] = []
    var prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("if_then", ScopeKind.If)

    val conditionBindingPattern = if conditionBinding |pattern| {
      val ty = typedCondition.ty.clone()
      if ty.nullable {
        ty.nullable = false
      }

      val vars = match self._typecheckBindingPattern(false, pattern, ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      (pattern, vars)
    } else {
      None
    }

    for node, idx in ifBlock {
      if self.currentScope.terminator return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      if idx == ifBlock.length - 1 && !isStatement {
        val typedNode = match self._typecheckExpressionOrTerminator(node, typeHint) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        typedIfBlock.push(typedNode)
      } else {
        val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        typedIfBlock.push(typedNode)
      }
    }
    val ifType = typedIfBlock[-1]?.ty
    val ifBlockTerminator = self.currentScope.terminator
    self.currentScope = prevScope

    var hasElseBlock = false
    val typedElseBlock: TypedAstNode[] = []
    prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("if_else", ScopeKind.If)
    if elseBlock |elseBlock| {
      hasElseBlock = true
      for node, idx in elseBlock {
        if self.currentScope.terminator {
          return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))
        }

        if idx == elseBlock.length - 1 && !isStatement {
          val typedNode = match self._typecheckExpressionOrTerminator(node, ifType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          typedElseBlock.push(typedNode)
        } else {
          val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          typedElseBlock.push(typedNode)
        }
      }
    }
    val elseBlockTerminator = self.currentScope.terminator
    self.currentScope = prevScope

    self.currentScope.terminator = Terminator.combine(ifBlockTerminator, elseBlockTerminator)

    val ty = if !isStatement {
      val t = if ifType |ifType| {
        if typedElseBlock[-1] |lastElseNode| {
          val elseType = lastElseNode.ty

          if ifType.hasUnfilledHoles() {
            ifType.tryFillHoles(elseType)
          }
          if elseType.nullable && !ifType.nullable {
            ifType.nullable = true
          }

          if !self._typeSatisfiesRequired(ty: elseType, required: ifType) {
            return Result.Err(TypeError(position: lastElseNode.token.position, kind: TypeErrorKind.TypeMismatch([ifType], elseType)))
          }

          val t = if ifType.kind == TypeKind.Never { elseType.clone() } else { ifType.clone() }
          t
        } else {
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredIfExprBlock(clause: "else", missing: !hasElseBlock)))
        }
      } else {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredIfExprBlock(clause: "if", missing: false)))
      }
      t
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    val kind = TypedAstNodeKind.If(isStatement, typedCondition, conditionBindingPattern, typedIfBlock, typedElseBlock)
    Result.Ok(TypedAstNode(token: token, ty: ty, kind: kind))
  }

  func _typecheckExpression(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token
    val typedExprRes: Result<TypedAstNode, TypeError> = match node.kind {
      AstNodeKind.Literal(literal) => {
        val kind = match literal {
          LiteralAstNode.Int => TypeKind.PrimitiveInt
          LiteralAstNode.Float => TypeKind.PrimitiveFloat
          LiteralAstNode.Bool => TypeKind.PrimitiveBool
          LiteralAstNode.String => TypeKind.PrimitiveString
        }

        Result.Ok(TypedAstNode(token: token, ty: Type(kind: kind), kind: TypedAstNodeKind.Literal(literal)))
      }
      AstNodeKind.Unary(node) => self._typecheckUnary(token, node)
      AstNodeKind.Binary(node) => self._typecheckBinary(token, node)
      AstNodeKind.Grouped(inner) => {
        val expr = match self._typecheckExpression(inner, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Grouped(expr)))
      }
      AstNodeKind.Identifier(kind) => self._typecheckIdentifier(token, kind, typeHint)
      AstNodeKind.Accessor(node) => self._typecheckAccessor(token, node, typeHint)
      AstNodeKind.Invocation(node) => self._typecheckInvocation(token, node, typeHint)
      AstNodeKind.Array(items) => self._typecheckArray(token, items, typeHint)
      AstNodeKind.Set(items) => self._typecheckSet(token, items, typeHint)
      AstNodeKind.Map(items) => self._typecheckMap(token, items, typeHint)
      AstNodeKind.Tuple(items) => self._typecheckTuple(token, items, typeHint)
      AstNodeKind.Indexing(expr, index) => self._typecheckIndexing(token, expr, index, typeHint)
      AstNodeKind.Lambda(value) => todo(node.token.position, "lambda expression")
      AstNodeKind.If(condition, conditionBinding, ifBlock, elseBlock) => self._typecheckIf(token, condition, conditionBinding, ifBlock, elseBlock, typeHint)
      _ => unreachable(node.token.position, "all other node types should have already been handled")
    }

    val typedExpr = match typedExprRes { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    // If we're parsing an expression in a context where we have a type hint and where that type hint is nullable, we
    // may want to make the expression's type nullable as well, if the types' kinds are equivalent. If the types' kinds
    // are _not_ equivalent, don't do anything because this mismatch will be raised at the callsite.
    if typeHint |hint| {
      if (hint.kind == typedExpr.ty.kind || hint.kind == TypeKind.Hole) && hint.nullable {
        typedExpr.ty.nullable = true
      }
    }

    Result.Ok(typedExpr)
  }

  func _typecheckExpressionOrTerminator(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    match node.kind {
      AstNodeKind.Break => self._typecheckBreak(node.token)
      AstNodeKind.Continue => self._typecheckContinue(node.token)
      AstNodeKind.Return(expr) => self._typecheckReturn(node.token, expr)
      _ => self._typecheckExpression(node, typeHint)
    }
  }

  func _typecheckUnary(self, token: Token, node: UnaryAstNode): Result<TypedAstNode, TypeError> {
    val expr = match self._typecheckExpression(node: node.expr, typeHint: None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match node.op {
      UnaryOp.Minus => {
        if expr.ty.kind != TypeKind.PrimitiveInt && expr.ty.kind != TypeKind.PrimitiveFloat {
          val expected = [Type(kind: TypeKind.PrimitiveInt), Type(kind: TypeKind.PrimitiveFloat)]
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch(expected, expr.ty)))
        }
      }
      UnaryOp.Negate => {
        if expr.ty.kind != TypeKind.PrimitiveBool {
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveBool)], expr.ty)))
        }
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Unary(op: node.op, expr: expr)))
  }

  func _typecheckBinary(self, token: Token, node: BinaryAstNode): Result<TypedAstNode, TypeError> {
    val handleCases: ((TypeKind, TypeKind, TypeKind)[]) => Result<TypedAstNode, TypeError> = (cases) => {
      val left = match self._typecheckExpression(node.left, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val right = match self._typecheckExpression(node.right, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      for _case in cases {
        // TODO: destructuring
        val lTy = _case[0]
        val rTy = _case[1]
        val outTy = _case[2]

        if (lTy == TypeKind.Hole || (lTy == left.ty.kind && !left.ty.nullable)) && (rTy == TypeKind.Hole || (rTy == right.ty.kind && !right.ty.nullable)) {
          return Result.Ok(TypedAstNode(token: token, ty: Type(kind: outTy), kind: TypedAstNodeKind.Binary(left, node.op, right)))
        }
      }

      return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, right.ty)))
    }

    val handleEquality: () => Result<TypedAstNode, TypeError> = () => {
      val left = match self._typecheckExpression(node.left, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val right = match self._typecheckExpression(node.right, left.ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      if !left.ty.nullable && right.ty.nullable {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, right.ty)))
      }

      if !self._typeSatisfiesRequired(ty: right.ty, required: left.ty) {
        return Result.Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([left.ty], right.ty)))
      }

      Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveBool), kind: TypedAstNodeKind.Binary(left, node.op, right)))
    }

    val standardArithmeticCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
    ]
    val allFloatArithmeticCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
    ]
    val boolOpCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
      (TypeKind.PrimitiveBool, TypeKind.PrimitiveBool, TypeKind.PrimitiveBool),
    ]
    val comparisonCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveBool),
    ]

    // TODO: combine match cases, this can be cleaned up a lot
    match node.op {
      BinaryOp.Add => {
        handleCases([
          (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
          (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
          (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
          (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
          (TypeKind.Hole, TypeKind.PrimitiveString, TypeKind.PrimitiveString),
          (TypeKind.PrimitiveString, TypeKind.Hole, TypeKind.PrimitiveString),
        ])
      }
      BinaryOp.AddEq => todo(token.position, "assignment binary ops")
      BinaryOp.Sub => handleCases(standardArithmeticCases)
      BinaryOp.SubEq => todo(token.position, "assignment binary ops")
      BinaryOp.Mul => handleCases(standardArithmeticCases)
      BinaryOp.MulEq => todo(token.position, "assignment binary ops")
      BinaryOp.Div => handleCases(allFloatArithmeticCases)
      BinaryOp.DivEq => todo(token.position, "assignment binary ops")
      BinaryOp.Mod => handleCases(standardArithmeticCases)
      BinaryOp.ModEq => todo(token.position, "assignment binary ops")
      BinaryOp.Pow => handleCases(allFloatArithmeticCases)
      BinaryOp.And => handleCases(boolOpCases)
      BinaryOp.AndEq => todo(token.position, "assignment binary ops")
      BinaryOp.Or => handleCases(boolOpCases)
      BinaryOp.OrEq => todo(token.position, "assignment binary ops")
      BinaryOp.Xor => handleCases(boolOpCases)
      BinaryOp.Coalesce => {
        // If the lhs isn't a nullable type then we can short-circuit and don't even typecheck the rhs
        val left = match self._typecheckExpression(node.left, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if !left.ty.nullable {
          // Pass Hole as rhs type because it doesn't matter - there's special logic within NoSuchOperator for `?:` used with non-Option types
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, Type(kind: TypeKind.Hole))))
        }

        val requiredTy = Type(kind: left.ty.kind) // non-nullable version of lhs's type
        val right = match self._typecheckExpression(node.right, requiredTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if right.ty.nullable {
          return Result.Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([requiredTy], right.ty)))
        }

        if !self._typeSatisfiesRequired(ty: right.ty, required: requiredTy) {
          return Result.Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([requiredTy], right.ty)))
        }

        Result.Ok(TypedAstNode(token: token, ty: right.ty, kind: TypedAstNodeKind.Binary(left, node.op, right)))
      }
      BinaryOp.CoalesceEq => todo(token.position, "assignment binary ops")
      BinaryOp.Eq => handleEquality()
      BinaryOp.Neq => handleEquality()
      BinaryOp.LT => handleCases(comparisonCases)
      BinaryOp.LTE => handleCases(comparisonCases)
      BinaryOp.Shl => handleCases([(TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt)])
      BinaryOp.GT => handleCases(comparisonCases)
      BinaryOp.GTE => handleCases(comparisonCases)
      BinaryOp.Shr => handleCases([(TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt)])
    }
  }

  func _typecheckIdentifier(self, token: Token, kind: IdentifierKind, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val _p = match kind {
      IdentifierKind.Named(name) => {
        val variable = if self._resolveIdentifier(name) |variable| variable else {
          if self.paramDefaultValueContext |ctx| {
            ctx.exprContainsVariableRef = true
          }
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName(name, "variable")))
        }
        (variable.ty, TypedIdentifierKind.Named(name, variable))
      }
      IdentifierKind.Discard => return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("_", "variable")))
      IdentifierKind.None_ => {
        val kind = typeHint?.kind ?: TypeKind.Hole
        val ty = Type(kind: kind, nullable: true)
        (ty, TypedIdentifierKind.None_)
      }
      IdentifierKind.Self => {
        val variable = if self._resolveIdentifier("self") |variable| variable else {
          if self.paramDefaultValueContext |ctx| {
            ctx.exprContainsVariableRef = true
          }
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("self", "variable")))
        }
        (variable.ty, TypedIdentifierKind.Named("self", variable))
      }
    }

    // TODO: destructuring
    Result.Ok(TypedAstNode(token: token, ty: _p[0], kind: TypedAstNodeKind.Identifier(_p[1])))
  }

  func _resolveAccessorPathSegment(self, ty: Type, label: Label): (AccessorPathSegment, Type)? {
    match ty.kind {
      TypeKind.PrimitiveUnit => None
      TypeKind.PrimitiveInt => None // TODO
      TypeKind.PrimitiveFloat => None // TODO
      TypeKind.PrimitiveBool => None // TODO
      TypeKind.PrimitiveString => None // TODO
      TypeKind.Never => None
      TypeKind.Generic => None // TODO
      TypeKind.Instance(struct, generics) => {
        for field in struct.fields {
          if field.name.name == label.name {
            val resolvedGenerics: Map<String, Type> = {}
            for name, idx in struct.typeParams {
              resolvedGenerics[name] = if generics[idx] |g| g else {
                println("struct.typeParams.length != generics.length") // Pseudo-assert
                break
              }
            }
            val ty = field.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false)
            return (AccessorPathSegment.Field(label, field), ty)
          }
        }

        for fn in struct.instanceMethods {
          if fn.label.name == label.name {
            val resolvedGenerics: Map<String, Type> = {}
            for name, idx in struct.typeParams {
              resolvedGenerics[name] = if generics[idx] |g| g else {
                println("struct.typeParams.length != generics.length") // Pseudo-assert
                break
              }
            }
            val method = if resolvedGenerics.isEmpty() fn else fn.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: true)
            return (AccessorPathSegment.Method(label, method), method.getType())
          }
        }

        None
      }
      TypeKind.Tuple => None
      TypeKind.Func => None
      TypeKind.Struct(struct) => {
        // TODO: static fields

        for method in struct.staticMethods {
          if method.label.name == label.name return (AccessorPathSegment.Method(label, method), method.getType())
        }

        None
      }
      TypeKind.Hole => None
    }
  }

  func _typecheckAccessor(self, token: Token, node: AccessorAstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val typedRoot = match self._typecheckExpression(node.root, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val path: AccessorPathSegment[] = []
    var ty = typedRoot.ty
    var isNullable = false
    for _p, idx in node.path {
      // TODO: destructuring
      val token = _p[0]
      val label = _p[1]
      val isOptSafe = token.kind == TokenKind.QuestionDot
      isNullable ||= ty.nullable
      if isOptSafe && !isNullable {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnnecessaryOptSafety))
      }

      ty = if self._resolveAccessorPathSegment(ty, label) |_s| {
        // TODO: destructuring
        val seg = _s[0]
        val nextTy = _s[1]
        if isNullable && !isOptSafe {
          return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownField(ty, label.name, UnknownFieldSpecialCase.ExistsButTypeIsNullable)))
        }

        path.push(seg)
        nextTy
      } else {
        val isSpecialCase = match ty.kind {
          TypeKind.Instance(struct, _) => !!self._resolveAccessorPathSegment(Type(kind: TypeKind.Struct(struct)), label)
          _ => false
        }

        val specialCase = if isSpecialCase UnknownFieldSpecialCase.StaticFieldReferencedAsInstance else None
        return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownField(ty, label.name, specialCase)))
      }
    }

    val finalField = if path.pop() |f| f else return unreachable(node.root.token.position, "the accessor path should not be empty")

    val resTy = Type(kind: ty.kind, nullable: isNullable)
    Result.Ok(TypedAstNode(token: token, ty: resTy, kind: TypedAstNodeKind.Accessor(typedRoot, path, finalField)))
  }

  func _typecheckInvocation(self, token: Token, node: InvocationAstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val invokee = match self._typecheckExpression(node.invokee, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    match invokee.kind {
      TypedAstNodeKind.Identifier(identKind) => match identKind {
        TypedIdentifierKind.Named(name, variable) => {
          match variable.alias {
            VariableAlias.Function(fn) => self._typecheckInvocationOfFunction(token, invokee, fn, node, typeHint)
            VariableAlias.Struct(struct) => {
              val initializerFn = Function.initializer(self.currentScope, struct)
              self._typecheckInvocationOfFunction(token, invokee, initializerFn, node, typeHint, struct)
            }
            None => self._typecheckInvocationOfExpression(token, invokee, invokee.token.position, node)
          }
        }
        TypedIdentifierKind.None_ => return Result.Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.IllegalCallableType(Type(kind: TypeKind.Hole, nullable: true))))
        TypedIdentifierKind.Discard => return unreachable(invokee.token.position, "resolving '_' should fail before reaching here")
      }
      TypedAstNodeKind.Accessor(_, _, finalField) => {
        match finalField {
          AccessorPathSegment.Method(_, fn) => self._typecheckInvocationOfFunction(token, invokee, fn, node, typeHint)
          AccessorPathSegment.Field(label) => self._typecheckInvocationOfExpression(token, invokee, label.position, node)
        }
      }
      _ => self._typecheckInvocationOfExpression(token, invokee, invokee.token.position, node)
    }
  }

  func _typecheckInvocationOfExpression(self, token: Token, invokeeExpr: TypedAstNode, exprPos: Position, invocationNode: InvocationAstNode): Result<TypedAstNode, TypeError> {
    val _pair = match invokeeExpr.ty.kind {
      TypeKind.Func(paramTypes, returnType) => (paramTypes.map(p => p[0]), returnType)
      _ => return Result.Err(TypeError(position: exprPos, kind: TypeErrorKind.IllegalCallableType(invokeeExpr.ty)))
    }
    // TODO: destructuring
    val paramTypes = _pair[0]
    val returnType = _pair[1]

    if self.paramDefaultValueContext |ctx| {
      ctx.exprContainsFunctionCall = true
      return Result.Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Placeholder))
    }

    val typedArguments: TypedAstNode?[] = []
    for arg, idx in invocationNode.arguments {
      if arg.label |label| {
        return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalParameterLabel))
      }

      var paramType = if paramTypes[idx] |t| t else {
        return Result.Err(TypeError(position: arg.position(), kind: TypeErrorKind.WrongInvocationArity(expected: paramTypes.length, given: invocationNode.arguments.length)))
      }

      val typedArg = match self._typecheckExpression(arg.value, paramType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if !self._typeSatisfiesRequired(ty: typedArg.ty, required: paramType) {
        return Result.Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(None, paramType, typedArg.ty)))
      }
      typedArguments.push(typedArg)
    }

    if typedArguments.length < paramTypes.length {
      return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.WrongInvocationArity(expected: paramTypes.length, given: typedArguments.length)))
    }

    val typedInvokee = TypedInvokee.Expr(invokeeExpr)
    Result.Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Invocation(typedInvokee, typedArguments)))
  }

  func _typecheckInvocationOfFunction(self, token: Token, invokee: TypedAstNode, fn: Function, invocationNode: InvocationAstNode, typeHint: Type?, instantiationOf: Struct? = None): Result<TypedAstNode, TypeError> {
    // Function invocation is position-based for required parameters, with optional parameter labels to express call-site intent (ie. for Bool params), and it's
    // an error if a positional parameter's label is incorrect. Once we reach any optional parameters in the argument list, parameters can either be positional
    // OR labeled, but once a labeled optional parameter is seen, all subsequent arguments in the argument list must also be labeled.
    val paramsByName = fn.params.keyBy(p => p.label.name)
    val typedArgumentsByName: Map<String, TypedAstNode> = {}
    val resolvedGenerics: Map<String, Type> = {}
    var hasBegunOptionalParams = false
    var mostRecentLabeledOptionalParam: Label? = None

    if !invocationNode.typeArguments.isEmpty() {
      for generic, idx in fn.typeParams {
        val typeArg = if invocationNode.typeArguments[idx] |typeArg| typeArg else {
          return Result.Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: fn.typeParams.length, given: invocationNode.typeArguments.length)))
        }
        val typeArgTy = match self._resolveTypeIdentifier(typeArg) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        resolvedGenerics[generic[1].name] = typeArgTy
      }
      if invocationNode.typeArguments.length > fn.typeParams.length {
        return Result.Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: fn.typeParams.length, given: invocationNode.typeArguments.length)))
      }
    }

    if typeHint |hint| {
      if self._containsGenerics(fn.returnType) {
        val extractedGenerics = self._extractGenerics(template: fn.returnType, source: hint)

        for _p in extractedGenerics {
          if resolvedGenerics[_p[0]] |original| {
            if original != _p[1] {
              val returnType = fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false)
              return Result.Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.TypeMismatch([hint], returnType)))
            }
            continue
          }
          resolvedGenerics[_p[0]] = _p[1]
        }
      }
    }

    if self.paramDefaultValueContext |ctx| {
      ctx.exprContainsFunctionCall = true

      val returnType = if self._containsGenerics(fn.returnType) {
        fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false)
      } else {
        fn.returnType
      }
      return Result.Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Placeholder))
    }

    val argumentsQueue = invocationNode.arguments.map((arg, idx) => (arg, idx, 0))
    for _a in argumentsQueue {
      // TODO: destructuring
      val arg = _a[0]
      val idx = _a[1]
      val numAttempts = _a[2]

      var param = if fn.params[idx] |param| param else {
        return Result.Err(TypeError(position: arg.position(), kind: TypeErrorKind.WrongInvocationArity(expected: fn.params.length, given: invocationNode.arguments.length)))
      }
      if param.defaultValue { hasBegunOptionalParams = true }
      if param.isVariadic { return todo(arg.position(), "variadic parameters") }

      if arg.label |label| {
        if label.name != param.label.name {
          if !hasBegunOptionalParams {
            return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.ParameterLabelMismatch(expected: param.label.name, given: label.name)))
          }

          param = if paramsByName[label.name] |p| p else {
            return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownParameterName(label.name)))
          }
        }
        if hasBegunOptionalParams && !mostRecentLabeledOptionalParam {
          mostRecentLabeledOptionalParam = label
        }
      } else if instantiationOf {
        return Result.Err(TypeError(position: arg.position(), kind: TypeErrorKind.MissingRequiredArgumentLabel))
      } else if mostRecentLabeledOptionalParam |label| {
        return Result.Err(TypeError(position: arg.position(), kind: TypeErrorKind.MixedArgumentType(label)))
      }

      val _p = if self._containsGenerics(param.ty) {
        var paramType = param.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false)

        val typedArg = match self._typecheckExpression(arg.value, paramType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if numAttempts < 1 && typedArg.ty.hasUnfilledHoles() {
          argumentsQueue.push((_a[0], _a[1], numAttempts + 1))
          continue
        }

        val extractedGenerics = self._extractGenerics(template: param.ty, source: typedArg.ty)

        for _p in extractedGenerics {
          if resolvedGenerics[_p[0]] |original| {
            if original != _p[1] {
              return Result.Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(param.label.name, original, typedArg.ty)))
            }
            continue
          }
          resolvedGenerics[_p[0]] = _p[1]
        }

        paramType = param.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false)
        (typedArg, paramType)
      } else {
        val typedArg = match self._typecheckExpression(arg.value, param.ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        (typedArg, param.ty)
      }
      // TODO: destructuring
      val typedArg = _p[0]
      val paramType = _p[1]
      if !self._typeSatisfiesRequired(ty: typedArg.ty, required: paramType) {
        return Result.Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(param.label.name, paramType, typedArg.ty)))
      }
      typedArgumentsByName[param.label.name] = typedArg
    }

    val typedArguments: TypedAstNode?[] = []
    for param in fn.params {
      if typedArgumentsByName[param.label.name] |argValue| {
        typedArguments.push(argValue)
      } else if param.defaultValue {
        typedArguments.push(None)
      } else {
        val errorKind = if instantiationOf |struct| {
          val missing = struct.fields
            .filter(f => !f.initializer && !typedArgumentsByName.containsKey(f.name.name))
            .map(f => f.name.name)
          TypeErrorKind.MissingRequiredFields(missing)
        } else {
          val numRequired = fn.params.filter(p => !p.defaultValue).length
          TypeErrorKind.WrongInvocationArity(expected: numRequired, given: invocationNode.arguments.length)
        }

        return Result.Err(TypeError(position: token.position, kind: errorKind))
      }
    }

    val returnType = if self._containsGenerics(fn.returnType) {
      fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false)
    } else fn.returnType

    val typedInvokee = if instantiationOf |struct| {
      TypedInvokee.Struct(struct)
    } else {
      TypedInvokee.Expr(invokee)
    }

    Result.Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Invocation(typedInvokee, typedArguments)))
  }

  func _typecheckArray(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerHintIsNullable = true
    var innerType: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance1(hint, self.project.preludeArrayStruct) |inner| {
        if inner.kind != TypeKind.Hole {
          innerHintIsNullable = inner.nullable
          innerType = inner
        }
      }
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = match self._typecheckExpression(node: node, typeHint: innerType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      makeItemsNullable ||= typedItem.ty.nullable
      if innerType |ty| {
        // Working inner type becomes nullable if we've discovered a nullable type and if the hint allows nullness (an absent hint allows nullness).
        if makeItemsNullable && innerHintIsNullable {
          ty.nullable = true
        }

        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          return Result.Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
        }
      } else if !typedItem.ty.hasUnfilledHoles() {
        innerType = typedItem.ty
      }
      typedItems.push(typedItem)
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(self.project.preludeArrayStruct, [inner]))
    val innerHasUnfilledHoles = inner.hasUnfilledHoles()

    for item in typedItems {
      if makeItemsNullable { item.ty.nullable = true }

      if !innerHasUnfilledHoles && item.ty.hasUnfilledHoles() {
        item.ty.tryFillHoles(inner)
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Array(typedItems)))
  }

  func _typecheckSet(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerHintIsNullable = true
    var innerType: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance1(hint, self.project.preludeSetStruct) |inner| {
        if inner.kind != TypeKind.Hole {
          innerHintIsNullable = inner.nullable
          innerType = inner
        }
      }
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = match self._typecheckExpression(node: node, typeHint: innerType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      makeItemsNullable ||= typedItem.ty.nullable
      if innerType |ty| {
        // Working inner type becomes nullable if we've discovered a nullable type and if the hint allows nullness (an absent hint allows nullness).
        if makeItemsNullable && innerHintIsNullable {
          ty.nullable = true
        }

        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          return Result.Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
        }
      } else if !typedItem.ty.hasUnfilledHoles() {
        innerType = typedItem.ty
      }
      typedItems.push(typedItem)
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(self.project.preludeSetStruct, [inner]))
    val innerHasUnfilledHoles = inner.hasUnfilledHoles()

    for item in typedItems {
      if makeItemsNullable { item.ty.nullable = true }

      if !innerHasUnfilledHoles && item.ty.hasUnfilledHoles() {
        item.ty.tryFillHoles(inner)
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Set(typedItems)))
  }

  func _typecheckMap(self, token: Token, items: (AstNode, AstNode)[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var keyHintIsNullable = true
    var keyTy: Type? = None
    var valHintIsNullable = true
    var valTy: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance2(hint, self.project.preludeMapStruct) |_p| {
        // TODO: destructuring
        val keyHintTy = _p[0]
        val valHintTy = _p[1]
        if keyHintTy.kind != TypeKind.Hole {
          keyHintIsNullable = keyHintTy.nullable
          keyTy = keyHintTy
        }
        if valHintTy.kind != TypeKind.Hole {
          valHintIsNullable = valHintTy.nullable
          valTy = valHintTy
        }
      }
    }

    var makeKeysNullable = false
    var makeValsNullable = false
    val typedItems: (TypedAstNode, TypedAstNode)[] = []
    for _p in items {
      // TODO: destructuring
      val keyNode = _p[0]
      val valNode = _p[1]

      val typedKey = match keyNode.kind {
        AstNodeKind.Identifier(identKind) => match identKind {
          IdentifierKind.Named(name) => TypedAstNode(token: keyNode.token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.Literal(LiteralAstNode.String(name)))
          IdentifierKind.Discard => TypedAstNode(token: keyNode.token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.Literal(LiteralAstNode.String("_")))
          IdentifierKind.Self => {
            val e = match self._typecheckExpression(node: keyNode, typeHint: keyTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            e
          }
          IdentifierKind.None_ => {
            val e = match self._typecheckExpression(node: keyNode, typeHint: keyTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            e
          }
        }
        _ => {
          val e = match self._typecheckExpression(node: keyNode, typeHint: keyTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          e
        }
      }
      makeKeysNullable ||= typedKey.ty.nullable

      if keyTy |ty| {
        // Working inner type for key becomes nullable if we've discovered a nullable key and if the key hint allows nullness (an absent hint allows nullness).
        if makeKeysNullable && keyHintIsNullable {
          ty.nullable = true
        }

        if !self._typeSatisfiesRequired(ty: typedKey.ty, required: ty) {
          return Result.Err(TypeError(position: typedKey.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedKey.ty)))
        }
      } else if !typedKey.ty.hasUnfilledHoles() {
        keyTy = typedKey.ty
      }

      val typedVal = match self._typecheckExpression(node: valNode, typeHint: valTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      makeValsNullable ||= typedVal.ty.nullable
      if valTy |ty| {
        // Working inner type for val becomes nullable if we've discovered a nullable val and if the val hint allows nullness (an absent hint allows nullness).
        if makeValsNullable && valHintIsNullable {
          ty.nullable = true
        }

        if !self._typeSatisfiesRequired(ty: typedVal.ty, required: ty) {
          return Result.Err(TypeError(position: typedVal.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedVal.ty)))
        }
      } else if !typedVal.ty.hasUnfilledHoles() {
        valTy = typedVal.ty
      }

      typedItems.push((typedKey, typedVal))
    }

    val kTy = keyTy ?: Type(kind: TypeKind.Hole)
    val vTy = valTy ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(self.project.preludeMapStruct, [kTy, vTy]))
    val keyTyHasUnfilledHoles = kTy.hasUnfilledHoles()
    val valTyHasUnfilledHoles = vTy.hasUnfilledHoles()

    for _p in typedItems {
      // TODO: destructuring
      val typedKey = _p[0]
      val typedVal = _p[1]

      if makeKeysNullable { typedKey.ty.nullable = true }
      if makeValsNullable { typedVal.ty.nullable = true }

      if !keyTyHasUnfilledHoles && typedKey.ty.hasUnfilledHoles() { typedKey.ty.tryFillHoles(kTy) }
      if !valTyHasUnfilledHoles && typedVal.ty.hasUnfilledHoles() { typedVal.ty.tryFillHoles(vTy) }
     }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Map(typedItems)))
  }

  func _typecheckTuple(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var typeHints: Type[]? = None
    if typeHint |hint| {
      match hint.kind {
        TypeKind.Tuple(types) => typeHints = types
        _ => {}
      }
    }

    val typedItems: TypedAstNode[] = []
    for node, idx in items {
      val typeHint = if typeHints |typeHints| typeHints[idx]
      val typedExpr = match self._typecheckExpression(node, typeHint) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if typeHint |hint| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: hint) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([hint], typedExpr.ty)))
        }
      }
      typedItems.push(typedExpr)
    }
    val ty = Type(kind: TypeKind.Tuple(typedItems.map(item => item.ty)))
    if typeHints |typeHints| {
      val hintTy = Type(kind: TypeKind.Tuple(typeHints))
      if !self._typeSatisfiesRequired(ty: ty, required: hintTy) {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.TypeMismatch([hintTy], ty)))
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Tuple(typedItems)))
  }

  func _typecheckIndexing(self, token: Token, expr: AstNode, indexMode: IndexingMode<AstNode>, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val typedExpr = match self._typecheckExpression(expr, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    if typedExpr.ty.nullable {
      return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
    }

    val res = match typedExpr.ty.kind {
      TypeKind.PrimitiveString => {
        val resTy = Type(kind: TypeKind.PrimitiveString)
        self._typecheckIndexingArraylike(token: token, typedExpr: typedExpr, indexMode: indexMode, singleModeType: resTy, rangeModeType: resTy)
      }
      TypeKind.Tuple(types) => self._typecheckIndexingTuple(token, types, typedExpr, indexMode)
      TypeKind.Instance(struct, typeArgs) => {
        if self._typeAsInstance1(typedExpr.ty, self.project.preludeArrayStruct) |inner| {
          self._typecheckIndexingArraylike(token: token, typedExpr: typedExpr, indexMode: indexMode, singleModeType: Type(kind: inner.kind, nullable: true), rangeModeType: typedExpr.ty)
        } else if self._typeAsInstance2(typedExpr.ty, self.project.preludeMapStruct) |_p| {
          // TODO: destructuring
          val keyTy = _p[0]
          val valTy = _p[1]

          match indexMode {
            IndexingMode.Single(idxExpr) => {
              val typedIdxExpr = match self._typecheckExpression(idxExpr, keyTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
              if !self._typeSatisfiesRequired(ty: typedIdxExpr.ty, required: keyTy) {
                return Result.Err(TypeError(position: typedIdxExpr.token.position, kind: TypeErrorKind.TypeMismatch([keyTy], typedIdxExpr.ty)))
              }

              val ty = Type(kind: valTy.kind, nullable: true)
              Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.Map(typedExpr, typedIdxExpr))))
            }
            IndexingMode.Range => return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: true)))
          }
        } else {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
        }
      }
      _ => return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
    }

    res
  }

  func _typecheckIndexingArraylike(self, token: Token, typedExpr: TypedAstNode, indexMode: IndexingMode<AstNode>, singleModeType: Type, rangeModeType: Type): Result<TypedAstNode, TypeError> {
    match indexMode {
      IndexingMode.Single(idxExpr) => {
        val typedIdxExpr = match self._typecheckExpression(idxExpr, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        val idxTy = typedIdxExpr.ty
        if idxTy.nullable || idxTy.kind != TypeKind.PrimitiveInt {
          return Result.Err(TypeError(position: typedIdxExpr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], idxTy)))
        }

        val typedIndexMode = IndexingMode.Single(typedIdxExpr)
        return Result.Ok(TypedAstNode(token: token, ty: singleModeType, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.ArrayLike(typedExpr, typedIndexMode))))
      }
      IndexingMode.Range(startExpr, endExpr) => {
        val typedStartExpr = if startExpr |expr| {
          val e = match self._typecheckExpression(expr, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          if e.ty.nullable || e.ty.kind != TypeKind.PrimitiveInt {
            return Result.Err(TypeError(position: e.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], e.ty)))
          }
          e
        }
        val typedEndExpr = if endExpr |expr| {
          val e = match self._typecheckExpression(expr, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          if e.ty.nullable || e.ty.kind != TypeKind.PrimitiveInt {
            return Result.Err(TypeError(position: e.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], e.ty)))
          }
          e
        }
        val typedIndexMode = IndexingMode.Range(typedStartExpr, typedEndExpr)
        return Result.Ok(TypedAstNode(token: token, ty: rangeModeType, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.ArrayLike(typedExpr, typedIndexMode))))
      }
    }
  }

  func _typecheckIndexingTuple(self, token: Token, tupleItemTypes: Type[], tupleExpr: TypedAstNode, indexMode: IndexingMode<AstNode>): Result<TypedAstNode, TypeError> {
    match indexMode {
      IndexingMode.Single(idxExpr) => {
        match idxExpr.kind {
          AstNodeKind.Literal(lit) => {
            match lit {
              LiteralAstNode.Int(i) => {
                val itemTy = if i < 0
                  return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.IndexNegative)))
                else if tupleItemTypes[i] |ty|
                  ty
                else
                  return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.IndexOutOfBounds)))

                Result.Ok(TypedAstNode(token: token, ty: itemTy, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.Tuple(tupleExpr, i))))
              }
              _ => Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.NotIntLiteral)))
            }
          }
          _ => Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.NotLiteralNode)))
        }
      }
      // TODO: should tuples be indexable as a range? it could just create a sub-tuple copy? is that useful at all? seems silly to forbid it
      IndexingMode.Range => Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalIndexableType(ty: tupleExpr.ty, isRange: true)))
    }
  }
}

func todo<V>(position: Position, reason = ""): Result<V, TypeError> {
  Result.Err(TypeError(position: position, kind: TypeErrorKind.NotYetImplemented(reason)))
}

func unreachable<V>(position: Position, message: String): Result<V, TypeError> {
  Result.Err(TypeError(position: position, kind: TypeErrorKind.Unreachable(message)))
}