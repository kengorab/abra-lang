import "fs" as fs
import getAbsolutePath, resolveRelativePath from "./utils"
import Lexer, LexerError, Token, TokenKind, Position from "./lexer"
import Parser, ParsedModule, ParseError, AstNode, AstNodeKind, LiteralAstNode, UnaryAstNode, UnaryOp, BinaryAstNode, BinaryOp, BindingDeclarationNode, BindingPattern, TypeIdentifier, Label, IdentifierKind, FunctionDeclarationNode, FunctionParam, InvocationAstNode, InvocationArgument, TypeDeclarationNode, EnumDeclarationNode, EnumVariant, AccessorAstNode, IndexingMode, AssignOp, AssignmentMode, ImportNode, ImportKind, DecoratorNode, LambdaNode from "./parser"

enum TokenizeAndParseError {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
}

export type ModuleLoader {
  stdRoot: String
  parsedModules: Map<String, ParsedModule> = {}

  func resolvePath(self, modulePath: String, relativeTo: String?): String {
    if relativeTo |relativeTo| {
      val pathParts = resolveRelativePath(path: modulePath, relativeTo: relativeTo)
      "/" + pathParts.join("/")
    } else {
      modulePath
    }
  }

  func hasSeenModule(self, modulePathAbs: String): Bool = self.parsedModules.containsKey(modulePathAbs)

  func tokenizeAndParse(self, modulePath: String): Result<ParsedModule, TokenizeAndParseError> {
    if self.parsedModules[modulePath] |m| return Result.Ok(m)

    val parsedModule = match fs.readFile(modulePath) {
      Result.Ok(contents) => {
        val m = match Lexer.tokenize(contents) {
          Result.Ok(tokens) => {
            val m = match Parser.parse(tokens) {
              Result.Ok(parsedModule) => parsedModule
              Result.Err(error) => return Result.Err(TokenizeAndParseError.ParseError(error))
            }
            m
          }
          Result.Err(error) => return Result.Err(TokenizeAndParseError.LexerError(error))
        }
        m
      }
      Result.Err(e) => return Result.Err(TokenizeAndParseError.ReadFileError(modulePath))
    }
    self.parsedModules[modulePath] = parsedModule

    Result.Ok(parsedModule)
  }
}

export enum Export {
  Variable(variable: Variable)
  Function(aliasVar: Variable)
  Type(structOrEnum: StructOrEnum, aliasVar: Variable)
}

export type Import {
  label: Label
  kind: TypedImportKind
}

enum TypedImportKind {
  Variable(variable: Variable)
  Function(aliasVar: Variable)
  Type(structOrEnum: StructOrEnum, aliasVar: Variable)
}

type ImportedModule {
  aliases: Label[] = []
  imports: Map<String, Import> = {}
}

export type TypedModule {
  id: Int
  name: String
  code: TypedAstNode[]
  rootScope: Scope
  complete: Bool = false
  imports: Map<String, ImportedModule> = {}
  exports: Map<String, Export> = {}
}

export enum VariableAlias {
  Function(fn: Function)
  Struct(struct: Struct)
  Enum(enum_: Enum)
}

export type Variable {
  label: Label
  mutable: Bool
  ty: Type
  alias: VariableAlias? = None
  isExported: Bool = false
}

export enum Terminator {
  Returning
  NonReturning

  func combine(t1: Terminator?, t2: Terminator?): Terminator? {
    val t1Returns = if t1 |t1| t1 == Terminator.Returning else false
    val t1NonReturns = if t1 |t1| t1 == Terminator.NonReturning else false
    val t2Returns = if t2 |t2| t2 == Terminator.Returning else false
    val t2NonReturns = if t2 |t2| t2 == Terminator.NonReturning else false

    if t1Returns && t2Returns return Terminator.Returning

    if (t1NonReturns && !!t2) || (t2NonReturns && !!t1) return Terminator.NonReturning

    None
  }
}

export enum ScopeKind {
  Root
  Module
  Func
  If
  While
  For
  Type
}

export type Scope {
  name: String
  variables: Variable[] = []
  functions: Function[] = []
  types: Type[] = []
  structs: Struct[] = []
  enums: Enum[] = []
  kind: ScopeKind = ScopeKind.Root
  parent: Scope? = None
  terminator: Terminator? = None
  numLambdas: Int = 0

  func nextLambdaName(self): String {
    val name = "lambda_${self.numLambdas}"
    self.numLambdas += 1
    name
  }

  func makeChild(self, name: String, kind: ScopeKind): Scope = Scope(name: "${self.name}::$name", kind: kind, parent: self)
}

export type Field {
  name: Label
  ty: Type
  initializer: TypedAstNode?
}

export type Struct {
  moduleId: Int
  label: Label
  scope: Scope
  typeParams: String[] = []
  fields: Field[] = []
  instanceMethods: Function[] = []
  staticMethods: Function[] = []

  // Override eq method since default implementation recurses infinitely (scope -> variables -> TypeKind.Struct)
  func eq(self, other: Struct): Bool = self.moduleId == other.moduleId && self.label == other.label
}

export type TypedEnumVariant {
  label: Label
  kind: EnumVariantKind
}

export enum EnumVariantKind {
  Constant
  Container(fields: Field[])
}

export type Enum {
  moduleId: Int
  label: Label
  scope: Scope
  typeParams: String[]
  variants: TypedEnumVariant[] = []
  instanceMethods: Function[] = []
  staticMethods: Function[] = []

  // Override eq method since default implementation recurses infinitely (scope -> variables -> TypeKind.Enum)
  func eq(self, other: Enum): Bool = self.moduleId == other.moduleId && self.label == other.label
}

enum Instantiatable {
  Struct(struct: Struct)
  EnumContainerVariant(enum_: Enum, variant: TypedEnumVariant, fields: Field[])
}


export type Project {
  modules: Map<String, TypedModule> = {}
  preludeScope: Scope = Scope(name: "bogus")
  preludeIntStruct: Struct = Struct(moduleId: 0, label: Label(name: "Int", position: Position(line: 0, col: 0)), scope: Scope(name: "Int"))
  preludeFloatStruct: Struct = Struct(moduleId: 0, label: Label(name: "Float", position: Position(line: 0, col: 0)), scope: Scope(name: "Float"))
  preludeBoolStruct: Struct = Struct(moduleId: 0, label: Label(name: "Bool", position: Position(line: 0, col: 0)), scope: Scope(name: "Bool"))
  preludeStringStruct: Struct = Struct(moduleId: 0, label: Label(name: "String", position: Position(line: 0, col: 0)), scope: Scope(name: "String"))
  preludeArrayStruct: Struct = Struct(moduleId: 0, label: Label(name: "Array", position: Position(line: 0, col: 0)), scope: Scope(name: "Array"), typeParams: ["T"])
  preludeMapStruct: Struct = Struct(moduleId: 0, label: Label(name: "Map", position: Position(line: 0, col: 0)), scope: Scope(name: "Array"), typeParams: ["K", "V"])
  preludeSetStruct: Struct = Struct(moduleId: 0, label: Label(name: "Set", position: Position(line: 0, col: 0)), scope: Scope(name: "Set"), typeParams: ["T"])
}

export type Type {
  kind: TypeKind
  nullable: Bool = false

  func clone(self): Type = Type(kind: self.kind, nullable: self.nullable)

  func repr(self): String {
    val repr = match self.kind {
      TypeKind.Any => "Any"
      TypeKind.PrimitiveUnit => "Unit"
      TypeKind.PrimitiveInt => "Int"
      TypeKind.PrimitiveFloat => "Float"
      TypeKind.PrimitiveBool => "Bool"
      TypeKind.PrimitiveString => "String"
      TypeKind.Never => "Never"
      TypeKind.Generic(name) => name
      TypeKind.Instance(structOrEnum, typeParams) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => {
            if struct.moduleId == 0 && struct.label.name == "Array" {
              val innerRepr = typeParams[0]?.repr() ?: "<unknown>"
              "$innerRepr[]"
            } else {
              val genericsRepr = if typeParams.isEmpty() "" else {
                val reprs = typeParams.map(t => t.repr()).join(", ")
                "<$reprs>"
              }
              "${struct.label.name}$genericsRepr"
            }
          }
          StructOrEnum.Enum(enum_) => {
            val genericsRepr = if typeParams.isEmpty() "" else {
              val reprs = typeParams.map(t => t.repr()).join(", ")
              "<$reprs>"
            }
            "${enum_.label.name}$genericsRepr"
          }
        }
      }
      TypeKind.Tuple(types) => "(${types.map(t => t.repr()).join(", ")})"
      TypeKind.Func(paramTypes, returnType) => {
        val paramsRepr = paramTypes.filter(p => p[1]).map(p => p[0].repr()).join(", ")
        val returnTypeRepr = returnType.repr()
        val repr = "($paramsRepr) => $returnTypeRepr"

        if self.nullable return "($repr)?"
        repr
      }
      TypeKind.Type(structOrEnum) => match structOrEnum {
        StructOrEnum.Struct(struct) => "<#type ${struct.label.name}>"
        StructOrEnum.Enum(enum_) => "<#enum ${enum_.label.name}>"
      }
      TypeKind.Hole => "<unknown>"
    }

    if self.nullable "$repr?" else repr
  }

  func hasUnfilledHoles(self): Bool = match self.kind {
    TypeKind.Any => false
    TypeKind.PrimitiveUnit => false
    TypeKind.PrimitiveInt => false
    TypeKind.PrimitiveFloat => false
    TypeKind.PrimitiveBool => false
    TypeKind.PrimitiveString => false
    TypeKind.Never => false
    TypeKind.Generic => false
    TypeKind.Instance(_, generics) => generics.any(t => t.hasUnfilledHoles())
    TypeKind.Tuple(types) => types.any(t => t.hasUnfilledHoles())
    TypeKind.Func(paramTypes, returnType) => paramTypes.any(t => t[0].hasUnfilledHoles()) || returnType.hasUnfilledHoles()
    TypeKind.Type => false
    TypeKind.Hole => true
  }

  func isInvalidValueType(self): Bool = self.kind == TypeKind.PrimitiveUnit || self.kind == TypeKind.Never || self.hasUnfilledHoles()

  func tryFillHoles(self, other: Type) {
    // TODO: this code is pretty ugly - I really need a way of destructuring multiple values simultaneously in `match`es
    match self.kind {
      TypeKind.Instance(selfStructOrEnum, selfTypeArgs) => {
        match other.kind {
          TypeKind.Instance(otherStructOrEnum, otherTypeArgs) => {
            if selfStructOrEnum != otherStructOrEnum return

            for typeArg, idx in selfTypeArgs {
              typeArg.tryFillHoles(otherTypeArgs[idx] ?: Type(kind: TypeKind.Hole))
            }
          }
          _ => {}
        }
      }
      TypeKind.Tuple(selfTypeArgs) => {
        match other.kind {
          TypeKind.Tuple(otherTypeArgs) => {
            for typeArg, idx in selfTypeArgs {
              typeArg.tryFillHoles(otherTypeArgs[idx] ?: Type(kind: TypeKind.Hole))
            }
          }
          _ => {}
        }
      }
      _ => {
        if self.kind == TypeKind.Hole {
          self.kind = other.kind
        }
      }
    }
  }

  func withSubstitutedGenerics(self, resolvedGenerics: Map<String, Type>, retainUnknown: Bool, genericsInScope: Set<String>): Type {
    val resultType = match self.kind {
      TypeKind.Generic(name) => {
        val t = if resolvedGenerics[name] |substitute| {
          val ty = substitute.clone()
          if self.nullable ty.nullable = true
          ty
        } else if retainUnknown || genericsInScope.contains(name) {
          self
        } else {
          Type(kind: TypeKind.Hole)
        }
        t
      }
      TypeKind.Instance(structOrEnum, typeArgs) => {
        val substTypeArgs = typeArgs.map(ty => ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope))
        Type(kind: TypeKind.Instance(structOrEnum, substTypeArgs), nullable: self.nullable)
      }
      TypeKind.Tuple(typeArgs) => {
        val substTypeArgs = typeArgs.map(ty => ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope))
        Type(kind: TypeKind.Tuple(substTypeArgs), nullable: self.nullable)
      }
      TypeKind.Func(paramTypes, returnType) => {
        val substParamTypes = paramTypes.map(p => {
          val t = p[0].withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)
          (t, p[1])
        })
        val substReturnType = returnType.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)
        Type(kind: TypeKind.Func(substParamTypes, substReturnType), nullable: self.nullable)
      }
      _ => self
    }

    resultType
  }
}

export enum StructOrEnum {
  Struct(struct: Struct)
  Enum(enum_: Enum)
}

export enum TypeKind {
  PrimitiveUnit
  PrimitiveInt
  PrimitiveFloat
  PrimitiveBool
  PrimitiveString
  Never
  Any
  Generic(name: String)
  Instance(structOrEnum: StructOrEnum, generics: Type[])
  Func(paramTypes: (Type, Bool)[], returnType: Type)
  Type(type_: StructOrEnum)
  Tuple(types: Type[])
  Hole
}

export type TypedAstNode {
  token: Token
  ty: Type
  kind: TypedAstNodeKind
}

export enum TypedIdentifierKind {
  Named(name: String, variable: Variable)
  None_
  Discard
}

type Decorator {
  label: Label
  arguments: LiteralAstNode[]
}

type TypedBindingDeclarationNode {
  bindingPattern: BindingPattern
  variables: Variable[]
  expr: TypedAstNode?
}

type TypedFunctionParam {
  label: Label
  ty: Type
  defaultValue: TypedAstNode? = None
  isVariadic: Bool = false
}

enum FunctionKind {
  Standalone
  InstanceMethod
  StaticMethod
}

export type Function {
  label: Label
  scope: Scope
  kind: FunctionKind
  typeParams: (Type, Label)[] = []
  params: TypedFunctionParam[] = []
  returnType: Type
  body: TypedAstNode[] = []
  isGenerated: Bool = false
  isLambda: Bool = false
  decorators: Decorator[] = []

  func generated(
    scope: Scope,
    name: String,
    params: (String, Type)[],
    returnType: Type,
    kind = FunctionKind.InstanceMethod,
    typeParams: (Type, Label)[] = [],
  ): Function {
    val bogusPosition = Position(line: 0, col: 0)

    val label = Label(name: name, position: bogusPosition)
    val fnScope = scope.makeChild(name, ScopeKind.Func)
    val fnParams = params.map(p => TypedFunctionParam(label: Label(name: p[0], position: bogusPosition), ty: p[1]))
    Function(label: label, scope: fnScope, kind: kind, typeParams: typeParams, params: fnParams, returnType: returnType, body: [], isGenerated: true)
  }

  func initializer(
    scope: Scope,
    struct: Struct,
  ): Function {
    val bogusPosition = Position(line: 0, col: 0)

    val fnScope = scope.makeChild(struct.label.name, ScopeKind.Func)
    val structTypeParams = struct.typeParams.map(t => (Type(kind: TypeKind.Generic(t)), Label(name: t, position: bogusPosition)))
    val params = struct.fields.map(f => TypedFunctionParam(label: Label(name: f.name.name, position: bogusPosition), ty: f.ty, defaultValue: f.initializer))
    val typeArgs = struct.typeParams.map(t => Type(kind: TypeKind.Generic(t)))
    val returnType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs))

    Function(label: struct.label, scope: fnScope, kind: FunctionKind.Standalone, typeParams: structTypeParams, params: params, returnType: returnType, body: [], isGenerated: true)
  }

  func forEnumVariant(
    scope: Scope,
    enum_: Enum,
    variantLabel: Label,
    variantFields: Field[],
  ): Function {
    val bogusPosition = Position(line: 0, col: 0)

    val fnScope = scope.makeChild("${enum_.label.name}.${variantLabel.name}", ScopeKind.Func)
    val typeParams = enum_.typeParams.map(t => (Type(kind: TypeKind.Generic(t)), Label(name: t, position: bogusPosition)))
    val params = variantFields.map(f => TypedFunctionParam(label: Label(name: f.name.name, position: bogusPosition), ty: f.ty, defaultValue: f.initializer))
    val typeArgs = enum_.typeParams.map(t => Type(kind: TypeKind.Generic(t)))
    val returnType = Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), typeArgs))

    Function(label: variantLabel, scope: fnScope, kind: FunctionKind.Standalone, typeParams: typeParams, params: params, returnType: returnType, body: [], isGenerated: true)
  }

  func getType(self): Type = Type(kind: TypeKind.Func(paramTypes: self.params.map(p => (p.ty, !p.defaultValue)), returnType: self.returnType))

  func withSubstitutedGenerics(self, resolvedGenerics: Map<String, Type>, retainUnknown: Bool, genericsInScope: Set<String>): Function {
    val params = self.params.map(p => {
      val ty = p.ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)
      TypedFunctionParam(label: p.label, ty: ty, defaultValue: p.defaultValue, isVariadic: p.isVariadic)
    })
    val returnType = self.returnType.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)

    Function(
      label: self.label,
      scope: self.scope,
      kind: self.kind,
      typeParams: self.typeParams,
      params: params,
      returnType: returnType,
      body: self.body,
      isGenerated: self.isGenerated,
      decorators: self.decorators,
    )
  }
}

export enum TypedInvokee {
  Struct(struct: Struct)
  Expr(expr: TypedAstNode)
  EnumVariant(enum_: Enum, variant: TypedEnumVariant)
}

export enum TypedIndexingNode {
  ArrayLike(expr: TypedAstNode, indexingMode: IndexingMode<TypedAstNode>)
  Map(expr: TypedAstNode, idx: TypedAstNode)
  Tuple(tupleExpr: TypedAstNode, idx: Int)
}

export enum TypedAssignmentMode {
  Variable(variable: Variable)
  Indexing(node: TypedIndexingNode)
  Accessor(head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment)
}

export enum TypedAstNodeKind {
  Literal(value: LiteralAstNode)
  Unary(op: UnaryOp, expr: TypedAstNode)
  Binary(left: TypedAstNode, op: BinaryOp, right: TypedAstNode)
  Grouped(inner: TypedAstNode)
  Identifier(kind: TypedIdentifierKind)
  Accessor(head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment)
  Invocation(invokee: TypedInvokee, arguments: TypedAstNode?[])
  Array(items: TypedAstNode[])
  Set(items: TypedAstNode[])
  Map(items: (TypedAstNode, TypedAstNode)[])
  Tuple(items: TypedAstNode[])
  Indexing(node: TypedIndexingNode)
  Lambda(fn: Function)
  Assignment(mode: TypedAssignmentMode, op: AssignOp, expr: TypedAstNode)
  If(isStatement: Bool, typedCondition: TypedAstNode, conditionBinding: (BindingPattern, Variable[])?, typedIfBlock: TypedAstNode[], typedElseBlock: TypedAstNode[])
  While(typedCondition: TypedAstNode, conditionBinding: (BindingPattern, Variable[])?, block: TypedAstNode[])
  For(typedIterator: TypedAstNode, itemBinding: (BindingPattern, Variable[]), indexBinding: Variable?, block: TypedAstNode[])
  BindingDeclaration(node: TypedBindingDeclarationNode)
  FunctionDeclaration(fn: Function)
  TypeDeclaration(struct: Struct)
  EnumDeclaration(enum_: Enum)
  Break
  Continue
  Return(expr: TypedAstNode?)

  Placeholder
}

export enum AccessorPathSegment {
  EnumVariant(label: Label, enum_: Enum, variant: TypedEnumVariant)
  Method(label: Label, fn: Function)
  Field(label: Label, f: Field)
}

type TypecheckerError {
  modulePath: String
  kind: TypecheckerErrorKind

  func getMessage(self): String {
    match self.kind {
      // TODO: Better error message, once imports are a thing
      TypecheckerErrorKind.ReadFileError(path) => "Could not read file '$path'"
      TypecheckerErrorKind.LexerError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.ParseError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
      TypecheckerErrorKind.TypeError(inner) => {
        val contents = match fs.readFile(self.modulePath) {
          Result.Ok(v) => v
          Result.Err => return "Could not read file '${self.modulePath}'"
        }
        inner.getMessage(self.modulePath, contents)
      }
    }
  }
}

enum TypecheckerErrorKind {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
  TypeError(inner: TypeError)
}

type TypeError {
  position: Position
  kind: TypeErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      TypeErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      TypeErrorKind.Unreachable(message) => {
        lines.push("Unreachable code reached")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Internal error: $message")
      }
      TypeErrorKind.TypeMismatch(expected, received) => {
        lines.push("Type mismatch")
        lines.push(self._getCursorLine(self.position, contents))

        val expectedReprs = expected.map(t => t.repr()).join(", ")
        if expected.length == 1 {
          lines.push("Expected: " + expectedReprs)
        } else {
          lines.push("Expected one of: " + expectedReprs)
        }
        lines.push("but instead found: " + received.repr())
      }
      TypeErrorKind.DuplicateName(original) => {
        lines.push("Duplicate name '${original.name}'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This name is also declared at (${original.position.line}:${original.position.col})")
        lines.push(self._getCursorLine(original.position, contents))
      }
      TypeErrorKind.UnknownName(name, kind) => {
        lines.push("Unknown $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        if name == "_" {
          lines.push("The '_' identifier is a special name used to discard values, and it cannot be referenced")
        } else {
          lines.push("No $kind with that name is visible in current scope")
        }
      }
      TypeErrorKind.UnknownField(ty, name, specialCase) => {
        lines.push("Unknown field '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        match ty.kind {
          TypeKind.Func => lines.push("Functions don't have any fields or methods")
          _ => {
            match specialCase {
              UnknownFieldSpecialCase.ExistsButTypeIsNullable => {
                if ty.nullable {
                  val nonNullableVersion = Type(kind: ty.kind, nullable: false)
                  lines.push("Type '${nonNullableVersion.repr()}' has field '$name', but lhs is of type '${ty.repr()}'")
                } else {
                  val nullableVersion = Type(kind: ty.kind, nullable: true)
                  lines.push("Type '${ty.repr()}' has field '$name', but lhs here is of type '${nullableVersion.repr()}' due to prior '?.'")
                }
                lines.push("(You can use the '?.' operator instead of '.')")
              }
              UnknownFieldSpecialCase.StaticFieldReferencedAsInstance => {
                lines.push("No field '$name' found on instance of type ${ty.repr()}")
                lines.push("'$name' is a static member of ${ty.repr()}, did you mean to write ${ty.repr()}.$name?")
              }
              None =>  {
                lines.push("No field '$name' found on type ${ty.repr()}")
              }
            }
          }
        }
      }
      TypeErrorKind.MissingValExpr(name) => {
        lines.push("Missing initializer for immutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.MissingVarExprAndTypeAnn(name) => {
        lines.push("Could not determine type of mutable variable '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("A 'var' must have either an initial value or a type annotation (or both)")
      }
      TypeErrorKind.IllegalValueType(ty, purpose) => {
        match ty.kind {
          TypeKind.PrimitiveUnit => {
            lines.push("Forbidden type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Instances of type ${ty.repr()} cannot be used as $purpose values")
          }
          TypeKind.Never => {
            lines.push("Forbidden type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Expression has type ${ty.repr()}, which can never be used for $purpose")
          }
          TypeKind.Type => {
            lines.push("Forbidden type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Expression has type ${ty.repr()}, which cannot be used as a value")
          }
          TypeKind.Instance(structOrEnum, _) => {
            match structOrEnum {
              StructOrEnum.Enum => {
                lines.push("Forbidden type for $purpose")
                lines.push(self._getCursorLine(self.position, contents))
                lines.push("This enum variant is non-constant and must be constructed")
              }
              // TODO: This is duplicated below, I should be able to match on `TypeKind.Instance(StructOrEnum.Enum, _)` to avoid this duplication
              _ => {
                lines.push("Could not determine type for $purpose")
                lines.push(self._getCursorLine(self.position, contents))
                lines.push("Type '${ty.repr()}' has unfilled holes. Please use an explicit type annotation to denote the type")
              }
            }
          }
          _ => {
            lines.push("Could not determine type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Type '${ty.repr()}' has unfilled holes. Please use an explicit type annotation to denote the type")
          }
        }
      }
      TypeErrorKind.IllegalControlFlowType(ty, purpose) => {
        if purpose == "if" || purpose == "while" {
          lines.push("Forbidden type for $purpose-condition")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Conditions must either be Bool or Option types")
          lines.push("but instead found " + ty.repr())
        } else if purpose == "for" {
          lines.push("Forbidden type for for-loop target")
          lines.push(self._getCursorLine(self.position, contents))
          if ty.hasUnfilledHoles() {
            lines.push("Type '${ty.repr()}' has unfilled holes")
          } else {
            lines.push("Type ${ty.repr()} is not iterable")
          }
        }
      }
      TypeErrorKind.MissingRequiredIfExprBlock(clause, missing) => {
        lines.push("Incomplete if-expression")
        lines.push(self._getCursorLine(self.position, contents))
        if missing {
          lines.push("The $clause-block must exist and contain a value")
        } else {
          lines.push("The $clause-block must contain a value")
        }
      }
      TypeErrorKind.DuplicateParameter(name) => {
        lines.push("Duplicate parameter '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.InvalidParamPosition(purpose) => {
        match purpose {
          "vararg" => {
            lines.push("Invalid location for variadic parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Variadic parameters must be the last in the parameter list")
          }
          "required" => {
            lines.push("Invalid location for required parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Required parameters must all be listed before any optional parameters")
          }
          "self" => {
            lines.push("Invalid usage of `self` parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("`self` can only appear within methods on types")
          }
          _ => { /* no other cases */ }
        }
      }
      TypeErrorKind.InvalidVarargType(ty) => {
        lines.push("Invalid type for vararg parameter")
        lines.push(self._getCursorLine(self.position, contents))
        if ty.nullable {
          lines.push("Vararg parameters must be a non-Option Array type, but got ${ty.repr()}")
        } else {
          lines.push("Vararg parameters must be an Array type, but got ${ty.repr()}")
        }
      }
      TypeErrorKind.ReturnTypeMismatch(fnName, expected, received) => {
        if fnName |name| {
          lines.push("Return type mismatch for function '$name'")
        } else {
          lines.push("Return type mismatch for lambda function")
        }

        lines.push(self._getCursorLine(self.position, contents))

        lines.push("Expected ${expected.repr()}")
        if received |received| {
          lines.push("but instead found ${received.repr()}")
        } else {
          lines.push("but function had empty body")
        }
      }
      TypeErrorKind.InvalidTerminatorPosition(terminator) => {
        lines.push("Invalid location for $terminator statement")
        lines.push(self._getCursorLine(self.position, contents))
        match terminator {
          "return" => lines.push("Return statements can only be used within function bodies")
          "break" => lines.push("Break statements can only be used within loop bodies")
          "continue" => lines.push("Continue statements can only be used within loop bodies")
          _ => { /* unreachable */ }
        }
      }
      TypeErrorKind.UnreachableCode => {
        lines.push("Unreachable code")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Control flow exits before this code is reached")
      }
      TypeErrorKind.WrongInvocationArity(expected, given) => {
        val argumentsStr = if expected == 1 "argument" else "arguments"
        val verbStr = if given == 1 "was" else "were"

        if given > expected {
          lines.push("Too many arguments for invocation")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Expected no more than $expected $argumentsStr, but $given $verbStr passed")
        } else {
          lines.push("Not enough arguments for invocation")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("$expected $argumentsStr required, but $given $verbStr passed")
        }
      }
      TypeErrorKind.ParameterLabelMismatch(expected, given) => {
        lines.push("Incorrect label for parameter")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The parameter's name is '$expected', but instead found '$given'")
      }
      TypeErrorKind.IllegalParameterLabel => {
        lines.push("Incorrect use of label for parameter")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Parameter labels are not allowed here because parameters' names cannot be determined")
      }
      TypeErrorKind.MixedArgumentType(label) => {
        lines.push("Cannot mix labeled and positional optional arguments")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This argument requires a label because a prior optional parameter has been labeled:")
        lines.push(self._getCursorLine(label.position, contents))
        lines.push("(Optional parameters may be listed positionally until a label is encountered. After that point, parameter values cannot be unambiguously determined without labels)")
      }
      TypeErrorKind.MissingRequiredArgumentLabel => {
        lines.push("Invalid instantiation")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Calls of type constructors must include argument labels")
      }
      TypeErrorKind.MissingRequiredFields(names) => {
        lines.push("Invalid instantiation")
        lines.push(self._getCursorLine(self.position, contents))

        val maxToShow = 3
        val missing = names[:maxToShow].map(n => "'$n'")
        if names.length > maxToShow {
          missing.push("and ${names.length - maxToShow} more")
        }
        lines.push("The following required fields are missing: ${missing.join(", ")}")
      }
      TypeErrorKind.UnknownParameterName(name) => {
        lines.push("Unknown parameter label")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This function doesn't have a parameter named '$name'")
      }
      TypeErrorKind.UnknownParameterType(name) => {
        lines.push("Could not determine type for parameter '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Consider adding a type annotation")
      }
      TypeErrorKind.ParameterTypeMismatch(name, expected, given) => {
        if name |name| {
          lines.push("Type mismatch for parameter '$name'")
        } else {
          lines.push("Type mismatch for parameter")
        }
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Expected: ${expected.repr()}")
        lines.push("but instead found: ${given.repr()}")
      }
      TypeErrorKind.IllegalCallableType(ty) => {
        lines.push("Cannot invoke target as function")
        lines.push(self._getCursorLine(self.position, contents))
        match ty.kind {
          TypeKind.Instance(structOrEnum) => {
            match structOrEnum {
              StructOrEnum.Enum => lines.push("This is a constant enum variant, and it accepts no arguments")
              _ => {
                // pseudo-assert
                println("This should be unreachable")
              }
            }
          }
          _ => lines.push("Type '${ty.repr()}' is not callable")
        }
      }
      TypeErrorKind.WrongTypeArgumentArity(expected, given) => {
        val verbStr = if given == 1 "was" else "were"

        lines.push("Incorrect number of type arguments")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Expected $expected, but $given $verbStr passed")
      }
      TypeErrorKind.NoSuchOperator(leftTy, op, rightTy) => {
        lines.push("Illegal operator")
        lines.push(self._getCursorLine(self.position, contents))
        if op == BinaryOp.Coalesce && !leftTy.nullable {
          val nullableVersion = Type(kind: leftTy.kind, nullable: true)
          lines.push("The '${op.repr()}' operator can only be used on an Option type")
          lines.push("(The lhs value's type here is ${leftTy.repr()}, not ${nullableVersion.repr()})")
        } else {
          lines.push("No operator '${op.repr()}' exists between types ${leftTy.repr()} and ${rightTy.repr()}")
        }
      }
      TypeErrorKind.IllegalIndexableType(ty, isRange) => {
        lines.push("Unsupported indexing operation")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Type '${ty.repr()}' is not indexable" + if isRange " as a range" else "")
      }
      TypeErrorKind.IllegalTupleIndexing(ty, reason) => {
        lines.push("Unsupported tuple indexing operation")
        lines.push(self._getCursorLine(self.position, contents))
        match reason {
          IllegalTupleIndexingReason.IndexOutOfBounds => {
            lines.push("No value at index for tuple of type '${ty.repr()}'")
            match ty.kind {
              TypeKind.Tuple(types) => lines.push("(Valid index values are from 0-${types.length - 1}, inclusive)")
              _ => println("The type here should always be a tuple")
            }
          }
          IllegalTupleIndexingReason.IndexNegative => {
            lines.push("Tuple index values must always be a non-negative integer")
            match ty.kind {
              TypeKind.Tuple(types) => lines.push("(Valid index values are from 0-${types.length - 1}, inclusive)")
              _ => println("The type here should always be a tuple")
            }
          }
          IllegalTupleIndexingReason.NotIntLiteral => lines.push("Cannot use non-Int literal as index value. Tuple index values must always be Int literals")
          IllegalTupleIndexingReason.NotLiteralNode => lines.push("Cannot use this expression as index value. Tuple index values must always be Int literals")
        }
      }
      TypeErrorKind.UnnecessaryOptSafety => {
        lines.push("Unnecessary use of '?.' operator")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("(The lhs value's type here is known to be a non-Option type)")
      }
      TypeErrorKind.InvalidTraitMethodSignature(givenFn) => {
        lines.push("Invalid signature for method '${givenFn.label.name}'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.IllegalAssignment(kind, name, reason) => {
        lines.push("Cannot assign to $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        match reason {
          IllegalAssignmentReason.ImmutableVariable => lines.push("'$name' is declared as immutable")
          IllegalAssignmentReason.TypeAlias => lines.push("'$name' is a type, which cannot be overwritten")
          IllegalAssignmentReason.FunctionAlias => lines.push("'$name' is a function, which cannot be overwritten")
          IllegalAssignmentReason.EnumVariant => lines.push("'$name' is an enum variant, which cannot be overwritten")
          IllegalAssignmentReason.Method => lines.push("'$name' is a method, which cannot be overwritten")
          IllegalAssignmentReason.StaticMethod => lines.push("'$name' is a static method, which cannot be overwritten")
        }
      }
      TypeErrorKind.UnknownModule(modulePath, isRelativeImport) => {
        lines.push("Could not import module")
        lines.push(self._getCursorLine(self.position, contents))
        if isRelativeImport {
          lines.push("No file exists at path '$modulePath'")
        } else {
          lines.push("Could not find module named '$modulePath'")
        }
      }
      TypeErrorKind.CircularDependency => {
        lines.push("Could not import module due to circular dependency")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The current module is imported by the imported module (or one of its imports), resulting in a cycle")
      }
      TypeErrorKind.IllegalExportScope => {
        lines.push("Invalid export modifier")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Exported values may only appear at the top level scope in a module")
      }
      TypeErrorKind.UnknownImport(moduleName, importName) => {
        lines.push("Invalid import")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("There's no exported value named '$importName' in module '$moduleName'")
      }
      TypeErrorKind.UnknownImportForAlias(importName, alias) => {
        lines.push("Unknown exported name for aliased module")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("There's no exported value named '$importName' in module aliased as '${alias.name}' at:")
        lines.push(self._getCursorLine(alias.position, contents))
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      "unreachable"
    }
  }
}

enum UnknownFieldSpecialCase {
  ExistsButTypeIsNullable
  StaticFieldReferencedAsInstance
}

enum IllegalTupleIndexingReason {
  IndexOutOfBounds
  IndexNegative
  NotIntLiteral
  NotLiteralNode
}

enum IllegalAssignmentReason {
  ImmutableVariable
  TypeAlias
  FunctionAlias
  EnumVariant
  Method
  StaticMethod
}

enum TypeErrorKind {
  NotYetImplemented(reason: String)
  Unreachable(message: String)
  TypeMismatch(expected: Type[], received: Type)
  DuplicateName(original: Label)
  UnknownName(name: String, kind: String)
  UnknownField(ty: Type, name: String, specialCase: UnknownFieldSpecialCase?)
  MissingValExpr(name: String)
  MissingVarExprAndTypeAnn(name: String)
  IllegalValueType(ty: Type, purpose: String)
  IllegalControlFlowType(ty: Type, purpose: String)
  MissingRequiredIfExprBlock(clause: String, missing: Bool)
  InvalidParamPosition(purpose: String)
  DuplicateParameter(name: String)
  InvalidVarargType(ty: Type)
  ReturnTypeMismatch(fnName: String?, expected: Type, received: Type?)
  InvalidTerminatorPosition(terminator: String)
  UnreachableCode
  WrongInvocationArity(expected: Int, given: Int)
  ParameterLabelMismatch(expected: String, given: String)
  IllegalParameterLabel
  MixedArgumentType(label: Label)
  MissingRequiredArgumentLabel
  MissingRequiredFields(names: String[])
  UnknownParameterName(name: String)
  UnknownParameterType(name: String)
  ParameterTypeMismatch(name: String?, expected: Type, given: Type)
  IllegalCallableType(ty: Type)
  WrongTypeArgumentArity(expected: Int, given: Int)
  NoSuchOperator(leftTy: Type, op: BinaryOp, rightTy: Type)
  IllegalIndexableType(ty: Type, isRange: Bool)
  IllegalTupleIndexing(ty: Type, reason: IllegalTupleIndexingReason)
  UnnecessaryOptSafety
  InvalidTraitMethodSignature(fn: Function)
  IllegalAssignment(kind: String, name: String, reason: IllegalAssignmentReason)
  UnknownModule(modulePath: String, isRelativeImport: Bool)
  CircularDependency
  IllegalExportScope
  UnknownImport(moduleName: String, importName: String)
  UnknownImportForAlias(importName: String, alias: Label)
}

type ParamDefaultValueContext {
  exprContainsFunctionCall: Bool = false
  exprContainsVariableRef: Bool = false
}

export type Typechecker {
  moduleLoader: ModuleLoader
  project: Project
  currentModuleId: Int = -1
  currentModuleExports: Map<String, Export> = {} // TODO: this is a little gross, could we instead track the currentModule?
  currentModuleImports: Map<String, ImportedModule> = {} // TODO: see above todo
  currentScope: Scope = Scope(name: "\$root")
  currentTypeDecl: StructOrEnum? = None
  currentFunction: Function? = None
  paramDefaultValueContext: ParamDefaultValueContext? = None
  isStructOrEnumValueAllowed: Bool = false
  isEnumContainerValueAllowed: Bool = false

  func typecheckEntrypoint(self, modulePathAbs: String): Result<Int, TypecheckerError> {
    val preludeModulePathSegs = getAbsolutePath(self.moduleLoader.stdRoot + "/prelude.abra")
    val preludeModulePathAbs = "/" + preludeModulePathSegs.join("/")
    match self._typecheckModule(preludeModulePathAbs) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val preludeStructs = [
      self.project.preludeIntStruct,
      self.project.preludeFloatStruct,
      self.project.preludeBoolStruct,
      self.project.preludeStringStruct,
      self.project.preludeArrayStruct,
      self.project.preludeMapStruct,
      self.project.preludeSetStruct,
    ]
    for struct in preludeStructs {
      if struct.label.position == Position(line: 0, col: 0) {
        val message = "Improperly initialized prelude struct ${struct.label.name}"
        val err = TypeError(position: struct.label.position, kind: TypeErrorKind.Unreachable(message))
        return Result.Err(TypecheckerError(modulePath: preludeModulePathAbs, kind: TypecheckerErrorKind.TypeError(err)))
      }
    }

    match self._typecheckModule(modulePathAbs) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(0)
  }

  func _tokenizeAndParse(self, modulePathAbs: String): Result<ParsedModule, TypecheckerError> {
    match self.moduleLoader.tokenizeAndParse(modulePathAbs) {
      Result.Ok(mod) => Result.Ok(mod)
      Result.Err(e) => {
        val kind = match e {
          TokenizeAndParseError.ReadFileError(path) => TypecheckerErrorKind.ReadFileError(path)
          TokenizeAndParseError.LexerError(inner) => TypecheckerErrorKind.LexerError(inner)
          TokenizeAndParseError.ParseError(inner) => TypecheckerErrorKind.ParseError(inner)
        }

        return Result.Err(TypecheckerError(modulePath: modulePathAbs, kind: kind))
      }
    }
  }

  func _verifyNameUniqueInScope(self, label: Label, scope: Scope): TypeError? {
    for importedModule in self.currentModuleImports.values() {
      for alias in importedModule.aliases {
        if alias.name == label.name {
          return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: alias))
        }
      }
      for _p in importedModule.imports {
        // TODO: destructuring
        val name = _p[0]
        val imp = _p[1]
        if name == label.name {
          return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: imp.label))
        }
      }
    }

    for v in scope.variables {
      if v.label.name == label.name {
        return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: v.label))
      }
    }

    for f in scope.functions {
      if f.label.name == label.name {
        return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: f.label))
      }
    }

    for s in scope.structs {
      if s.label.name == label.name {
        return TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: s.label))
      }
    }

    None
  }

  func _addVariableToScope(self, variable: Variable, scope = self.currentScope): Result<Int, TypeError> {
    if variable.label.name == "_" return Result.Ok(0) // <- unnecessary 0

    if self._verifyNameUniqueInScope(variable.label, scope) |e| return Result.Err(e)
    scope.variables.push(variable)

    Result.Ok(0) // <- unnecessary 0
  }

  func _addFunctionToScope(self, fn: Function, scope = self.currentScope): Result<Int, TypeError> {
    if self._verifyNameUniqueInScope(fn.label, scope) |e| return Result.Err(e)
    scope.functions.push(fn)

    Result.Ok(0) // <- unnecessary 0
  }

  func _addStructToScope(self, struct: Struct, isExported: Bool, scope = self.currentScope): Result<Int, TypeError> {
    val structTy = Type(kind: TypeKind.Type(type_: StructOrEnum.Struct(struct)))
    match self._addTypeToScope(structTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val variable = Variable(label: struct.label, mutable: false, ty: structTy, alias: VariableAlias.Struct(struct))
    match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    scope.structs.push(struct)

    if isExported {
      variable.isExported = true
      self.currentModuleExports[struct.label.name] = Export.Type(StructOrEnum.Struct(struct), variable)
    }

    Result.Ok(0) // <- unnecessary 0
  }

  func _addEnumToScope(self, enum_: Enum, isExported: Bool, scope = self.currentScope): Result<Int, TypeError> {
    val enumTy = Type(kind: TypeKind.Type(type_: StructOrEnum.Enum(enum_)))
    match self._addTypeToScope(enumTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val variable = Variable(label: enum_.label, mutable: false, ty: enumTy, alias: VariableAlias.Enum(enum_))
    match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    scope.enums.push(enum_)

    if isExported {
      variable.isExported = true
      self.currentModuleExports[enum_.label.name] = Export.Type(StructOrEnum.Enum(enum_), variable)
    }

    Result.Ok(0) // <- unnecessary 0
  }

  func _addTypeToScope(self, ty: Type, scope = self.currentScope): Result<Int, TypeError> {
    scope.types.push(ty)

    Result.Ok(0) // <- unnecessary 0
  }

  func _findModuleByAlias(self, name: String): Result<(TypedModule, Label)?, TypeError> {
    for _m in self.currentModuleImports {
      // TODO: destructuring
      val importModulePath = _m[0]
      val importedModule = _m[1]
      if importedModule.aliases.find(a => a.name == name) |alias| {
        val mod = if self.project.modules[importModulePath] |m| m else return unreachable(alias.position, "unknown module")
        return Result.Ok((mod, alias))
      }
    }

    Result.Ok(None)
  }

  func _verifyNumTypeArgs(self, position: Position, typeArguments: TypeIdentifier[], num: Int): Result<Type[], TypeError> {
    if typeArguments.length != num {
      return Result.Err(TypeError(position: position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: num, given: typeArguments.length)))
    }

    val types: Type[] = []
    for i in range(0, num) {
      val typeIdent = if typeArguments.get(i) |typeIdent| typeIdent else return unreachable(position, "verified above that typeArguments.length == num")
      val ty = match self._resolveTypeIdentifier(typeIdent) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      types.push(ty)
    }

    Result.Ok(types)
  }

  func _resolveInstanceTypeIdentifier(self, structOrEnum: StructOrEnum, label: Label, typeArguments: TypeIdentifier[]): Result<Type?, TypeError> {
    match structOrEnum {
      StructOrEnum.Struct(struct) => {
        if label.name == struct.label.name {
          val instanceTypeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, struct.typeParams.length) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          return Result.Ok(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), instanceTypeArgs)))
        }
      }
      StructOrEnum.Enum(enum_) => {
        if label.name == enum_.label.name {
          val instanceTypeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, enum_.typeParams.length) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          return Result.Ok(Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), instanceTypeArgs)))
        }
      }
    }

    Result.Ok(None)
  }

  func _resolveTypeIdentifier(self, typeIdent: TypeIdentifier): Result<Type, TypeError> {
    val ty = match typeIdent {
      TypeIdentifier.Normal(label, typeArguments, path) => {
        if path[0] |firstSeg| {
          val _mod = match self._findModuleByAlias(firstSeg.name) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          val _m = if _mod |mod| mod else return Result.Err(TypeError(position: firstSeg.position, kind: TypeErrorKind.UnknownName(firstSeg.name, "module")))
          // TODO: destructuring
          val mod = _m[0]
          val aliasLabel = _m[1]

          if path[1] |seg| return todo(seg.position, "qualified type paths longer than 2")

          val foundTy = match mod.exports[label.name] {
            None => return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownImportForAlias(label.name, aliasLabel)))
            Export.Type(structOrEnum) => {
              val t = match self._resolveInstanceTypeIdentifier(structOrEnum, label, typeArguments) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
              t
            }
            _ => None
          }

          // TODO: clean this up, it's gross
          val res: Result<Type, TypeError> = if foundTy |ty|
            Result.Ok(ty)
          else
            Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
          return res
        }

        val t = match label.name {
          "Any" => {
            match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            Type(kind: TypeKind.Any)
          }
          "Unit" => {
            match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            Type(kind: TypeKind.PrimitiveUnit)
          }
          "Int" => {
            match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            Type(kind: TypeKind.PrimitiveInt)
          }
          "Float" => {
            match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            Type(kind: TypeKind.PrimitiveFloat)
          }
          "Bool" => {
            match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            Type(kind: TypeKind.PrimitiveBool)
          }
          "String" => {
            match self._verifyNumTypeArgs(label.position, typeArguments, 0) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            Type(kind: TypeKind.PrimitiveString)
          }
          "Map" => {
            val typeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, 2) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeMapStruct), typeArgs))
          }
          "Set" => {
            val typeArgs = match self._verifyNumTypeArgs(label.position, typeArguments, 1) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeSetStruct), typeArgs))
          }
          _ => {
            var scope: Scope? = self.currentScope
            while scope |sc| {
              for ty in sc.types {
                match ty.kind {
                  TypeKind.Generic(name) => { if label.name == name return Result.Ok(ty.clone()) }
                  TypeKind.Type(structOrEnum) => {
                    val foundTy = match self._resolveInstanceTypeIdentifier(structOrEnum, label, typeArguments) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
                    if foundTy |ty| return Result.Ok(ty)
                  }
                  _ => continue
                }
              }
              scope = sc.parent
            }

            for importedModule in self.currentModuleImports.values() {
              for _p in importedModule.imports {
                // TODO: destructuring
                val name = _p[0]
                val imp = _p[1]
                if name == label.name {
                  match imp.kind {
                    TypedImportKind.Type(structOrEnum) => {
                      val foundTy = match self._resolveInstanceTypeIdentifier(structOrEnum, label, typeArguments) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
                      if foundTy |ty| return Result.Ok(ty)
                    }
                    _ => continue
                  }
                }
              }
            }

            return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
          }
        }
        t
      }
      TypeIdentifier.Array(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [innerTy]))
      }
      TypeIdentifier.Option(inner) => {
        val innerTy = match self._resolveTypeIdentifier(inner) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        innerTy.nullable = true
        innerTy
      }
      TypeIdentifier.Tuple(typeIdents) => {
        val types: Type[] = []
        for typeIdent in typeIdents {
          val ty = match self._resolveTypeIdentifier(typeIdent) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          types.push(ty)
        }

        Type(kind: TypeKind.Tuple(types))
      }
      TypeIdentifier.Function(params, ret) => {
        val paramTypes: (Type, Bool)[] = []
        for p in params {
          val t = match self._resolveTypeIdentifier(p) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          paramTypes.push((t, true))
        }

        val returnType = match self._resolveTypeIdentifier(ret) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Type(kind: TypeKind.Func(paramTypes, returnType))
      }
    }

    Result.Ok(ty)
  }

  func _resolveIdentifier(self, ident: String): Variable? {
    var scope: Scope? = self.currentScope
    while scope |s| {
      for v in s.variables {
        if v.label.name == ident return v
      }
      scope = s.parent
    }

    var foundVar: Variable? = None
    for importedModule in self.currentModuleImports.values() {
      for _p in importedModule.imports {
        // TODO: destructuring
        val importedName = _p[0]
        val importedValue = _p[1]
        if importedName == ident {
          // TODO: this is inefficient
          match importedValue.kind {
            TypedImportKind.Variable(v) => foundVar = v
            TypedImportKind.Function(aliasVar) => foundVar = aliasVar
            TypedImportKind.Type(_, aliasVar) => foundVar = aliasVar
          }
        }
      }

      if foundVar break
    }

    foundVar
  }

  func _typeSatisfiesRequired(self, ty: Type, required: Type): Bool {
    if ty.nullable && !required.nullable return false

    if required.kind == TypeKind.Hole return true
    if required.kind == TypeKind.Never || ty.kind == TypeKind.Never return true
    if required.kind == TypeKind.Any return true

    match required.kind {
      TypeKind.PrimitiveInt => match ty.kind {
        TypeKind.PrimitiveInt => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeIntStruct)
        _ => false
      }
      TypeKind.PrimitiveFloat => match ty.kind {
        TypeKind.PrimitiveFloat => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeFloatStruct)
        _ => false
      }
      TypeKind.PrimitiveBool => match ty.kind {
        TypeKind.PrimitiveBool => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeBoolStruct)
        _ => false
      }
      TypeKind.PrimitiveString => match ty.kind {
        TypeKind.PrimitiveString => true
        TypeKind.Instance(structOrEnum, _) => structOrEnum == StructOrEnum.Struct(self.project.preludeStringStruct)
        _ => false
      }
      TypeKind.Func(reqParamTypes, reqRetType) => match ty.kind {
        TypeKind.Func(paramTypes, retType) => {
          if !self._typeSatisfiesRequired(ty: retType, required: reqRetType) return false

          var idx = 0
          for reqParamType, i in reqParamTypes {
            val paramType = if paramTypes[i] |t| t[0] else { return true }
            if !self._typeSatisfiesRequired(ty: paramType, required: reqParamType[0]) return false

            idx = i
          }
          if paramTypes[idx + 1] |nextParam| {
            if nextParam[1] return false
          }

          true
        }
        _ => false
      }
      TypeKind.Instance(reqStructOrEnum, reqTypeArgs) => match ty.kind {
        TypeKind.Instance(structOrEnum, typeArgs) => {
          if reqStructOrEnum != structOrEnum return false

          if reqTypeArgs.length != typeArgs.length return false
          for reqTypeArg, i in reqTypeArgs {
            val typeArg = if typeArgs[i] |t| t else { return true }
            if !self._typeSatisfiesRequired(ty: typeArg, required: reqTypeArg) return false
          }

          true
        }
        TypeKind.PrimitiveInt => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeIntStruct)
        TypeKind.PrimitiveFloat => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeFloatStruct)
        TypeKind.PrimitiveBool => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeBoolStruct)
        TypeKind.PrimitiveString => reqStructOrEnum == StructOrEnum.Struct(self.project.preludeStringStruct)
        _ => false
      }
      TypeKind.Tuple(reqTypes) => match ty.kind {
        TypeKind.Tuple(types) => {
          if reqTypes.length != types.length return false
          for reqTy, i in reqTypes {
            val ty = if types[i] |t| t else { /* unreachable, length verified above to be equal */ return false }
            if !self._typeSatisfiesRequired(ty: ty, required: reqTy) return false
          }

          true
        }
        _ => false
      }
      _ => {
        ty.kind == required.kind
      }
    }
  }

  func _containsGenerics(self, ty: Type): Bool {
    match ty.kind {
      TypeKind.Generic(name) => true
      TypeKind.Instance(_, typeArgs) => typeArgs.any(t => self._containsGenerics(t))
      TypeKind.Tuple(typeArgs) => typeArgs.any(t => self._containsGenerics(t))
      TypeKind.Func(paramTypes, returnType) => {
        if self._containsGenerics(returnType) return true

        paramTypes.any(p => self._containsGenerics(p[0]))
      }
      _ => false
    }
  }

  func __extractGenerics(self, template: Type, source: Type, extracted: (String, Type)[]) {
    match template.kind {
      TypeKind.Generic(name) => {
        extracted.push((name, source))
      }
      TypeKind.Instance(_, templateTypeArgs) => {
        match source.kind {
          TypeKind.Instance(_, sourceTypeArgs) => {
            if templateTypeArgs.length != sourceTypeArgs.length {
              // There's currently no notion of asserts, but this will show up in output files and fail tests so it won't go unnoticed.
              println("templateTypeArgs.length != sourceTypeArgs.length")
              return
            }
            for tplTypeArg, idx in templateTypeArgs {
              val srcTypeArg = if sourceTypeArgs[idx] |t| t else {
                println("templateTypeArgs.length != sourceTypeArgs.length")
                return
              }
              self.__extractGenerics(template: tplTypeArg, source: srcTypeArg, extracted: extracted)
            }
          }
          _ => {}
        }
      }
      TypeKind.Tuple(templateTypes) => {
        match source.kind {
          TypeKind.Tuple(sourceTypes) => {
            for tplType, idx in templateTypes {
              val srcType = if sourceTypes[idx] |t| t else break
              self.__extractGenerics(template: tplType, source: srcType, extracted: extracted)
            }
          }
          _ => {}
        }
      }
      TypeKind.Func(templateParamTypes, templateReturnType) => {
        match source.kind {
          TypeKind.Func(sourceParamTypes, sourceReturnType) => {
            self.__extractGenerics(template: templateReturnType, source: sourceReturnType, extracted: extracted)

            for tplParamType, idx in templateParamTypes {
              val srcParamType = if sourceParamTypes[idx] |t| t else break
              self.__extractGenerics(template: tplParamType[0], source: srcParamType[0], extracted: extracted)
            }
          }
          _ => {}
        }
      }
      _ => {}
    }
  }

  func _extractGenerics(self, template: Type, source: Type): (String, Type)[] {
    val extracted: (String, Type)[] = []
    self.__extractGenerics(template, source, extracted)
    extracted
  }

  func _genericsInScope(self): Set<String> {
    val genericsInScope: Set<String> = #{}
    if self.currentFunction |fn| {
      for _p in fn.typeParams {
        match _p[0].kind {
          TypeKind.Generic(name) => genericsInScope.insert(name)
          _ => {
            // pseudo-assert
            println("typeParam.kind != TypeKind.Generic")
            return #{}
          }
        }
      }

      if fn.kind == FunctionKind.InstanceMethod {
        if self.currentTypeDecl |typeDecl| {
          val genericNames = match typeDecl {
            StructOrEnum.Struct(struct) => struct.typeParams,
            StructOrEnum.Enum(enum_) => enum_.typeParams,
          }
          for name in genericNames {
            genericsInScope.insert(name)
          }
        }
      }
    }

    genericsInScope
  }

  func _typeAsInstance1(self, ty: Type, struct: Struct): Type? {
    match ty.kind {
      TypeKind.Instance(s, generics) => if s == StructOrEnum.Struct(struct) { generics[0] } else None
      _ => None
    }
  }

  func _typeAsInstance2(self, ty: Type, struct: Struct): (Type, Type)? {
    match ty.kind {
      TypeKind.Instance(s, generics) => if s == StructOrEnum.Struct(struct) {
        if generics[0] |g1| (if generics[1] |g2| (g1, g2) else None) else None
      } else None
      _ => None
    }
  }

  func _ensureValidExportScope(self, exportToken: Token): Result<Int, TypeError> {
    if self.currentScope.kind != ScopeKind.Module {
      Result.Err(TypeError(position: exportToken.position, kind: TypeErrorKind.IllegalExportScope))
    } else {
      Result.Ok(0) // <-- unnecessary int
    }
  }

  func _typecheckModule(self, modulePathAbs: String): Result<TypedModule, TypecheckerError> {
    val moduleId = self.project.modules.size
    self.currentModuleId = moduleId

    val moduleScope = self.currentScope.makeChild("module_$moduleId", ScopeKind.Module)
    if moduleId == 0 {
      self.project.preludeScope = moduleScope
    }
    val prevScope = self.currentScope
    self.currentScope = moduleScope
    val mod = TypedModule(id: moduleId, name: modulePathAbs, code: [], rootScope: moduleScope)
    self.project.modules[modulePathAbs] = mod

    val parsedModule = match self._tokenizeAndParse(modulePathAbs) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    for importNode in parsedModule.imports {
      var importNodePath = importNode.moduleName.name
      val isRelativeImport = importNodePath.startsWith(".")
      if !importNodePath.endsWith(".abra") importNodePath += ".abra"

      val importPathAbs = if !isRelativeImport {
        self.moduleLoader.stdRoot + "/" + importNodePath
      } else {
        self.moduleLoader.resolvePath(modulePath: importNodePath, relativeTo: modulePathAbs)
      }

      val typedImportModule = if self.project.modules[importPathAbs] |m| {
        if !m.complete {
          val err = TypeError(position: importNode.moduleName.position, kind: TypeErrorKind.CircularDependency)
          return Result.Err(TypecheckerError(modulePath: modulePathAbs, kind: TypecheckerErrorKind.TypeError(err)))
        }

        m
      } else {
        val childTypechecker = Typechecker(moduleLoader: self.moduleLoader, project: self.project)
        val typedImportModule = match childTypechecker._typecheckModule(importPathAbs) {
          Result.Ok(m) => m
          Result.Err(e) => {
            val err = match e.kind {
              TypecheckerErrorKind.ReadFileError => {
                val kind = if isRelativeImport {
                  TypeErrorKind.UnknownModule(importPathAbs, true)
                } else {
                  TypeErrorKind.UnknownModule(importNode.moduleName.name, false)
                }

                val err = TypeError(position: importNode.moduleName.position, kind: kind)
                TypecheckerError(modulePath: modulePathAbs, kind: TypecheckerErrorKind.TypeError(err))
              }
              _ => e
            }

            return Result.Err(err)
          }
        }

        typedImportModule
      }

      match self._typecheckImport(typedImportModule, importNode) {
        Result.Ok(v) => v
        Result.Err(e) => return Result.Err(TypecheckerError(modulePath: modulePathAbs, kind: TypecheckerErrorKind.TypeError(e)))
      }
    }

    mod.code = match self._typecheckBlock(parsedModule.nodes) {
      Result.Ok(v) => v
      Result.Err(e) => return Result.Err(TypecheckerError(modulePath: modulePathAbs, kind: TypecheckerErrorKind.TypeError(e)))
    }

    mod.imports = self.currentModuleImports
    self.currentModuleImports = {} // is this necessary?

    mod.exports = self.currentModuleExports
    self.currentModuleExports = {} // is this necessary?

    self.currentScope = prevScope

    mod.complete = true
    Result.Ok(mod)
  }

  func _typecheckDecoratorNode(self, dec: DecoratorNode): Result<Decorator, TypeError> {
    val args: LiteralAstNode[] = []
    for arg in dec.arguments {
      val typedArg = match self._typecheckExpression(arg.value, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      match typedArg.kind {
        TypedAstNodeKind.Literal(litNode) => args.push(litNode)
        _ => return unreachable(typedArg.token.position, "should have been caught during parsing")
      }
    }

    Result.Ok(Decorator(label: dec.name, arguments: args))
  }

  func _typecheckFunctionPass1(self, node: FunctionDeclarationNode): Result<Function, TypeError> {
    val decorators: Decorator[] = []
    for d in node.decorators {
      val dec = match self._typecheckDecoratorNode(d) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      decorators.push(dec)
    }

    val fnScope = self.currentScope.makeChild(node.name.name, ScopeKind.Func)
    val prevScope = self.currentScope
    self.currentScope = fnScope

    val typeParams: (Type, Label)[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenTypeParams[label.name] = label

      val generic = Type(kind: TypeKind.Generic(label.name))
      match self._addTypeToScope(generic) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typeParams.push((generic, label))
    }

    val returnType = if node.returnTypeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    self.currentScope = prevScope

    val hasSelf = if node.params[0] |param| param.label.name == "self" else false
    val fnKind = if hasSelf {
      if !self.currentTypeDecl {
        val param = if node.params[0] |p| p else return unreachable(node.name.position, "expected a first parameter to be present")
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))
      }

      FunctionKind.InstanceMethod
    } else if self.currentTypeDecl {
      FunctionKind.StaticMethod
    } else {
      FunctionKind.Standalone
    }

    val fn = Function(label: node.name, scope: fnScope, kind: fnKind, typeParams: typeParams, params: [], returnType: returnType, body: [], decorators: decorators)
    match self._addFunctionToScope(fn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(fn)
  }

  func _typecheckFunctionParam(self, param: FunctionParam, typeHint: Type?, allowSelf: Bool, isRevisit = false): Result<(TypedFunctionParam, Bool), TypeError> {
    if param.label.name == "self" {
      if !allowSelf return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))

      if self.currentTypeDecl |structOrEnum| {
        val ty = match structOrEnum {
          StructOrEnum.Struct(struct) => {
            val typeArgs = struct.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
            Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs))
          }
          StructOrEnum.Enum(enum_) => {
            val typeArgs = enum_.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
            Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), typeArgs))
          }
        }

        val variable = Variable(label: param.label, mutable: false, ty: ty)
        match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

        val typedParam = TypedFunctionParam(label: param.label, ty: ty, defaultValue: None, isVariadic: false)
        return Result.Ok((typedParam, false))
      }

      return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))
    }

    val paramType = if param.typeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if typeHint |hintTy| {
        if !self._typeSatisfiesRequired(ty: ty, required: hintTy) {
          return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.TypeMismatch([hintTy], ty)))
        }
      }
      ty
    } else if typeHint |hintTy| {
      hintTy
    } else {
      None
    }

    var defaultValue: TypedAstNode? = None
    if param.defaultValue |node| {
      if isRevisit {
        val expr = match self._typecheckExpression(node, paramType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        defaultValue = expr
      } else {
        // TODO: There has to be a cleaner way of representing this
        val ctx = ParamDefaultValueContext()
        self.paramDefaultValueContext = ctx
        val expr = match self._typecheckExpression(node, paramType) {
          Result.Ok(v) => v
          Result.Err(e) => {
            self.paramDefaultValueContext = None
            if ctx.exprContainsFunctionCall || ctx.exprContainsVariableRef {
              val typedParam = TypedFunctionParam(label: param.label, ty: Type(kind: TypeKind.Hole), defaultValue: TypedAstNode(token: node.token, ty: Type(kind: TypeKind.Hole), kind: TypedAstNodeKind.Placeholder), isVariadic: param.isVariadic)
              return Result.Ok((typedParam, true))
            }
            return Result.Err(e)
          }
        }
        self.paramDefaultValueContext = None
        if ctx.exprContainsFunctionCall || ctx.exprContainsVariableRef {
          val typedParam = TypedFunctionParam(label: param.label, ty: paramType ?: expr.ty, defaultValue: expr, isVariadic: param.isVariadic)
          return Result.Ok((typedParam, true))
        }
        defaultValue = expr
      }
    }

    var ty = if paramType |paramType| {
      if defaultValue |defaultValue| {
        if !self._typeSatisfiesRequired(ty: defaultValue.ty, required: paramType) {
          return Result.Err(TypeError(position: defaultValue.token.position, kind: TypeErrorKind.TypeMismatch([paramType], defaultValue.ty)))
        }
      }

      paramType
    } else {
      if defaultValue |defaultValue| {
        defaultValue.ty
      } else {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.UnknownParameterType(param.label.name)))
      }
    }

    val variable = Variable(label: param.label, mutable: false, ty: ty)
    match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    if param.isVariadic {
      if ty.nullable {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidVarargType(ty)))
      } else if self._typeAsInstance1(ty, self.project.preludeArrayStruct) |innerType| {
        ty = innerType
      } else {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidVarargType(ty)))
      }
    }

    if ty.hasUnfilledHoles() {
      return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "parameter")))
    }

    val typedParam = TypedFunctionParam(label: param.label, ty: ty, defaultValue: defaultValue, isVariadic: param.isVariadic)
    Result.Ok((typedParam, false))
  }

  func _typecheckFunctionPass2(self, fn: Function, allowSelf: Bool, params: FunctionParam[], paramHints: Type[] = []): Result<Int[], TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope

    val paramsNeedingRevisit: Int[] = []
    val seenParamNames: Set<String> = #{}
    var startedOptionalParams = false
    for param, idx in params {
      if param.isVariadic && idx != params.length - 1 {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "vararg")))
      }

      if seenParamNames.contains(param.label.name) {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.DuplicateParameter(param.label.name)))
      }
      seenParamNames.insert(param.label.name)

      if param.defaultValue {
        startedOptionalParams = true
      } else if startedOptionalParams {
        return Result.Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "required")))
      }

      val hint = paramHints[idx]
      val _p = match self._typecheckFunctionParam(param, hint, allowSelf) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      // TODO: destructuring
      val typedParam = _p[0]
      val needsRevisit = _p[1]
      val paramName = typedParam.label.name
      // This is a bit messy - if param is `self` then don't add here; it's already denoted as an instance method via its FunctionKind
      if paramName != "self" { fn.params.push(typedParam) }
      // Adjust the index value if we're in an instance method, since `self` isn't included in the fn.params array
      if needsRevisit {
        val paramIdx = if fn.kind == FunctionKind.InstanceMethod idx - 1 else idx
        paramsNeedingRevisit.push(paramIdx)
      }
    }

    self.currentScope = prevScope

    Result.Ok(paramsNeedingRevisit)
  }

  func _typecheckFunctionPass3(self, fn: Function, allowSelf: Bool, params: FunctionParam[], body: AstNode[], paramsNeedingRevisit: Int[], paramHints: Type[] = []): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope
    val prevFn = self.currentFunction
    self.currentFunction = fn

    val hasReturnValue = fn.returnType.kind != TypeKind.PrimitiveUnit
    if hasReturnValue && body.isEmpty() {
      if !fn.decorators.find(dec => dec.label.name == "Stub" || dec.label.name == "Intrinsic" || dec.label.name == "CBinding")
        return Result.Err(TypeError(position: fn.label.position, kind: TypeErrorKind.ReturnTypeMismatch(fn.label.name, fn.returnType, None)))
    }

    for param, idx in fn.params {
      if !paramsNeedingRevisit.contains(idx) continue

      // Since `self` is not included in the fn.params array, but it is in the untyped AST, when referring to the untyped AST, we need to adjust
      val origNodeParamIdx = if fn.kind == FunctionKind.InstanceMethod idx + 1 else idx
      val paramNode = if params[origNodeParamIdx] |p| p else return unreachable(param.label.position, "there should be as many parameter nodes as typed parameters")
      val defaultValueNode = if paramNode.defaultValue |n| n else return unreachable(param.label.position, "the only way a parameter needs revisiting is if it has a default value")

      val hint = paramHints[idx]
      val _p = match self._typecheckFunctionParam(param: paramNode, typeHint: hint, allowSelf: allowSelf, isRevisit: true) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      // TODO: destructuring
      val typedParam = _p[0]
      val needsRevisit = _p[1]
      if needsRevisit return unreachable(param.label.position, "parameters should not need to be revisited more than once")
      fn.params[idx] = typedParam
    }

    for node, idx in body {
      if self.currentScope.terminator return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = if idx == body.length - 1 && hasReturnValue {
        val fnName = if fn.isLambda None else fn.label.name
        val err = TypeError(position: node.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Type(kind: TypeKind.PrimitiveUnit)))
        match node.kind {
          AstNodeKind.While => return Result.Err(err)
          AstNodeKind.For => return Result.Err(err)
          AstNodeKind.BindingDeclaration => return Result.Err(err)
          AstNodeKind.FunctionDeclaration => return Result.Err(err)
          AstNodeKind.TypeDeclaration => return Result.Err(err)
          AstNodeKind.EnumDeclaration => return Result.Err(err)
          _ => {}
        }

        val expr = if fn.returnType.kind == TypeKind.Hole {
          val expr = match self._typecheckExpressionOrTerminator(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          fn.returnType = expr.ty.clone()
          expr
        } else {
          val expr = match self._typecheckExpressionOrTerminator(node, fn.returnType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          if !self._typeSatisfiesRequired(ty: expr.ty, required: fn.returnType) {
            val fnName = if fn.isLambda None else fn.label.name
            return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, expr.ty)))
          }
          expr
        }

        expr
      } else {
        val stmt = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        stmt
      }
      fn.body.push(typedNode)
    }

    self.currentFunction = prevFn
    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckStructPass1(self, node: TypeDeclarationNode): Result<Struct, TypeError> {
    val isExported = if node.exportToken |exportToken| {
      match self._ensureValidExportScope(exportToken) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      true
    } else {
      false
    }

    val typeScope = self.currentScope.makeChild(node.name.name, ScopeKind.Type)
    val prevScope = self.currentScope
    self.currentScope = typeScope

    val typeParams: String[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenTypeParams[label.name] = label

      val generic = Type(kind: TypeKind.Generic(label.name))
      match self._addTypeToScope(generic) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typeParams.push(label.name)
    }

    self.currentScope = prevScope

    val struct = Struct(moduleId: self.currentModuleId, label: node.name, scope: typeScope, typeParams: typeParams)
    match self._addStructToScope(struct, isExported) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(struct)
  }

  func _typecheckStructPass2_1(self, struct: Struct, node: TypeDeclarationNode): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = StructOrEnum.Struct(struct)

    val seenFields: Map<String, Label> = {}
    for field in node.fields {
      if seenFields[field.name.name] |original| {
        return Result.Err(TypeError(position: field.name.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenFields[field.name.name] = field.name

      val ty = match self._resolveTypeIdentifier(field.typeAnnotation) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      struct.fields.push(Field(name: field.name, ty: ty, initializer: None))
    }

    for funcDeclNode in node.methods {
      val fn = match self._typecheckFunctionPass1(funcDeclNode) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      match fn.kind {
        FunctionKind.InstanceMethod => struct.instanceMethods.push(fn)
        FunctionKind.StaticMethod => struct.staticMethods.push(fn)
        FunctionKind.Standalone => return unreachable(fn.label.position, "method has invalid function kind at this point")
      }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckMethodsPass2(self, structOrEnum: StructOrEnum, funcDeclNodes: FunctionDeclarationNode[]): Result<Map<Label, Int[]>, TypeError> {
    val allParamsNeedingRevisit: Map<Label, Int[]> = {}

    val _p = match structOrEnum {
      StructOrEnum.Struct(struct) => (struct.scope, struct.instanceMethods, struct.staticMethods)
      StructOrEnum.Enum(enum_) => (enum_.scope, enum_.instanceMethods, enum_.staticMethods)
    }
    // TODO: destructuring
    val scope = _p[0]
    val instanceMethods = _p[1]
    val staticMethods = _p[2]

    val selfInstanceType = match structOrEnum {
      StructOrEnum.Struct(struct) => {
        val typeArgs = struct.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
        Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs))
      }
      StructOrEnum.Enum(enum_) => Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), []))
    }

    val instanceMethodsByName = instanceMethods.keyBy(f => f.label)
    val staticMethodsByName = staticMethods.keyBy(f => f.label)
    var toStringFn: Function? = None
    var hashFn: Function? = None
    var eqFn: Function? = None
    for funcDeclNode in funcDeclNodes {
      var isToString = false
      var isHash = false
      var isEq = false
      val fn = if instanceMethodsByName[funcDeclNode.name] |fn| {
        isToString = fn.label.name == "toString"
        isHash = fn.label.name == "hash"
        isEq = fn.label.name == "eq"
        fn
      } else if staticMethodsByName[funcDeclNode.name] |fn| {
        fn
      } else {
        return unreachable(funcDeclNode.name.position, "could not find function among instance/static methods")
      }
      val paramsNeedingRevisit = match self._typecheckFunctionPass2(fn: fn, allowSelf: true, params: funcDeclNode.params) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      allParamsNeedingRevisit[fn.label] = paramsNeedingRevisit

      if isToString {
        val required = Type(kind: TypeKind.Func([], Type(kind: TypeKind.PrimitiveString)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Result.Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        toStringFn = fn
      }
      if isHash {
        val required = Type(kind: TypeKind.Func([], Type(kind: TypeKind.PrimitiveInt)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Result.Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        hashFn = fn
      }
      if isEq {
        val required = Type(kind: TypeKind.Func([(selfInstanceType, true)], Type(kind: TypeKind.PrimitiveBool)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Result.Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        eqFn = fn
      }
    }

    // Ensure toString/hash/eq methods exist (include generated stubs if not), and sure the proper order
    val reorderedInstanceMethods = [
      toStringFn ?: Function.generated(scope, "toString", [], Type(kind: TypeKind.PrimitiveString)),
      hashFn ?: Function.generated(scope, "hash", [], Type(kind: TypeKind.PrimitiveInt)),
      eqFn ?: Function.generated(scope, "eq", [("other", selfInstanceType)], Type(kind: TypeKind.PrimitiveBool)),
    ]
    for m in instanceMethods {
      if m.label.name == "toString" || m.label.name == "hash" || m.label.name == "eq" continue
      reorderedInstanceMethods.push(m)
    }

    match structOrEnum {
      StructOrEnum.Struct(struct) => struct.instanceMethods = reorderedInstanceMethods
      StructOrEnum.Enum(enum_) => enum_.instanceMethods = reorderedInstanceMethods
    }

    Result.Ok(allParamsNeedingRevisit)
  }

  func _typecheckStructPass2_2(self, struct: Struct, node: TypeDeclarationNode): Result<Map<Label, Int[]>, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = StructOrEnum.Struct(struct)

    val allParamsNeedingRevisit = match self._typecheckMethodsPass2(StructOrEnum.Struct(struct), node.methods) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Result.Ok(allParamsNeedingRevisit)
  }

  func _typecheckStructPass3(self, struct: Struct, node: TypeDeclarationNode, paramsNeedingRevisit: Map<Label, Int[]>): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = StructOrEnum.Struct(struct)

    for field, idx in node.fields {
      val initializer = if field.initializer |v| v else continue
      val structField = if struct.fields[idx] |f| f else return unreachable(struct.label.position, "")

      val typedInitializer = match self._typecheckExpression(initializer, structField.ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if !self._typeSatisfiesRequired(ty: typedInitializer.ty, required: structField.ty) {
        return Result.Err(TypeError(position: initializer.token.position, kind: TypeErrorKind.TypeMismatch([structField.ty], typedInitializer.ty)))
      }
      structField.initializer = typedInitializer
    }

    val instanceMethods = struct.instanceMethods.keyBy(f => f.label)
    val staticMethods = struct.staticMethods.keyBy(f => f.label)
    for funcDeclNode in node.methods {
      val fnLabel = funcDeclNode.name
      val fn = if instanceMethods[fnLabel] |f| {
        f
      } else if staticMethods[fnLabel] |f| {
        f
      } else {
        return unreachable(funcDeclNode.name.position, "method not visited in prior pass")
      }

      val toRevisit = if paramsNeedingRevisit[fnLabel] |paramIds| paramIds else return unreachable(funcDeclNode.name.position, "params improperly visited in prior pass")
      match self._typecheckFunctionPass3(fn: fn, allowSelf: true, params: funcDeclNode.params, body: funcDeclNode.body, paramsNeedingRevisit: toRevisit) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckEnumPass1(self, node: EnumDeclarationNode): Result<Enum, TypeError> {
    val isExported = if node.exportToken |exportToken| {
      match self._ensureValidExportScope(exportToken) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      true
    } else {
      false
    }

    val typeScope = self.currentScope.makeChild(node.name.name, ScopeKind.Type)
    val prevScope = self.currentScope
    self.currentScope = typeScope

    val typeParams: String[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenTypeParams[label.name] = label

      val generic = Type(kind: TypeKind.Generic(label.name))
      match self._addTypeToScope(generic) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typeParams.push(label.name)
    }

    self.currentScope = prevScope

    val enum_ = Enum(moduleId: self.currentModuleId, label: node.name, scope: typeScope, typeParams: typeParams)
    match self._addEnumToScope(enum_, isExported) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    Result.Ok(enum_)
  }

  func _typecheckEnumPass2_1(self, enum_: Enum, node: EnumDeclarationNode): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = enum_.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = StructOrEnum.Enum(enum_)

    var allVariantsConstant = true
    val seenVariants: Map<String, Label> = {}
    for variant, idx in node.variants {
      val variantLabel = match variant { EnumVariant.Constant(label) => label, EnumVariant.Container(label) => label }
      if seenVariants[variantLabel.name] |original| {
        return Result.Err(TypeError(position: variantLabel.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenVariants[variantLabel.name] = variantLabel

      match variant {
        EnumVariant.Constant(label) => {
          enum_.variants.push(TypedEnumVariant(label: label, kind: EnumVariantKind.Constant))
        }
        EnumVariant.Container(label, fields) => {
          allVariantsConstant = false

          val typedFields: Field[] = []
          val seenFields: Map<String, Label> = {}
          for field in fields {
            if seenFields[field.name.name] |original| {
              return Result.Err(TypeError(position: field.name.position, kind: TypeErrorKind.DuplicateName(original)))
            }
            seenFields[field.name.name] = field.name

            val ty = match self._resolveTypeIdentifier(field.typeAnnotation) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            // The initializer (if present) will be filled in during the next pass
            typedFields.push(Field(name: field.name, ty: ty, initializer: None))
          }

          enum_.variants.push(TypedEnumVariant(label: label, kind: EnumVariantKind.Container(typedFields)))
        }
      }
    }

    for funcDeclNode in node.methods {
      val fn = match self._typecheckFunctionPass1(funcDeclNode) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      match fn.kind {
        FunctionKind.InstanceMethod => enum_.instanceMethods.push(fn)
        FunctionKind.StaticMethod => enum_.staticMethods.push(fn)
        FunctionKind.Standalone => return unreachable(fn.label.position, "method has invalid function kind at this point")
      }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckEnumPass2_2(self, enum_: Enum, node: EnumDeclarationNode): Result<Map<Label, Int[]>, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = enum_.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = StructOrEnum.Enum(enum_)

    for typedVariant, idx in enum_.variants {
      match typedVariant.kind {
        EnumVariantKind.Constant => continue
        EnumVariantKind.Container(typedFields) => {
          val fields = match node.variants[idx] {
            EnumVariant.Container(_, fields) => fields
            _ => return unreachable(typedVariant.label.position, "the untyped enum variant must exist at index, and must also be a Container")
          }

          for typedField, idx in typedFields {
            val field = if fields[idx] |f| f else return unreachable(typedField.name.position, "the untyped field must exist at index")
            if field.initializer |initializer| {
              val typedInitializer = match self._typecheckExpression(initializer, typedField.ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
              if !self._typeSatisfiesRequired(ty: typedInitializer.ty, required: typedField.ty) {
                return Result.Err(TypeError(position: typedInitializer.token.position, kind: TypeErrorKind.TypeMismatch([typedField.ty], typedInitializer.ty)))
              }

              typedField.initializer = typedInitializer
            } else {
              continue
            }
          }
        }
      }
    }

    val allParamsNeedingRevisit = match self._typecheckMethodsPass2(StructOrEnum.Enum(enum_), node.methods) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Result.Ok(allParamsNeedingRevisit)
  }

  func _typecheckEnumPass3(self, enum_: Enum, node: EnumDeclarationNode, paramsNeedingRevisit: Map<Label, Int[]>): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = enum_.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = StructOrEnum.Enum(enum_)

    val instanceMethods = enum_.instanceMethods.keyBy(f => f.label)
    val staticMethods = enum_.staticMethods.keyBy(f => f.label)
    for funcDeclNode in node.methods {
      val fnLabel = funcDeclNode.name
      val fn = if instanceMethods[fnLabel] |f| {
        f
      } else if staticMethods[fnLabel] |f| {
        f
      } else {
        return unreachable(funcDeclNode.name.position, "method not visited in prior pass")
      }

      val toRevisit = if paramsNeedingRevisit[fnLabel] |paramIds| paramIds else return unreachable(funcDeclNode.name.position, "params improperly visited in prior pass")
      match self._typecheckFunctionPass3(fn: fn, allowSelf: true, params: funcDeclNode.params, body: funcDeclNode.body, paramsNeedingRevisit: toRevisit) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Result.Ok(0)
  }

  func _typecheckImport(self, mod: TypedModule, node: ImportNode): Result<Int, TypeError> {
    val importedModule = if self.currentModuleImports[mod.name] |importedModule| importedModule else {
      // TODO: better API for this
      val importedModule = ImportedModule()
      self.currentModuleImports[mod.name] = importedModule
      importedModule
    }

    match node.kind {
      ImportKind.List(importNames) => {
        for imp in importNames {
          for importedModule in self.currentModuleImports.values() {
            for _p in importedModule.imports {
              // TODO: destructuring
              val importedName = _p[0]
              val importedValue = _p[1]
              if importedName == imp.name {
                return Result.Err(TypeError(position: imp.position, kind: TypeErrorKind.DuplicateName(original: importedValue.label)))
              }
            }
          }

          val typedImportKind = match mod.exports[imp.name] {
            Export.Variable(v) => TypedImportKind.Variable(v)
            Export.Function(v) => TypedImportKind.Function(v)
            Export.Type(structOrEnum, v) => TypedImportKind.Type(structOrEnum, v)
            None => return Result.Err(TypeError(position: imp.position, kind: TypeErrorKind.UnknownImport(moduleName: node.moduleName.name, importName: imp.name)))
          }

          importedModule.imports[imp.name] = Import(label: imp, kind: typedImportKind)
        }
      }
      ImportKind.Alias(alias) => {
        if self._verifyNameUniqueInScope(alias, self.currentScope) |e| return Result.Err(e)

        importedModule.aliases.push(alias)
      }
    }

    Result.Ok(0)
  }

  func _typecheckBlock(self, nodes: AstNode[]): Result<TypedAstNode[], TypeError> {
    val funcDecls: FunctionDeclarationNode[] = []
    val typeDecls: TypeDeclarationNode[] = []
    val enumDecls: EnumDeclarationNode[] = []
    for node in nodes {
      match node.kind {
        AstNodeKind.FunctionDeclaration(node) => funcDecls.push(node)
        AstNodeKind.TypeDeclaration(node) => typeDecls.push(node)
        AstNodeKind.EnumDeclaration(node) => enumDecls.push(node)
        _ => {}
      }
    }

    // --- Pass 1 for types, enums, and functions

    val structsPass1: (Struct, TypeDeclarationNode)[] = []
    for node in typeDecls {
      val struct = match self._typecheckStructPass1(node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if self.currentModuleId == 0 {
        match struct.label.name {
          "Int" => self.project.preludeIntStruct = struct
          "Float" => self.project.preludeFloatStruct = struct
          "Bool" => self.project.preludeBoolStruct = struct
          "String" => self.project.preludeStringStruct = struct
          "Array" => self.project.preludeArrayStruct = struct
          "Set" => self.project.preludeSetStruct = struct
          "Map" => self.project.preludeMapStruct = struct
          _ => {}
        }
      }
      structsPass1.push((struct, node))
    }

    val enumsPass1: (Enum, EnumDeclarationNode)[] = []
    for node in enumDecls {
      val enum_ = match self._typecheckEnumPass1(node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      enumsPass1.push((enum_, node))
    }

    val functionsPass1: (Function, Variable, FunctionDeclarationNode)[] = []
    for node in funcDecls {
      val isExported = if node.exportToken |exportToken| {
        match self._ensureValidExportScope(exportToken) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        true
      } else {
        false
      }

      val fn = match self._typecheckFunctionPass1(node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val aliasVar = Variable(label: fn.label, mutable: false, ty: fn.getType(), alias: VariableAlias.Function(fn))
      self.currentScope.variables.push(aliasVar)
      functionsPass1.push((fn, aliasVar, node))
      if isExported {
        aliasVar.isExported = true
        self.currentModuleExports[fn.label.name] = Export.Function(aliasVar)
      }
    }

    // --- Pass 2 for types, enums, and functions

    val structsPass2_1: (Struct, TypeDeclarationNode)[] = []
    for pair in structsPass1 {
      val struct = pair[0]
      val node = pair[1]
      match self._typecheckStructPass2_1(struct, node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      structsPass2_1.push((struct, node))
    }

    val enumsPass2_1: (Enum, EnumDeclarationNode)[] = []
    for pair in enumsPass1 {
      val enum_ = pair[0]
      val node = pair[1]
      match self._typecheckEnumPass2_1(enum_, node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      enumsPass2_1.push((enum_, node))
    }

    val structsPass2_2: (Struct, TypeDeclarationNode, Map<Label, Int[]>)[] = []
    for pair in structsPass1 {
      val struct = pair[0]
      val node = pair[1]
      val toRevisit = match self._typecheckStructPass2_2(struct, node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      structsPass2_2.push((struct, node, toRevisit))
    }

    val enumsPass2_2: (Enum, EnumDeclarationNode, Map<Label, Int[]>)[] = []
    for pair in enumsPass2_1 {
      val enum_ = pair[0]
      val node = pair[1]
      val toRevisit = match self._typecheckEnumPass2_2(enum_, node) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      enumsPass2_2.push((enum_, node, toRevisit))
    }

    val functionsPass2: (Function, FunctionDeclarationNode, Int[])[] = []
    for fnPair in functionsPass1 {
      val fn = fnPair[0]
      val aliasVar = fnPair[1]
      val node = fnPair[2]
      val paramsNeedingRevisit = match self._typecheckFunctionPass2(fn: fn, allowSelf: false, params: node.params) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      aliasVar.ty = fn.getType()
      functionsPass2.push((fn, node, paramsNeedingRevisit))
    }

    val functionsIter = functionsPass2.iterator()
    val structsIter = structsPass2_2.iterator()
    val enumsIter = enumsPass2_2.iterator()

    val typedNodes: TypedAstNode[] = []
    for node in nodes {
      val res = match node.kind {
        AstNodeKind.FunctionDeclaration => {
          val typedNode = if functionsIter.next() |pair| {
            val fn = pair[0]
            val fnDeclNode = pair[1]
            val paramsNeedingRevisit = pair[2]
            match self._typecheckFunctionPass3(fn: fn, allowSelf: false, params: fnDeclNode.params, body: fnDeclNode.body, paramsNeedingRevisit: paramsNeedingRevisit) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.FunctionDeclaration(fn))
          } else {
            return unreachable(node.token.position, "there should be as many functions as there are functiondecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        AstNodeKind.TypeDeclaration => {
          val typedNode = if structsIter.next() |pair| {
            val struct = pair[0]
            val typeDeclNode = pair[1]
            val toRevisit = pair[2]

            match self._typecheckStructPass3(struct, typeDeclNode, toRevisit) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.TypeDeclaration(struct))
          } else {
            return unreachable(node.token.position, "there should be as many types as there are typedecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        AstNodeKind.EnumDeclaration => {
          val typedNode = if enumsIter.next() |pair| {
            val enum_ = pair[0]
            val enumDeclNode = pair[1]
            val toRevisit = pair[2]

            match self._typecheckEnumPass3(enum_, enumDeclNode, toRevisit) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.EnumDeclaration(enum_))
          } else {
            return unreachable(node.token.position, "there should be as many enums as there are enumdecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        _ => self._typecheckStatement(node: node, typeHint: None)
      }

      val typedNode = match res { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }

    return Result.Ok(typedNodes)
  }

  func _typecheckStatement(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token

    match node.kind {
      AstNodeKind.Assignment(expr, op, mode) => self._typecheckAssignment(token, expr, op, mode)
      AstNodeKind.While(condition, conditionBinding, block) => self._typecheckWhile(token, condition, conditionBinding, block)
      AstNodeKind.For(itemPattern, indexPattern, iterator, block) => self._typecheckFor(token, itemPattern, indexPattern, iterator, block)
      AstNodeKind.BindingDeclaration(node) => self._typecheckBindingDeclaration(token, node)
      AstNodeKind.Break => self._typecheckBreak(token)
      AstNodeKind.Continue => self._typecheckContinue(token)
      AstNodeKind.Return(expr) => self._typecheckReturn(token, expr)
      _ => self._typecheckExpression(node, Type(kind: TypeKind.PrimitiveUnit))
    }
  }

  func _typecheckBindingPattern(self, mutable: Bool, pattern: BindingPattern, ty: Type): Result<Variable[], TypeError> {
    match pattern {
      BindingPattern.Variable(label) => {
        val variable = Variable(label: label, mutable: mutable, ty: ty)
        match self._addVariableToScope(variable) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

        Result.Ok([variable])
      }
    }
  }

  func _typecheckBindingDeclaration(self, token: Token, node: BindingDeclarationNode): Result<TypedAstNode, TypeError> {
    val isMutable = token.kind == TokenKind.Var
    val isExported = if node.exportToken |exportToken| {
      match self._ensureValidExportScope(exportToken) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      true
    } else {
      false
    }

    val annType = if node.typeAnnotation |typeAnn| {
      val ty = match self._resolveTypeIdentifier(typeAnn) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty
    } else {
      None
    }

    val _pair = if node.expr |expr| {
      val typedExpr = match self._typecheckExpression(expr, annType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val ty = if annType |annotatedType| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: annotatedType) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([annotatedType], typedExpr.ty)))
        }

        annotatedType
      } else {
        typedExpr.ty
      }

      if ty.isInvalidValueType() {
        return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "assignment")))
      }

      // TODO: type could not be auto-coerced to `TypedAstNode?` on its own
      val typedExpr_: TypedAstNode? = typedExpr
      (typedExpr_, ty)
    } else if !isMutable {
      val label = match node.bindingPattern {
        BindingPattern.Variable(label) => label
        // _ => return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingValExpr(None)))
      }
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingValExpr(label.name)))
    } else if annType |ty| {
      (None, ty)
    } else {
      val label = match node.bindingPattern {
        BindingPattern.Variable(label) => label
        // _ => return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(None)))
      }
      return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(label.name)))
    }
    // TODO: destructuring
    val expr = _pair[0]
    val ty = _pair[1]

    val variables = match self._typecheckBindingPattern(isMutable, node.bindingPattern, ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    for v in variables {
      if isExported {
        v.isExported = true
        self.currentModuleExports[v.label.name] = Export.Variable(v)
      }
    }

    val typedNode = TypedBindingDeclarationNode(bindingPattern: node.bindingPattern, variables: variables, expr: expr)
    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.BindingDeclaration(typedNode)))
  }

  func _typecheckAssignment(self, token: Token, expr: AstNode, op: AssignOp, mode: AssignmentMode): Result<TypedAstNode, TypeError> {
    match mode {
      AssignmentMode.Variable(name, varToken) => {
        val pos = varToken.position

        val variable = if self._resolveIdentifier(name) |variable| variable else {
          return Result.Err(TypeError(position: pos, kind: TypeErrorKind.UnknownName(name, "variable")))
        }
        match variable.alias {
          VariableAlias.Function => return Result.Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.FunctionAlias)))
          VariableAlias.Struct => return Result.Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.TypeAlias)))
          _ => {
            if !variable.mutable return Result.Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.ImmutableVariable)))
          }
        }

        val typedExpr = match self._typecheckExpression(expr, variable.ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: variable.ty) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([variable.ty], typedExpr.ty)))
        }

        val mode = TypedAssignmentMode.Variable(variable)
        return Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.Assignment(mode, op, typedExpr)))
      }
      AssignmentMode.Indexing(targetExpr, indexExpr) => {
        val typedLhs = match self._typecheckIndexing(token, targetExpr, IndexingMode.Single(indexExpr), None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        val typedIndexingNode = match typedLhs.kind {
          TypedAstNodeKind.Indexing(node) => node
          _ => return unreachable(typedLhs.token.position, "_typecheckIndexing returned unexpected TypedAstNodeKind")
        }
        val assignmentTy = Type(kind: typedLhs.ty.kind, nullable: false)

        val typedExpr = match self._typecheckExpression(expr, assignmentTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: assignmentTy) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([assignmentTy], typedExpr.ty)))
        }

        val mode = TypedAssignmentMode.Indexing(typedIndexingNode)
        return Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.Assignment(mode, op, typedExpr)))
      }
      AssignmentMode.Accessor(accessorNode) => {
        val typedLhs = match self._typecheckAccessor(token, accessorNode, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        val _p = match typedLhs.kind {
          TypedAstNodeKind.Accessor(head, mid, tail) => {
            val t = match tail {
              AccessorPathSegment.EnumVariant(label, _, variant) => {
                return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAssignment("enum variant", variant.label.name, IllegalAssignmentReason.EnumVariant)))
              }
              AccessorPathSegment.Method(label, fn) => {
                val _p = if fn.kind == FunctionKind.StaticMethod {
                  ("static method", IllegalAssignmentReason.StaticMethod)
                } else {
                  ("method", IllegalAssignmentReason.Method)
                }
                // TODO: destructuring
                val kind = _p[0]
                val reason = _p[1]

                return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAssignment(kind, fn.label.name, reason)))
              }
              AccessorPathSegment.Field(label, field) => {
                val mode = TypedAssignmentMode.Accessor(head, mid, tail)
                (mode, label, field)
              }
            }
            t
          }
          _ => return unreachable(typedLhs.token.position, "_typecheckAccessor returned unexpected TypedAstNodeKind")
        }
        // TODO: destructuring
        val mode = _p[0]
        val fieldLabel = _p[1]
        val field = _p[2]

        val typedExpr = match self._typecheckExpression(expr, field.ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: field.ty) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([field.ty], typedExpr.ty)))
        }

        return Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.Assignment(mode, op, typedExpr)))
      }
    }
  }

  func _typecheckWhile(self, token: Token, condition: AstNode, conditionBinding: BindingPattern?, block: AstNode[]): Result<TypedAstNode, TypeError> {
    val typedCondition = match self._typecheckExpression(condition, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    if !typedCondition.ty.nullable && !self._typeSatisfiesRequired(ty: typedCondition.ty, required: Type(kind: TypeKind.PrimitiveBool)) {
      return Result.Err(TypeError(position: typedCondition.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedCondition.ty, purpose: "while")))
    }

    val prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("while", ScopeKind.While)

    val conditionBindingPattern = if conditionBinding |pattern| {
      val ty = typedCondition.ty.clone()
      if ty.nullable {
        ty.nullable = false
      }

      val vars = match self._typecheckBindingPattern(false, pattern, ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      (pattern, vars)
    } else {
      None
    }

    val typedNodes: TypedAstNode[] = []
    for node in block {
      if self.currentScope.terminator return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }
    val terminator = self.currentScope.terminator

    self.currentScope = prevScope
    self.currentScope.terminator = terminator

    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.While(typedCondition, conditionBindingPattern, typedNodes)))
  }

  func _typeIsIterable(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(structOrEnum, generics) => {
        val instanceMethods = match structOrEnum {
          StructOrEnum.Struct(struct) => {
            if struct == self.project.preludeArrayStruct return generics[0]
            if struct == self.project.preludeSetStruct return generics[0]
            if struct == self.project.preludeMapStruct {
              val keyTy = generics[0] ?: Type(kind: TypeKind.Hole)
              val valTy = generics[1] ?: Type(kind: TypeKind.Hole)
              return Type(kind: TypeKind.Tuple([keyTy, valTy]))
            }

            struct.instanceMethods
          }
          StructOrEnum.Enum(enum_) => enum_.instanceMethods
        }
        for m in instanceMethods {
          if m.label.name == "next" {
            if !m.params.isEmpty() return None
            val iterItemType = m.returnType.clone()
            iterItemType.nullable = false
            return iterItemType
          }
        }

        None
      }
      _ => None
    }
  }

  func _typecheckFor(self, token: Token, itemPattern: BindingPattern, indexPattern: BindingPattern?, iterator: AstNode, block: AstNode[]): Result<TypedAstNode, TypeError> {
    val typedIterator = match self._typecheckExpression(iterator, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val itemType = if self._typeIsIterable(typedIterator.ty) |innerTy| innerTy else {
      return Result.Err(TypeError(position: typedIterator.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedIterator.ty, purpose: "for")))
    }
    if itemType.kind == TypeKind.Hole {
      return Result.Err(TypeError(position: typedIterator.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedIterator.ty, purpose: "for")))
    }

    val prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("for", ScopeKind.For)

    val variables = match self._typecheckBindingPattern(false, itemPattern, itemType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val indexBinding = if indexPattern |pat| {
      val variables = match self._typecheckBindingPattern(false, pat, Type(kind: TypeKind.PrimitiveInt)) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      variables[0]
    } else {
      None
    }

    val typedNodes: TypedAstNode[] = []
    for node in block {
      if self.currentScope.terminator return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      typedNodes.push(typedNode)
    }
    val terminator = self.currentScope.terminator

    self.currentScope = prevScope
    self.currentScope.terminator = terminator

    val kind = TypedAstNodeKind.For(typedIterator, (itemPattern, variables), indexBinding, typedNodes)
    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: kind))
  }

  func _typecheckBreak(self, token: Token): Result<TypedAstNode, TypeError> = self._typecheckBreakContinue(token, "break", TypedAstNodeKind.Break)

  func _typecheckContinue(self, token: Token): Result<TypedAstNode, TypeError> = self._typecheckBreakContinue(token, "continue", TypedAstNodeKind.Continue)

  func _typecheckBreakContinue(self, token: Token, terminator: String, kind: TypedAstNodeKind): Result<TypedAstNode, TypeError> {
    var scope: Scope? = self.currentScope
    while scope |sc| {
      val isValid = match sc.kind {
        ScopeKind.Root => false
        ScopeKind.Module => false
        ScopeKind.Type => false
        ScopeKind.Func => false
        ScopeKind.If => {
          scope = sc.parent
          continue
        }
        ScopeKind.While => true
        ScopeKind.For => true
      }

      if !isValid return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTerminatorPosition(terminator)))
      break
    }
    self.currentScope.terminator = Terminator.NonReturning

    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.Never), kind: kind))
  }

  func _typecheckReturn(self, token: Token, expr: AstNode?): Result<TypedAstNode, TypeError> {
    val fn = if self.currentFunction |fn| fn else {
      return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTerminatorPosition("return")))
    }

    val typedExpr = if expr |expr| {
      val typedExpr = match self._typecheckExpression(expr, fn.returnType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: fn.returnType) {
        val fnName = if fn.isLambda None else fn.label.name
        return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, typedExpr.ty)))
      }

      typedExpr
    } else {
      if fn.returnType.kind != TypeKind.PrimitiveUnit {
        val fnName = if fn.isLambda None else fn.label.name
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Type(kind: TypeKind.PrimitiveUnit))))
      }

      None
    }

    self.currentScope.terminator = Terminator.Returning

    Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.Never), kind: TypedAstNodeKind.Return(typedExpr)))
  }

  func _typecheckIf(
    self,
    token: Token,
    condition: AstNode,
    conditionBinding: BindingPattern?,
    ifBlock: AstNode[],
    elseBlock: AstNode[]?,
    typeHint: Type?,
  ): Result<TypedAstNode, TypeError> {
    val isStatement = if typeHint |hint| hint.kind == TypeKind.PrimitiveUnit else false

    val typedCondition = match self._typecheckExpression(condition, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    if !typedCondition.ty.nullable && !self._typeSatisfiesRequired(ty: typedCondition.ty, required: Type(kind: TypeKind.PrimitiveBool)) {
      return Result.Err(TypeError(position: typedCondition.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedCondition.ty, purpose: "if")))
    }

    val typedIfBlock: TypedAstNode[] = []
    var prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("if_then", ScopeKind.If)

    val conditionBindingPattern = if conditionBinding |pattern| {
      val ty = typedCondition.ty.clone()
      if ty.nullable {
        ty.nullable = false
      }

      val vars = match self._typecheckBindingPattern(false, pattern, ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      (pattern, vars)
    } else {
      None
    }

    for node, idx in ifBlock {
      if self.currentScope.terminator return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      if idx == ifBlock.length - 1 && !isStatement {
        val typedNode = match self._typecheckExpressionOrTerminator(node, typeHint) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        typedIfBlock.push(typedNode)
      } else {
        val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        typedIfBlock.push(typedNode)
      }
    }
    val ifType = typedIfBlock[-1]?.ty
    val ifBlockTerminator = self.currentScope.terminator
    self.currentScope = prevScope

    var hasElseBlock = false
    val typedElseBlock: TypedAstNode[] = []
    prevScope = self.currentScope
    self.currentScope = self.currentScope.makeChild("if_else", ScopeKind.If)
    if elseBlock |elseBlock| {
      hasElseBlock = true
      for node, idx in elseBlock {
        if self.currentScope.terminator {
          return Result.Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))
        }

        if idx == elseBlock.length - 1 && !isStatement {
          val typedNode = match self._typecheckExpressionOrTerminator(node, ifType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          typedElseBlock.push(typedNode)
        } else {
          val typedNode = match self._typecheckStatement(node, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          typedElseBlock.push(typedNode)
        }
      }
    }
    val elseBlockTerminator = self.currentScope.terminator
    self.currentScope = prevScope

    self.currentScope.terminator = Terminator.combine(ifBlockTerminator, elseBlockTerminator)

    val ty = if !isStatement {
      val t = if ifType |ifType| {
        if typedElseBlock[-1] |lastElseNode| {
          val elseType = lastElseNode.ty

          if ifType.hasUnfilledHoles() {
            ifType.tryFillHoles(elseType)
          }
          if elseType.nullable && !ifType.nullable {
            ifType.nullable = true
          }

          if !self._typeSatisfiesRequired(ty: elseType, required: ifType) {
            return Result.Err(TypeError(position: lastElseNode.token.position, kind: TypeErrorKind.TypeMismatch([ifType], elseType)))
          }

          val t = if ifType.kind == TypeKind.Never { elseType.clone() } else { ifType.clone() }
          t
        } else {
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredIfExprBlock(clause: "else", missing: !hasElseBlock)))
        }
      } else {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredIfExprBlock(clause: "if", missing: false)))
      }
      t
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    val kind = TypedAstNodeKind.If(isStatement, typedCondition, conditionBindingPattern, typedIfBlock, typedElseBlock)
    Result.Ok(TypedAstNode(token: token, ty: ty, kind: kind))
  }

  func _typecheckExpression(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token
    val typedExprRes: Result<TypedAstNode, TypeError> = match node.kind {
      AstNodeKind.Literal(literal) => {
        val kind = match literal {
          LiteralAstNode.Int => TypeKind.PrimitiveInt
          LiteralAstNode.Float => TypeKind.PrimitiveFloat
          LiteralAstNode.Bool => TypeKind.PrimitiveBool
          LiteralAstNode.String => TypeKind.PrimitiveString
        }

        Result.Ok(TypedAstNode(token: token, ty: Type(kind: kind), kind: TypedAstNodeKind.Literal(literal)))
      }
      AstNodeKind.Unary(node) => self._typecheckUnary(token, node)
      AstNodeKind.Binary(node) => self._typecheckBinary(token, node)
      AstNodeKind.Grouped(inner) => {
        val expr = match self._typecheckExpression(inner, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Grouped(expr)))
      }
      AstNodeKind.Identifier(kind) => self._typecheckIdentifier(token, kind, typeHint)
      AstNodeKind.Accessor(node) => self._typecheckAccessor(token, node, typeHint)
      AstNodeKind.Invocation(node) => self._typecheckInvocation(token, node, typeHint)
      AstNodeKind.Array(items) => self._typecheckArray(token, items, typeHint)
      AstNodeKind.Set(items) => self._typecheckSet(token, items, typeHint)
      AstNodeKind.Map(items) => self._typecheckMap(token, items, typeHint)
      AstNodeKind.Tuple(items) => self._typecheckTuple(token, items, typeHint)
      AstNodeKind.Indexing(expr, index) => self._typecheckIndexing(token, expr, index, typeHint)
      AstNodeKind.Lambda(value) => self._typecheckLambda(token, value, typeHint)
      AstNodeKind.If(condition, conditionBinding, ifBlock, elseBlock) => self._typecheckIf(token, condition, conditionBinding, ifBlock, elseBlock, typeHint)
      AstNodeKind.Match => todo(node.token.position, "match expression")
      _ => unreachable(node.token.position, "all other node types should have already been handled")
    }

    val typedExpr = match typedExprRes { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    // If we're parsing an expression in a context where we have a type hint and where that type hint is nullable, we
    // may want to make the expression's type nullable as well, if the types' kinds are equivalent. If the types' kinds
    // are _not_ equivalent, don't do anything because this mismatch will be raised at the callsite.
    if typeHint |hint| {
      if (hint.kind == typedExpr.ty.kind || hint.kind == TypeKind.Hole) && hint.nullable {
        typedExpr.ty.nullable = true
      }
    }

    match typedExpr.ty.kind {
      TypeKind.Type => {
        if !self.isStructOrEnumValueAllowed {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalValueType(typedExpr.ty, "value")))
        }
      }
      _ => {}
    }

    Result.Ok(typedExpr)
  }

  func _typecheckExpressionOrTerminator(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    match node.kind {
      AstNodeKind.Break => self._typecheckBreak(node.token)
      AstNodeKind.Continue => self._typecheckContinue(node.token)
      AstNodeKind.Return(expr) => self._typecheckReturn(node.token, expr)
      _ => self._typecheckExpression(node, typeHint)
    }
  }

  func _typecheckUnary(self, token: Token, node: UnaryAstNode): Result<TypedAstNode, TypeError> {
    val expr = match self._typecheckExpression(node: node.expr, typeHint: None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match node.op {
      UnaryOp.Minus => {
        if !self._typeSatisfiesRequired(ty: expr.ty, required: Type(kind: TypeKind.PrimitiveInt)) &&
          !self._typeSatisfiesRequired(ty: expr.ty, required: Type(kind: TypeKind.PrimitiveFloat)) {
          val expected = [Type(kind: TypeKind.PrimitiveInt), Type(kind: TypeKind.PrimitiveFloat)]
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch(expected, expr.ty)))
        }
      }
      UnaryOp.Negate => {
        if !expr.ty.nullable && !self._typeSatisfiesRequired(ty: expr.ty, required: Type(kind: TypeKind.PrimitiveBool)) {
          return Result.Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveBool)], expr.ty)))
        }
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Unary(op: node.op, expr: expr)))
  }

  func _typecheckBinary(self, token: Token, node: BinaryAstNode): Result<TypedAstNode, TypeError> {
    val handleCases: ((TypeKind, TypeKind, TypeKind)[]) => Result<TypedAstNode, TypeError> = (cases) => {
      val left = match self._typecheckExpression(node.left, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val right = match self._typecheckExpression(node.right, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      for _case in cases {
        // TODO: destructuring
        val lTy = _case[0]
        val rTy = _case[1]
        val outTy = _case[2]

        if (lTy == TypeKind.Hole || (!left.ty.nullable && self._typeSatisfiesRequired(ty: left.ty, required: Type(kind: lTy)))) &&
          ((rTy == TypeKind.Hole || (!right.ty.nullable && self._typeSatisfiesRequired(ty: right.ty, required: Type(kind: rTy))))) {
          return Result.Ok(TypedAstNode(token: token, ty: Type(kind: outTy), kind: TypedAstNodeKind.Binary(left, node.op, right)))
        }
      }

      return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, right.ty)))
    }

    val handleEquality: () => Result<TypedAstNode, TypeError> = () => {
      val left = match self._typecheckExpression(node.left, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      val right = match self._typecheckExpression(node.right, left.ty) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

      if !left.ty.nullable && right.ty.nullable {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, right.ty)))
      }

      if !self._typeSatisfiesRequired(ty: right.ty, required: left.ty) {
        return Result.Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([left.ty], right.ty)))
      }

      Result.Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveBool), kind: TypedAstNodeKind.Binary(left, node.op, right)))
    }

    val standardArithmeticCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
    ]
    val allFloatArithmeticCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
    ]
    val boolOpCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
      (TypeKind.PrimitiveBool, TypeKind.PrimitiveBool, TypeKind.PrimitiveBool),
    ]
    val comparisonCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveBool),
    ]

    // TODO: combine match cases, this can be cleaned up a lot
    match node.op {
      BinaryOp.Add => {
        handleCases([
          (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
          (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
          (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
          (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
          (TypeKind.Hole, TypeKind.PrimitiveString, TypeKind.PrimitiveString),
          (TypeKind.PrimitiveString, TypeKind.Hole, TypeKind.PrimitiveString),
        ])
      }
      BinaryOp.Sub => handleCases(standardArithmeticCases)
      BinaryOp.Mul => handleCases(standardArithmeticCases)
      BinaryOp.Div => handleCases(allFloatArithmeticCases)
      BinaryOp.Mod => handleCases(standardArithmeticCases)
      BinaryOp.Pow => handleCases(allFloatArithmeticCases)
      BinaryOp.And => handleCases(boolOpCases)
      BinaryOp.Or => handleCases(boolOpCases)
      BinaryOp.Xor => handleCases(boolOpCases)
      BinaryOp.Coalesce => {
        // If the lhs isn't a nullable type then we can short-circuit and don't even typecheck the rhs
        val left = match self._typecheckExpression(node.left, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if !left.ty.nullable {
          // Pass Hole as rhs type because it doesn't matter - there's special logic within NoSuchOperator for `?:` used with non-Option types
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, Type(kind: TypeKind.Hole))))
        }

        val requiredTy = Type(kind: left.ty.kind) // non-nullable version of lhs's type
        val right = match self._typecheckExpression(node.right, requiredTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if right.ty.nullable {
          return Result.Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([requiredTy], right.ty)))
        }

        if !self._typeSatisfiesRequired(ty: right.ty, required: requiredTy) {
          return Result.Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([requiredTy], right.ty)))
        }

        Result.Ok(TypedAstNode(token: token, ty: right.ty, kind: TypedAstNodeKind.Binary(left, node.op, right)))
      }
      BinaryOp.Eq => handleEquality()
      BinaryOp.Neq => handleEquality()
      BinaryOp.LT => handleCases(comparisonCases)
      BinaryOp.LTE => handleCases(comparisonCases)
      BinaryOp.Shl => handleCases([(TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt)])
      BinaryOp.GT => handleCases(comparisonCases)
      BinaryOp.GTE => handleCases(comparisonCases)
      BinaryOp.Shr => handleCases([(TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt)])
    }
  }

  func _typecheckIdentifier(self, token: Token, kind: IdentifierKind, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val _p = match kind {
      IdentifierKind.Named(name) => {
        val variable = if self._resolveIdentifier(name) |variable| variable else {
          if self.paramDefaultValueContext |ctx| {
            ctx.exprContainsVariableRef = true
          }
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName(name, "variable")))
        }
        (variable.ty, TypedIdentifierKind.Named(name, variable))
      }
      IdentifierKind.Discard => return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("_", "variable")))
      IdentifierKind.None_ => {
        val kind = typeHint?.kind ?: TypeKind.Hole
        val ty = Type(kind: kind, nullable: true)
        (ty, TypedIdentifierKind.None_)
      }
      IdentifierKind.Self => {
        val variable = if self._resolveIdentifier("self") |variable| variable else {
          if self.paramDefaultValueContext |ctx| {
            ctx.exprContainsVariableRef = true
          }
          return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("self", "variable")))
        }
        (variable.ty, TypedIdentifierKind.Named("self", variable))
      }
    }

    // TODO: destructuring
    Result.Ok(TypedAstNode(token: token, ty: _p[0], kind: TypedAstNodeKind.Identifier(_p[1])))
  }

  func _resolveAccessorPathSegmentAny(self, label: Label): (AccessorPathSegment, Type)? {
    val scope = self.project.preludeScope.makeChild("Any", ScopeKind.Type)
    val method: Function? = if label.name == "toString" {
      Function.generated(scope, "toString", [], Type(kind: TypeKind.PrimitiveString))
    } else if label.name == "hash" {
      Function.generated(scope, "hash", [], Type(kind: TypeKind.PrimitiveInt))
    } else if label.name == "eq" {
      Function.generated(scope, "eq", [("other", Type(kind: TypeKind.Any))], Type(kind: TypeKind.PrimitiveBool))
    } else {
      None
    }

    if method |method| {
      (AccessorPathSegment.Method(label, method), method.getType())
    } else {
      None
    }
  }

  func _resolveAccessorPathSegment(self, ty: Type, label: Label): Result<(AccessorPathSegment, Type)?, TypeError> {
    val foundSegment = match ty.kind {
      TypeKind.Any => self._resolveAccessorPathSegmentAny(label)
      TypeKind.PrimitiveUnit => None
      TypeKind.PrimitiveInt => return self._resolveAccessorPathSegment(Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeIntStruct), [])), label)
      TypeKind.PrimitiveFloat => return self._resolveAccessorPathSegment(Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeFloatStruct), [])), label)
      TypeKind.PrimitiveBool => None
      TypeKind.PrimitiveString => return self._resolveAccessorPathSegment(Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeStringStruct), [])), label)
      TypeKind.Never => None
      TypeKind.Generic => self._resolveAccessorPathSegmentAny(label)
      TypeKind.Instance(structOrEnum, generics) => {
        val _p = match structOrEnum {
          StructOrEnum.Struct(struct) => {
            for field in struct.fields {
              if field.name.name == label.name {
                val resolvedGenerics: Map<String, Type> = {}
                for name, idx in struct.typeParams {
                  resolvedGenerics[name] = if generics[idx] |g| g else return unreachable(label.position, "typeParams.length != generics.length")
                }
                val ty = field.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
                return Result.Ok((AccessorPathSegment.Field(label, field), ty))
              }
            }

            (struct.instanceMethods, struct.typeParams)
          }
          StructOrEnum.Enum(enum_) => (enum_.instanceMethods, enum_.typeParams)
        }
        // TODO: destructuring
        val instanceMethods = _p[0]
        val typeParams = _p[1]

        for fn in instanceMethods {
          if fn.label.name == label.name {
            val resolvedGenerics: Map<String, Type> = {}
            for name, idx in typeParams {
              resolvedGenerics[name] = if generics[idx] |g| g else return unreachable(label.position, "typeParams.length != generics.length")
            }
            val method = if resolvedGenerics.isEmpty() fn else fn.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: true, genericsInScope: #{})
            return Result.Ok((AccessorPathSegment.Method(label, method), method.getType()))
          }
        }

        None
      }
      TypeKind.Tuple => None
      TypeKind.Func => None
      TypeKind.Type(structOrEnum) => {
        // TODO: static fields

        val staticMethods = match structOrEnum {
          StructOrEnum.Struct(struct) => struct.staticMethods
          StructOrEnum.Enum(enum_) => {
            for variant in enum_.variants {
              if variant.label.name == label.name {
                val typeArgs = enum_.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
                val ty = Type(kind: TypeKind.Instance(StructOrEnum.Enum(enum_), typeArgs))

                match variant.kind {
                  EnumVariantKind.Container => {
                    if !self.isEnumContainerValueAllowed return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalValueType(ty, "value")))
                  }
                  _ => {}
                }

                return Result.Ok((AccessorPathSegment.EnumVariant(label, enum_, variant), ty))
              }
            }

            enum_.staticMethods
          }
        }

        for method in staticMethods {
          if method.label.name == label.name return Result.Ok((AccessorPathSegment.Method(label, method), method.getType()))
        }

        None
      }
      TypeKind.Hole => None
    }

    Result.Ok(foundSegment)
  }

  func _resolveModuleAliasAccessor(self, root: AstNode, field: (Token, Label)): Result<TypedAstNode?, TypeError> {
    val _mod = match root.kind {
      AstNodeKind.Identifier(identKind) => {
        val m = match identKind {
          IdentifierKind.Named(name) => {
            val m = match self._findModuleByAlias(name) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            m
          }
          _ => None
        }
        m
      }
      _ => None
    }

    val identifierNode = if _mod |_mod| {
      // TODO: destructuring
      val mod = _mod[0]
      val aliasLabel = _mod[1]

      // TODO: destructuring
      val dotTok = field[0]
      val label = field[1]
      if dotTok.kind == TokenKind.QuestionDot return Result.Err(TypeError(position: dotTok.position, kind: TypeErrorKind.UnnecessaryOptSafety))

      val exportVar = match mod.exports[label.name] {
        None => return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownImportForAlias(label.name, aliasLabel)))
        Export.Variable(v) => v
        Export.Function(v) => v
        Export.Type(_, v) => v
      }

      val token = Token(position: label.position, kind: TokenKind.Ident(label.name))
      val identifierKind = TypedIdentifierKind.Named(label.name, exportVar)
      TypedAstNode(token: token, ty: exportVar.ty, kind: TypedAstNodeKind.Identifier(identifierKind))
    } else None

    Result.Ok(identifierNode)
  }

  func _typecheckAccessor(self, token: Token, node: AccessorAstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    var accessorPath = node.path

    val _firstSeg = if accessorPath[0] |p| p else return unreachable(token.position, "path should have at least 1 segment")
    val maybeModuleAccessor = match self._resolveModuleAliasAccessor(node.root, _firstSeg) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    val typedRoot = if maybeModuleAccessor |n| {
      if accessorPath.length == 1 return Result.Ok(n)

      accessorPath = accessorPath[1:]
      n
    } else {
      self.isStructOrEnumValueAllowed = true
      val typedNode = match self._typecheckExpression(node.root, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      self.isStructOrEnumValueAllowed = false
      typedNode
    }

    val path: AccessorPathSegment[] = []
    var ty = typedRoot.ty
    var isNullable = ty.nullable
    for _p, idx in accessorPath {
      // TODO: destructuring
      val token = _p[0]
      val label = _p[1]
      val isOptSafe = token.kind == TokenKind.QuestionDot
      if isOptSafe && !isNullable {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.UnnecessaryOptSafety))
      }

      val seg = match self._resolveAccessorPathSegment(ty, label) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      ty = if seg |_s| {
        // TODO: destructuring
        val seg = _s[0]
        val nextTy = _s[1]
        if isNullable && !isOptSafe {
          return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownField(ty, label.name, UnknownFieldSpecialCase.ExistsButTypeIsNullable)))
        }

        path.push(seg)
        isNullable ||= nextTy.nullable
        nextTy
      } else {
        val isSpecialCase = match ty.kind {
          TypeKind.Instance(structOrEnum, _) => {
            val seg = match structOrEnum {
              StructOrEnum.Struct(struct) => {
                val seg = match self._resolveAccessorPathSegment(Type(kind: TypeKind.Type(StructOrEnum.Struct(struct))), label) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
                seg
              }
              StructOrEnum.Enum(enum_) => {
                val seg = match self._resolveAccessorPathSegment(Type(kind: TypeKind.Type(StructOrEnum.Enum(enum_))), label) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
                seg
              }
            }
            !!seg
          }
          _ => false
        }

        val specialCase = if isSpecialCase UnknownFieldSpecialCase.StaticFieldReferencedAsInstance else None
        return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownField(ty, label.name, specialCase)))
      }
    }

    val finalField = if path.pop() |f| f else return unreachable(node.root.token.position, "the accessor path should not be empty")

    val resTy = Type(kind: ty.kind, nullable: isNullable)
    Result.Ok(TypedAstNode(token: token, ty: resTy, kind: TypedAstNodeKind.Accessor(typedRoot, path, finalField)))
  }

  func _typecheckInvocation(self, token: Token, node: InvocationAstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    self.isStructOrEnumValueAllowed = true
    self.isEnumContainerValueAllowed = true
    val invokee = match self._typecheckExpression(node.invokee, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    self.isEnumContainerValueAllowed = false
    self.isStructOrEnumValueAllowed = false

    match invokee.kind {
      TypedAstNodeKind.Identifier(identKind) => match identKind {
        TypedIdentifierKind.Named(name, variable) => {
          match variable.alias {
            VariableAlias.Function(fn) => self._typecheckInvocationOfFunction(token, invokee, fn, node, typeHint)
            VariableAlias.Struct(struct) => {
              val initializerFn = Function.initializer(self.currentScope, struct)
              self._typecheckInvocationOfFunction(token, invokee, initializerFn, node, typeHint, Instantiatable.Struct(struct))
            }
            VariableAlias.Enum(enum_) => return Result.Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.IllegalCallableType(Type(kind: TypeKind.Type(StructOrEnum.Enum(enum_))))))
            None => self._typecheckInvocationOfExpression(token, invokee, invokee.token.position, node)
          }
        }
        TypedIdentifierKind.None_ => return Result.Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.IllegalCallableType(Type(kind: TypeKind.Hole, nullable: true))))
        TypedIdentifierKind.Discard => return unreachable(invokee.token.position, "resolving '_' should fail before reaching here")
      }
      TypedAstNodeKind.Accessor(_, _, tail) => {
        match tail {
          AccessorPathSegment.EnumVariant(label, enum_, variant) => {
            val fields = match variant.kind {
              EnumVariantKind.Constant => return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalCallableType(invokee.ty)))
              EnumVariantKind.Container(fields) => fields
            }

            val enumVariantAsFn = Function.forEnumVariant(self.currentScope, enum_, variant.label, fields)

            self._typecheckInvocationOfFunction(token, invokee, enumVariantAsFn, node, typeHint, Instantiatable.EnumContainerVariant(enum_, variant, fields))
          }
          AccessorPathSegment.Method(_, fn) => self._typecheckInvocationOfFunction(token, invokee, fn, node, typeHint)
          AccessorPathSegment.Field(label) => self._typecheckInvocationOfExpression(token, invokee, label.position, node)
        }
      }
      _ => self._typecheckInvocationOfExpression(token, invokee, invokee.token.position, node)
    }
  }

  func _typecheckInvocationOfExpression(self, token: Token, invokeeExpr: TypedAstNode, exprPos: Position, invocationNode: InvocationAstNode): Result<TypedAstNode, TypeError> {
    val _pair = match invokeeExpr.ty.kind {
      TypeKind.Func(paramTypes, returnType) => (paramTypes.map(p => p[0]), returnType)
      _ => return Result.Err(TypeError(position: exprPos, kind: TypeErrorKind.IllegalCallableType(invokeeExpr.ty)))
    }
    // TODO: destructuring
    val paramTypes = _pair[0]
    val returnType = _pair[1]

    if self.paramDefaultValueContext |ctx| {
      ctx.exprContainsFunctionCall = true
      return Result.Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Placeholder))
    }

    val typedArguments: TypedAstNode?[] = []
    for arg, idx in invocationNode.arguments {
      if arg.label |label| {
        return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalParameterLabel))
      }

      var paramType = if paramTypes[idx] |t| t else {
        return Result.Err(TypeError(position: arg.position(), kind: TypeErrorKind.WrongInvocationArity(expected: paramTypes.length, given: invocationNode.arguments.length)))
      }

      val typedArg = match self._typecheckExpression(arg.value, paramType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if !self._typeSatisfiesRequired(ty: typedArg.ty, required: paramType) {
        return Result.Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(None, paramType, typedArg.ty)))
      }
      typedArguments.push(typedArg)
    }

    if typedArguments.length < paramTypes.length {
      return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.WrongInvocationArity(expected: paramTypes.length, given: typedArguments.length)))
    }

    val typedInvokee = TypedInvokee.Expr(invokeeExpr)
    Result.Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Invocation(typedInvokee, typedArguments)))
  }

  func _typecheckInvocationOfFunction(self, token: Token, invokee: TypedAstNode, fn: Function, invocationNode: InvocationAstNode, typeHint: Type?, instantiationOf: Instantiatable? = None): Result<TypedAstNode, TypeError> {
    // Function invocation is position-based for required parameters, with optional parameter labels to express call-site intent (ie. for Bool params), and it's
    // an error if a positional parameter's label is incorrect. Once we reach any optional parameters in the argument list, parameters can either be positional
    // OR labeled, but once a labeled optional parameter is seen, all subsequent arguments in the argument list must also be labeled.
    val paramsByName = fn.params.keyBy(p => p.label.name)
    val typedArgumentsByName: Map<String, TypedAstNode> = {}
    val resolvedGenerics: Map<String, Type> = {}

    if !invocationNode.typeArguments.isEmpty() {
      for generic, idx in fn.typeParams {
        val typeArg = if invocationNode.typeArguments[idx] |typeArg| typeArg else {
          return Result.Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: fn.typeParams.length, given: invocationNode.typeArguments.length)))
        }
        val typeArgTy = match self._resolveTypeIdentifier(typeArg) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        resolvedGenerics[generic[1].name] = typeArgTy
      }
      if invocationNode.typeArguments.length > fn.typeParams.length {
        return Result.Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: fn.typeParams.length, given: invocationNode.typeArguments.length)))
      }
    }

    if typeHint |hint| {
      if hint.kind != TypeKind.PrimitiveUnit && self._containsGenerics(fn.returnType) {
        val extractedGenerics = self._extractGenerics(template: fn.returnType, source: hint)

        for _p in extractedGenerics {
          if resolvedGenerics[_p[0]] |original| {
            if original != _p[1] {
              val returnType = fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
              return Result.Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.TypeMismatch([hint], returnType)))
            }
            continue
          }
          resolvedGenerics[_p[0]] = _p[1]
        }
      }
    }

    if self.paramDefaultValueContext |ctx| {
      ctx.exprContainsFunctionCall = true

      val returnType = if self._containsGenerics(fn.returnType) {
        fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
      } else {
        fn.returnType.clone()
      }
      return Result.Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Placeholder))
    }

    var hasBegunOptionalParams = false
    var variadicParam: (TypedFunctionParam, Int)? = None
    val variadicArgs: TypedAstNode[] = []
    var mostRecentLabeledOptionalParam: Label? = None
    val argumentsQueue = invocationNode.arguments.map((arg, idx) => (arg, idx, 0))
    for _a in argumentsQueue {
      // TODO: destructuring
      val arg = _a[0]
      val idx = if variadicParam |p| p[1] else _a[1]
      val numAttempts = _a[2]

      var param = if fn.params[idx] |param| param else {
        return Result.Err(TypeError(position: arg.position(), kind: TypeErrorKind.WrongInvocationArity(expected: fn.params.length, given: invocationNode.arguments.length)))
      }
      if (!!param.defaultValue) || param.isVariadic { hasBegunOptionalParams = true }

      var paramTy = param.ty
      if arg.label |label| {
        if label.name != param.label.name {
          if !hasBegunOptionalParams {
            return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.ParameterLabelMismatch(expected: param.label.name, given: label.name)))
          }

          param = if paramsByName[label.name] |p| p else {
            return Result.Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownParameterName(label.name)))
          }
          paramTy = param.ty
        }
        if hasBegunOptionalParams && !mostRecentLabeledOptionalParam {
          mostRecentLabeledOptionalParam = label
        }
        if param.isVariadic {
          paramTy = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [paramTy]))
        }
      } else if instantiationOf {
        return Result.Err(TypeError(position: arg.position(), kind: TypeErrorKind.MissingRequiredArgumentLabel))
      } else if mostRecentLabeledOptionalParam |label| {
        return Result.Err(TypeError(position: arg.position(), kind: TypeErrorKind.MixedArgumentType(label)))
      } else {
        if param.isVariadic { variadicParam = (param, idx) }
      }

      val _p = if self._containsGenerics(param.ty) {
        var paramType = paramTy.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})

        val typedArg = match self._typecheckExpression(arg.value, paramType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        if numAttempts < 1 && typedArg.ty.hasUnfilledHoles() {
          argumentsQueue.push((_a[0], _a[1], numAttempts + 1))
          continue
        }

        val extractedGenerics = self._extractGenerics(template: paramTy, source: typedArg.ty)

        for _p in extractedGenerics {
          if resolvedGenerics[_p[0]] |original| {
            if original != _p[1] {
              return Result.Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(param.label.name, original, typedArg.ty)))
            }
            continue
          }
          resolvedGenerics[_p[0]] = _p[1]
        }

        paramType = paramTy.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
        (typedArg, paramType)
      } else {
        val typedArg = match self._typecheckExpression(arg.value, paramTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        (typedArg, paramTy)
      }
      // TODO: destructuring
      val typedArg = _p[0]
      val paramType = _p[1]
      if !self._typeSatisfiesRequired(ty: typedArg.ty, required: paramType) {
        return Result.Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(param.label.name, paramType, typedArg.ty)))
      }

      if variadicParam {
        variadicArgs.push(typedArg)
      } else {
        typedArgumentsByName[param.label.name] = typedArg
      }
    }

    if variadicParam |_p| {
      val param = _p[0]
      var innerType = param.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
      val paramType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [innerType]))
      typedArgumentsByName[param.label.name] = TypedAstNode(token: token, ty: paramType, kind: TypedAstNodeKind.Array(variadicArgs))
    }

    val typedArguments: TypedAstNode?[] = []
    for param in fn.params {
      if typedArgumentsByName[param.label.name] |argValue| {
        typedArguments.push(argValue)
      } else if param.defaultValue {
        typedArguments.push(None)
      } else if param.isVariadic {
        var innerType = param.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
        val paramType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [innerType]))
        typedArguments.push(TypedAstNode(token: token, ty: paramType, kind: TypedAstNodeKind.Array([])))
      } else {
        val errorKind = if instantiationOf |i| {
          val missing = match i {
            Instantiatable.Struct(struct) => {
              struct.fields
                .filter(f => !f.initializer && !typedArgumentsByName.containsKey(f.name.name))
                .map(f => f.name.name)
            }
            Instantiatable.EnumContainerVariant(_, _, fields) => {
              fields
                .filter(f => !f.initializer && !typedArgumentsByName.containsKey(f.name.name))
                .map(f => f.name.name)
            }
          }
          TypeErrorKind.MissingRequiredFields(missing)
        } else {
          val numRequired = fn.params.filter(p => !p.defaultValue).length
          TypeErrorKind.WrongInvocationArity(expected: numRequired, given: invocationNode.arguments.length)
        }

        return Result.Err(TypeError(position: token.position, kind: errorKind))
      }
    }

    val genericsInScope = self._genericsInScope()
    val returnType = if self._containsGenerics(fn.returnType) {
      fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)
    } else {
      fn.returnType.clone()
    }

    val typedInvokee = if instantiationOf |i| {
      val v = match i {
        Instantiatable.Struct(struct) => TypedInvokee.Struct(struct)
        Instantiatable.EnumContainerVariant(enum_, variant, _) => TypedInvokee.EnumVariant(enum_, variant)
      }
      v
    } else {
      TypedInvokee.Expr(invokee)
    }

    Result.Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Invocation(typedInvokee, typedArguments)))
  }

  func _typecheckArray(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerHintIsNullable = true
    var innerType: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance1(hint, self.project.preludeArrayStruct) |inner| {
        if inner.kind != TypeKind.Hole {
          innerHintIsNullable = inner.nullable
          innerType = inner
        }
      }
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = match self._typecheckExpression(node: node, typeHint: innerType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      makeItemsNullable ||= typedItem.ty.nullable
      if innerType |ty| {
        // Working inner type becomes nullable if we've discovered a nullable type and if the hint allows nullness (an absent hint allows nullness).
        if makeItemsNullable && innerHintIsNullable {
          ty.nullable = true
        }

        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          return Result.Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
        }
      } else if !typedItem.ty.hasUnfilledHoles() {
        innerType = typedItem.ty
      }
      typedItems.push(typedItem)
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeArrayStruct), [inner]))
    val innerHasUnfilledHoles = inner.hasUnfilledHoles()

    for item in typedItems {
      if makeItemsNullable { item.ty.nullable = true }

      if !innerHasUnfilledHoles && item.ty.hasUnfilledHoles() {
        item.ty.tryFillHoles(inner)
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Array(typedItems)))
  }

  func _typecheckSet(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerHintIsNullable = true
    var innerType: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance1(hint, self.project.preludeSetStruct) |inner| {
        if inner.kind != TypeKind.Hole {
          innerHintIsNullable = inner.nullable
          innerType = inner
        }
      }
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = match self._typecheckExpression(node: node, typeHint: innerType) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      makeItemsNullable ||= typedItem.ty.nullable
      if innerType |ty| {
        // Working inner type becomes nullable if we've discovered a nullable type and if the hint allows nullness (an absent hint allows nullness).
        if makeItemsNullable && innerHintIsNullable {
          ty.nullable = true
        }

        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          return Result.Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
        }
      } else if !typedItem.ty.hasUnfilledHoles() {
        innerType = typedItem.ty
      }
      typedItems.push(typedItem)
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeSetStruct), [inner]))
    val innerHasUnfilledHoles = inner.hasUnfilledHoles()

    for item in typedItems {
      if makeItemsNullable { item.ty.nullable = true }

      if !innerHasUnfilledHoles && item.ty.hasUnfilledHoles() {
        item.ty.tryFillHoles(inner)
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Set(typedItems)))
  }

  func _typecheckMap(self, token: Token, items: (AstNode, AstNode)[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var keyHintIsNullable = true
    var keyTy: Type? = None
    var valHintIsNullable = true
    var valTy: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance2(hint, self.project.preludeMapStruct) |_p| {
        // TODO: destructuring
        val keyHintTy = _p[0]
        val valHintTy = _p[1]
        if keyHintTy.kind != TypeKind.Hole {
          keyHintIsNullable = keyHintTy.nullable
          keyTy = keyHintTy
        }
        if valHintTy.kind != TypeKind.Hole {
          valHintIsNullable = valHintTy.nullable
          valTy = valHintTy
        }
      }
    }

    var makeKeysNullable = false
    var makeValsNullable = false
    val typedItems: (TypedAstNode, TypedAstNode)[] = []
    for _p in items {
      // TODO: destructuring
      val keyNode = _p[0]
      val valNode = _p[1]

      val typedKey = match keyNode.kind {
        AstNodeKind.Identifier(identKind) => match identKind {
          IdentifierKind.Named(name) => TypedAstNode(token: keyNode.token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.Literal(LiteralAstNode.String(name)))
          IdentifierKind.Discard => TypedAstNode(token: keyNode.token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.Literal(LiteralAstNode.String("_")))
          IdentifierKind.Self => {
            val e = match self._typecheckExpression(node: keyNode, typeHint: keyTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            e
          }
          IdentifierKind.None_ => {
            val e = match self._typecheckExpression(node: keyNode, typeHint: keyTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
            e
          }
        }
        _ => {
          val e = match self._typecheckExpression(node: keyNode, typeHint: keyTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          e
        }
      }
      makeKeysNullable ||= typedKey.ty.nullable

      if keyTy |ty| {
        // Working inner type for key becomes nullable if we've discovered a nullable key and if the key hint allows nullness (an absent hint allows nullness).
        if makeKeysNullable && keyHintIsNullable {
          ty.nullable = true
        }

        if !self._typeSatisfiesRequired(ty: typedKey.ty, required: ty) {
          return Result.Err(TypeError(position: typedKey.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedKey.ty)))
        }
      } else if !typedKey.ty.hasUnfilledHoles() {
        keyTy = typedKey.ty
      }

      val typedVal = match self._typecheckExpression(node: valNode, typeHint: valTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      makeValsNullable ||= typedVal.ty.nullable
      if valTy |ty| {
        // Working inner type for val becomes nullable if we've discovered a nullable val and if the val hint allows nullness (an absent hint allows nullness).
        if makeValsNullable && valHintIsNullable {
          ty.nullable = true
        }

        if !self._typeSatisfiesRequired(ty: typedVal.ty, required: ty) {
          return Result.Err(TypeError(position: typedVal.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedVal.ty)))
        }
      } else if !typedVal.ty.hasUnfilledHoles() {
        valTy = typedVal.ty
      }

      typedItems.push((typedKey, typedVal))
    }

    val kTy = keyTy ?: Type(kind: TypeKind.Hole)
    val vTy = valTy ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self.project.preludeMapStruct), [kTy, vTy]))
    val keyTyHasUnfilledHoles = kTy.hasUnfilledHoles()
    val valTyHasUnfilledHoles = vTy.hasUnfilledHoles()

    for _p in typedItems {
      // TODO: destructuring
      val typedKey = _p[0]
      val typedVal = _p[1]

      if makeKeysNullable { typedKey.ty.nullable = true }
      if makeValsNullable { typedVal.ty.nullable = true }

      if !keyTyHasUnfilledHoles && typedKey.ty.hasUnfilledHoles() { typedKey.ty.tryFillHoles(kTy) }
      if !valTyHasUnfilledHoles && typedVal.ty.hasUnfilledHoles() { typedVal.ty.tryFillHoles(vTy) }
     }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Map(typedItems)))
  }

  func _typecheckTuple(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var typeHints: Type[]? = None
    if typeHint |hint| {
      match hint.kind {
        TypeKind.Tuple(types) => typeHints = types
        _ => {}
      }
    }

    val typedItems: TypedAstNode[] = []
    for node, idx in items {
      val typeHint = if typeHints |typeHints| typeHints[idx]
      val typedExpr = match self._typecheckExpression(node, typeHint) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
      if typeHint |hint| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: hint) {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([hint], typedExpr.ty)))
        }
      }
      typedItems.push(typedExpr)
    }
    val ty = Type(kind: TypeKind.Tuple(typedItems.map(item => item.ty)))
    if typeHints |typeHints| {
      val hintTy = Type(kind: TypeKind.Tuple(typeHints))
      if !self._typeSatisfiesRequired(ty: ty, required: hintTy) {
        return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.TypeMismatch([hintTy], ty)))
      }
    }

    Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Tuple(typedItems)))
  }

  func _typecheckIndexing(self, token: Token, expr: AstNode, indexMode: IndexingMode<AstNode>, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val typedExpr = match self._typecheckExpression(expr, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    if typedExpr.ty.nullable {
      return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
    }

    val res = match typedExpr.ty.kind {
      TypeKind.PrimitiveString => {
        val resTy = Type(kind: TypeKind.PrimitiveString)
        self._typecheckIndexingArraylike(token: token, typedExpr: typedExpr, indexMode: indexMode, singleModeType: resTy, rangeModeType: resTy)
      }
      TypeKind.Tuple(types) => self._typecheckIndexingTuple(token, types, typedExpr, indexMode)
      TypeKind.Instance(struct, typeArgs) => {
        if self._typeAsInstance1(typedExpr.ty, self.project.preludeArrayStruct) |inner| {
          self._typecheckIndexingArraylike(token: token, typedExpr: typedExpr, indexMode: indexMode, singleModeType: Type(kind: inner.kind, nullable: true), rangeModeType: typedExpr.ty)
        } else if self._typeAsInstance2(typedExpr.ty, self.project.preludeMapStruct) |_p| {
          // TODO: destructuring
          val keyTy = _p[0]
          val valTy = _p[1]

          match indexMode {
            IndexingMode.Single(idxExpr) => {
              val typedIdxExpr = match self._typecheckExpression(idxExpr, keyTy) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
              if !self._typeSatisfiesRequired(ty: typedIdxExpr.ty, required: keyTy) {
                return Result.Err(TypeError(position: typedIdxExpr.token.position, kind: TypeErrorKind.TypeMismatch([keyTy], typedIdxExpr.ty)))
              }

              val ty = Type(kind: valTy.kind, nullable: true)
              Result.Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.Map(typedExpr, typedIdxExpr))))
            }
            IndexingMode.Range => return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: true)))
          }
        } else {
          return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
        }
      }
      _ => return Result.Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
    }

    res
  }

  func _typecheckIndexingArraylike(self, token: Token, typedExpr: TypedAstNode, indexMode: IndexingMode<AstNode>, singleModeType: Type, rangeModeType: Type): Result<TypedAstNode, TypeError> {
    match indexMode {
      IndexingMode.Single(idxExpr) => {
        val typedIdxExpr = match self._typecheckExpression(idxExpr, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
        val idxTy = typedIdxExpr.ty
        if idxTy.nullable || idxTy.kind != TypeKind.PrimitiveInt {
          return Result.Err(TypeError(position: typedIdxExpr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], idxTy)))
        }

        val typedIndexMode = IndexingMode.Single(typedIdxExpr)
        return Result.Ok(TypedAstNode(token: token, ty: singleModeType, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.ArrayLike(typedExpr, typedIndexMode))))
      }
      IndexingMode.Range(startExpr, endExpr) => {
        val typedStartExpr = if startExpr |expr| {
          val e = match self._typecheckExpression(expr, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          if e.ty.nullable || e.ty.kind != TypeKind.PrimitiveInt {
            return Result.Err(TypeError(position: e.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], e.ty)))
          }
          e
        }
        val typedEndExpr = if endExpr |expr| {
          val e = match self._typecheckExpression(expr, None) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
          if e.ty.nullable || e.ty.kind != TypeKind.PrimitiveInt {
            return Result.Err(TypeError(position: e.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], e.ty)))
          }
          e
        }
        val typedIndexMode = IndexingMode.Range(typedStartExpr, typedEndExpr)
        return Result.Ok(TypedAstNode(token: token, ty: rangeModeType, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.ArrayLike(typedExpr, typedIndexMode))))
      }
    }
  }

  func _typecheckIndexingTuple(self, token: Token, tupleItemTypes: Type[], tupleExpr: TypedAstNode, indexMode: IndexingMode<AstNode>): Result<TypedAstNode, TypeError> {
    match indexMode {
      IndexingMode.Single(idxExpr) => {
        match idxExpr.kind {
          AstNodeKind.Literal(lit) => {
            match lit {
              LiteralAstNode.Int(i) => {
                val itemTy = if i < 0
                  return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.IndexNegative)))
                else if tupleItemTypes[i] |ty|
                  ty
                else
                  return Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.IndexOutOfBounds)))

                Result.Ok(TypedAstNode(token: token, ty: itemTy, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.Tuple(tupleExpr, i))))
              }
              _ => Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.NotIntLiteral)))
            }
          }
          _ => Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.NotLiteralNode)))
        }
      }
      // TODO: should tuples be indexable as a range? it could just create a sub-tuple copy? is that useful at all? seems silly to forbid it
      IndexingMode.Range => Result.Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalIndexableType(ty: tupleExpr.ty, isRange: true)))
    }
  }

  func _typecheckLambda(self, token: Token, node: LambdaNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    var paramHints: Type[] = []
    var retHint: Type? = None
    if typeHint |hint| {
      match hint.kind {
        TypeKind.Func(paramTypes, retType) => {
          paramHints = paramTypes.map(_p => {
            val ty = _p[0]
            val isRequired = _p[1]
            if !isRequired {
              // pseudo-assert
              println("unexpected non-required param in TypeKind.Func")
            }

            ty
          })
          retHint = retType
        }
        _ => {}
      }
    }

    val lambdaName = self.currentScope.nextLambdaName()
    val fnScope = self.currentScope.makeChild(lambdaName, ScopeKind.Func)
    val returnType = retHint ?: Type(kind: TypeKind.Hole)
    val fn = Function(
      label: Label(name: lambdaName, position: token.position),
      scope: fnScope,
      kind: FunctionKind.Standalone,
      returnType: returnType,
      isLambda: true,
    )

    val paramsNeedingRevisit = match self._typecheckFunctionPass2(fn: fn, allowSelf: false, params: node.params, paramHints: paramHints) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }
    match self._typecheckFunctionPass3(fn: fn, allowSelf: false, params: node.params, body: node.body, paramsNeedingRevisit: paramsNeedingRevisit) { Result.Ok(v) => v, Result.Err(e) => return Result.Err(e) }

    val lambdaTy = fn.getType()

    Result.Ok(TypedAstNode(token: token, ty: lambdaTy, kind: TypedAstNodeKind.Lambda(fn)))
  }
}

func todo<V>(position: Position, reason = ""): Result<V, TypeError> {
  Result.Err(TypeError(position: position, kind: TypeErrorKind.NotYetImplemented(reason)))
}

func unreachable<V>(position: Position, message: String): Result<V, TypeError> {
  Result.Err(TypeError(position: position, kind: TypeErrorKind.Unreachable(message)))
}