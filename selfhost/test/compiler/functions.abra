// Default-valued parameters
func foo(a: Int, b = bar(a), c = bar(a, b), arr = [a, b, c]): Int = a + b + c + arr.length
func bar(x: Int, y = 10): Int = x + y
/// Expect: 31
println(foo(2))

// Variadic parameters
func variadic(*items: Int[]) = println(items)
/// Expect: [1, 2, 3]
variadic(1, 2, 3)
/// Expect: []
variadic()

// Functions and closures as value (lambdas too)
func abc(): Int = 24
/// Expect: <#function>
println(abc)
val abcVal = abc
/// Expect: <#function> 24
println(abcVal, abcVal())

func def(a: Int): Int = a + 1
val defVal = def
/// Expect: 24
println(defVal(23))

func ghi(a: Int, b: Int): Int = a + b
val ghiVal = ghi
/// Expect: 24
println(ghiVal(11, 13))

func callFn(fn: (Int) => Int) = println(fn(16))
func callFn2(fn: (Int, Int, Int) => Int) = println(fn(16, 17, 18))
func callFn3(fn: (Int, Int, Int, Int) => Int) = println(fn(16, 17, 18, 19))

// val xyz = "xyz"

func f0(x: Int): Int = x
// func f0Closure(x: Int): Int = x + xyz.length
/// Expect: 16
callFn(f0)
/// Expect: 16
callFn(x => x)
// /// Expect: 19
// callFn(f0Closure)
// /// Expect: 19
// callFn(x => x + xyz.length)

func f1(x = 12): Int = x
// func f1Closure(x = 12): Int = x + xyz.length
/// Expect: 16
callFn(f1)
/// Expect: 16
callFn((x = 12) => x)
// /// Expect: 19
// callFn(f1Closure)
// /// Expect: 19
// callFn((x = 12) => x + xyz.length)

func f2(x: Int, y = 6): Int = x + y
// func f2Closure(x: Int, y = 6): Int = x + y + xyz.length
/// Expect: 22
callFn(f2)
/// Expect: 22
callFn((x, y = 6) => x + y)
// /// Expect: 25
// callFn(f2Closure)
// /// Expect: 25
// callFn((x, y = 6) => x + y + xyz.length)

func f3(x = 12, y = 6): Int = x + y
// func f3Closure(x = 12, y = 6): Int = x + y + xyz.length
/// Expect: 22
callFn(f3)
/// Expect: 22
callFn((x = 12, y = 6) => x + y)
// /// Expect: 25
// callFn(f3Closure)
// /// Expect: 25
// callFn((x = 12, y = 6) => x + y + xyz.length)

func f4(x: Int): Int = x
// func f4Closure(x: Int): Int = x + xyz.length
/// Expect: 16
callFn2(f4)
/// Expect: 16
callFn2(x => x)
// /// Expect: 19
// callFn2(f4Closure)
// /// Expect: 19
// callFn2(x => x + xyz.length)

func f5(x: Int, y: Int): Int = x + y
// func f5Closure(x: Int, y: Int): Int = x + y + xyz.length
/// Expect: 33
callFn2(f5)
/// Expect: 33
callFn2((x, y) => x + y)
// /// Expect: 36
// callFn2(f5Closure)
// /// Expect: 36
// callFn2((x, y) => x + y + xyz.length)

func f6(x: Int, y = 12): Int = x + y
// func f6Closure(x: Int, y = 12): Int = x + y + xyz.length
/// Expect: 33
callFn2(f6)
/// Expect: 33
callFn2((x, y = 12) => x + y)
// /// Expect: 36
// callFn2(f6Closure)
// /// Expect: 36
// callFn2((x, y = 12) => x + y + xyz.length)

func f7(x: Int, y = 12, z = 100): Int = x + y + z
// func f7Closure(x: Int, y = 12, z = 100): Int = x + y + z + xyz.length
/// Expect: 51
callFn3(f7)
/// Expect: 51
callFn3((x, y = 12, z = 100) => x + y + z)
// /// Expect: 54
// callFn3(f7Closure)
// /// Expect: 54
// callFn3((x, y = 12, z = 100) => x + y + z + xyz.length)

// Closures
var capturedFloat = 1.1
func closure1(one: Int): Float {
  capturedFloat += 1.1
  val x = capturedFloat + one
  x
}
/// Expect: 1.1
println(capturedFloat)
/// Expect: 3.2
println(closure1(one: 1))
/// Expect: 2.2
println(capturedFloat)

capturedFloat = 10.1
/// Expect: 10.1
println(capturedFloat)
/// Expect: 12.2
println(closure1(one: 1))
/// Expect: 11.2
println(capturedFloat)

val capturedArray = [1, 2, 3]
func closure2(zero = 0): Int {
  capturedArray.pop()
  capturedArray.length + zero
}
/// Expect: [1, 2, 3]
println(capturedArray)
/// Expect: 2
println(closure2())
/// Expect: [1, 2]
println(capturedArray)
capturedArray.push(3)
/// Expect: [1, 2, 3]
println(capturedArray)

var capturedInt = 1
func closure3<T>(arr: T[], extra = 0) {
  capturedInt += arr.length + extra
}

/// Expect: 1
println(capturedInt)
closure3([1, 2, 3])
/// Expect: 4
println(capturedInt)
capturedInt = 1
closure3(["a", "b"], 12)
/// Expect: 15
println(capturedInt)

func closure4(a: Int, b = a + capturedInt): Int = a + b
/// Expect: 3
println(closure4(1, 2))
/// Expect: 16
capturedInt = 14
println(closure4(1))

// capturedInt = 1
// func closure5() { capturedInt += 2 }
// func containsClosures1() { closure5() }
// func containsClosures2() { containsClosures1() }

// /// Expect: 1
// println(capturedInt)
// containsClosures2()
// /// Expect: 3
// println(capturedInt)
// containsClosures2()
// /// Expect: 5
// println(capturedInt)

// // Returning a function/closure value
// func makeNonClosure(): (Int) => Int = i => i + 1
// val nonClosure = makeNonClosure()
// /// Expect: 12
// println(nonClosure(11))

// val one = 1
// func makeClosureCapturingOutside(): (Int) => Int {
//   i => i + one
// }
// val closureCapturingOutside = makeClosureCapturingOutside()
// /// Expect: 12
// println(closureCapturingOutside(11))

// func makeAdder(x: Int): (Int) => Int {
//   i => i + x
// }
// val addOne = makeAdder(1)
// /// Expect: 12
// println(addOne(11))

// val capturedArr = [1, 2, 3]
// func makeClosureCapturingOutsideAndParam(arr: Int[]): (Int) => Int {
//   val f = (i: Int) => i + arr.length + one
//   arr.pop()
//   f
// }
// val closureCapturingOutsideAndParam = makeClosureCapturingOutsideAndParam(capturedArr)
// /// Expect: [1, 2]
// println(capturedArr)
// capturedArr.push(3)
// /// Expect: [1, 2, 3]
// println(capturedArr)
// /// Expect: 15
// println(closureCapturingOutsideAndParam(11))

// // This is a pretty cool stress-test for closures and functions as values
// type JankInstance<A, B> {
//   a: A
//   b: B
//   setA: (A) => A
//   setB: (B) => B
//   toString: () => String
// }
// func makeJankClass(className: String, a: Int, b: Float[]): JankInstance<Int, Float[]> {
//   var selfA = a
//   var selfB = b

//   JankInstance(
//     a: a,
//     b: b,
//     setA: a => selfA = a,
//     setB: b => selfB = b,
//     toString: () => "$className(a: $selfA, b: $selfB)"
//   )
// }
// val jank = makeJankClass("Wow", 1, [2.3, 4.5])
// /// Expect: Wow(a: 1, b: [2.3, 4.5])
// println(jank.toString())

// jank.setA(0)
// jank.setB([1.2, 3.4])
// /// Expect: Wow(a: 0, b: [1.2, 3.4])
// println(jank.toString())

// // Return statements in if-expressions
// func returnExprInArr(i: Int): Int[] {
//   val arr = [
//     1,
//     if i == 0 { return [] } else 2,
//     3
//   ]

//   arr
// }
// /// Expect: []
// println(returnExprInArr(0))
// /// Expect: [1, 2, 3]
// println(returnExprInArr(1))

// func returnInVarDecl(i: Int): Int {
//   val a = if i == 100 {
//     17
//   } else {
//     return -1
//   }

//   return a
// }

// /// Expect: 17
// println(returnInVarDecl(100))
// /// Expect: -1
// println(returnInVarDecl(0))
