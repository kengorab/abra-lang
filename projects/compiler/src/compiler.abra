import "fs" as fs
import "process" as process
import Position from "./lexer"
import getCursorLine from "./utils"
import LiteralAstNode, UnaryOp, BinaryOp, AssignOp, BindingPattern, IndexingMode from "./parser"
import Project, TypedModule, Scope, ScopeKind, TypedAstNode, TypedAstNodeKind, Type, TypeKind, Field, Struct, InstanceKind, TypedInvokee, Function, FunctionKind, Decorator, AccessorPathSegment, TypedAssignmentMode, Enum, TypedEnumVariant, EnumVariantKind, TypedIndexingNode, VariableAlias, TypedMatchCase, TypedMatchCaseKind, BuiltinModule, Variable, Terminator, TypedForIterKind from "./typechecker"
import ModuleBuilder, Block, QbeType, Dest, QbeFunction, Value, Label, Callable, QbeData, QbeDataKind, Var from "./qbe"

type CompilationError {
  modulePath: String
  error: CompileError

  pub func getMessage(self): String {
    val contents = match fs.readFile(self.modulePath) {
      Ok(v) => v
      Err => return "Could not read file '${self.modulePath}'"
    }
    self.error.getMessage(self.modulePath, contents)
  }
}

type CompileError {
  position: Position
  kind: CompileErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      CompileErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(getCursorLine(self.position.line, self.position.col, contents))
        lines.push("Reason: $reason")
      }
      CompileErrorKind.QbeError(message) => {
        // todo: somehow thread the `node` which generated the error through to the error message
        lines.push("Encountered error while generating qbe code:")
        lines.push(message)
      }
      CompileErrorKind.ResolvedGenericsError(context, message) => {
        // todo: somehow thread the `node` which generated the error through to the error message
        lines.push("Encountered error resolving generics for '$context':")
        lines.push(message)
      }
    }

    lines.join("\n")
  }
}

enum CompileErrorKind {
  NotYetImplemented(reason: String)
  QbeError(message: String)
  ResolvedGenericsError(context: String, message: String)
}

func qbeError<V>(message: String): Result<V, CompileError> = Err(CompileError(position: Position.bogus(), kind: CompileErrorKind.QbeError(message)))

type ResolvedGenerics {
  _layers: (String, Map<String, Type>)[] = []

  func toString(self): String {
    val parts = ["ResolvedGenerics(_layers: ["]
    for (layerName, generics), idx in self._layers {
      parts.push("(\"$layerName\", { ")
      for (name, ty) in generics {
        parts.push("\"$name\": \"${ty.repr()}\", ")
      }
      parts.push("}")

      if idx != self._layers.length - 1 { parts.push(", ") }
    }
    parts.push("])")

    parts.join()
  }

  func resolveGeneric(self, name: String): Type? {
    var idx = self._layers.length - 1
    while self._layers[idx] |(_, generics)| {
      if generics[name] |ty| return Some(ty)
      idx -= 1
    }

    None
  }

  func _resolveType(self, ty: Type): Result<Type, String> {
    match ty.kind {
      TypeKind.Generic(genericName) => {
        if self.resolveGeneric(genericName) |resolved| {
          Ok(resolved)
        } else {
          Err("layer: could not resolve generic '$genericName'")
        }
      }
      TypeKind.Instance(instanceKind, typeArgs) => {
        val resolvedGenerics: Type[] = []
        for typeArg in typeArgs {
          resolvedGenerics.push(try self._resolveType(typeArg))
        }
        Ok(Type(kind: TypeKind.Instance(instanceKind, resolvedGenerics)))
      }
      TypeKind.Tuple(typeArgs) => {
        val resolvedGenerics: Type[] = []
        for typeArg in typeArgs {
          resolvedGenerics.push(try self._resolveType(typeArg))
        }
        Ok(Type(kind: TypeKind.Tuple(resolvedGenerics)))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val resolvedParams: (Type, Bool)[] = []
        for (paramType, paramIsRequired) in paramTypes {
          val ty = try self._resolveType(paramType)
          resolvedParams.push((ty, paramIsRequired))
        }
        val resolvedReturn = try self._resolveType(returnType)

        Ok(Type(kind: TypeKind.Func(resolvedParams, resolvedReturn)))
      }
      _ => Ok(ty)
    }
  }

  func addLayer(self, context: String, given: Map<String, Type>): Result<Int, String> {
    val newLayer: Map<String, Type> = {}
    for (name, ty) in given {
      newLayer[name] = try self._resolveType(ty)
    }

    self._layers.push((context, newLayer))

    Ok(0)
  }

  func popLayer(self) {
    self._layers.pop()
  }
}

func variableToVar(v: Variable): Var = Var(name: v.label.name, location: (v.label.position.line, v.label.position.col))

type CallframeContext {
  position: Position
  callee: String? // callee is None when the callee is an expression
}

type LoopBounds {
  continueLabel: Label
  breakLabel: Label
}

pub type Compiler {
  _project: Project
  _builder: ModuleBuilder
  _currentModule: TypedModule
  _currentFn: QbeFunction
  _currentFunction: Function?
  _currentNode: TypedAstNode?
  _argcPtr: Value
  _argvPtr: Value
  _callstack: (/* callstack: */ Value, /* ptr */ Value)
  _moduleNamesPtr: Value
  _functionNames: Map<String, Int> = {}
  _fnNamesPtr: Value
  _resolvedGenerics: ResolvedGenerics = ResolvedGenerics()
  _loopStack: LoopBounds[] = []
  // cached things
  _printf: QbeFunction = QbeFunction.spec(name: "printf", returnType: None, parameters: [], variadicIdx: Some(1))
  _snprintf: QbeFunction = QbeFunction.spec(name: "snprintf", returnType: Some(QbeType.U64), parameters: [], variadicIdx: Some(3))
  _memcpy: QbeFunction = QbeFunction.spec(name: "memcpy", returnType: None)
  _malloc: QbeFunction = QbeFunction.spec(name: "GC_malloc", returnType: Some(QbeType.Pointer))
  _realloc: QbeFunction = QbeFunction.spec(name: "GC_realloc", returnType: Some(QbeType.Pointer))
  _tupleStructs: Map<String, Struct> = {}
  _functionStructs: Map<String, (Struct, Function)> = {}
  _aliasedTypeNames: Map<String, String> = {}

  pub func compile(project: Project): Result<ModuleBuilder, CompilationError> {
    val builder = ModuleBuilder()

    val mainFn = builder.buildFunction(name: "main", returnType: Some(QbeType.U32), exported: true)
    mainFn.addComment("main entrypoint function")
    val argcParam = mainFn.addParameter("argc", QbeType.U64)
    val argvParam = mainFn.addParameter("argv", QbeType.U64)

    val (argcPtr, _) = builder.addData(QbeData(name: "__argc", kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(0))])))
    mainFn.block.buildStoreL(argcParam, argcPtr)
    val (argvPtr, _) = builder.addData(QbeData(name: "__argv", kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(0))])))
    mainFn.block.buildStoreL(argvParam, argvPtr)

    val (callstack, _) = builder.addData(QbeData(name: "__callstack", kind: QbeDataKind.Zeros(size: 1024 * 8)))
    val (callstackPtr, _) = builder.addData(QbeData(name: "__callstackp", kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(0))])))

    val allModules = project.sortedModules()
    val (moduleNamesPtr, _) = builder.addData(QbeData(name: "__modnames", kind: QbeDataKind.Strings(allModules.map(m => m.name))))

    val (fnNamesPtr, fnNamesIdx) = builder.addData(QbeData(name: "__fnnames", kind: QbeDataKind.Strings([])))

    // Seed the RNG, for any future calls to `libc.rand()`
    val timeVal = match mainFn.block.buildCallRaw("time", QbeType.U64, [Value.Int(0)]) { Ok(v) => v, Err(e) => return Err(CompilationError(modulePath: "<entrypoint>", error: CompileError(position: Position.bogus(), kind: CompileErrorKind.QbeError(e)))) }
    mainFn.block.buildVoidCallRaw("srand", [timeVal])

    mainFn.block.buildVoidCallRaw("GC_init", [])

    val dummyMod = TypedModule.bogus()
    val compiler = Compiler(_project: project, _builder: builder, _currentModule: dummyMod, _currentFn: mainFn, _currentFunction: None, _currentNode: None, _argcPtr: argcPtr, _argvPtr: argvPtr, _callstack: (callstack, callstackPtr), _moduleNamesPtr: moduleNamesPtr, _fnNamesPtr: fnNamesPtr)

    for mod in allModules {
      val moduleFn = match compiler._compileModule(mod) {
        Ok(v) => v
        Err(e) => {
          // stdoutWriteln(compiler._currentNode?.token)
          return Err(CompilationError(modulePath: mod.name, error: e))
        }
      }
      match moduleFn.block.verify() {
        Ok(v) => v
        Err(e) => return Err(CompilationError(modulePath: mod.name, error: CompileError(position: Position.bogus(), kind: CompileErrorKind.QbeError(e))))
      }
      mainFn.block.buildVoidCall(Callable.Function(moduleFn), [])
    }

    mainFn.block.buildReturn(Some(Value.Int(0)))

    match mainFn.block.verify() {
      Ok(v) => v
      Err(e) => return Err(CompilationError(modulePath: "<entrypoint>", error: CompileError(position: Position.bogus(), kind: CompileErrorKind.QbeError(e))))
    }

    val functionNames = compiler._functionNames.entries().asArray().sortBy(p => p[1])
    for (_, id), idx in functionNames {
      if id != idx unreachable("invalid _functionNames: gap at index $idx")
    }
    builder.setData(fnNamesIdx, QbeDataKind.Strings(functionNames.map(p => p[0])))

    Ok(builder)
  }

  func _compileModule(self, module: TypedModule): Result<QbeFunction, CompileError> {
    val modFnName = self._moduleWrapperFnName(module)
    self._currentModule = module

    val fn = self._builder.buildFunction(name: modFnName, returnType: None)
    fn.addComment(module.name)

    self._currentFn = fn

    for node, idx in module.code {
      val value = try self._compileStatement(node)
      // If the last statement in the module is an expression, call the `toString` method on that expression, and print the result using `printf`.
      if idx == module.code.length - 1 && node.ty.kind != TypeKind.PrimitiveUnit {
        if value |v| {
          self._currentFn.block.addComment("call `toString` on final expression, and `printf` the String's chars")
          val (dataPtr, _, _) = self._builder.buildGlobalString("%s\\n")
          val tostringMethod = try self._getOrCompileToStringMethod(node.ty)

          val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(node.ty))[0]), true))
          val frameCtx = CallframeContext(position: node.token.position, callee: Some(fnName))
          val tostringRepr = try self._buildCall(Some(frameCtx), Callable.Function(tostringMethod), [v])
          val reprCharsPtr = try self._currentFn.block.buildAdd(Value.Int(8), tostringRepr, Some("_repr_chars_ptr")) else |e| return qbeError(e)
          val reprChars = self._currentFn.block.buildLoadL(reprCharsPtr, Some("_repr_chars"))
          self._currentFn.block.buildVoidCall(Callable.Function(self._printf), [dataPtr, reprChars])
        }
      }
    }

    fn.block.buildReturn()

    try fn.block.verify() else |e| return qbeError(e)

    Ok(fn)
  }

  func _compileStatement(self, node: TypedAstNode): Result<Value?, CompileError> {
    val prevNode = self._currentNode
    self._currentNode = Some(node)

    val res: Result<Value?, CompileError> = match node.kind {
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if !isStatement {
          val res = try self._compileExpression(node)
          return Ok(Some(res))
        }

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        val condVal = try self._compileExpression(cond)
        val condExprIsOpt = self._typeIsOption(cond.ty)

        if condExprIsOpt {
          val variantIsOptionSome = try self._emitOptValueIsSomeVariant(condVal)
          self._currentFn.block.buildJnz(variantIsOptionSome, labelThen, if elseBlock.isEmpty() labelCont else labelElse)
        } else {
          self._currentFn.block.buildJnz(condVal, labelThen, if elseBlock.isEmpty() labelCont else labelElse)
        }

        self._currentFn.block.registerLabel(labelThen)
        if conditionBinding |(bindingPattern, vars)| {
          val variables = vars.keyBy(v => v.label.name)

          val bindingVal = if condExprIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            try self._emitOptValueGetValue(innerQbeType, condVal)
          } else {
            Value.Int(1)
          }
          try self._compileBindingPattern(bindingPattern, variables, Some(bindingVal))
        }

        for node in ifBlock {
          try self._compileStatement(node)
        }
        if !ifBlockTerminator {
          self._currentFn.block.buildJmp(labelCont)
        }

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node in elseBlock {
            try self._compileStatement(node)
          }
          if !elseBlockTerminator {
            self._currentFn.block.buildJmp(labelCont)
          }
        }

        self._currentFn.block.registerLabel(labelCont)

        Ok(None)
      }
      TypedAstNodeKind.Match(isStatement, expr, cases) => self._compileMatch(node, isStatement, expr, cases)
      TypedAstNodeKind.While(cond, conditionBinding, block, blockTerminator) => {
        val loopStartLabel = self._currentFn.block.addLabel("while_loop_start")
        val loopBodyLabel = self._currentFn.block.addLabel("while_loop_body")
        val loopEndLabel = self._currentFn.block.addLabel("while_loop_end")

        self._loopStack.push(LoopBounds(continueLabel: loopStartLabel, breakLabel: loopEndLabel))

        self._currentFn.block.registerLabel(loopStartLabel)
        val condVal = try self._compileExpression(cond)
        val condExprIsOpt = self._typeIsOption(cond.ty)

        if condExprIsOpt {
          val variantIsOptionSome = try self._emitOptValueIsSomeVariant(condVal)
          self._currentFn.block.buildJnz(variantIsOptionSome, loopBodyLabel, loopEndLabel)
        } else {
          self._currentFn.block.buildJnz(condVal, loopBodyLabel, loopEndLabel)
        }

        self._currentFn.block.registerLabel(loopBodyLabel)
        if conditionBinding |(bindingPattern, vars)| {
          val variables = vars.keyBy(v => v.label.name)

          val bindingVal = if condExprIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            try self._emitOptValueGetValue(innerQbeType, condVal)
          } else {
            Value.Int(1)
          }
          try self._compileBindingPattern(bindingPattern, variables, Some(bindingVal))
        }

        for node in block {
          try self._compileStatement(node)
        }
        if !blockTerminator {
          self._currentFn.block.buildJmp(loopStartLabel)
        }

        self._currentFn.block.registerLabel(loopEndLabel)

        self._loopStack.pop()

        Ok(None)
      }
      TypedAstNodeKind.For(typedForIterKind, itemBindingPattern, indexBinding, block, _) => {
        val (iterateePattern, iterateeBindingVars) = itemBindingPattern

        val forLabelPrefix = "for_${node.token.position.line}_${node.token.position.col}"
        val loopStartLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_start")
        val loopBodyLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_body")
        val loopTailLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_tail")
        val loopEndLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_end")

        self._loopStack.push(LoopBounds(continueLabel: loopTailLabel, breakLabel: loopEndLabel))

        val indexBindingSlot = if indexBinding |bindingVar| {
          val slotName = self._currentFn.block.addVar(variableToVar(bindingVar))
          val slot = self._buildStackAllocForQbeType(QbeType.U64, Some(slotName))
          self._currentFn.block.buildStoreL(Value.Int(0), slot)
          Some(slot)
        } else {
          None
        }

        val typedIterator = match typedForIterKind {
          TypedForIterKind.Expr(typedIterator) => typedIterator
          TypedForIterKind.Range(start, end) => {
            val iterateeVar = try iterateeBindingVars[0] else unreachable("There should always be an iteratee binding variable")
            val iterateeBindingSlot = self._buildStackAllocForQbeType(QbeType.U64, Some(self._currentFn.block.addVar(variableToVar(iterateeVar))))
            val rangeStartVal = try self._compileExpression(start)
            self._currentFn.block.buildStoreL(rangeStartVal, iterateeBindingSlot)

            self._currentFn.block.registerLabel(loopStartLabel)
            val rangeEndVal = try self._compileExpression(end)
            val iterateeVal = self._currentFn.block.buildLoadL(iterateeBindingSlot)
            val cond = try self._currentFn.block.buildCompareLt(iterateeVal, rangeEndVal) else |e| return qbeError(e)
            self._currentFn.block.buildJnz(cond, loopBodyLabel, loopEndLabel)

            self._currentFn.block.registerLabel(loopBodyLabel)

            for node in block {
              try self._compileStatement(node)
            }

            self._currentFn.block.registerLabel(loopTailLabel)
            val iterateeIncVal = try self._currentFn.block.buildAdd(Value.Int(1), iterateeVal) else |e| return qbeError(e)
            self._currentFn.block.buildStoreL(iterateeIncVal, iterateeBindingSlot)
            if indexBindingSlot |idxSlot| {
              val idxVal = self._currentFn.block.buildLoadL(idxSlot)
              val idxIncrVal = try self._currentFn.block.buildAdd(Value.Int(1), idxVal) else |e| return qbeError(e)
              self._currentFn.block.buildStoreL(idxIncrVal, idxSlot)
            }
            self._currentFn.block.buildJmp(loopStartLabel)

            self._currentFn.block.registerLabel(loopEndLabel)
            self._loopStack.pop()
            return Ok(None)
          }
        }

        val (instTy, typeArgs) = try self._getInstanceTypeForType(typedIterator.ty)

        val (iterVal, iterTy, nextFn, popAdditionalResolvedGenericsLayer) = match instTy {
          InstanceKind.Struct(s) => {
            if s == self._project.preludeArrayStruct {
              val innerTy = try typeArgs[0] else unreachable("Array has 1 required type argument")
              match self._resolvedGenerics.addLayer("array literal", { "T": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "array literal", message: e))) }

              val arrayVal = try self._compileExpression(typedIterator)
              val instType = try self._addResolvedGenericsLayerForInstanceMethod(typedIterator.ty, "iterator", typedIterator.token.position)
              val iteratorFn = self._getMethodFunctionByName(instTy, "iterator")
              val iteratorFnVal = try self._getOrCompileMethod(instType, iteratorFn)
              self._resolvedGenerics.popLayer()

              self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) iterator")
              val fnName = self._functionName(iteratorFn.label.name, iteratorFn.kind)
              val frameCtx = CallframeContext(position: typedIterator.token.position, callee: Some(fnName))
              val iter = try self._buildCall(Some(frameCtx), Callable.Function(iteratorFnVal), [arrayVal])

              val (instanceKind, typeArgs) = try self._getInstanceTypeForType(iteratorFn.returnType)
              val nextFn = self._getMethodFunctionByName(instanceKind, "next")

              val iterTy = Type(kind: TypeKind.Instance(instanceKind, typeArgs))
              (iter, iterTy, nextFn, true)
            } else if s == self._project.preludeSetStruct {
              val innerTy = try typeArgs[0] else unreachable("Set has 1 required type argument")
              match self._resolvedGenerics.addLayer("set literal", { "T": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "set literal", message: e))) }

              val mapVal = try self._compileExpression(typedIterator)
              val instType = try self._addResolvedGenericsLayerForInstanceMethod(typedIterator.ty, "iterator", typedIterator.token.position)
              val iteratorFn = self._getMethodFunctionByName(instTy, "iterator")
              val iteratorFnVal = try self._getOrCompileMethod(instType, iteratorFn)
              self._resolvedGenerics.popLayer()

              self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) iterator")
              val fnName = self._functionName(iteratorFn.label.name, iteratorFn.kind)
              val frameCtx = CallframeContext(position: typedIterator.token.position, callee: Some(fnName))
              val iter = try self._buildCall(Some(frameCtx), Callable.Function(iteratorFnVal), [mapVal])

              val (instanceKind, typeArgs) = try self._getInstanceTypeForType(iteratorFn.returnType)
              val nextFn = self._getMethodFunctionByName(instanceKind, "next")

              val iterTy = Type(kind: TypeKind.Instance(instanceKind, typeArgs))
              (iter, iterTy, nextFn, true)
            } else if s == self._project.preludeMapStruct {
              val keyTy = try typeArgs[0] else unreachable("Map has 2 required type arguments")
              val valTy = try typeArgs[1] else unreachable("Map has 2 required type arguments")
              match self._resolvedGenerics.addLayer("map literal", { "K": keyTy, "V": valTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "map literal", message: e))) }

              val mapVal = try self._compileExpression(typedIterator)
              val instType = try self._addResolvedGenericsLayerForInstanceMethod(typedIterator.ty, "iterator", typedIterator.token.position)
              val iteratorFn = self._getMethodFunctionByName(instTy, "iterator")
              val iteratorFnVal = try self._getOrCompileMethod(instType, iteratorFn)
              self._resolvedGenerics.popLayer()

              self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) iterator")
              val fnName = self._functionName(iteratorFn.label.name, iteratorFn.kind)
              val frameCtx = CallframeContext(position: typedIterator.token.position, callee: Some(fnName))
              val iter = try self._buildCall(Some(frameCtx), Callable.Function(iteratorFnVal), [mapVal])

              val (instanceKind, typeArgs) = try self._getInstanceTypeForType(iteratorFn.returnType)
              val nextFn = self._getMethodFunctionByName(instanceKind, "next")

              val iterTy = Type(kind: TypeKind.Instance(instanceKind, typeArgs))
              (iter, iterTy, nextFn, true)
            } else {
              self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) iterator")
              val iter = try self._compileExpression(typedIterator)
              val nextFn = self._getMethodFunctionByName(instTy, "next")

              (iter, typedIterator.ty, nextFn, false)
            }
          }
          InstanceKind.Enum(_enum) => todo("enum as for-loop target")
        }

        val nextItemTy = try self._typeIsOption(nextFn.returnType) else unreachable("a 'next' method must return an Option type")
        val iterInstTy = try self._addResolvedGenericsLayerForInstanceMethod(iterTy, "next", node.token.position)
        val nextItemQbeTy = try self._getQbeTypeForTypeExpect(nextItemTy, "unacceptable type for 'next' method return type")

        val nextFnVal = try self._getOrCompileMethod(iterInstTy, nextFn)
        self._resolvedGenerics.popLayer()
        if popAdditionalResolvedGenericsLayer self._resolvedGenerics.popLayer()

        self._currentFn.block.registerLabel(loopStartLabel)
        val iterateeBindingVariables = iterateeBindingVars.keyBy(v => v.label.name)
        self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) next() ret value")
        val fnName = self._functionName(nextFn.label.name, nextFn.kind)
        val frameCtx = CallframeContext(position: node.token.position, callee: Some(fnName))
        val nextRet = try self._buildCall(Some(frameCtx), Callable.Function(nextFnVal), [iterVal])

        val variantIsOptionSome = try self._emitOptValueIsSomeVariant(nextRet)
        self._currentFn.block.buildJnz(variantIsOptionSome, loopBodyLabel, loopEndLabel)

        self._currentFn.block.registerLabel(loopBodyLabel)
        val optInnerValue = try self._emitOptValueGetValue(nextItemQbeTy, nextRet)
        try self._compileBindingPattern(iterateePattern, iterateeBindingVariables, Some(optInnerValue))

        for node in block {
          try self._compileStatement(node)
        }
        self._currentFn.block.registerLabel(loopTailLabel)
        if indexBindingSlot |idxSlot| {
          val idxVal = self._currentFn.block.buildLoadL(idxSlot)
          val idxIncrVal = try self._currentFn.block.buildAdd(Value.Int(1), idxVal) else |e| return qbeError(e)
          self._currentFn.block.buildStoreL(idxIncrVal, idxSlot)
        }
        self._currentFn.block.buildJmp(loopStartLabel)

        self._currentFn.block.registerLabel(loopEndLabel)
        self._loopStack.pop()
        Ok(None)
      }
      TypedAstNodeKind.BindingDeclaration(bindingDeclNode) => {
        val variables = bindingDeclNode.variables.keyBy(v => v.label.name)
        val exprVal = if bindingDeclNode.expr |expr| {
          Some(try self._compileExpression(expr))
        } else {
          None
        }
        try self._compileBindingPattern(bindingDeclNode.bindingPattern, variables, exprVal)

        Ok(None)
      }
      TypedAstNodeKind.FunctionDeclaration(fn) => {
        if fn.isClosure() {
          val capturesMem = try self._createClosureCaptures(fn)
          val capturesSlot = self._buildStackAllocForQbeType(QbeType.Pointer, Some("${fn.label.name}.captures"))
          self._currentFn.block.buildStore(QbeType.Pointer, capturesMem, capturesSlot)
        }

        Ok(None)
      }
      TypedAstNodeKind.TypeDeclaration(struct) => {
        for fn in struct.instanceMethods {
          if fn.isClosure() {
            val capturesMem = try self._createClosureCaptures(fn)
            val methodName = "${struct.label.name}..${fn.label.name}"
            val capturesSlot = self._buildStackAllocForQbeType(QbeType.Pointer, Some("$methodName.captures"))
            self._currentFn.block.buildStore(QbeType.Pointer, capturesMem, capturesSlot)
          }
        }

        for fn in struct.staticMethods {
          if fn.isClosure() {
            val capturesMem = try self._createClosureCaptures(fn)
            val methodName = "${struct.label.name}.${fn.label.name}"
            val capturesSlot = self._buildStackAllocForQbeType(QbeType.Pointer, Some("$methodName.captures"))
            self._currentFn.block.buildStore(QbeType.Pointer, capturesMem, capturesSlot)
          }
        }

        Ok(None)
      }
      TypedAstNodeKind.EnumDeclaration => Ok(None)
      TypedAstNodeKind.Break => {
        if self._loopStack[-1] |loop| {
          self._currentFn.block.buildJmp(loop.breakLabel)

          Ok(None)
        } else {
          unreachable("cannot have a break statement outside of a loop")
        }
      }
      TypedAstNodeKind.Continue => {
        if self._loopStack[-1] |loop| {
          self._currentFn.block.buildJmp(loop.continueLabel)

          Ok(None)
        } else {
          unreachable("cannot have a continue statement outside of a loop")
        }
      }
      TypedAstNodeKind.Return(expr) => {
        if expr |expr| {
          val retVal = try self._compileExpression(expr)
          self._currentFn.block.buildReturn(Some(retVal))
        } else {
          self._currentFn.block.buildReturn(None)
        }

        Ok(None)
      }
      TypedAstNodeKind.Placeholder => unreachable("placeholder ast node emitted from typechecker")
      TypedAstNodeKind.Assignment(mode, op, expr) => {
        val res = try self._compileExpression(expr)

        match mode {
          TypedAssignmentMode.Variable(variable) => {
            if variable.isParameter unreachable("parameters cannot be reassigned to")

            val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
            // A top-level variable in a module is only hoisted to global if it's captured; otherwise it's effectively a local within the module wrapper function
            if variable.isCaptured {
              if variable.isGlobal() |modId| {
                val name = self._globalVarName(modId, variable.label.name)
                val slot = Value.Global(name, QbeType.Pointer)
                self._currentFn.block.buildStore(varTy, res, slot)
              } else {
                val ptr = try self._getCapturedVarPtr(variable)
                self._currentFn.block.addComment("overwrite ptr to captured '${variable.label.name}'")
                self._currentFn.block.buildStore(varTy, res, ptr)
              }
            } else {
              val slotName = try self._currentFn.block.lookupVarName(variableToVar(variable)) else unreachable("Could not resolve name for variable '${variable.label.name}'")
              val slot = Value.Ident(slotName, QbeType.Pointer)
              self._currentFn.block.buildStore(varTy, res, slot)
            }
          }
          TypedAssignmentMode.Indexing(idxNode) => {
            match idxNode {
              TypedIndexingNode.ArrayLike(expr, indexingMode) => {
                match indexingMode {
                  IndexingMode.Single(idxExpr) => {
                    val exprVal = try self._compileExpression(expr)
                    val idxExprVal = try self._compileExpression(idxExpr)

                    val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "set", expr.token.position)
                    val (instanceKind, _) = try self._getInstanceTypeForType(expr.ty)
                    match instanceKind {
                      InstanceKind.Struct(struct) => if struct != self._project.preludeArrayStruct unreachable("index-assignment only implemented for arrays")
                      InstanceKind.Enum => unreachable("index-assignment only implemented for arrays")
                    }

                    val setFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeArrayStruct), "set")
                    val setFnVal = try self._getOrCompileMethod(instType, setFn)
                    self._resolvedGenerics.popLayer()

                    // Do not track Array#set in callframes
                    try self._buildCall(None, Callable.Function(setFnVal), [exprVal, idxExprVal, res])
                  }
                  _ => unreachable("cannot use range index in index-assignment")
                }
              }
              TypedIndexingNode.Map(expr, idxExpr) => {
                val exprVal = try self._compileExpression(expr)
                val idxExprVal = try self._compileExpression(idxExpr)

                val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "set", expr.token.position)
                val (instanceKind, _) = try self._getInstanceTypeForType(expr.ty)
                match instanceKind {
                  InstanceKind.Struct(struct) => if struct != self._project.preludeMapStruct unreachable("index-assignment only implemented for map")
                  InstanceKind.Enum => unreachable("index-assignment only implemented for maps")
                }

                val insertFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeMapStruct), "insert")
                val insertFnVal = try self._getOrCompileMethod(instType, insertFn)
                self._resolvedGenerics.popLayer()

                // Do not track Map#insert in callframes
                try self._buildCall(None, Callable.Function(insertFnVal), [exprVal, idxExprVal, res])
              }
              TypedIndexingNode.Tuple(_, _) => unreachable("tuples are not assignable via index-assignment")
            }
          }
          TypedAssignmentMode.Accessor(head, middle, tail) => {
            val ptr = try self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: false)
            self._currentFn.block.buildStore(res.ty(), res, ptr)
          }
        }

        Ok(None)
      }
      _ => {
        val v = try self._compileExpression(node)
        if node.ty.kind == TypeKind.PrimitiveUnit {
          Ok(None)
        } else {
          Ok(Some(v))
        }
      }
    }

    self._currentNode = prevNode

    res
  }

  func _compileExpression(self, node: TypedAstNode, resultLocalName: String? = None): Result<Value, CompileError> {
    val prevNode = self._currentNode
    self._currentNode = Some(node)

    val res: Result<Value, CompileError> = match node.kind {
      TypedAstNodeKind.Literal(lit) => {
        val (value, _) = try self._compileLiteral(lit)
        Ok(value)
      }
      TypedAstNodeKind.StringInterpolation(exprs) => {
        self._currentFn.block.addComment("begin string interpolation...")

        val strVals: Value[] = []
        var lenVal = Value.Int(0)
        for item in exprs {
          val itemVal = try self._compileExpression(item)

          val itemInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(item.ty, "toString", item.token.position)
          val itemToStringFnVal = try self._getOrCompileToStringMethod(itemInstanceType)
          self._resolvedGenerics.popLayer()

          val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(item.ty))[0]), true))
          val frameCtx = CallframeContext(position: item.token.position, callee: Some(fnName))
          val toStringVal = try self._buildCall(Some(frameCtx), Callable.Function(itemToStringFnVal), [itemVal])
          strVals.push(toStringVal)

          val stringLength = self._currentFn.block.buildLoadL(toStringVal)
          lenVal = try self._currentFn.block.buildAdd(lenVal, stringLength) else |e| return qbeError(e)
        }

        val stringWithLengthFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeStringStruct), "withLength", staticMethod: true)
        val stringWithLengthFnVal = try self._getOrCompileMethod(Type(kind: TypeKind.Type(InstanceKind.Struct(self._project.preludeStringStruct))), stringWithLengthFn)
        // Do not track String.withLength in callframes
        val newString = try self._buildCall(None, Callable.Function(stringWithLengthFnVal), [lenVal])
        var newBuffer = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), newString) else |e| return qbeError(e))

        for strVal, idx in strVals {
          val strValLen = self._currentFn.block.buildLoadL(strVal)
          val strValBuf = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), strVal) else |e| return qbeError(e))

          self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newBuffer, strValBuf, strValLen])
          if idx != strVals.length {
            newBuffer = try self._currentFn.block.buildAdd(newBuffer, strValLen) else |e| return qbeError(e)
          }
        }

        self._currentFn.block.addComment("...string interpolation end")

        Ok(newString)
      }
      TypedAstNodeKind.Unary(op, expr) => {
        match op {
          UnaryOp.Minus => {
            val exprVal = try self._compileExpression(expr)
            val res = try self._currentFn.block.buildNeg(exprVal) else |e| return qbeError(e)

            Ok(res)
          }
          UnaryOp.Negate => {
            val exprVal = try self._compileExpression(expr)
            val exprIsOpt = self._typeIsOption(expr.ty)
            if exprIsOpt {
              val variantIsNotOptionSome = try self._emitOptValueIsSomeVariant(exprVal: exprVal, negate: true)
              val res = self._currentFn.block.buildExt(variantIsNotOptionSome, false)
              Ok(res)
            } else {
              val plusOneVal = try self._currentFn.block.buildAdd(Value.Int(1), exprVal) else |e| return qbeError(e)
              val res = try self._currentFn.block.buildRem(plusOneVal, Value.Int(2)) else |e| return qbeError(e)
              Ok(res)
            }
          }
        }
      }
      TypedAstNodeKind.Binary(left, op, right) => {
        match op {
          BinaryOp.Add => {
            val leftIsString = self._typeIsString(left.ty)
            val rightIsString = self._typeIsString(right.ty)

            if leftIsString || rightIsString {
              self._currentFn.block.addComment("begin string concatenation...")
              var leftVal = try self._compileExpression(left)
              if !leftIsString {
                val leftInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(left.ty, "toString", left.token.position)
                val leftToStringFnVal = try self._getOrCompileToStringMethod(leftInstanceType)
                self._resolvedGenerics.popLayer()

                val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(left.ty))[0]), true))
                val frameCtx = CallframeContext(position: left.token.position, callee: Some(fnName))
                leftVal = try self._buildCall(Some(frameCtx), Callable.Function(leftToStringFnVal), [leftVal])
              }

              var rightVal = try self._compileExpression(right)
              if !rightIsString {
                val rightInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(right.ty, "toString", right.token.position)
                val rightToStringFnVal = try self._getOrCompileToStringMethod(rightInstanceType)
                self._resolvedGenerics.popLayer()

                val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(right.ty))[0]), true))
                val frameCtx = CallframeContext(position: right.token.position, callee: Some(fnName))
                rightVal = try self._buildCall(Some(frameCtx), Callable.Function(rightToStringFnVal), [rightVal])
              }

              val stringWithLengthFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeStringStruct), "withLength", staticMethod: true)
              val stringWithLengthFnVal = try self._getOrCompileMethod(Type(kind: TypeKind.Type(InstanceKind.Struct(self._project.preludeStringStruct))), stringWithLengthFn)
              val leftLength = self._currentFn.block.buildLoadL(leftVal)
              val rightLength = self._currentFn.block.buildLoadL(rightVal)
              val totalLength = try self._currentFn.block.buildAdd(leftLength, rightLength) else |e| return qbeError(e)
              // Do not track String.withLength in callframes
              val newString = try self._buildCall(None, Callable.Function(stringWithLengthFnVal), [totalLength])

              var newBuffer = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), newString) else |e| return qbeError(e))

              val leftBuffer = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), leftVal) else |e| return qbeError(e))
              self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newBuffer, leftBuffer, leftLength])

              val rightBuffer = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), rightVal) else |e| return qbeError(e))
              newBuffer = try self._currentFn.block.buildAdd(newBuffer, leftLength) else |e| return qbeError(e)
              self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newBuffer, rightBuffer, rightLength])

              self._currentFn.block.addComment("...string concatenation end")

              return Ok(newString)
            }

            val (lval, rval) = try self._compileBinaryOperands(left, right, "+")
            val res = try self._currentFn.block.buildAdd(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.Sub => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, "-")
            val res = try self._currentFn.block.buildSub(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.Mul => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, "*")
            val res = try self._currentFn.block.buildMul(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.Div => {
            var leftVal = try self._compileExpression(left)
            var rightVal = try self._compileExpression(right)

            if !self._typeIsFloat(left.ty)
              leftVal = self._currentFn.block.buildLToF(leftVal)
            if !self._typeIsFloat(right.ty)
              rightVal = self._currentFn.block.buildLToF(rightVal)

            val res = try self._currentFn.block.buildDiv(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.Mod => {
            var leftVal = try self._compileExpression(left)
            var rightVal = try self._compileExpression(right)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val res = try self._currentFn.block.buildRem(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
              Ok(res)
            } else {
              if !self._typeIsFloat(left.ty)
                leftVal = self._currentFn.block.buildLToF(leftVal)
              if !self._typeIsFloat(right.ty)
                rightVal = self._currentFn.block.buildLToF(rightVal)

              val res = try self._currentFn.block.buildCallRaw("fmod", QbeType.F64, [leftVal, rightVal]) else |e| return qbeError(e)
              Ok(res)
            }
          }
          BinaryOp.Pow => {
            var leftVal = try self._compileExpression(left)
            var rightVal = try self._compileExpression(right)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              leftVal = self._currentFn.block.buildLToF(leftVal)
              rightVal = self._currentFn.block.buildLToF(rightVal)
              val res = try self._currentFn.block.buildCallRaw("pow", QbeType.F64, [leftVal, rightVal]) else |e| return qbeError(e)
              Ok(res)
            } else {
              // if a < 0 { -(-a ** b) } else { a ** b }
              if !self._typeIsFloat(left.ty)
                leftVal = self._currentFn.block.buildLToF(leftVal)
              if !self._typeIsFloat(right.ty)
                rightVal = self._currentFn.block.buildLToF(rightVal)

              val labelThen = self._currentFn.block.addLabel("fpow_l_neg")
              val labelElse = self._currentFn.block.addLabel("fpow_l_pos")
              val labelCont = self._currentFn.block.addLabel("fpow_cont")
              val cond = try self._currentFn.block.buildCompareLt(leftVal, Value.Float(0.0)) else |e| return qbeError(e)
              self._currentFn.block.buildJnz(cond, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              val leftValNeg = try self._currentFn.block.buildMul(leftVal, Value.Float(-1.0)) else |e| return qbeError(e)
              val thenValNeg = try self._currentFn.block.buildCallRaw("pow", QbeType.F64, [leftValNeg, rightVal]) else |e| return qbeError(e)
              val thenVal = try self._currentFn.block.buildMul(thenValNeg, Value.Float(-1.0)) else |e| return qbeError(e)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              val elseVal = try self._currentFn.block.buildCallRaw("pow", QbeType.F64, [leftVal, rightVal]) else |e| return qbeError(e)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(labelThen, thenVal), (labelElse, elseVal)]
              val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)

              Ok(res)
            }
          }
          BinaryOp.And => {
            val leftVal = try self._compileExpression(left)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val rightVal = try self._compileExpression(right)

              val res = try self._currentFn.block.buildAnd(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
              Ok(res)
            } else {
              val labelThen = self._currentFn.block.addLabel("bool_and_then")
              val labelElse = self._currentFn.block.addLabel("bool_and_else")
              val labelCont = self._currentFn.block.addLabel("bool_and_cont")

              self._currentFn.block.buildJnz(leftVal, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              val rightVal = try self._compileExpression(right)
              val rightLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(rightLabel, rightVal), (labelElse, leftVal)]
              val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)

              Ok(res)
            }
          }
          BinaryOp.Or => {
            val leftVal = try self._compileExpression(left)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val rightVal = try self._compileExpression(right)

              val res = try self._currentFn.block.buildOr(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
              Ok(res)
            } else {
              val labelThen = self._currentFn.block.addLabel("bool_or_then")
              val labelElse = self._currentFn.block.addLabel("bool_or_else")
              val labelCont = self._currentFn.block.addLabel("bool_or_cont")

              self._currentFn.block.buildJnz(leftVal, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              val rightVal = try self._compileExpression(right)
              val rightLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(labelThen, leftVal), (rightLabel, rightVal)]
              val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)

              Ok(res)
            }
          }
          BinaryOp.Xor => {
            val leftVal = try self._compileExpression(left)
            val rightVal = try self._compileExpression(right)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) || self._typeIsBool(left.ty) && self._typeIsBool(right.ty) {
              val res = try self._currentFn.block.buildXor(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
              Ok(res)
            } else {
              unreachable("unknown operator '^' between types '${left.ty.repr()}' and '${right.ty.repr()}")
            }
          }
          BinaryOp.Coalesce => {
            val leftVal = try self._compileExpression(left)

            val labelThen = self._currentFn.block.addLabel("coalesce_then")
            val labelElse = self._currentFn.block.addLabel("coalesce_else")
            val labelCont = self._currentFn.block.addLabel("coalesce_cont")

            val isSome = try self._emitOptValueIsSomeVariant(leftVal)

            self._currentFn.block.buildJnz(isSome, labelThen, labelElse)

            self._currentFn.block.registerLabel(labelThen)
            val innerTy = try self._typeIsOption(left.ty) else unreachable()
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            val innerVal = try self._emitOptValueGetValue(innerQbeType, leftVal)
            val leftLabel = self._currentFn.block.currentLabel
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.registerLabel(labelElse)
            val rightVal = try self._compileExpression(right)
            val rightLabel = self._currentFn.block.currentLabel
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.registerLabel(labelCont)

            val phiCases = [(leftLabel, innerVal), (rightLabel, rightVal)]
            val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)

            Ok(res)
          }
          BinaryOp.Eq => self._compileBinaryEq(left, right)
          BinaryOp.Neq => self._compileBinaryEq(left: left, right: right, negate: true)
          BinaryOp.LT => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, "<")
            val res = try self._currentFn.block.buildCompareLt(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(self._currentFn.block.buildExt(res, false))
          }
          BinaryOp.LTE => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, "<=")
            val res = try self._currentFn.block.buildCompareLte(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(self._currentFn.block.buildExt(res, false))
          }
          BinaryOp.Shl => {
            val leftVal = try self._compileExpression(left)
            val rightVal = try self._compileExpression(right)

            val res = try self._currentFn.block.buildShl(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.GT => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, ">")
            val res = try self._currentFn.block.buildCompareGt(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(self._currentFn.block.buildExt(res, false))
          }
          BinaryOp.GTE => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, ">=")
            val res = try self._currentFn.block.buildCompareGte(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(self._currentFn.block.buildExt(res, false))
          }
          BinaryOp.Shr => {
            val leftVal = try self._compileExpression(left)
            val rightVal = try self._compileExpression(right)

            val res = try self._currentFn.block.buildShr(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
        }
      }
      TypedAstNodeKind.Grouped(inner) => self._compileExpression(inner, resultLocalName)
      TypedAstNodeKind.Identifier(name, variable, fnAliasTypeHint, varImportModule) => {
        // If a variable is function parameter, it can just be referenced by name as a temporary/local, otherwise it can be obtained by
        // loading the value pointed to by the temporary/local with that name.
        // TODO: handle captured variables in closures, global variables, etc).
        val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
        if variable.isParameter {
          if variable.isCaptured {
            if variable.mutable unreachable("parameters cannot be mutable")
            val value = try self._getCapturedVarPtr(variable)
            Ok(value)
          } else {
            val varName = try self._currentFn.block.lookupVarName(variableToVar(variable)) else unreachable("Could not resolve name for variable '${variable.label.name}'")
            Ok(Value.Ident(varName, varTy))
          }
        } else {
          match variable.alias {
            VariableAlias.Function(fn) => {
              val targetParamTypes = if fnAliasTypeHint |hint| {
                val paramTypes = match hint.kind {
                  TypeKind.Func(paramTypes, _) => Some(paramTypes)
                  // If the function value is being treated as a Hole, then no param type info needs to be known later anyway
                  TypeKind.Hole => None
                  _ => unreachable("fnAliasTypeKind must be TypeKind.Func")
                }
                paramTypes
              } else {
                None
              }

              val capturesMem = if !fn.isClosure() None else {
                val mem = try self._getCapturesArrForClosure(fn)
                Some(mem)
              }

              self._compileFunctionValue(node.token.position, fn, targetParamTypes, capturesMem, None)
            }
            _ => {
              if varImportModule |mod| {
                val name = self._globalVarName(mod.id, name)
                val slot = Value.Global(name, QbeType.Pointer)
                val res = self._currentFn.block.buildLoad(varTy, slot)
                Ok(res)
              } else if variable.isCaptured {
                // A top-level variable in a module is only hoisted to global if it's captured; otherwise it's effectively a local within the module wrapper function
                val res = if variable.isGlobal() |modId| {
                  val name = self._globalVarName(modId, name)
                  val slot = Value.Global(name, QbeType.Pointer)
                  self._currentFn.block.buildLoad(varTy, slot)
                } else {
                  val ptr = try self._getCapturedVarPtr(variable)
                  if variable.mutable {
                    self._currentFn.block.addComment("deref ptr to captured mutable '${variable.label.name}'")
                    self._currentFn.block.buildLoad(varTy, ptr)
                  } else {
                    ptr
                  }
                }

                Ok(res)
              } else {
                val slotName = try self._currentFn.block.lookupVarName(variableToVar(variable)) else unreachable("Could not resolve name for variable '${variable.label.name}'")
                val slot = Value.Ident(slotName, QbeType.Pointer)
                val res = self._currentFn.block.buildLoad(varTy, slot)
                Ok(res)
              }
            }
          }
        }
      }
      TypedAstNodeKind.Accessor(head, middle, tail) => self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: true, localName: resultLocalName)
      TypedAstNodeKind.Invocation(invokee, arguments, resolvedGenerics) => {
        val args: Value[] = []
        var optSafeCtx: (Label, Value?, QbeFunction, Label)? = None

        val (fnVal, frameCtx, closureEnvPtr) = match invokee {
          TypedInvokee.Function(fn) => {
            match self._resolvedGenerics.addLayer(fn.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: fn.label.name, message: e))) }

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "intrinsic")
            if intrinsicDec |dec| {
              val res = self.invokeIntrinsicFn(dec, fn, arguments)
              self._resolvedGenerics.popLayer()
              return res
            }

            val externalDec = fn.decorators.find(dec => dec.label.name == "external")
            if externalDec |dec| {
              val res = self.invokeExternalFn(dec, fn, arguments)
              self._resolvedGenerics.popLayer()
              return res
            }

            val closureEnvPtr = if fn.isClosure() Some(try self._getCapturesArrForClosure(fn)) else None

            val paramsNeedingDefaultValue = arguments.map((arg, idx) => {
              if fn.params[idx] |param| { !!param.defaultValue && !arg } else { false }
            })
            val fnVal = match fn.kind {
              FunctionKind.StaticMethod(parentTy, _) => {
                try self._getOrCompileMethod(Type(kind: TypeKind.Type(parentTy)), fn, paramsNeedingDefaultValue)
              }
              FunctionKind.Standalone => {
                try self._getOrCompileFunction(fn, paramsNeedingDefaultValue)
              }
              FunctionKind.InstanceMethod => unreachable("instance methods handled in the following block")
            }

            self._resolvedGenerics.popLayer()

            val frameCtx = CallframeContext(position: node.token.position, callee: Some(self._functionName(fn.label.name, fn.kind)))
            (fnVal, Some(frameCtx), closureEnvPtr)
          }
          TypedInvokee.Method(fn, selfExpr, isOptSafe) => {
            var selfInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(selfExpr.ty, fn.label.name, node.token.position, resolvedGenerics)

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "intrinsic")
            if intrinsicDec |dec| {
              if isOptSafe unreachable("cannot have opt-safe intrinsic method calls")
              val res = self.invokeIntrinsicFn(dec, fn, [Some(selfExpr)].concat(arguments))
              self._resolvedGenerics.popLayer()
              return res
            }

            val closureEnvPtr = if fn.isClosure() Some(try self._getCapturesArrForClosure(fn)) else None

            val selfVal = if isOptSafe {
              val innerTy = try self._typeIsOption(selfInstanceType) else unreachable("an opt-safe invocation needs to have an Option type as its lhs")
              selfInstanceType = innerTy

              val selfVal = try self._compileExpression(selfExpr)
              val variantIsOptionSome = try self._emitOptValueIsSomeVariant(selfVal)

              val labelIsSome = self._currentFn.block.addLabel("optsafe_call_is_some")
              val labelIsNone = self._currentFn.block.addLabel("optsafe_call_is_none")
              val labelCont = self._currentFn.block.addLabel("optsafe_call_cont")

              self._currentFn.block.addComment("begin opt-safe call...")
              self._currentFn.block.buildJnz(variantIsOptionSome, labelIsSome, labelIsNone)

              self._currentFn.block.registerLabel(labelIsNone)
              val noneRes = if fn.returnType.kind != TypeKind.PrimitiveUnit {
                val (optNoneVariant, _) = self._getEnumVariantByName(self._project.preludeOptionEnum, "None")
                val noneRes = try self._getOrCompileEnumVariantConst(self._project.preludeOptionEnum, optNoneVariant)
                Some(noneRes)
              } else None
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelIsSome)
              val (optSomeVariant, _) = self._getEnumVariantByName(self._project.preludeOptionEnum, "Some")
              match self._resolvedGenerics.addLayer("Option.Some", { "V": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "Option.Some", message: e))) }
              val someVariantFn = try self._getOrCompileEnumVariantFn(self._project.preludeOptionEnum, optSomeVariant)
              self._resolvedGenerics.popLayer()

              optSafeCtx = Some((labelIsNone, noneRes, someVariantFn, labelCont))

              val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
              try self._emitOptValueGetValue(innerQbeType, selfVal)
            } else {
              try self._compileExpression(selfExpr)
            }

            val paramsNeedingDefaultValue = arguments.map((arg, idx) => {
              if fn.params[idx] |param| { !!param.defaultValue && !arg } else { false }
            })
            val fnVal = try self._getOrCompileMethod(selfInstanceType, fn, paramsNeedingDefaultValue)
            args.push(selfVal)

            self._resolvedGenerics.popLayer()

            val frameCtx = CallframeContext(position: node.token.position, callee: Some(self._functionName(fn.label.name, fn.kind)))
            (fnVal, Some(frameCtx), closureEnvPtr)
          }
          TypedInvokee.Struct(struct) => {
            match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }

            val fieldsNeedingDefaultValue = arguments.map((arg, idx) => {
              if struct.fields[idx] |field| { !!field.initializer && !arg } else { false }
            })
            val fnVal = try self._getOrCompileStructInitializer(struct, fieldsNeedingDefaultValue)

            self._resolvedGenerics.popLayer()

            val hasOptionalField = struct.fields.any(f => !!f.initializer)
            val frameCtx = if hasOptionalField {
              Some(CallframeContext(position: node.token.position, callee: Some(struct.label.name)))
            } else {
              None
            }
            (fnVal, frameCtx, None)
          }
          TypedInvokee.EnumVariant(enum_, variant) => {
            match self._resolvedGenerics.addLayer(variant.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: variant.label.name, message: e))) }

            match variant.kind {
              EnumVariantKind.Container(fields) => {
                val fieldsNeedingDefaultValue = arguments.map((arg, idx) => {
                  if fields[idx] |field| { !!field.initializer && !arg } else { false }
                })
                val enumVariantFn = try self._getOrCompileEnumVariantFn(enum_, variant, fieldsNeedingDefaultValue)
                self._resolvedGenerics.popLayer()

                val hasOptionalField = fields.any(f => !!f.initializer)
                val frameCtx = if hasOptionalField {
                  Some(CallframeContext(position: node.token.position, callee: Some("${enum_.label.name}.${variant.label.name}")))
                } else {
                  None
                }
                (enumVariantFn, frameCtx, None)
              }
              _ => unreachable("cannot invoke constant enum variant ${enum_.label.name}.${variant.label.name}")
            }
          }
          TypedInvokee.Expr(expr) => {
            val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "call", expr.token.position)
            val callMethodFn = try self._getOrCompileFunctionCallMethod(expr.ty)

            val fnObj = try self._compileExpression(expr)
            args.push(fnObj)

            self._resolvedGenerics.popLayer()
            (callMethodFn, Some(CallframeContext(position: node.token.position, callee: None)), None)
          }
        }

        for arg, idx in arguments {
          if arg |node| {
            args.push(try self._compileExpression(node))
          }
        }

        val callable = Callable.Function(fnVal)
        var res = if fnVal.returnType {
          if closureEnvPtr |envPtr| {
            try self._buildCall(frameCtx, callable, args, resultLocalName, Some(envPtr))
          } else {
            try self._buildCall(frameCtx, callable, args, resultLocalName)
          }
        } else {
          if closureEnvPtr |envPtr| {
            try self._buildVoidCall(frameCtx, callable, args, Some(envPtr))
          } else {
            try self._buildVoidCall(frameCtx, callable, args)
          }

          Value.Ident("bogus", QbeType.F32)
        }

        if optSafeCtx |(labelIsNone, noneRes, someVariantFn, labelCont)| {
          val labelIsSome = if noneRes |noneRes| {
            val labelIsSome = self._currentFn.block.currentLabel
            // Do not track Option.Some in callframes
            val someRes = try self._buildCall(None, Callable.Function(someVariantFn), [res])
            Some((labelIsSome, someRes, noneRes))
          } else None
          self._currentFn.block.buildJmp(labelCont)

          self._currentFn.block.addComment("...opt-safe call end")
          self._currentFn.block.registerLabel(labelCont)

          if labelIsSome |(labelIsSome, someRes, noneRes)| {
            val phiCases = [(labelIsNone, noneRes), (labelIsSome, someRes)]
            res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)
          }
        }

        if node.ty.kind == TypeKind.Never {
          self._currentFn.block.buildHalt()
        }

        Ok(res)
      }
      TypedAstNodeKind.Array(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val inner = try generics[0] else unreachable("Array has 1 required type argument")
            match self._resolvedGenerics.addLayer("array literal", { "T": inner }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "array literal", message: e))) }
          }
          _ => unreachable("we know it's an array instance here")
        }

        val arrayWithCapacityFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeArrayStruct), "withCapacity", staticMethod: true)
        val arrayWithCapacityFnVal = try self._getOrCompileMethod(node.ty, arrayWithCapacityFn)

        val sizeVal = Value.Int(items.length.nextPowerOf2())
        // Do not track Array.withCapacity in callframes
        val arrayInstance = try self._buildCall(None, Callable.Function(arrayWithCapacityFnVal), [sizeVal], resultLocalName)
        self._currentFn.block.addCommentBefore("${arrayInstance.repr()}: ${node.ty.repr()}")

        val arrayPushFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeArrayStruct), "push")
        val arrayPushFnVal = try self._getOrCompileMethod(node.ty, arrayPushFn)

        for item in items {
          val itemVal = try self._compileExpression(item)
          // Do not track Array#push in callframes
          try self._buildVoidCall(None, Callable.Function(arrayPushFnVal), [arrayInstance, itemVal])
        }

        self._resolvedGenerics.popLayer()

        Ok(arrayInstance)
      }
      TypedAstNodeKind.Set(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val inner = try generics[0] else unreachable("Set has 1 required type argument")
            match self._resolvedGenerics.addLayer("set literal", { "T": inner }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "set literal", message: e))) }
          }
          _ => unreachable("we know it's a set instance here")
        }

        val setNewFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeSetStruct), "new", staticMethod: true)
        val setNewFnVal = try self._getOrCompileMethod(node.ty, setNewFn, [true])

        // Do not track Set.new in callframes
        val setInstance = try self._buildCall(None, Callable.Function(setNewFnVal), [], resultLocalName)
        self._currentFn.block.addCommentBefore("${setInstance.repr()}: ${node.ty.repr()}")

        val setInsertFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeSetStruct), "insert")
        val setInsertFnVal = try self._getOrCompileMethod(node.ty, setInsertFn)

        for item in items {
          val itemVal = try self._compileExpression(item)
          // Do not track Set#insert in callframes
          try self._buildVoidCall(None, Callable.Function(setInsertFnVal), [setInstance, itemVal])
        }

        self._resolvedGenerics.popLayer()

        Ok(setInstance)
      }
      TypedAstNodeKind.Map(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val key = try generics[0] else unreachable("Map has 2 required type arguments")
            val value = try generics[1] else unreachable("Map has 2 required type arguments")
            match self._resolvedGenerics.addLayer("map literal", { "K": key, "V": value }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "map literal", message: e))) }
          }
          _ => unreachable("we know it's a map instance here")
        }

        val mapNewFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeMapStruct), "new", staticMethod: true)
        val mapNewFnVal = try self._getOrCompileMethod(node.ty, mapNewFn, [true])

        val fnName = self._functionName(mapNewFn.label.name, mapNewFn.kind)
        // Do not track Map.new in callframes
        val mapInstance = try self._buildCall(None, Callable.Function(mapNewFnVal), [], resultLocalName)
        self._currentFn.block.addCommentBefore("${mapInstance.repr()}: ${node.ty.repr()}")

        val mapInsertFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeMapStruct), "insert")
        val mapInsertFnVal = try self._getOrCompileMethod(node.ty, mapInsertFn)

        for (keyExpr, valExpr) in items {
          val keyVal = try self._compileExpression(keyExpr)
          val valueVal = try self._compileExpression(valExpr)
          // Do not track Map#insert in callframes
          try self._buildCall(None, Callable.Function(mapInsertFnVal), [mapInstance, keyVal, valueVal])
        }

        self._resolvedGenerics.popLayer()

        Ok(mapInstance)
      }
      TypedAstNodeKind.Tuple(items) => {
        val tupleStruct = self._tupleStruct(items.length)
        val selfType = Type(kind: TypeKind.Instance(InstanceKind.Struct(tupleStruct), items.map(node => node.ty)))

        val resolvedGenerics: Map<String, Type> = {}
        val template = Type(kind: TypeKind.Instance(InstanceKind.Struct(tupleStruct), tupleStruct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        for (name, ty) in selfType.extractGenerics(template) {
          resolvedGenerics[name] = ty
        }
        match self._resolvedGenerics.addLayer(tupleStruct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: tupleStruct.label.name, message: e))) }
        val fnVal = try self._getOrCompileStructInitializer(tupleStruct)

        self._resolvedGenerics.popLayer()

        val itemVals: Value[] = []
        for item in items {
          val itemVal = try self._compileExpression(item)
          itemVals.push(itemVal)
        }

        // Do not track Tuple.init in callframes
        self._buildCall(None, Callable.Function(fnVal), itemVals)
      }
      TypedAstNodeKind.Indexing(indexingNode) => {
        match indexingNode {
          TypedIndexingNode.ArrayLike(expr, indexingMode) => {
            val exprVal = try self._compileExpression(expr)

            match indexingMode {
              IndexingMode.Single(idxExpr) => {
                val idxExprVal = try self._compileExpression(idxExpr)

                val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "get", expr.token.position)
                val (instanceKind, _) = try self._getInstanceTypeForType(expr.ty)
                val getFn = match instanceKind {
                  InstanceKind.Struct => self._getMethodFunctionByName(instanceKind, "get")
                  InstanceKind.Enum => unreachable("array-like indexing never applies to enum instances")
                }
                val getFnVal = try self._getOrCompileMethod(instType, getFn)
                self._resolvedGenerics.popLayer()

                // Do not track Array#get in callframes
                self._buildCall(None, Callable.Function(getFnVal), [exprVal, idxExprVal])
              }
              IndexingMode.Range(startExpr, endExpr) => {
                val params = [exprVal]
                val paramsNeedingDefaultValue: Bool[] = []
                if startExpr |startExpr| {
                  paramsNeedingDefaultValue.push(false)
                  params.push(try self._compileExpression(startExpr))
                } else {
                  paramsNeedingDefaultValue.push(true)
                }
                if endExpr |endExpr| {
                  paramsNeedingDefaultValue.push(false)
                  params.push(try self._compileExpression(endExpr))
                } else {
                  paramsNeedingDefaultValue.push(true)
                }

                val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "getRange", expr.token.position)
                val (instanceKind, _) = try self._getInstanceTypeForType(expr.ty)
                val getRangeFn = match instanceKind {
                  InstanceKind.Struct => self._getMethodFunctionByName(instanceKind, "getRange")
                  InstanceKind.Enum => unreachable("array-like indexing never applies to enum instances")
                }
                val getRangeFnVal = try self._getOrCompileMethod(instType, getRangeFn, paramsNeedingDefaultValue)
                self._resolvedGenerics.popLayer()

                // Do not track Array#getRange in callframes
                self._buildCall(None, Callable.Function(getRangeFnVal), params)
              }
            }
          }
          TypedIndexingNode.Map(expr, idxExpr) => {
            val exprVal = try self._compileExpression(expr)
            val idxExprVal = try self._compileExpression(idxExpr)

            val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "get", expr.token.position)
            val (instanceKind, _) = try self._getInstanceTypeForType(expr.ty)
            match instanceKind {
              InstanceKind.Struct(struct) => if struct != self._project.preludeMapStruct unreachable("map indexing only implemented for map")
              InstanceKind.Enum => unreachable("map indexing never applies to enum instances")
            }

            val getFn = self._getMethodFunctionByName(instanceKind, "get")
            val getFnVal = try self._getOrCompileMethod(instType, getFn)
            self._resolvedGenerics.popLayer()

            // Do not track Map#get in callframes
            self._buildCall(None, Callable.Function(getFnVal), [exprVal, idxExprVal])
          }
          TypedIndexingNode.Tuple(tupleExpr, idx) => {
            val exprVal = try self._compileExpression(tupleExpr)

            val (instanceKind, typeArgs) = try self._getInstanceTypeForType(tupleExpr.ty)
            val struct = match instanceKind {
              InstanceKind.Struct(struct) => struct
              InstanceKind.Enum => unreachable("tuples are represented as structs")
            }

            val selfType = Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), typeArgs))

            val resolvedGenerics: Map<String, Type> = {}
            val template = Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
            for (name, ty) in selfType.extractGenerics(template) {
              resolvedGenerics[name] = ty
            }
            match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }

            var offset = 0
            for f, fieldIdx in struct.fields {
              if fieldIdx == idx break

              val fieldTy = try self._getQbeTypeForTypeExpect(f.ty, "unacceptable type for field", Some(f.name.position))
              offset += fieldTy.size()
            }

            self._resolvedGenerics.popLayer()

            val ptr = try self._currentFn.block.buildAdd(Value.Int(offset), exprVal) else |e| return qbeError(e)
            val res = self._currentFn.block.buildLoadL(ptr)
            self._currentFn.block.addCommentBefore("${res.repr()}: ${exprVal.repr()}.$idx")
            Ok(res)
          }
        }
      }
      TypedAstNodeKind.Lambda(fn, typeHint) => {
        val targetParamTypes = if typeHint |hint| {
          val paramTypes = match hint.kind {
            TypeKind.Func(paramTypes, _) => Some(paramTypes)
            // If the function value is being treated as a Hole, then no param type info needs to be known later anyway
            TypeKind.Hole => None
            _ => unreachable("typeKind must be TypeKind.Func")
          }
          paramTypes
        } else {
          None
        }

        val capturesMem = if !fn.isClosure() None else {
          val mem = try self._createClosureCaptures(fn)
          Some(mem)
        }

        self._compileFunctionValue(node.token.position, fn, targetParamTypes, capturesMem, None)
      }
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if isStatement unreachable("if-statements are handled elsewhere")
        if elseBlock.isEmpty() unreachable("if-expressions must not have empty else-blocks")

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        val condVal = try self._compileExpression(cond)
        val condExprIsOpt = self._typeIsOption(cond.ty)
        if condExprIsOpt {
          val variantIsOptionSome = try self._emitOptValueIsSomeVariant(condVal)
          self._currentFn.block.buildJnz(variantIsOptionSome, labelThen, labelElse)
        } else {
          self._currentFn.block.buildJnz(condVal, labelThen, labelElse)
        }

        val phiCases: (Label, Value)[] = []

        self._currentFn.block.registerLabel(labelThen)
        if conditionBinding |(bindingPattern, vars)| {
          val variables = vars.keyBy(v => v.label.name)

          val bindingVal = if condExprIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            val optInnerValue = try self._emitOptValueGetValue(innerQbeType, condVal)
            optInnerValue
          } else {
            Value.Int(1)
          }
          try self._compileBindingPattern(bindingPattern, variables, Some(bindingVal))
        }
        for node, idx in ifBlock {
          val res = try self._compileStatement(node)
          if idx == ifBlock.length - 1 {
            if !ifBlockTerminator {
              if res |res| {
                val label = self._currentFn.block.currentLabel
                phiCases.push((label, res))
              } else {
                unreachable("last statement in if-expr block has no value and is not a terminator")
              }
            }
          }
        }
        if !ifBlockTerminator {
          self._currentFn.block.buildJmp(labelCont)
        }

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node, idx in elseBlock {
            val res = try self._compileStatement(node)
            if idx == elseBlock.length - 1 {
              if !elseBlockTerminator {
                if res |res| {
                  val label = self._currentFn.block.currentLabel
                  phiCases.push((label, res))
                } else {
                  unreachable("last statement in if-expr else block has no value and is not a terminator")
                }
              }
            }
          }
          if !elseBlockTerminator {
            self._currentFn.block.buildJmp(labelCont)
          }
        }

        self._currentFn.block.registerLabel(labelCont)

        if !phiCases.isEmpty() {
          val res = try self._currentFn.block.buildPhi(phiCases, resultLocalName) else |e| return qbeError(e)
          Ok(res)
        } else {
          self._currentFn.block.buildHalt()
          Ok(Value.Ident("bogus", QbeType.F32))
        }
      }
      TypedAstNodeKind.Match(isStatement, expr, cases) => {
        val res = try self._compileMatch(node, isStatement, expr, cases)
        if res |res| Ok(res) else unreachable("match expression needs a resulting value")
      }
      TypedAstNodeKind.Try(expr, elseClause) => {
        val exprVal = try self._compileExpression(expr)
        val isOptionTry = !!self._typeIsOption(expr.ty)
        val isUnhappyPath = if isOptionTry {
          try self._emitOptValueIsSomeVariant(exprVal, negate: true)
        } else {
          try self._emitResultValueIsOkVariant(exprVal, negate: true)
        }

        val labelIsUnhappyPath = self._currentFn.block.addLabel("isUnhappyPath")
        val labelCont = self._currentFn.block.addLabel("cont")

        if elseClause |clause| {
          val phiCases: (Label, Value)[] = []

          val labelIsHappyPath = self._currentFn.block.addLabel("isOk")
          self._currentFn.block.buildJnz(isUnhappyPath, labelIsUnhappyPath, labelIsHappyPath)

          self._currentFn.block.registerLabel(labelIsUnhappyPath)
          if clause.pattern |(bindingPattern, vars)| {
            val variables = vars.keyBy(v => v.label.name)

            val errorQbeType = try self._getQbeTypeForTypeExpect(clause.errorType, "unacceptable type", None)
            val bindingVal = if isOptionTry {
              exprVal
            } else {
              try self._emitResultValueGetValue(errorQbeType, exprVal)
            }
            try self._compileBindingPattern(bindingPattern, variables, Some(bindingVal))
          }
          for node, idx in clause.block {
            val res = try self._compileStatement(node)
            if idx == clause.block.length - 1 {
              if !clause.terminator {
                if res |res| {
                  val label = self._currentFn.block.currentLabel
                  phiCases.push((label, res))
                } else {
                  unreachable("last statement in try-expr block has no value and is not a terminator")
                }
              }
            }
          }
          if !clause.terminator {
            self._currentFn.block.buildJmp(labelCont)
          }

          self._currentFn.block.registerLabel(labelIsHappyPath)
          val happyPathQbeType = try self._getQbeTypeForTypeExpect(node.ty, "unacceptable type", None)
          val happyPathVal = if isOptionTry {
            try self._emitOptValueGetValue(happyPathQbeType, exprVal)
          } else {
            try self._emitResultValueGetValue(happyPathQbeType, exprVal)
          }
          val label = self._currentFn.block.currentLabel
          phiCases.push((label, happyPathVal))
          self._currentFn.block.buildJmp(labelCont)

          self._currentFn.block.registerLabel(labelCont)
          val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)
          Ok(res)
        } else {
          self._currentFn.block.buildJnz(isUnhappyPath, labelIsUnhappyPath, labelCont)

          self._currentFn.block.registerLabel(labelIsUnhappyPath)
          self._currentFn.block.buildReturn(Some(exprVal))

          self._currentFn.block.registerLabel(labelCont)
          val happyPathQbeType = try self._getQbeTypeForTypeExpect(node.ty, "unacceptable type", None)
          val happyPathVal = if isOptionTry {
            try self._emitOptValueGetValue(happyPathQbeType, exprVal)
          } else {
            try self._emitResultValueGetValue(happyPathQbeType, exprVal)
          }

          Ok(happyPathVal)
        }
      }
      _ => unreachable("node must be a statement")
    }

    self._currentNode = prevNode

    res
  }

  func _compileLiteral(self, lit: LiteralAstNode): Result<(Value, Type), CompileError> {
    Ok(match lit {
      LiteralAstNode.Int(v) => (Value.Int(v), Type(kind: TypeKind.PrimitiveInt))
      LiteralAstNode.Float(f) => (Value.Float(f), Type(kind: TypeKind.PrimitiveFloat))
      LiteralAstNode.Bool(b) => (Value.Int(if b 1 else 0), Type(kind: TypeKind.PrimitiveBool))
      LiteralAstNode.Char(c) => (Value.IntU64(c), Type(kind: TypeKind.PrimitiveChar))
      LiteralAstNode.String(s) => {
        val (dataPtr, _, _) = self._builder.buildGlobalString(s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"").replaceAll("\n", "\\n").replaceAll("\r", "\\r"))
        val instancePtr = try self._constructString(dataPtr, Value.Int(s.length))
        (instancePtr, Type(kind: TypeKind.PrimitiveString))
      }
    })
  }

  func _compileMatch(self, node: TypedAstNode, isStatement: Bool, expr: TypedAstNode, cases: TypedMatchCase[]): Result<Value?, CompileError> {
    val exprVal = try self._compileExpression(expr)

    val matchLabelPrefix = "match_${node.token.position.line}_${node.token.position.col}"
    val endLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_end")
    var seenNoneCase = false
    val exprTypeIsOpt = self._typeIsOption(expr.ty)

    val resValSlotCtx = if !isStatement {
      val slotName = "${matchLabelPrefix}_result.slot"
      val nodeTypeQbe = try self._getQbeTypeForTypeExpect(node.ty, "qbe type should exist", Some(node.token.position))
      val slot = self._buildStackAllocForQbeType(nodeTypeQbe, Some(slotName))
      Some((slot, nodeTypeQbe))
    } else None

    for case, idx in cases {
      val (nextCaseLabel, exprVal, exprType) = match case.kind {
        TypedMatchCaseKind.Literal(lit) => {
          val nextCaseLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__next")

          val (exprVal, exprType) = if exprTypeIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            if seenNoneCase {
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)
              (optInnerValue, innerTy)
            } else {
              val isSomeCond = try self._emitOptValueIsSomeVariant(exprVal)
              val isSomeLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__issome")
              self._currentFn.block.buildJnz(isSomeCond, isSomeLabel, nextCaseLabel)
              self._currentFn.block.registerLabel(isSomeLabel)
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)
              (optInnerValue, innerTy)
            }
          } else {
            (exprVal, expr.ty)
          }

          val (litVal, litType) = try self._compileLiteral(lit)

          if !self._project.typesAreEquivalent(exprType, litType) unreachable("equality operators require matching types")

          val cond = try self._compileEqLogic(exprVal, litVal, litType, expr.token.position)
          val isEqLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_iseq")

          self._currentFn.block.buildJnz(cond, isEqLabel, nextCaseLabel)
          self._currentFn.block.registerLabel(isEqLabel)

          (Some(nextCaseLabel), exprVal, exprType)
        }
        TypedMatchCaseKind.None_ => {
          seenNoneCase = true

          val isNoneCond = try self._emitOptValueIsSomeVariant(exprVal: exprVal, negate: true)
          val isNoneLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_isnone")
          val nextCaseLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_next_$idx")

          self._currentFn.block.buildJnz(isNoneCond, isNoneLabel, nextCaseLabel)
          self._currentFn.block.registerLabel(isNoneLabel)

          (Some(nextCaseLabel), exprVal, expr.ty)
        }
        TypedMatchCaseKind.EnumVariant(enum_, variant, variantIdx, destructuredVariables) => {
          val nextCaseLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__next")
          val (exprVal, exprType) = if exprTypeIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            if seenNoneCase {
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)
              (optInnerValue, innerTy)
            } else {
              val isSomeCond = try self._emitOptValueIsSomeVariant(exprVal)
              val isSomeLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__issome")
              self._currentFn.block.buildJnz(isSomeCond, isSomeLabel, nextCaseLabel)
              self._currentFn.block.registerLabel(isSomeLabel)
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)
              (optInnerValue, innerTy)
            }
          } else {
            (exprVal, expr.ty)
          }

          val exprValVariantIdxVal = self._emitGetEnumVariantIdx(exprVal)
          val cond = try self._currentFn.block.buildCompareEq(exprValVariantIdxVal, Value.Int(variantIdx)) else |e| return qbeError(e)
          val isVariantLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_is${variant.label.name}")

          self._currentFn.block.buildJnz(cond, isVariantLabel, nextCaseLabel)
          self._currentFn.block.registerLabel(isVariantLabel)

          if !destructuredVariables.isEmpty() {
            try self._addResolvedGenericsLayerForEnumVariant(exprType, variant.label.name, node.token.position)
            val variantFields = match variant.kind {
              EnumVariantKind.Container(fields) => fields
              _ => unreachable("cannot destructure a non-container enum variant")
            }

            var memCursor = try self._emitGetEnumVariantValueStart(exprVal)
            for v, idx in destructuredVariables {
              val field = try variantFields[idx] else unreachable("this should be caught during typechecking")
              val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))

              val fieldVal = self._currentFn.block.buildLoad(fieldTy, memCursor)
              val slotName = self._currentFn.block.addVar(variableToVar(v))
              val slot = self._buildStackAllocForQbeType(fieldTy, Some(slotName))
              self._currentFn.block.buildStore(fieldTy, fieldVal, slot)

              if idx != destructuredVariables.length - 1 {
                val offset = fieldTy.size()
                memCursor = try self._currentFn.block.buildAdd(Value.Int(offset), memCursor) else |e| return qbeError(e)
              }
            }

            self._resolvedGenerics.popLayer()
          }

          (Some(nextCaseLabel), exprVal, exprType)
        }
        TypedMatchCaseKind.Else => {
          val (exprVal, exprType) = if exprTypeIsOpt |innerTy| {
            if seenNoneCase {
              val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)

              (optInnerValue, innerTy)
            } else {
              (exprVal, expr.ty)
            }
          } else (exprVal, expr.ty)

          // No nextCaseLabel, since the `else` case will always be the last case if present
          (None, exprVal, exprType)
        }
        _ => todo("other match case types")
      }

      if case.binding |v| {
        val slotName = self._currentFn.block.addVar(variableToVar(v))
        val bindingTypeQbe = try self._getQbeTypeForTypeExpect(exprType, "qbe type should exist", Some(v.label.position))
        val slot = self._buildStackAllocForQbeType(bindingTypeQbe, Some(slotName))
        self._currentFn.block.buildStore(bindingTypeQbe, exprVal, slot)
      }

      for node, idx in case.body {
        val res = try self._compileStatement(node)
        if idx == case.body.length - 1 {
          if resValSlotCtx |(slot, slotTy)| {
            if !case.terminator {
              if res |res| {
                self._currentFn.block.buildStore(slotTy, res, slot)
              }
            }
          }
        }
      }
      if !case.terminator {
        self._currentFn.block.buildJmp(endLabel)
      }

      if nextCaseLabel |nextCaseLabel| {
        self._currentFn.block.registerLabel(nextCaseLabel)
      }
    }

    self._currentFn.block.registerLabel(endLabel)

    val result = if resValSlotCtx |(slot, slotTy)| {
      val res = self._currentFn.block.buildLoad(slotTy, slot)
      Some(res)
    } else {
      None
    }

    Ok(result)
  }

  func _compileBindingPattern(self, pattern: BindingPattern, variables: Map<String, Variable>, exprVal: Value?): Result<Int, CompileError> {
    val varName = match pattern {
      BindingPattern.Variable(label) => label.name
      BindingPattern.Tuple(_, patterns) => {
        val tuplePtr = try exprVal else return Ok(0)

        for pat, idx in patterns {
          val tupleItemSlot = try self._currentFn.block.buildAdd(Value.Int(idx * QbeType.Pointer.size()), tuplePtr) else |e| return qbeError(e)
          val tupleItemSlotTy = match pat {
            BindingPattern.Variable(label) => {
              val variable = try variables[label.name] else unreachable("expected binding '${label.name}', but missing from variables")
              val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
              varTy
            }
            _ => QbeType.Pointer
          }
          val tupleItemVal = self._currentFn.block.buildLoad(tupleItemSlotTy, tupleItemSlot)
          try self._compileBindingPattern(pat, variables, Some(tupleItemVal))
        }

        return Ok(0)
      }
    }

    val variable = try variables[varName] else unreachable("expected binding '$varName', but missing from variables")
    val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))

    val v = try exprVal else return Ok(0)

    // A top-level variable in a module is only hoisted to global if it's captured; otherwise it's effectively a local within the module wrapper function
    val isGlobal = !!variable.isGlobal()
    if variable.isExported || (variable.isCaptured && isGlobal) {
      val name = self._globalVarName(self._currentModule.id, variable.label.name)
      self._currentFn.block.addVar(variableToVar(variable))
      val (slot, _) = self._builder.addData(QbeData(name: name, kind: QbeDataKind.Constants([(varTy, varTy.zeroValue())])))
      self._currentFn.block.buildStore(varTy, v, slot)
      return Ok(0)
    }

    val slotName = self._currentFn.block.addVar(variableToVar(variable))
    if variable.isCaptured && variable.mutable && !isGlobal {
      // Only move captured variables to the heap if they're mutable - captured immutable variables can just have their value present in
      // a closure's captures array, but a mutable variable needs an additional layer of indirection to handle possible reassignment.
      self._currentFn.block.addComment("move captured mutable '${variable.label.name}' to heap")
      val size = varTy.size()
      val heapMem = try self._callMalloc(Value.Int(size), Some("${variable.label.name}.mem"))
      self._currentFn.block.buildStore(varTy, v, heapMem)

      val slot = self._buildStackAllocForQbeType(QbeType.Pointer, Some(slotName))
      self._currentFn.block.buildStore(QbeType.Pointer, heapMem, slot)
    } else {
      val slot = self._buildStackAllocForQbeType(varTy, Some(slotName))
      self._currentFn.block.buildStore(varTy, v, slot)
    }

    Ok(0)
  }

  func _getCapturedVarPtr(self, variable: Variable): Result<Value, CompileError> {
    if variable.isGlobal() unreachable("Global variables are never included in a function's captures")

    if self._currentFunction |fn| {
      if self._currentFn.env |env| {
        for v, idx in fn.captures {
          if v.label.name == variable.label.name {
            // When loading the captured variable from the closure env, if the captured variable is immutable then we
            // don't need to dereference the value of `env[idx]`; only mutable variables need to be stored using an
            // additional indirection layer to account for reassignment.
            val captureSlot = try self._currentFn.block.buildAdd(Value.Int(idx * QbeType.Pointer.size()), env) else |e| return qbeError(e)
            var varTy = if variable.mutable {
              self._currentFn.block.addComment("get ptr to captured mutable '${variable.label.name}'")
              QbeType.Pointer
            } else {
              self._currentFn.block.addComment("get captured '${variable.label.name}'")
              try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
            }
            val ptrOrValue = self._currentFn.block.buildLoad(varTy, captureSlot)
            return Ok(ptrOrValue)
          }
        }
      }
    }

    // If the captured variable is a parameter but we're not currently referencing it from a closure, then it can be resolved as any ordinary
    // parameter (simply by name) since it's an immutable variable that has not been moved to the heap.
    if variable.isParameter {
      val slotName = try self._currentFn.block.lookupVarName(variableToVar(variable)) else unreachable("Could not resolve name for variable '${variable.label.name}'")
      val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
      return Ok(Value.Ident(slotName, varTy))
    }

    // If we're not currently in a function body, or if the captured variable is not a capture of the current function, then
    // we may need to undo the extra layer of pointer indirection which comes as a result of being captured by some other function,
    // if the captured variable is mutable. If it's not mutable then it will not have been moved to the heap, so no additional pointer
    // needs to be dereferenced.
    val slotName = try self._currentFn.block.lookupVarName(variableToVar(variable)) else unreachable("Could not resolve name for variable '${variable.label.name}'")
    val slot = Value.Ident(slotName, QbeType.Pointer)
    var varTy = if variable.mutable {
      self._currentFn.block.addComment("get ptr to captured mutable '${variable.label.name}'")
      QbeType.Pointer
    } else {
      self._currentFn.block.addComment("get captured '${variable.label.name}'")
      try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
    }
    val ptrOrValue = self._currentFn.block.buildLoad(varTy, slot)
    Ok(ptrOrValue)
  }

  func _createClosureCaptures(self, fn: Function): Result<Value, CompileError> {
    val size = QbeType.Pointer.size() * (fn.captures.length + fn.capturedClosures.length)
    val capturesMem = try self._callMalloc(Value.Int(size), Some("${fn.label.name}_captures.mem"))
    var cursor = capturesMem

    for variable in fn.captures {
      val ptr = try self._getCapturedVarPtr(variable)
      var varTy = if variable.mutable {
        self._currentFn.block.addComment("store ptr to captured mutable '${variable.label.name}' in captures")
        QbeType.Pointer
      } else {
        self._currentFn.block.addComment("store captured '${variable.label.name}' in captures")
        try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
      }
      self._currentFn.block.buildStore(varTy, ptr, cursor)
      if fn.captures.length > 1 || fn.capturedClosures.length > 0 {
        cursor = try self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size()), cursor) else |e| return qbeError(e)
      }
    }

    for capturedFn in fn.capturedClosures {
      val capturesArr = try self._getCapturesArrForClosure(capturedFn)
      self._currentFn.block.buildStore(QbeType.Pointer, capturesArr, cursor)
      if fn.capturedClosures.length > 1 {
        cursor = try self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size()), cursor) else |e| return qbeError(e)
      }
    }

    Ok(capturesMem)
  }

  func _getCapturesArrForClosure(self, fn: Function): Result<Value, CompileError> {
    val fnInvocationIsAtDeclaredScope = if self._currentFunction |currentFunc| {
      fn.scope.parent == Some(currentFunc.scope)
    } else {
      true
    }

    val res = if !fnInvocationIsAtDeclaredScope {
      val currentFunc = try self._currentFunction else unreachable("we must be within a function to enter this case")

      val idx = if currentFunc.capturedClosures.findIndex(f => f.label.name == fn.label.name) |(_, idx)| idx else unreachable("closure '${fn.label.name}' called within function '${currentFunc.label.name}', but not tracked in its capturedClosures")
      val env = try self._currentFn.env else unreachable("expected currentFn ('${self._currentFn.name}') to have an `env`, but it didn't")
      val offset = QbeType.Pointer.size() * (currentFunc.captures.length + idx)

      val ptr = try self._currentFn.block.buildAdd(Value.Int(offset), env) else |e| return qbeError(e)
      self._currentFn.block.buildLoadL(ptr)
    } else {
      // If the closure is being called in the same scope in which it was declared, then the `*.captures` value is visible as a stack local.
      val prefix = match fn.kind {
        FunctionKind.InstanceMethod(instanceKind, _) => {
          if instanceKind |instanceKind| {
            val typeName = match instanceKind {
              InstanceKind.Struct(struct) => struct.label.name
              InstanceKind.Enum(enum_) => enum_.label.name
            }
            "$typeName.."
          } else unreachable("an instance method should have a instanceKind")
        }
        FunctionKind.StaticMethod(instanceKind, _) => {
          val typeName = match instanceKind {
            InstanceKind.Struct(struct) => struct.label.name
            InstanceKind.Enum(enum_) => enum_.label.name
          }
          "$typeName."
        }
        _ => ""
      }
      val capturesName = "$prefix${fn.label.name}.captures"
      self._currentFn.block.buildLoadL(Value.Ident(capturesName, QbeType.Pointer))
    }

    Ok(res)
  }

  func _compileBinaryOperands(self, left: TypedAstNode, right: TypedAstNode, op: String): Result<(Value, Value), CompileError> {
    var leftVal = try self._compileExpression(left)
    var rightVal = try self._compileExpression(right)

    if !self._project.typesAreEquivalent(left.ty, right.ty) {
      val leftIsFloat = self._typeIsFloat(left.ty)
      val rightIsFloat = self._typeIsFloat(right.ty)
      if leftIsFloat && !rightIsFloat {
        rightVal = self._currentFn.block.buildLToF(rightVal)
      } else if rightIsFloat && !leftIsFloat {
        leftVal = self._currentFn.block.buildLToF(leftVal)
      } else {
        unreachable("unknown operator '$op' between types '${left.ty.repr()}' and '${right.ty.repr()}'")
      }
    }

    Ok((leftVal, rightVal))
  }

  func _compileBinaryEq(self, left: TypedAstNode, right: TypedAstNode, localName: String? = None, negate = false): Result<Value, CompileError> {
    var leftVal = try self._compileExpression(left)
    var rightVal = try self._compileExpression(right)

    if !self._project.typesAreEquivalent(left.ty, right.ty) unreachable("equality operators require matching types")

    self._compileEqLogic(leftVal, rightVal, left.ty, left.token.position, localName, negate)
  }

  func _compileEqLogic(self, leftVal: Value, rightVal: Value, ty: Type, position: Position, localName: String? = None, negate = false): Result<Value, CompileError> {
    if self._typeIsInt(ty) || self._typeIsFloat(ty) || self._typeIsBool(ty) || self._typeIsChar(ty) {
      val res = if negate {
        val res = try self._currentFn.block.buildCompareNeq(leftVal, rightVal, localName) else |e| return qbeError(e)
        self._currentFn.block.buildExt(res, false)
      } else {
        val res = try self._currentFn.block.buildCompareEq(leftVal, rightVal, localName) else |e| return qbeError(e)
        self._currentFn.block.buildExt(res, false)
      }
      return Ok(res)
    }

    val instType = try self._addResolvedGenericsLayerForInstanceMethod(ty, "eq", position)
    val eqFnVal = try self._getOrCompileEqMethod(instType)
    self._resolvedGenerics.popLayer()

    val fnName = self._functionName("eq", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(ty))[0]), true))
    val frameCtx = CallframeContext(position: position, callee: Some(fnName))
    val res = try self._buildCall(Some(frameCtx), Callable.Function(eqFnVal), [leftVal, rightVal], localName)
    if negate {
      val plusOneVal = try self._currentFn.block.buildAdd(Value.Int(1), res) else |e| return qbeError(e)
      val res = try self._currentFn.block.buildRem(plusOneVal, Value.Int(2)) else |e| return qbeError(e)
      Ok(res)
    } else {
      Ok(res)
    }
  }

  func _compileFunctionValue(
    self,
    position: Position,
    fn: Function,
    targetParamTypes: (Type, Bool)[]?,
    capturesPtr: Value?,
    capturedSelf: (Value, Type)?,
  ): Result<Value, CompileError> {
    val closureEnvPtr = capturesPtr ?: Value.Int(0)

    val (selfVal, selfType, selfTy) = if capturedSelf |(selfVal, selfType)| {
      val selfTy = try self._getQbeTypeForTypeExpect(selfType, "unacceptable type for param", Some(position))
      (selfVal, Some(selfType), Some(selfTy))
    } else {
      (Value.Int(0), None, None)
    }

    val fnValParamTypes = if targetParamTypes |paramTypes| {
      paramTypes.filter(_p => _p[1]).map(_p => _p[0])
    } else {
      fn.params.filter(p => !p.defaultValue).map(p => p.ty)
    }
    val targetArity = fnValParamTypes.length

    val fnVal = if targetArity == fn.params.length {
      if selfType |selfType| {
        try self._getOrCompileMethod(selfType, fn)
      } else {
        try self._getOrCompileFunction(fn)
      }
    } else if targetArity < fn.params.length {
      val paramsNeedingDefaultValue = fn.params.map((param, idx) => {
        if fnValParamTypes[idx] {
          false
        } else {
          if !param.defaultValue unreachable("creating fn val for fn '${fn.label}' with arity $targetArity param '${param.label.name}' to be optional (at $position)")
          true
        }
      })

      if selfType |selfType| {
        try self._getOrCompileMethod(selfType, fn, paramsNeedingDefaultValue)
      } else {
        try self._getOrCompileFunction(fn, paramsNeedingDefaultValue)
      }
    } else {
      val baseFn = if selfType |selfType| {
        try self._getOrCompileMethod(selfType, fn)
      } else {
        try self._getOrCompileFunction(fn)
      }

      val fnName = self._fnName(fn) + ".discard"
      val returnTypeQbe = try self._getQbeTypeForType(fn.returnType)
      val fnVal = self._builder.buildFunction(name: fnName, returnType: returnTypeQbe)
      if fn.isClosure() fnVal.addEnv()

      val prevFn = self._currentFn
      self._currentFn = fnVal
      val prevFunction = self._currentFunction
      self._currentFunction = Some(fn)

      val argsForUnderlying: Value[] = []
      for param, idx in fn.params {
        val paramTy = try self._getQbeTypeForTypeExpect(param.ty, "unacceptable type for param", Some(param.label.position))

        val paramVal = fnVal.addParameter(param.label.name, paramTy)
        argsForUnderlying.push(paramVal)
      }
      fnVal.isVariadic = true

      var retVal = if fn.returnType.kind != TypeKind.PrimitiveUnit {
        val ret = try self._buildCall(None, Callable.Function(baseFn), argsForUnderlying)
        Some(ret)
      } else {
        try self._buildVoidCall(None, Callable.Function(baseFn), argsForUnderlying)
        None
      }

      if fn.scope.terminator != Some(Terminator.Returning) {
        fnVal.block.buildReturn(retVal)
      }

      self._currentFn = prevFn
      self._currentFunction = prevFunction

      fnVal
    }

    val hasReturn = fn.returnType.kind != TypeKind.PrimitiveUnit
    val (struct, _) = self._functionStruct(targetArity, hasReturn)
    val typeArgs = (if hasReturn { [fn.returnType] } else []).concat(fnValParamTypes)
    val fnStructSelfType = Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), typeArgs))

    val resolvedGenerics: Map<String, Type> = {}
    val template = Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
    for (name, ty) in fnStructSelfType.extractGenerics(template) {
      resolvedGenerics[name] = ty
    }
    match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }
    val initFnVal = try self._getOrCompileStructInitializer(struct)

    self._resolvedGenerics.popLayer()

    // Do not track Function.init in callframes
    self._buildCall(None, Callable.Function(initFnVal), [closureEnvPtr, selfVal, Value.Global(fnVal.name, QbeType.Pointer)])
  }

  func _constructString(self, ptrVal: Value, lenVal: Value, localName: String? = None): Result<Value, CompileError> {
    val fnVal = try self._getOrCompileStructInitializer(self._project.preludeStringStruct, [false, false])
    val structTy = try fnVal.returnType else unreachable("initializer functions must have return types specified")

    // Do not track String.init in callframes
    self._buildCall(None, Callable.Function(fnVal), [lenVal, ptrVal], localName)
  }

  func _getQbeTypeForType(self, ty: Type): Result<QbeType?, CompileError> {
    match ty.kind {
      TypeKind.CouldNotDetermine => unreachable("used for surfacing partial results; no module with this type should make it to the compilation phase")
      TypeKind.PrimitiveUnit => Ok(None)
      TypeKind.PrimitiveInt => Ok(Some(QbeType.U64))
      TypeKind.PrimitiveFloat => Ok(Some(QbeType.F64))
      TypeKind.PrimitiveBool => Ok(Some(QbeType.U64))
      TypeKind.PrimitiveChar => Ok(Some(QbeType.U64))
      TypeKind.PrimitiveString => Ok(Some(QbeType.Pointer))
      TypeKind.Never => Ok(None)
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getQbeTypeForType(ty) else unreachable("unexpected generic '$name' at this point")
      }
      TypeKind.Instance(instanceKind, generics) => {
        match instanceKind {
          InstanceKind.Struct(struct) => {
            if struct == self._project.preludeIntStruct return Ok(Some(QbeType.U64))
            if struct == self._project.preludeFloatStruct return Ok(Some(QbeType.F64))

            if struct.builtin == Some(BuiltinModule.Intrinsics) {
              if struct.label.name == "Byte" return Ok(Some(QbeType.U64))
              if struct.label.name == "Pointer" return Ok(Some(QbeType.Pointer))
            }
          }
          _ => {}
        }

        Ok(Some(QbeType.Pointer))
      }
      TypeKind.Func(paramTypes, returnType) => Ok(Some(QbeType.Pointer))
      TypeKind.Type(type_) => todo("TypeKind.Type")
      TypeKind.Tuple(_) => Ok(Some(QbeType.Pointer))
      TypeKind.Hole => unreachable("unexpected hole in emitted typed ast")
    }
  }

  func _getQbeTypeForTypeExpect(self, ty: Type, reason: String, position: Position? = None): Result<QbeType, CompileError> {
    val _ty = try self._getQbeTypeForType(ty)
    if _ty |ty| Ok(ty) else if position |pos| unreachable("($pos) reason") else unreachable(reason)
  }

  func _followAccessorPath(self, head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment, loadFinal: Bool, localName: String? = None): Result<Value, CompileError> {
    val segs = middle.concat([tail])
    var instTy = InstanceKind.Struct(self._project.preludeBoolStruct)
    var instType = Type(kind: TypeKind.Instance(InstanceKind.Struct(self._project.preludeBoolStruct), []))
    var curVal = Value.Ident("bogus", QbeType.F32)
    match segs[0] {
      AccessorPathSegment.Field => {
        // TODO: assert that `head.ty` is a pointer type (attempting to do pointer arithmetic later on will fail otherwise)
        val (_instTy, typeArgs) = try self._getInstanceTypeForType(head.ty)
        instTy = _instTy
        instType = Type(kind: TypeKind.Instance(instTy, typeArgs))

        curVal = try self._compileExpression(head)
        self._currentFn.block.addCommentBefore("${curVal.repr()}: ${head.ty.repr()}")
      }
      AccessorPathSegment.Method(_, fn, _, _) => {
        match fn.kind {
          FunctionKind.InstanceMethod => {
            // TODO: assert that `head.ty` is a pointer type (attempting to do pointer arithmetic later on will fail otherwise)
            val (_instTy, typeArgs) = try self._getInstanceTypeForType(head.ty)
            instTy = _instTy
            instType = Type(kind: TypeKind.Instance(instTy, typeArgs))

            curVal = try self._compileExpression(head)
            self._currentFn.block.addCommentBefore("${curVal.repr()}: ${head.ty.repr()}")
          }
          _ => {}
        }
      }
      _ => {}
    }

    for seg, idx in segs {
      match seg {
        AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => {
          match variant.kind {
            EnumVariantKind.Container => unreachable("non-constant enum variant missing instantation")
            _ => {}
          }

          curVal = try self._getOrCompileEnumVariantConst(enum_, variant)

          instTy = InstanceKind.Enum(enum_)
        }
        AccessorPathSegment.Method(label, fn, isOptSafe, fnAliasTypeHint) => {
          if isOptSafe todo("opt-safe method accessor")

          val selfInstType = match fn.kind {
            FunctionKind.InstanceMethod => {
              val selfInstType = try self._addResolvedGenericsLayerForInstanceMethod(instType, fn.label.name, label.position)
              Some(selfInstType)
            }
            _ => None
          }

          val capturesMem = if fn.isClosure() {
            val capturesArr = try self._getCapturesArrForClosure(fn)
            Some(capturesArr)
          } else {
            None
          }

          val targetParamTypes = if fnAliasTypeHint |hint| {
            val paramTypes = match hint.kind {
              TypeKind.Func(paramTypes, _) => Some(paramTypes)
              // If the function value is being treated as a Hole, then no param type info needs to be known later anyway
              TypeKind.Hole => None
              _ => unreachable("fnAliasTypeKind must be TypeKind.Func")
            }
            paramTypes
          } else {
            None
          }

          self._resolvedGenerics.popLayer()

          val selfVal = if selfInstType |selfInstType| Some((curVal, selfInstType)) else None
          curVal = try self._compileFunctionValue(label.position, fn, targetParamTypes, capturesMem, selfVal)
        }
        AccessorPathSegment.Field(label, ty, field, isOptSafe) => {
          val selfInstType = try self._addResolvedGenericsLayerForInstanceMethod(instType, field.name.name, label.position)

          var optSafeCtx: (Label, Value, QbeFunction, Label)? = None

          if isOptSafe {
            val innerTy = try self._typeIsOption(ty) else unreachable("an opt-safe field accessor needs to have an Option type as its lhs")
            val unwrappedInstType = try self._typeIsOption(instType) else unreachable("an opt-safe field accessor needs to have an Option type as its lhs")
            instType = unwrappedInstType
            val (_instTy, _) = try self._getInstanceTypeForType(unwrappedInstType)
            instTy = _instTy

            val variantIsOptionSome = try self._emitOptValueIsSomeVariant(curVal)
            val labelIsSome = self._currentFn.block.addLabel("optsafe_field_is_some")
            val labelIsNone = self._currentFn.block.addLabel("optsafe_field_is_none")
            val labelCont = self._currentFn.block.addLabel("optsafe_field_cont")

            self._currentFn.block.addComment("begin opt-safe field accessor...")
            self._currentFn.block.buildJnz(variantIsOptionSome, labelIsSome, labelIsNone)

            self._currentFn.block.registerLabel(labelIsNone)
            val (optNoneVariant, _) = self._getEnumVariantByName(self._project.preludeOptionEnum, "None")
            val noneRes = try self._getOrCompileEnumVariantConst(self._project.preludeOptionEnum, optNoneVariant)
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.registerLabel(labelIsSome)
            val (optSomeVariant, _) = self._getEnumVariantByName(self._project.preludeOptionEnum, "Some")
            match self._resolvedGenerics.addLayer("Option.Some", { "V": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: label.position, kind: CompileErrorKind.ResolvedGenericsError(context: "Option.Some", message: e))) }
            val someVariantFn = try self._getOrCompileEnumVariantFn(self._project.preludeOptionEnum, optSomeVariant)
            self._resolvedGenerics.popLayer()

            optSafeCtx = Some((labelIsNone, noneRes, someVariantFn, labelCont))

            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            curVal = try self._emitOptValueGetValue(innerQbeType, curVal)
          }

          match instTy {
            InstanceKind.Struct(struct) => {
              var offset = 0
              var fieldTyQbe = QbeType.F32 // placeholder sentinel value
              for f in struct.fields {
                val fieldTy = try self._getQbeTypeForTypeExpect(f.ty, "unacceptable type for field", Some(f.name.position))
                if f.name.name == field.name.name {
                  fieldTyQbe = fieldTy
                  break
                }

                offset += fieldTy.size()
              }
              if fieldTyQbe == QbeType.F32 unreachable("fieldTyQbe == QbeType.F32")

              val ptr = try self._currentFn.block.buildAdd(Value.Int(offset), curVal) else |e| return qbeError(e)
              if idx == segs.length - 1 {
                if !loadFinal {
                  curVal = ptr
                } else {
                  val nextVal = self._currentFn.block.buildLoad(fieldTyQbe, ptr, localName)
                  self._currentFn.block.addCommentBefore("${nextVal.repr()}: ${curVal.repr()}.${field.name.name}")
                  curVal = nextVal
                }
              } else {
                val nextVal = self._currentFn.block.buildLoad(fieldTyQbe, ptr)
                self._currentFn.block.addCommentBefore("${nextVal.repr()}: ${curVal.repr()}.${field.name.name}")
                curVal = nextVal
              }
            }
            InstanceKind.Enum(_enum) => todo("enum field accessor")
          }

          if optSafeCtx |(labelIsNone, noneRes, someVariantFn, labelCont)| {
            val labelIsSome = self._currentFn.block.currentLabel
            // Do not track Option.Some in callframes
            val someRes = try self._buildCall(None, Callable.Function(someVariantFn), [curVal])
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.addComment("...opt-safe field accessor end")
            self._currentFn.block.registerLabel(labelCont)

            val phiCases = [(labelIsNone, noneRes), (labelIsSome, someRes)]
            curVal = try self._currentFn.block.buildPhi(phiCases, localName) else |e| return qbeError(e)
          }

          val (_instTy, typeArgs) = try self._getInstanceTypeForType(ty)
          instTy = _instTy
          instType = Type(kind: TypeKind.Instance(instTy, typeArgs))

          self._resolvedGenerics.popLayer()
        }
      }
    }

    Ok(curVal)
  }

  func _getOrCompileStructInitializer(self, struct: Struct, fieldsNeedingDefaultValue: Bool[] = []): Result<QbeFunction, CompileError> {
    val defaultValuesFlag = fieldsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    var fnName = try self._structInitializerFnName(struct)
    if defaultValuesFlag != 0 { fnName += ".$defaultValuesFlag" }
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: fnName, returnType: Some(QbeType.Pointer))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    fnVal.addCommentMultiline(try self._structSignature(struct, fieldsNeedingDefaultValue))

    val argsForUnderlying: Value[] = []
    var anyFieldNeedsDefault = false
    var size = 0
    for field, idx in struct.fields {
      val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))
      size += fieldTy.size()

      val fieldVal = if field.initializer |initializerNode| {
        val fieldNeedsDefault = fieldsNeedingDefaultValue[idx] ?: false
        if fieldNeedsDefault {
          anyFieldNeedsDefault = true
          try self._compileExpression(initializerNode, Some(field.name.name))
        } else {
          fnVal.addParameter(field.name.name, fieldTy)
        }
      } else {
        fnVal.addParameter(field.name.name, fieldTy)
      }
      argsForUnderlying.push(fieldVal)
    }

    val retVal = if anyFieldNeedsDefault {
      val baseFn = try self._getOrCompileStructInitializer(struct)
      try self._buildCall(None, Callable.Function(baseFn), argsForUnderlying)
    } else {
      val memLocal = try self._callMalloc(Value.Int(size), Some("struct.mem"))

      var offset = 0
      for field in struct.fields {
        val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))
        val param = Value.Ident(field.name.name, fieldTy)

        val localName = "mem_offset_${field.name.name}"
        val memCursorLocal = try fnVal.block.buildAdd(Value.Int(offset), memLocal, Some(localName)) else |e| return qbeError(e)
        fnVal.block.buildStore(fieldTy, param, memCursorLocal)

        offset += fieldTy.size()
      }

      memLocal
    }
    fnVal.block.buildReturn(Some(retVal))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileEnumVariantConst(self, enum_: Enum, variant: TypedEnumVariant): Result<Value, CompileError> {
    val base = self._enumTypeNameBase(enum_)
    val variantDataName = "$base.${variant.label.name}"
    if self._builder.getData(variantDataName) |v| return Ok(v)

    val (_, variantIdx) = self._getEnumVariantByName(enum_, variant.label.name)
    val (slot, _) = self._builder.addData(QbeData(name: variantDataName, kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(variantIdx))])))

    Ok(slot)
  }

  func _getOrCompileEnumVariantFn(self, enum_: Enum, variant: TypedEnumVariant, fieldsNeedingDefaultValue: Bool[] = []): Result<QbeFunction, CompileError> {
    val defaultValuesFlag = fieldsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    var variantFnName = try self._enumVariantFnName(enum_, variant)
    if defaultValuesFlag != 0 { variantFnName += ".$defaultValuesFlag" }

    if self._builder.getFunction(variantFnName) |fn| return Ok(fn)

    // TODO: constant variants shouldn't be a function - it should just be a `data` segment with the proper idx set
    val fn = self._builder.buildFunction(name: variantFnName, returnType: Some(QbeType.Pointer))
    val prevFn = self._currentFn
    self._currentFn = fn
    fn.addComment(try self._enumVariantSignature(enum_, variant, fieldsNeedingDefaultValue))

    val fields = match variant.kind {
      EnumVariantKind.Container(fields) => fields
      _ => unreachable("constant enum variants are not backed by functions, see _getOrCompileEnumVariantConst")
    }

    val argsForUnderlying: Value[] = []
    var anyFieldNeedsDefault = false
    var size = 0
    size += QbeType.U64.size() // account for space for variant idx slot
    for field, idx in fields {
      val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))
      size += fieldTy.size()

      val fieldVal = if field.initializer |initializerNode| {
        val fieldNeedsDefault = fieldsNeedingDefaultValue[idx] ?: false
        if fieldNeedsDefault {
          anyFieldNeedsDefault = true
          try self._compileExpression(initializerNode, Some(field.name.name))
        } else {
          fn.addParameter(field.name.name, fieldTy)
        }
      } else {
        fn.addParameter(field.name.name, fieldTy)
      }
      argsForUnderlying.push(fieldVal)
    }

    val retVal = if anyFieldNeedsDefault {
      val baseFn = try self._getOrCompileEnumVariantFn(enum_, variant)
      try self._buildCall(None, Callable.Function(baseFn), argsForUnderlying)
    } else {
      val memLocal = try self._callMalloc(Value.Int(size), Some("enum_variant.mem"))

      val (_, variantIdx) = self._getEnumVariantByName(enum_, variant.label.name)
      fn.block.buildStoreL(Value.Int(variantIdx), memLocal) // Store variant idx at designated slot
      var offset = QbeType.U64.size() // begin inserting any fields after that variant idx slot

      for field in fields {
        val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))
        val param = Value.Ident(field.name.name, fieldTy)

        val localName = "mem_offset_${field.name.name}"
        val memCursorLocal = try fn.block.buildAdd(Value.Int(offset), memLocal, Some(localName)) else |e| return qbeError(e)
        fn.block.buildStore(fieldTy, param, memCursorLocal)

        offset += fieldTy.size()
      }

      memLocal
    }

    fn.block.buildReturn(Some(retVal))

    self._currentFn = prevFn

    Ok(fn)
  }

  func invokeExternalFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val cFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => unreachable("@external decorator requires 1 string argument for the name")
    }

    val args: Value[] = []
    for arg in arguments {
      if arg |node| {
        val arg = try self._compileExpression(node)
        args.push(arg)
      } else {
        unreachable("functions with @external decorator cannot have optional parameters")
      }
    }

    val returnTypeQbe = try self._getQbeTypeForType(fn.returnType)
    val res = if returnTypeQbe |returnTy| {
      val res = try self._currentFn.block.buildCallRaw(cFnName, returnTy, args) else |e| return qbeError(e)
      res
    } else {
      self._currentFn.block.buildVoidCallRaw(cFnName, args)
      Value.Ident("bogus", QbeType.F32)
    }
    Ok(res)
  }

  func _pointerSize(self, ty: Type): Result<Int, CompileError> {
    val isByte = match ty.kind {
      TypeKind.Generic(name) => unreachable("unresolved generic '$name'")
      TypeKind.Instance(instanceKind, generics) => {
        match instanceKind {
          InstanceKind.Struct(struct) => struct.builtin == Some(BuiltinModule.Intrinsics) && struct.label.name == "Byte"
          _ => false
        }
      }
      _ => false
    }
    val size = if isByte 1 else 8

    Ok(size)
  }

  func _intrinsicArgs1(self, name: String, arguments: TypedAstNode?[]): TypedAstNode {
    val arg0 = try arguments[0] else unreachable("'$name' has 1 required argument")
    try arg0 else unreachable("'$name' has 1 required argument")
  }

  func _intrinsicArgs2(self, name: String, arguments: TypedAstNode?[]): (TypedAstNode, TypedAstNode) {
    val _arg0 = try arguments[0] else unreachable("'$name' has 2 required arguments")
    val arg0 = try _arg0 else unreachable("'$name' has 2 required arguments")

    val _arg1 = try arguments[1] else unreachable("'$name' has 2 required arguments")
    val arg1 = try _arg1 else unreachable("'$name' has 2 required arguments")

    (arg0, arg1)
  }

  func _intrinsicArgs3(self, name: String, arguments: TypedAstNode?[]): (TypedAstNode, TypedAstNode, TypedAstNode) {
    val _arg0 = try arguments[0] else unreachable("'$name' has 3 required arguments")
    val arg0 = try _arg0 else unreachable("'$name' has 3 required arguments")

    val _arg1 = try arguments[1] else unreachable("'$name' has 3 required arguments")
    val arg1 = try _arg1 else unreachable("'$name' has 3 required arguments")

    val _arg2 = try arguments[2] else unreachable("'$name' has 3 required arguments")
    val arg2 = try _arg2 else unreachable("'$name' has 3 required arguments")

    (arg0, arg1, arg2)
  }

  func _intrinsicArgs5(self, name: String, arguments: TypedAstNode?[]): (TypedAstNode, TypedAstNode, TypedAstNode, TypedAstNode, TypedAstNode) {
    val _arg0 = try arguments[0] else unreachable("'$name' has 5 required arguments")
    val arg0 = try _arg0 else unreachable("'$name' has 5 required arguments")

    val _arg1 = try arguments[1] else unreachable("'$name' has 5 required arguments")
    val arg1 = try _arg1 else unreachable("'$name' has 5 required arguments")

    val _arg2 = try arguments[2] else unreachable("'$name' has 5 required arguments")
    val arg2 = try _arg2 else unreachable("'$name' has 5 required arguments")

    val _arg3 = try arguments[3] else unreachable("'$name' has 5 required arguments")
    val arg3 = try _arg3 else unreachable("'$name' has 5 required arguments")

    val _arg4 = try arguments[4] else unreachable("'$name' has 5 required arguments")
    val arg4 = try _arg4 else unreachable("'$name' has 5 required arguments")

    (arg0, arg1, arg2, arg3, arg4)
  }

  func invokeIntrinsicFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val intrinsicFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => unreachable("@intrinsic decorator requires 1 string argument for the name")
    }

    self._currentFn.block.addComment("begin $intrinsicFnName...")

    val bogusValue = Value.Ident("bogus", QbeType.F32)
    val res = match intrinsicFnName {
      "pointer_is_null" => {
        val ptr = self._intrinsicArgs1(intrinsicFnName, arguments)
        val ptrVal = try self._compileExpression(ptr)

        val labelIsNull = self._currentFn.block.addLabel("ptr_is_null")
        val labelIsNotNull = self._currentFn.block.addLabel("ptr_is_not_null")
        val labelCont = self._currentFn.block.addLabel("ptr_null_cont")

        self._currentFn.block.buildJnz(ptrVal, labelIsNotNull, labelIsNull)

        self._currentFn.block.registerLabel(labelIsNotNull)
        val f = Value.Int(0)
        self._currentFn.block.buildJmp(labelCont)
        self._currentFn.block.registerLabel(labelIsNull)
        val t = Value.Int(1)
        self._currentFn.block.buildJmp(labelCont)
        self._currentFn.block.registerLabel(labelCont)

        val phiCases = [(labelIsNotNull, f), (labelIsNull, t)]
        try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)
      }
      "pointer_malloc" => {
        val count = self._intrinsicArgs1(intrinsicFnName, arguments)
        val countVal = try self._compileExpression(count)

        val innerTy = try self._resolvedGenerics.resolveGeneric("T") else unreachable("(pointer_malloc) could not resolve T for Pointer<T>")
        val innerTySize = try self._pointerSize(innerTy)
        val sizeVal = try self._currentFn.block.buildMul(Value.Int(innerTySize), countVal) else |e| return qbeError(e)

        try self._callMalloc(sizeVal, Some("ptr.mem"))
      }
      "pointer_null" => {
        try self._currentFn.block.buildAdd(Value.Int(0), Value.Int(0)) else |e| return qbeError(e)
      }
      "pointer_reinterpret" => {
        val ptr = self._intrinsicArgs1(intrinsicFnName, arguments)
        val ptrVal = try self._compileExpression(ptr)

        try self._currentFn.block.buildAdd(Value.Int(0), ptrVal) else |e| return qbeError(e)
      }
      "pointer_addressof" => {
        val ptr = self._intrinsicArgs1(intrinsicFnName, arguments)
        val ptrVal = try self._compileExpression(ptr)

        try self._currentFn.block.buildAdd(Value.Int(0), ptrVal) else |e| return qbeError(e)
      }
      "pointer_fromint" => {
        val ptr = self._intrinsicArgs1(intrinsicFnName, arguments)
        val ptrVal = try self._compileExpression(ptr)

        try self._currentFn.block.buildAdd(Value.Int(0), ptrVal) else |e| return qbeError(e)
      }
      "pointer_realloc" => {
        val (ptr, count) = self._intrinsicArgs2(intrinsicFnName, arguments)
        val ptrVal = try self._compileExpression(ptr)
        val countVal = try self._compileExpression(count)

        val innerTy = try self._resolvedGenerics.resolveGeneric("T") else unreachable("(pointer_realloc) could not resolve T for Pointer<T>")
        val innerTySize = try self._pointerSize(innerTy)
        val sizeVal = try self._currentFn.block.buildMul(Value.Int(innerTySize), countVal) else |e| return qbeError(e)

        try self._currentFn.block.buildCall(Callable.Function(self._realloc), [ptrVal, sizeVal], Some("mem")) else |e| return qbeError(e)
      }
      "pointer_store_at" => {
        val (ptr, value, offset) = self._intrinsicArgs3(intrinsicFnName, arguments)
        val ptrVal = try self._compileExpression(ptr)
        val valueVal = try self._compileExpression(value)
        val offsetVal = try self._compileExpression(offset)

        val innerTy = try self._resolvedGenerics.resolveGeneric("T") else unreachable("(pointer_store) could not resolve T for Pointer<T>")
        val innerTySize = try self._pointerSize(innerTy)

        val sizeVal = try self._currentFn.block.buildMul(Value.Int(innerTySize), offsetVal) else |e| return qbeError(e)
        val mem = try self._currentFn.block.buildAdd(sizeVal, ptrVal) else |e| return qbeError(e)

        if innerTySize == 1 {
          self._currentFn.block.buildStoreB(valueVal, mem)
        } else {
          val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
          self._currentFn.block.buildStore(innerQbeType, valueVal, mem)
        }

        bogusValue
      }
      "pointer_load_at" => {
        val (ptr, offset) = self._intrinsicArgs2(intrinsicFnName, arguments)
        val ptrVal = try self._compileExpression(ptr)
        val offsetVal = try self._compileExpression(offset)

        val innerTy = try self._resolvedGenerics.resolveGeneric("T") else unreachable("(pointer_load) could not resolve T for Pointer<T>")

        val innerTySize = try self._pointerSize(innerTy)
        val innerQbeType = if innerTySize == 1 QbeType.U8 else try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)

        val sizeVal = try self._currentFn.block.buildMul(Value.Int(innerTySize), offsetVal) else |e| return qbeError(e)
        val mem = try self._currentFn.block.buildAdd(sizeVal, ptrVal) else |e| return qbeError(e)

        self._currentFn.block.buildLoad(innerQbeType, mem)
      }
      "pointer_copy_from" => {
        val (ptr, dstOffset, src, srcOffset, size) = self._intrinsicArgs5(intrinsicFnName, arguments)
        val ptrVal = try self._compileExpression(ptr)
        val dstOffsetVal = try self._compileExpression(dstOffset)
        val srcVal = try self._compileExpression(src)
        val srcOffsetVal = try self._compileExpression(srcOffset)
        val sizeArg = try self._compileExpression(size)

        val innerTy = try self._resolvedGenerics.resolveGeneric("T") else unreachable("(pointer_copy_from) could not resolve T for Pointer<T>")
        val innerTySize = try self._pointerSize(innerTy)
        val sizeVal = try self._currentFn.block.buildMul(Value.Int(innerTySize), sizeArg) else |e| return qbeError(e)

        val dstMem = try self._currentFn.block.buildAdd(
          try self._currentFn.block.buildMul(Value.Int(innerTySize), dstOffsetVal) else |e| return qbeError(e),
          ptrVal
        ) else |e| return qbeError(e)
        val srcMem = try self._currentFn.block.buildAdd(
          try self._currentFn.block.buildMul(Value.Int(innerTySize), srcOffsetVal) else |e| return qbeError(e),
          srcVal
        ) else |e| return qbeError(e)

        self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [dstMem, srcMem, sizeVal])

        bogusValue
      }
      "errno" => {
        val errnoFnName = match process.uname().sysname {
          "Linux" => "__errno_location"
          "Darwin" => "__error"
          _ sysname => todo("[errno] unsupported system " + sysname)
        }
        val errnoPtr = try self._currentFn.block.buildCallRaw(errnoFnName, QbeType.Pointer, []) else |e| return qbeError(e)
        val errnoVal = self._currentFn.block.buildLoadW(errnoPtr)
        self._currentFn.block.buildExt(value: errnoVal, signed: false)
      }
      "byte_from_int" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        try self._compileExpression(arg)
      }
      "byte_as_int" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        try self._compileExpression(arg)
      }
      "uninitialized" => {
        val innerTy = try self._resolvedGenerics.resolveGeneric("T") else unreachable("(uninitialized) could not resolve T for uninitialized<T>()")
        val innerTySize = try self._pointerSize(innerTy)
        if innerTySize != QbeType.U64.size() unreachable("innerTySize != QbeType.U64.size()")

        Value.Int(0)
      }
      "u64_to_string" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        val argVal = try self._compileExpression(arg)

        val (intFmtPtr, _, _) = self._builder.buildGlobalString("%llu")
        val sizeVal = try self._currentFn.block.buildCall(Callable.Function(self._snprintf), [Value.Int(0), Value.Int(0), intFmtPtr, argVal]) else |e| return qbeError(e)
        val mallocSizeVal = try self._currentFn.block.buildAdd(Value.Int(1), sizeVal) else |e| return qbeError(e)

        val mem = try self._callMalloc(mallocSizeVal)
        try self._currentFn.block.buildCall(Callable.Function(self._snprintf), [mem, mallocSizeVal, intFmtPtr, argVal]) else |e| return qbeError(e)
        try self._constructString(mem, sizeVal)
      }
      "char_as_int" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        try self._compileExpression(arg)
      }
      "int_as_char" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        try self._compileExpression(arg)
      }
      "int_as_float" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        val argVal = try self._compileExpression(arg)

        self._currentFn.block.buildLToF(argVal)
      }
      "float_as_int" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        val argVal = try self._compileExpression(arg)

        self._currentFn.block.buildFToL(argVal)
      }
      "float_floor" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        val argVal = try self._compileExpression(arg)

        val floorRes = try self._currentFn.block.buildCallRaw("floor", QbeType.F64, [argVal]) else |e| return qbeError(e)
        self._currentFn.block.buildFToL(floorRes)
      }
      "float_ceil" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        val argVal = try self._compileExpression(arg)

        val ceilRes = try self._currentFn.block.buildCallRaw("ceil", QbeType.F64, [argVal]) else |e| return qbeError(e)
        self._currentFn.block.buildFToL(ceilRes)
      }
      "float_round" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        val argVal = try self._compileExpression(arg)

        val roundRes = try self._currentFn.block.buildCallRaw("round", QbeType.F64, [argVal]) else |e| return qbeError(e)
        self._currentFn.block.buildFToL(roundRes)
      }
      "argc" => {
        self._currentFn.block.buildLoadL(self._argcPtr)
      }
      "argv" => {
        self._currentFn.block.buildLoadL(self._argvPtr)
      }
      "__callstack" => {
        try self._currentFn.block.buildAdd(Value.Int(0), self._callstack[0]) else |e| return qbeError(e)
      }
      "__callstackp" => {
        self._currentFn.block.buildLoadL(self._callstack[1])
      }
      "modulenames" => {
        try self._currentFn.block.buildAdd(Value.Int(0), self._moduleNamesPtr) else |e| return qbeError(e)
      }
      "functionnames" => {
        try self._currentFn.block.buildAdd(Value.Int(0), self._fnNamesPtr) else |e| return qbeError(e)
      }
      "pointer_address" => {
        val arg = self._intrinsicArgs1(intrinsicFnName, arguments)
        val argVal = try self._compileExpression(arg)

        try self._currentFn.block.buildAdd(Value.Int(0), argVal) else |e| return qbeError(e)
      }
      _ => unreachable("unsupported intrinsic '$intrinsicFnName'")
    }

    self._currentFn.block.addComment("...$intrinsicFnName end")

    Ok(res)
  }

  func _buildCall(self, ctx: CallframeContext?, callable: Callable, arguments: Value[], dst: String? = None, envPtr: Value? = None): Result<Value, CompileError> {
    if ctx |ctx| try self._emitCallstackPush(ctx.callee, ctx.position)
    val v = try self._currentFn.block.buildCall(callable, arguments, dst, envPtr) else |e| return qbeError(e)
    if ctx try self._emitCallstackPop()

    Ok(v)
  }

  func _buildVoidCall(self, ctx: CallframeContext?, callable: Callable, arguments: Value[], envPtr: Value? = None): Result<Int, CompileError> {
    if ctx |ctx| try self._emitCallstackPush(ctx.callee, ctx.position)
    self._currentFn.block.buildVoidCall(callable, arguments, envPtr)
    if ctx try self._emitCallstackPop()

    Ok(0) // <-- unnecessary int
  }

  func _emitCallstackPush(self, calleeName: String?, position: Position): Result<Int, CompileError> {
    self._currentFn.block.addComment("begin __callstack push...")
    val (stack, stackPtr) = self._callstack

    val moduleId = if self._currentFunction |fn| {
      var modId = 0 // a moduleId of 0 represents <builtin> code
      var scope = Some(fn.scope)
      while scope |sc| {
        match sc.kind {
          ScopeKind.Module(id, _) => {
            modId = id + 1
            break
          }
          _ => {
            scope = sc.parent
          }
        }
      }

      modId
    } else {
      self._currentModule.id + 1
    }

    // a fnId of 0 represents <expression> callee
    val fnId = if calleeName |name| {
      if self._functionNames[name] |fnId| {
        fnId + 1
      } else {
        val fnId = self._functionNames.size
        self._functionNames[name] = fnId
        fnId + 1
      }
    } else {
      0
    }

    var frame = position.line || (moduleId << 16) || (fnId << 32)

    val stackPtrVal = self._currentFn.block.buildLoadL(stackPtr)
    val ptr = try self._currentFn.block.buildAdd(stackPtrVal, stack) else |e| return qbeError(e)
    self._currentFn.block.buildStoreL(Value.IntU64(frame), ptr)
    val ptrInc = try self._currentFn.block.buildAdd(Value.Int(8), stackPtrVal) else |e| return qbeError(e)
    self._currentFn.block.buildStoreL(ptrInc, stackPtr)

    self._currentFn.block.addComment("...__callstack push end")

    Ok(0) // <-- unnecessary int
  }

  func _emitCallstackPop(self): Result<Int, CompileError> {
    self._currentFn.block.addComment("begin __callstack pop...")
    val (_, stackPtr) = self._callstack

    val stackPtrVal = self._currentFn.block.buildLoadL(stackPtr)
    val ptrDec = try self._currentFn.block.buildSub(stackPtrVal, Value.Int(8)) else |e| return qbeError(e)
    self._currentFn.block.buildStoreL(ptrDec, stackPtr)

    self._currentFn.block.addComment("...__callstack pop end")

    Ok(0) // <-- unnecessary int
  }

  func _getOrCompileFunction(self, fn: Function, paramsNeedingDefaultValue: Bool[] = []): Result<QbeFunction, CompileError> {
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    val fnName = if defaultValuesFlag == 0 { self._fnName(fn) } else { self._fnName(fn) + ".$defaultValuesFlag" }
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val returnTypeQbe = try self._getQbeTypeForType(fn.returnType)
    val fnVal = self._builder.buildFunction(name: fnName, returnType: returnTypeQbe)
    if fn.isClosure() fnVal.addEnv()

    try self._compileFunc(None, fnVal, fn, paramsNeedingDefaultValue)
    fnVal.addComment(try self._fnSignature(None, fn, paramsNeedingDefaultValue))

    Ok(fnVal)
  }

  func _getOrCompileMethod(self, selfType: Type, fn: Function, paramsNeedingDefaultValue: Bool[] = []): Result<QbeFunction, CompileError> {
    val isInstanceMethod = match fn.kind { FunctionKind.InstanceMethod => true, _ => false }
    if isInstanceMethod && fn.label.name == "toString" && fn.isGenerated return self._getOrCompileToStringMethod(selfType)
    if isInstanceMethod && fn.label.name == "eq" && fn.isGenerated return self._getOrCompileEqMethod(selfType)
    if isInstanceMethod && fn.label.name == "hash" && fn.isGenerated return self._getOrCompileHashMethod(selfType)

    val (selfTy, _) = try self._getInstanceTypeForType(selfType)
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    var methodName = try self._methodFnName(selfTy, fn)
    if defaultValuesFlag != 0 { methodName += ".$defaultValuesFlag" }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val returnTypeQbe = try self._getQbeTypeForType(fn.returnType)
    val fnVal = self._builder.buildFunction(name: methodName, returnType: returnTypeQbe)
    if fn.isClosure() fnVal.addEnv()

    val selfCtx = if isInstanceMethod {
      val selfTyQbe = try self._getQbeTypeForTypeExpect(selfType, "unacceptable type for self")
      val selfParam = fnVal.addParameter("self", selfTyQbe)
      val selfVariable = try fn.scope.variables.find(v => v.label.name == "self") else unreachable("Function '${fn.label.name}' is an instance method but does not have a variable 'self' in its scope")
      fnVal.block.addVar(variableToVar(selfVariable), Some("self"))
      (selfType, Some(selfParam))
    } else {
      (selfType, None)
    }
    try self._compileFunc(Some(selfCtx), fnVal, fn, paramsNeedingDefaultValue)
    fnVal.addComment(try self._fnSignature(Some(selfTy), fn, paramsNeedingDefaultValue))

    Ok(fnVal)
  }

  func _compileFunc(self, selfCtx: (Type, Value?)?, fnVal: QbeFunction, fn: Function, paramsNeedingDefaultValue: Bool[] = []): Result<Int, CompileError> {
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val argsForUnderlying = if selfCtx |(_, selfParam)| {
      if selfParam |v| [v] else []
    } else {
      []
    }
    var anyParamNeedsDefault = false
    for param, idx in fn.params {
      val paramTy = try self._getQbeTypeForTypeExpect(param.ty, "unacceptable type for param", Some(param.label.position))
      self._currentFn.block.addVar(variableToVar(param.variable), Some(param.label.name))

      val paramVal = if param.defaultValue |defaultValueNode| {
        val paramNeedsDefault = paramsNeedingDefaultValue[idx] ?: false
        if paramNeedsDefault {
          anyParamNeedsDefault = true
          try self._compileExpression(defaultValueNode, Some(param.label.name))
        } else {
          fnVal.addParameter(param.label.name, paramTy)
        }
      } else {
        fnVal.addParameter(param.label.name, paramTy)
      }
      argsForUnderlying.push(paramVal)
    }

    var retVal: Value? = None
    if anyParamNeedsDefault {
      val baseFn = if selfCtx |(selfType, _)| {
        try self._getOrCompileMethod(selfType, fn)
      } else {
        try self._getOrCompileFunction(fn)
      }
      retVal = if fn.returnType.kind != TypeKind.PrimitiveUnit {
        val ret = try self._buildCall(None, Callable.Function(baseFn), argsForUnderlying)
        Some(ret)
      } else {
        try self._buildVoidCall(None, Callable.Function(baseFn), argsForUnderlying)
        None
      }
    } else {
      for node, idx in fn.body {
        val res = try self._compileStatement(node)
        if idx == fn.body.length - 1 && fn.returnType.kind != TypeKind.PrimitiveUnit {
          retVal = res
        }
      }
    }

    if fn.scope.terminator != Some(Terminator.Returning) {
      fnVal.block.buildReturn(retVal)
    }

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(0)
  }

  func _getOrCompileFunctionCallMethod(self, selfType: Type): Result<QbeFunction, CompileError> {
    val (selfTy, typeArgs) = try self._getInstanceTypeForType(selfType)
    val (fnStruct, fnCallMethodFn) = match selfTy {
      InstanceKind.Struct(struct) => try self._isFunctionStruct(struct) else unreachable("type of fn expr must be a Function struct")
      InstanceKind.Enum => unreachable()
    }

    var methodName = try self._structMethodFnName(fnStruct, fnCallMethodFn)
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val returnTypeQbe = try self._getQbeTypeForType(fnCallMethodFn.returnType)
    val fnVal = self._builder.buildFunction(name: methodName, returnType: returnTypeQbe)

    val selfTyQbe = try self._getQbeTypeForTypeExpect(selfType, "unacceptable type for self")
    val selfParam = fnVal.addParameter("self", selfTyQbe)

    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fnCallMethodFn)

    val argsForUnderlying: Value[] = []
    for param, idx in fnCallMethodFn.params {
      val paramTy = try self._getQbeTypeForTypeExpect(param.ty, "unacceptable type for param", Some(param.label.position))
      self._currentFn.block.addVar(variableToVar(param.variable), Some(param.label.name))

      argsForUnderlying.push(fnVal.addParameter(param.label.name, paramTy))
    }

    // Memory layout of adhoc Function struct (24 bytes):
    // |----------------------------------------------------|
    // | closure_env_ptr | captured_self_ptr | function_ptr |
    // |----------------------------------------------------|
    // 0                 8                   16             24
    // See Self#_functionStruct for definition
    val envPtrSlot = try self._currentFn.block.buildAdd(Value.Int(0), selfParam) else |e| return qbeError(e)
    self._currentFn.block.addComment("load stored closure env pointer (nullable)")
    val envPtr = self._currentFn.block.buildLoadL(envPtrSlot)

    val capturedSelfPtrSlot = try self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size()), selfParam) else |e| return qbeError(e)
    self._currentFn.block.addComment("load stored captured_self pointer (nullable)")
    val capturedSelfPtr = self._currentFn.block.buildLoadL(capturedSelfPtrSlot)

    val fnValPtrSlot = try self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size() * 2), selfParam) else |e| return qbeError(e)
    self._currentFn.block.addComment("load stored function pointer")
    val fnValPtr = self._currentFn.block.buildLoadL(fnValPtrSlot)
    val callable = Callable.Value(fnValPtr, returnTypeQbe)

    // This block of text is long, but simple. Effectively the #call method for an adhoc Function type
    // needs to know how to invoke the stored function pointer; if this instance is a closure (ie. it
    // has a non-NULL closure_env_ptr member), then that environment must be passed along to the call.
    // Similarly for a captured_self_ptr member (which represents a function value built from a method
    // reference `val fn = someInstance.method`). The 4 resulting combinations need to be evaluated
    // at runtime, and qbe code is emitted for each of the branching cases below.
    // Also, since the underlying function may or may not return, we need special logic (compile-time,
    // thankfully) to properly resolve the return value.
    val phiCases: (Label, Value)[]? = if fnVal.returnType Some([]) else None
    val labelCallWithEnv = self._currentFn.block.addLabel("call_fn_val_with_env")
    val labelCallWithoutEnv = self._currentFn.block.addLabel("call_fn_val_without_env")
    val labelCont = self._currentFn.block.addLabel("call_fn_val_cont")
    self._currentFn.block.buildJnz(envPtr, labelCallWithEnv, labelCallWithoutEnv)

    // if self.env is not null {
    self._currentFn.block.registerLabel(labelCallWithEnv)
    val phiCasesWithEnv: (Label, Value)[]? = if fnVal.returnType Some([]) else None
    val labelCallWithEnvWithSelf = self._currentFn.block.addLabel("call_fn_val_with_env_with_self")
    val labelCallWithEnvWithoutSelf = self._currentFn.block.addLabel("call_fn_val_with_env_without_self")
    val labelCont2 = self._currentFn.block.addLabel("call_fn_val_cont_with_env")
    self._currentFn.block.buildJnz(capturedSelfPtr, labelCallWithEnvWithSelf, labelCallWithEnvWithoutSelf)

    //   if self.capturedSelf is not null {
    self._currentFn.block.registerLabel(labelCallWithEnvWithSelf)
    if phiCasesWithEnv |cases| {
      val res = try self._buildCall(None, callable, [capturedSelfPtr].concat(argsForUnderlying), None, Some(envPtr))
      val label = self._currentFn.block.currentLabel
      cases.push((label, res))
    } else {
      try self._buildVoidCall(None, callable, [capturedSelfPtr].concat(argsForUnderlying), Some(envPtr))
    }
    self._currentFn.block.buildJmp(labelCont2)

    //   } else { // self.capturedSelf is null
    self._currentFn.block.registerLabel(labelCallWithEnvWithoutSelf)
    if phiCasesWithEnv |cases| {
      val res = try self._buildCall(None, callable, argsForUnderlying, None, Some(envPtr))
      val label = self._currentFn.block.currentLabel
      cases.push((label, res))
    } else {
      try self._buildVoidCall(None, callable, argsForUnderlying, Some(envPtr))
    }
    self._currentFn.block.buildJmp(labelCont2)

    //   }
    self._currentFn.block.registerLabel(labelCont2)
    if phiCasesWithEnv |cases| {
      val resWithEnv = try self._currentFn.block.buildPhi(cases) else |e| return qbeError(e)
      val resWithEnvLabel = self._currentFn.block.currentLabel
      if phiCases |topLevelCases| {
        topLevelCases.push((resWithEnvLabel, resWithEnv))
      }
    }
    self._currentFn.block.buildJmp(labelCont)

    // } else { // self.env is null
    self._currentFn.block.registerLabel(labelCallWithoutEnv)
    val phiCasesWithoutEnv: (Label, Value)[]? = if fnVal.returnType Some([]) else None
    val labelCallWithoutEnvWithSelf = self._currentFn.block.addLabel("call_fn_val_without_env_with_self")
    val labelCallWithoutEnvWithoutSelf = self._currentFn.block.addLabel("call_fn_val_without_env_without_self")
    val labelCont3 = self._currentFn.block.addLabel("call_fn_val_cont_without_env")
    self._currentFn.block.buildJnz(capturedSelfPtr, labelCallWithoutEnvWithSelf, labelCallWithoutEnvWithoutSelf)

    //   if self.capturedSelf is not null {
    self._currentFn.block.registerLabel(labelCallWithoutEnvWithSelf)
    if phiCasesWithoutEnv |cases| {
      val res = try self._buildCall(None, callable, [capturedSelfPtr].concat(argsForUnderlying))
      val label = self._currentFn.block.currentLabel
      cases.push((label, res))
    } else {
      try self._buildVoidCall(None, callable, [capturedSelfPtr].concat(argsForUnderlying))
    }
    self._currentFn.block.buildJmp(labelCont3)

    //   } else { // if self.capturedSelf is null
    self._currentFn.block.registerLabel(labelCallWithoutEnvWithoutSelf)
    if phiCasesWithoutEnv |cases| {
      val res = try self._buildCall(None, callable, argsForUnderlying)
      val label = self._currentFn.block.currentLabel
      cases.push((label, res))
    } else {
      try self._buildVoidCall(None, callable, argsForUnderlying)
    }
    self._currentFn.block.buildJmp(labelCont3)

    // }
    self._currentFn.block.registerLabel(labelCont3)
    if phiCasesWithoutEnv |cases| {
      val resWithoutEnv = try self._currentFn.block.buildPhi(cases) else |e| return qbeError(e)
      val resWithoutEnvLabel = self._currentFn.block.currentLabel

      if phiCases |topLevelCases| {
        topLevelCases.push((resWithoutEnvLabel, resWithoutEnv))
      }
    }
    self._currentFn.block.buildJmp(labelCont)

    self._currentFn.block.registerLabel(labelCont)
    val retVal = if phiCases |cases| {
      Some(try self._currentFn.block.buildPhi(cases) else |e| return qbeError(e))
    } else {
      None
    }

    fnVal.block.buildReturn(retVal)

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    fnVal.addComment(try self._fnSignature(Some(selfTy), fnCallMethodFn, []))

    Ok(fnVal)
  }

  func _getOrCompileToStringMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val (selfTy, typeArgs) = try self._getInstanceTypeForType(ty)
    val (methodName, fn) = match selfTy {
      InstanceKind.Struct(struct) => {
        if struct == self._project.preludeIntStruct return self._getOrCompileIntToStringMethod()
        if struct == self._project.preludeFloatStruct return self._getOrCompileFloatToStringMethod()
        if struct == self._project.preludeStringStruct return self._getOrCompileStringToStringMethod()
        if struct == self._project.preludeBoolStruct return self._getOrCompileBoolToStringMethod()

        val fn = self._getMethodFunctionByName(selfTy, "toString")

        (try self._structMethodFnName(struct, fn), fn)
      }
      InstanceKind.Enum(enum_) => {
        val fn = self._getMethodFunctionByName(selfTy, "toString")

        (try self._enumMethodFnName(enum_, fn), fn)
      }
    }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated return self._compileGeneratedToStringMethod(ty, fn)

    self._getOrCompileMethod(ty, fn)
  }

  func _compileGeneratedToStringMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")

    val (selfTy, typeArgs) = try self._getInstanceTypeForType(selfType)
    val selfInstanceTy = Type(kind: TypeKind.Instance(selfTy, typeArgs))

    val methodName = try self._methodFnName(selfTy, fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val selfTyQbe = try self._getQbeTypeForTypeExpect(selfInstanceTy, "unacceptable type for self")
    val selfParamVal = fnVal.addParameter("self", selfTyQbe)

    match selfTy {
      InstanceKind.Struct(struct) => {
        val data: (String, Position, Type)[] = []

        if self._isFunctionStruct(struct) {
          val (str, _, _) = self._builder.buildGlobalString("<#function>")
          val res = try self._constructString(str, Value.Int(11))

          self._currentFn.block.buildReturn(Some(res))
        } else {
          val isTuple = self._isTupleStruct(struct)
          for field in struct.fields {
            val fieldName = if isTuple "" else field.name.name
            data.push((fieldName, field.name.position, field.ty))
          }

          val prefix = if isTuple "" else struct.label.name
          val res = try self._emitToStringLogicForStructuredData(prefix, selfParamVal, data)
          self._currentFn.block.buildReturn(Some(res))
        }
      }
      InstanceKind.Enum(enum_) => {
        val variantIdxVal = self._emitGetEnumVariantIdx(selfParamVal)

        var labelElse = self._currentFn.block.addLabel("__initial")
        val labelEnd = self._currentFn.block.addLabel("unreachable")

        for variant, idx in enum_.variants {
          if idx != 0 {
            self._currentFn.block.registerLabel(labelElse)
          }

          val cond = try self._currentFn.block.buildCompareEq(Value.Int(idx), variantIdxVal) else |e| return qbeError(e)

          val labelThen = self._currentFn.block.addLabel("variant_${variant.label.name}")
          if idx != enum_.variants.length - 1 {
            labelElse = self._currentFn.block.addLabel("next")
            self._currentFn.block.buildJnz(cond, labelThen, labelElse)
          } else {
            self._currentFn.block.buildJnz(cond, labelThen, labelEnd)
          }

          self._currentFn.block.registerLabel(labelThen)
          val variantName = "${enum_.label.name}.${variant.label.name}"
          match variant.kind {
            EnumVariantKind.Constant => {
              val (variantNameStr, _, _) = self._builder.buildGlobalString(variantName)
              val retVal = try self._constructString(variantNameStr, Value.Int(variantName.length))
              self._currentFn.block.buildReturn(Some(retVal))
            }
            EnumVariantKind.Container(fields) => {
              val data: (String, Position, Type)[] = []
              for field in fields {
                data.push((field.name.name, field.name.position, field.ty))
              }
              val ptr = try self._emitGetEnumVariantValueStart(selfParamVal)
              val retVal = try self._emitToStringLogicForStructuredData(variantName, ptr, data)
              self._currentFn.block.buildReturn(Some(retVal))
            }
          }
        }

        self._currentFn.block.registerLabel(labelEnd)
        self._currentFn.block.buildHalt()
      }
    }

    fnVal.addComment(try self._fnSignature(Some(selfTy), fn))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(fnVal)
  }

  func _emitToStringLogicForStructuredData(self, prefix: String, selfPtr: Value, data: (String, Position, Type)[]): Result<Value, CompileError> {
    val (prefixStr, _, _) = self._builder.buildGlobalString(prefix)
    var len = prefix.length + 2 + (data.length - 1) * 2 // account for '(' and ')', as well as ',' and ' ' between items
    var lenVal = Value.Int(0)

    val reprVals: (String, Value, Bool)[] = []
    var offset = 0
    for (itemName, itemPosition, itemType), idx in data {
      // If the item label is meant to be output, account for the label as well as ':' and ' ' between the label and the value
      if !itemName.isEmpty() { len += (itemName.length + 2) }

      val itemInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(itemType, "toString", itemPosition)
      val itemToStringFnVal = try self._getOrCompileToStringMethod(itemInstanceType)
      self._resolvedGenerics.popLayer()

      val itemTy = try self._getQbeTypeForTypeExpect(itemType, "unacceptable type for item", Some(itemPosition))
      val itemIsString = self._typeIsString(itemInstanceType)

      val memCursorLocalName = if itemName.isEmpty() "$idx" else itemName
      val memCursorLocal = try self._currentFn.block.buildAdd(Value.Int(offset), selfPtr, Some("mem_offset_$memCursorLocalName")) else |e| return qbeError(e)
      val itemVal = self._currentFn.block.buildLoad(itemTy, memCursorLocal)

      offset += itemTy.size()

      val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(itemType))[0]), true))
      val frameCtx = CallframeContext(position: itemPosition, callee: Some(fnName))
      val itemToStringVal = try self._buildCall(Some(frameCtx), Callable.Function(itemToStringFnVal), [itemVal])
      val itemToStringLengthVal = self._currentFn.block.buildLoadL(itemToStringVal)
      lenVal = try self._currentFn.block.buildAdd(lenVal, itemToStringLengthVal, Some("length_total")) else |e| return qbeError(e)
      if itemIsString {
        self._currentFn.block.addComment("account for opening and closing \"'s")
        lenVal = try self._currentFn.block.buildAdd(lenVal, Value.Int(2), Some("length_total")) else |e| return qbeError(e)
      }

      reprVals.push((itemName, itemToStringVal, itemIsString))
    }

    val totalLengthVal = try self._currentFn.block.buildAdd(Value.Int(len), lenVal) else |e| return qbeError(e)
    val stringWithLengthFn = self._getMethodFunctionByName(InstanceKind.Struct(self._project.preludeStringStruct), "withLength", staticMethod: true)
    val stringWithLengthFnVal = try self._getOrCompileMethod(Type(kind: TypeKind.Type(InstanceKind.Struct(self._project.preludeStringStruct))), stringWithLengthFn)
    // Do not track String.withLength in callframes
    val newStr = try self._buildCall(None, Callable.Function(stringWithLengthFnVal), [totalLengthVal])

    var newStrBuf = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), newStr) else |e| return qbeError(e))
    if !prefix.isEmpty() {
      self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newStrBuf, prefixStr, Value.Int(prefix.length)])
    }
    var cursor = try self._currentFn.block.buildAdd(newStrBuf, Value.Int(prefix.length), Some("str_cursor")) else |e| return qbeError(e)
    self._currentFn.block.addComment("'('")
    self._currentFn.block.buildStoreB(Value.Int(40), cursor)
    cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)

    for (fieldName, strVal, isString), idx in reprVals {
      if !fieldName.isEmpty() {
        val (fieldNameStr, _, _) = self._builder.buildGlobalString(fieldName)
        self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [cursor, fieldNameStr, Value.Int(fieldName.length)])
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(fieldName.length), Some("str_cursor")) else |e| return qbeError(e)
        self._currentFn.block.addComment("\": \"")
        self._currentFn.block.buildStoreB(Value.Int(58), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
        self._currentFn.block.buildStoreB(Value.Int(32), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
      }

      if isString {
        self._currentFn.block.addComment("'\"'")
        self._currentFn.block.buildStoreB(Value.Int(34), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
      }

      val strValLen = self._currentFn.block.buildLoadL(strVal)
      val strValChars = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), strVal) else |e| return qbeError(e))
      self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [cursor, strValChars, strValLen])
      cursor = try self._currentFn.block.buildAdd(cursor, strValLen, Some("str_cursor")) else |e| return qbeError(e)

      if isString {
        self._currentFn.block.addComment("'\"'")
        self._currentFn.block.buildStoreB(Value.Int(34), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
      }

      if idx != reprVals.length - 1 {
        self._currentFn.block.addComment("\", \"")
        self._currentFn.block.buildStoreB(Value.Int(44), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
        self._currentFn.block.buildStoreB(Value.Int(32), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
      }
    }

    self._currentFn.block.addComment("')'")
    self._currentFn.block.buildStoreB(Value.Int(41), cursor)

    Ok(newStr)
  }

  func _getOrCompileIntToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")
    val intTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist")

    val typeName = try self._structTypeName(self._project.preludeIntStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Int#toString(self): String")
    val selfParam = fnVal.addParameter("self", intTypeQbe)

    val (intFmtPtr, _, _) = self._builder.buildGlobalString("%lld")
    val sizeVal = try fnVal.block.buildCall(Callable.Function(self._snprintf), [Value.Int(0), Value.Int(0), intFmtPtr, selfParam]) else |e| return qbeError(e)
    val mallocSizeVal = try fnVal.block.buildAdd(Value.Int(1), sizeVal) else |e| return qbeError(e)

    val mem = try self._callMalloc(mallocSizeVal)
    try fnVal.block.buildCall(Callable.Function(self._snprintf), [mem, mallocSizeVal, intFmtPtr, selfParam]) else |e| return qbeError(e)

    val str = try self._constructString(mem, sizeVal)
    fnVal.block.buildReturn(Some(str))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileFloatToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")
    val floatTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist")

    val typeName = try self._structTypeName(self._project.preludeFloatStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Float#toString(self): String")
    val selfParam = fnVal.addParameter("self", floatTypeQbe)

    val (floatFmtPtr, _, _) = self._builder.buildGlobalString("%g")
    val sizeVal = try fnVal.block.buildCall(Callable.Function(self._snprintf), [Value.Int(0), Value.Int(0), floatFmtPtr, selfParam]) else |e| return qbeError(e)
    val mallocSizeVal = try fnVal.block.buildAdd(Value.Int(1), sizeVal) else |e| return qbeError(e)

    val mem = try self._callMalloc(mallocSizeVal)
    try fnVal.block.buildCall(Callable.Function(self._snprintf), [mem, mallocSizeVal, floatFmtPtr, selfParam]) else |e| return qbeError(e)

    val str = try self._constructString(mem, sizeVal)
    fnVal.block.buildReturn(Some(str))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileBoolToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")
    val boolTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist")

    val typeName = try self._structTypeName(self._project.preludeBoolStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Bool#toString(self): String")
    val selfParam = fnVal.addParameter("self", boolTypeQbe)

    val labelIfTrue = fnVal.block.addLabel("if_true")
    val labelIfFalse = fnVal.block.addLabel("if_false")
    fnVal.block.buildJnz(selfParam, labelIfTrue, labelIfFalse)

    fnVal.block.registerLabel(labelIfTrue)
    val (trueStrData, _, _) = self._builder.buildGlobalString("true")
    val trueStr = try self._constructString(trueStrData, Value.Int(4))
    fnVal.block.buildReturn(Some(trueStr))

    fnVal.block.registerLabel(labelIfFalse)
    val (falseStrData, _, _) = self._builder.buildGlobalString("false")
    val falseStr = try self._constructString(falseStrData, Value.Int(5))
    fnVal.block.buildReturn(Some(falseStr))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileStringToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")

    val typeName = try self._structTypeName(self._project.preludeStringStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("String#toString(self): String")
    val selfParam = fnVal.addParameter("self", stringTypeQbe)
    fnVal.block.buildReturn(Some(selfParam))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileEqMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val (selfTy, _) = try self._getInstanceTypeForType(ty)
    val (methodName, fn) = match selfTy {
      InstanceKind.Struct(struct) => {
        val boolTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist")

        // TODO: surely there's a cleaner way to represent these built-in eq methods
        if struct == self._project.preludeIntStruct {
          val intTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist")

          val methodName = "Int..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Int#eq(self, other: Int): Bool")
          val selfParam = fnVal.addParameter("self", intTypeQbe)
          val otherParam = fnVal.addParameter("other", intTypeQbe)
          val res = try self._currentFn.block.buildCompareEq(selfParam, otherParam) else |e| return qbeError(e)
          fnVal.block.buildReturn(Some(self._currentFn.block.buildExt(res, false)))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeFloatStruct {
          val floatTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist")

          val methodName = "Float..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Float#eq(self, other: Float): Bool")
          val selfParam = fnVal.addParameter("self", floatTypeQbe)
          val otherParam = fnVal.addParameter("other", floatTypeQbe)
          val res = try self._currentFn.block.buildCompareEq(selfParam, otherParam) else |e| return qbeError(e)
          fnVal.block.buildReturn(Some(self._currentFn.block.buildExt(res, false)))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeBoolStruct {
          val methodName = "Bool..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Bool#eq(self, other: Bool): Bool")
          val selfParam = fnVal.addParameter("self", boolTypeQbe)
          val otherParam = fnVal.addParameter("other", boolTypeQbe)
          val res = try self._currentFn.block.buildCompareEq(selfParam, otherParam) else |e| return qbeError(e)
          fnVal.block.buildReturn(Some(self._currentFn.block.buildExt(res, false)))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeCharStruct {
          val charTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveChar), "char qbe type should exist")

          val methodName = "Char..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Char#eq(self, other: Char): Char")
          val selfParam = fnVal.addParameter("self", charTypeQbe)
          val otherParam = fnVal.addParameter("other", charTypeQbe)
          val res = try self._currentFn.block.buildCompareEq(selfParam, otherParam) else |e| return qbeError(e)
          fnVal.block.buildReturn(Some(self._currentFn.block.buildExt(res, false)))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }

        val fn = self._getMethodFunctionByName(selfTy, "eq")

        (try self._structMethodFnName(struct, fn), fn)
      }
      InstanceKind.Enum(enum_) => {
        val fn = self._getMethodFunctionByName(selfTy, "eq")

        (try self._enumMethodFnName(enum_, fn), fn)
      }
    }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated return self._compileGeneratedEqMethod(ty, fn)

    self._getOrCompileMethod(ty, fn)
  }

  func _compileGeneratedEqMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val boolTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist")

    val (selfTy, typeArgs) = try self._getInstanceTypeForType(selfType)
    val selfInstanceTy = Type(kind: TypeKind.Instance(selfTy, typeArgs))

    val methodName = try self._methodFnName(selfTy, fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val selfTyQbe = try self._getQbeTypeForTypeExpect(selfInstanceTy, "unacceptable type for self")
    val selfParamVal = fnVal.addParameter("self", selfTyQbe)
    val otherParamVal = fnVal.addParameter("other", selfTyQbe)

    match selfTy {
      InstanceKind.Struct(struct) => {
        val data: (String, Position, Type)[] = []

        val isTuple = self._isTupleStruct(struct)
        for field in struct.fields {
          val fieldName = if isTuple "" else field.name.name
          data.push((fieldName, field.name.position, field.ty))
        }

        try self._emitEqLogicForStructuredData(selfParamVal, otherParamVal, data)
      }
      InstanceKind.Enum(enum_) => {
        val selfVariantIdxVal = self._emitGetEnumVariantIdx(selfParamVal)
        val otherVariantIdxVal = self._emitGetEnumVariantIdx(otherParamVal)

        val labelVariantsNeq = self._currentFn.block.addLabel("variants_not_eq")
        val labelVariantsEq = self._currentFn.block.addLabel("variants_eq")

        val cond = try self._currentFn.block.buildCompareEq(selfVariantIdxVal, otherVariantIdxVal) else |e| return qbeError(e)
        self._currentFn.block.buildJnz(cond, labelVariantsEq, labelVariantsNeq)

        self._currentFn.block.registerLabel(labelVariantsNeq)
        self._currentFn.block.addComment("return false")
        self._currentFn.block.buildReturn(Some(Value.Int(0)))

        self._currentFn.block.registerLabel(labelVariantsEq)

        var labelElse = self._currentFn.block.addLabel("__initial")
        val labelEnd = self._currentFn.block.addLabel("unreachable")

        for variant, idx in enum_.variants {
          if idx != 0 {
            self._currentFn.block.registerLabel(labelElse)
          }

          val cond = try self._currentFn.block.buildCompareEq(Value.Int(idx), selfVariantIdxVal) else |e| return qbeError(e)

          val labelThen = self._currentFn.block.addLabel("variant_${variant.label.name}")
          if idx != enum_.variants.length - 1 {
            labelElse = self._currentFn.block.addLabel("next")
            self._currentFn.block.buildJnz(cond, labelThen, labelElse)
          } else {
            self._currentFn.block.buildJnz(cond, labelThen, labelEnd)
          }

          self._currentFn.block.registerLabel(labelThen)
          match variant.kind {
            EnumVariantKind.Constant => {
              self._currentFn.block.addComment("return true")
              self._currentFn.block.buildReturn(Some(Value.Int(1)))
            }
            EnumVariantKind.Container(fields) => {
              val data: (String, Position, Type)[] = []
              for field in fields {
                data.push((field.name.name, field.name.position, field.ty))
              }
              val selfPtr = try self._emitGetEnumVariantValueStart(selfParamVal)
              val otherPtr = try self._emitGetEnumVariantValueStart(otherParamVal)
              try self._emitEqLogicForStructuredData(selfPtr, otherPtr, data)
            }
          }
        }

        self._currentFn.block.registerLabel(labelEnd)
        self._currentFn.block.buildHalt()
      }
    }

    fnVal.addComment(try self._fnSignature(Some(selfTy), fn))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(fnVal)
  }

  func _emitEqLogicForStructuredData(self, selfPtr: Value, otherPtr: Value, data: (String, Position, Type)[]): Result<Int, CompileError> {
    var offset = 0
    for (itemName, itemPosition, itemType) in data {
      val itemTy = try self._getQbeTypeForTypeExpect(itemType, "unacceptable type for item", Some(itemPosition))

      val selfMemCursor = try self._currentFn.block.buildAdd(Value.Int(offset), selfPtr, Some("self_mem_offset_$itemName")) else |e| return qbeError(e)
      val selfItemVal = self._currentFn.block.buildLoad(itemTy, selfMemCursor)
      val otherMemCursor = try self._currentFn.block.buildAdd(Value.Int(offset), otherPtr, Some("other_mem_offset_$itemName")) else |e| return qbeError(e)
      val otherItemVal = self._currentFn.block.buildLoad(itemTy, otherMemCursor)

      val labelNeq = self._currentFn.block.addLabel("${itemName}_vals_not_equal")
      val labelEq = self._currentFn.block.addLabel("${itemName}_vals_equal")

      val fieldsEqVal = try self._compileEqLogic(selfItemVal, otherItemVal, itemType, itemPosition)
      self._currentFn.block.buildJnz(fieldsEqVal, labelEq, labelNeq)

      self._currentFn.block.registerLabel(labelNeq)
      self._currentFn.block.addComment("return false")
      self._currentFn.block.buildReturn(Some(Value.Int(0)))

      self._currentFn.block.registerLabel(labelEq)

      offset += itemTy.size()
    }

    self._currentFn.block.addComment("return true")
    self._currentFn.block.buildReturn(Some(Value.Int(1)))

    Ok(0)
  }

  func _getOrCompileHashMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val (selfTy, _) = try self._getInstanceTypeForType(ty)
    val (methodName, fn) = match selfTy {
      InstanceKind.Struct(struct) => {
        val intTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist")

        // TODO: surely there's a cleaner way to represent these built-in hash methods
        if struct == self._project.preludeIntStruct {
          val methodName = "Int..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Int#hash(self): Int")
          val selfParam = fnVal.addParameter("self", intTypeQbe)
          fnVal.block.buildReturn(Some(selfParam))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeFloatStruct {
          val floatTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist")

          val methodName = "Float..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Float#hash(self): Int")
          val selfParam = fnVal.addParameter("self", floatTypeQbe)
          val res = self._currentFn.block.buildCastD(selfParam)
          fnVal.block.buildReturn(Some(res))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeBoolStruct {
          val boolTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist")

          val methodName = "Bool..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Bool#hash(self): Int")
          val selfParam = fnVal.addParameter("self", boolTypeQbe)
          val res = self._currentFn.block.buildExt(value: selfParam, signed: false)
          fnVal.block.buildReturn(Some(res))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeCharStruct {
          val charTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveChar), "char qbe type should exist")

          val methodName = "Char..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Charhash(self): Int")
          val selfParam = fnVal.addParameter("self", charTypeQbe)
          fnVal.block.buildReturn(Some(selfParam))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }

        val fn = self._getMethodFunctionByName(selfTy, "hash")

        (try self._structMethodFnName(struct, fn), fn)
      }
      InstanceKind.Enum(enum_) => {
        val fn = self._getMethodFunctionByName(selfTy, "hash")

        (try self._enumMethodFnName(enum_, fn), fn)
      }
    }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated return self._compileGeneratedHashMethod(ty, fn)

    self._getOrCompileMethod(ty, fn)
  }

  func _compileGeneratedHashMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val intTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist")

    val (selfTy, typeArgs) = try self._getInstanceTypeForType(selfType)
    val selfInstanceTy = Type(kind: TypeKind.Instance(selfTy, typeArgs))

    val methodName = try self._methodFnName(selfTy, fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val selfTyQbe = try self._getQbeTypeForTypeExpect(selfInstanceTy, "unacceptable type for self")
    val selfParamVal = fnVal.addParameter("self", selfTyQbe)

    match selfTy {
      InstanceKind.Struct(struct) => {
        val data: (String, Position, Type)[] = []
        val isTuple = self._isTupleStruct(struct)
        for field in struct.fields {
          val fieldName = if isTuple "" else field.name.name
          data.push((fieldName, field.name.position, field.ty))
        }

        try self._emitHashLogicForStructuredData(selfParamVal, data)
      }
      InstanceKind.Enum(enum_) => {
        val variantIdxVal = self._emitGetEnumVariantIdx(selfParamVal)

        var labelElse = self._currentFn.block.addLabel("__initial")
        val labelEnd = self._currentFn.block.addLabel("unreachable")

        for variant, idx in enum_.variants {
          if idx != 0 {
            self._currentFn.block.registerLabel(labelElse)
          }

          val cond = try self._currentFn.block.buildCompareEq(Value.Int(idx), variantIdxVal) else |e| return qbeError(e)

          val labelThen = self._currentFn.block.addLabel("variant_${variant.label.name}")
          if idx != enum_.variants.length - 1 {
            labelElse = self._currentFn.block.addLabel("next")
            self._currentFn.block.buildJnz(cond, labelThen, labelElse)
          } else {
            self._currentFn.block.buildJnz(cond, labelThen, labelEnd)
          }

          self._currentFn.block.registerLabel(labelThen)
          match variant.kind {
            EnumVariantKind.Constant => {
              self._currentFn.block.buildReturn(Some(variantIdxVal))
            }
            EnumVariantKind.Container(fields) => {
              val data: (String, Position, Type)[] = []
              for field in fields {
                data.push((field.name.name, field.name.position, field.ty))
              }
              val selfPtr = try self._emitGetEnumVariantValueStart(selfParamVal)
              try self._emitHashLogicForStructuredData(selfPtr, data)
            }
          }
        }

        self._currentFn.block.registerLabel(labelEnd)
        self._currentFn.block.buildHalt()
      }
    }

    fnVal.addComment(try self._fnSignature(Some(selfTy), fn))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(fnVal)
  }

  func _emitHashLogicForStructuredData(self, selfPtr: Value, data: (String, Position, Type)[]): Result<Int, CompileError> {
    var retVal = Value.Int(1)
    var offset = 0
    for (itemName, itemPosition, itemType) in data {
      val itemTy = try self._getQbeTypeForTypeExpect(itemType, "unacceptable type for item", Some(itemPosition))

      val memCursor = try self._currentFn.block.buildAdd(Value.Int(offset), selfPtr, Some("self_mem_offset_$itemName")) else |e| return qbeError(e)
      val itemVal = self._currentFn.block.buildLoad(itemTy, memCursor)

      val itemInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(itemType, "hash", itemPosition)
      val itemHashFnVal = try self._getOrCompileHashMethod(itemType)
      self._resolvedGenerics.popLayer()

      val fnName = self._functionName("hash", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(itemType))[0]), true))
      val frameCtx = CallframeContext(position: itemPosition, callee: Some(fnName))
      val itemHashVal = try self._buildCall(Some(frameCtx), Callable.Function(itemHashFnVal), [itemVal])
      val newPart = try self._currentFn.block.buildMul(Value.Int(31), itemHashVal) else |e| return qbeError(e)
      retVal = try self._currentFn.block.buildAdd(retVal, newPart) else |e| return qbeError(e)

      offset += itemTy.size()
    }

    self._currentFn.block.buildReturn(Some(retVal))

    Ok(0)
  }

  func _callMalloc(self, sizeVal: Value, localName: String? = None): Result<Value, CompileError> {
    val mem = try self._currentFn.block.buildCall(Callable.Function(self._malloc), [sizeVal], localName) else |e| return qbeError(e)

    // val labelIsZero = self._currentFn.block.addLabel("malloc_is_zero")
    // val labelCont = self._currentFn.block.addLabel("malloc_is_nonzero")
    // self._currentFn.block.buildJnz(mem, labelCont, labelIsZero)

    // self._currentFn.block.registerLabel(labelIsZero)
    // self._currentFn.block.buildHalt()

    // self._currentFn.block.registerLabel(labelCont)

    Ok(mem)
  }

  func _buildStackAllocForQbeType(self, ty: QbeType, name: String? = None): Value {
    match ty {
      QbeType.U8 => self._currentFn.block.buildAlloc8(1, name)      // 'b'
      QbeType.U16 => self._currentFn.block.buildAlloc4(1, name)     // 'h'
      QbeType.U32 => self._currentFn.block.buildAlloc4(1, name)     // 'w'
      QbeType.U64 => self._currentFn.block.buildAlloc8(1, name)     // 'l'
      QbeType.Pointer => self._currentFn.block.buildAlloc8(1, name) // 'l'
      QbeType.F32 => self._currentFn.block.buildAlloc4(1, name)     // 's'
      QbeType.F64 => self._currentFn.block.buildAlloc8(1, name)     // 'd'
    }
  }

  func _emitGetEnumVariantIdx(self, enumVariantVal: Value): Value = self._currentFn.block.buildLoadL(enumVariantVal)
  func _emitGetEnumVariantValueStart(self, enumVariantVal: Value): Result<Value, CompileError> {
    val res = try self._currentFn.block.buildAdd(Value.Int(QbeType.U64.size()), enumVariantVal) else |e| return qbeError(e)
    Ok(res)
  }

  func _emitOptValueIsSomeVariant(self, exprVal: Value, negate = false): Result<Value, CompileError> {
    val variantIdx = self._emitGetEnumVariantIdx(exprVal)
    val (_, optionSomeVariantIdx) = self._getEnumVariantByName(self._project.preludeOptionEnum, "Some")
    if negate {
      val res = try self._currentFn.block.buildCompareNeq(variantIdx, Value.Int(optionSomeVariantIdx)) else |e| return qbeError(e)
      Ok(res)
    } else {
      val res = try self._currentFn.block.buildCompareEq(variantIdx, Value.Int(optionSomeVariantIdx)) else |e| return qbeError(e)
      Ok(res)
    }
  }

  func _emitOptValueGetValue(self, ty: QbeType, exprVal: Value): Result<Value, CompileError> {
    val valueSlot = try self._emitGetEnumVariantValueStart(exprVal)
    val value = self._currentFn.block.buildLoad(ty, valueSlot)

    Ok(value)
  }

  func _emitResultValueIsOkVariant(self, exprVal: Value, negate = false): Result<Value, CompileError> {
    val variantIdx = self._emitGetEnumVariantIdx(exprVal)
    val (_, resultOkVariantIdx) = self._getEnumVariantByName(self._project.preludeResultEnum, "Ok")
    if negate {
      val res = try self._currentFn.block.buildCompareNeq(variantIdx, Value.Int(resultOkVariantIdx)) else |e| return qbeError(e)
      Ok(res)
    } else {
      val res = try self._currentFn.block.buildCompareEq(variantIdx, Value.Int(resultOkVariantIdx)) else |e| return qbeError(e)
      Ok(res)
    }
  }

  func _emitResultValueGetValue(self, ty: QbeType, exprVal: Value): Result<Value, CompileError> {
    val valueSlot = try self._emitGetEnumVariantValueStart(exprVal)
    val value = self._currentFn.block.buildLoad(ty, valueSlot)

    Ok(value)
  }

  func _addResolvedGenericsLayerForInstanceMethod(self, ty: Type, methodName: String, position: Position, resolvedGenerics: Map<String, Type> = {}): Result<Type, CompileError> {
    val (instanceKind, typeArgs) = try self._getInstanceTypeForType(ty)
    val (template, selfInstanceType) = match instanceKind {
      InstanceKind.Struct(struct) => {
        val template = Type(kind: TypeKind.Instance(instanceKind, struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val inst = Type(kind: TypeKind.Instance(instanceKind, typeArgs))

        (template, inst)
      }
      InstanceKind.Enum(enum_) => {
        val template = Type(kind: TypeKind.Instance(instanceKind, enum_.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val inst = Type(kind: TypeKind.Instance(instanceKind, typeArgs))

        (template, inst)
      }
    }
    for (name, ty) in selfInstanceType.extractGenerics(template) {
      resolvedGenerics[name] = ty
    }
    val layerName = match instanceKind {
      InstanceKind.Struct(struct) => "${struct.label.name}.$methodName"
      InstanceKind.Enum(enum_) => "${enum_.label.name}.$methodName"
    }
    match self._resolvedGenerics.addLayer(layerName, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: layerName, message: e))) }

    Ok(selfInstanceType)
  }

  func _addResolvedGenericsLayerForEnumVariant(self, ty: Type, variantName: String, position: Position, resolvedGenerics: Map<String, Type> = {}): Result<Type, CompileError> {
    val (instanceKind, typeArgs) = try self._getInstanceTypeForType(ty)
    match instanceKind {
      InstanceKind.Struct => unreachable("type should always be an enum here")
      InstanceKind.Enum(enum_) => {
        val template = Type(kind: TypeKind.Instance(instanceKind, enum_.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val selfInstanceType = Type(kind: TypeKind.Instance(instanceKind, typeArgs))

        for (name, ty) in selfInstanceType.extractGenerics(template) {
          resolvedGenerics[name] = ty
        }

        val layerName = "${enum_.label.name}.$variantName"
        match self._resolvedGenerics.addLayer(layerName, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: layerName, message: e))) }

        Ok(selfInstanceType)
      }
    }
  }

  func _functionStruct(self, arity: Int, hasReturnType: Bool): (Struct, Function) {
    val name = if hasReturnType "Function$arity" else "UnitFunction$arity"

    self._functionStructs.getOrInsert(name, () => {
      val dummyModuleId = 0
      val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      val typeParams = (if hasReturnType { ["_R"] } else []).concat(alphabet[:arity].split(""))
      val fields = [
        ("_env", Type(kind: TypeKind.PrimitiveInt)),
        ("_self", Type(kind: TypeKind.PrimitiveInt)),
        ("_ptr", Type(kind: TypeKind.PrimitiveInt)),
      ]

      val struct = Struct.makeDummy(moduleId: dummyModuleId, name: name, typeParams: typeParams, fields: fields)

      val params = alphabet[:arity].split("").map(ch => (ch.toLower(), Type(kind: TypeKind.Generic(ch))))
      val returnType = if hasReturnType Type(kind: TypeKind.Generic("_R")) else Type(kind: TypeKind.PrimitiveUnit)
      val callMethod = Function.generated(
        scope: struct.scope.makeChild("call", kind: ScopeKind.Func),
        name: "call",
        params: params,
        returnType: returnType,
        kind: FunctionKind.InstanceMethod(Some(InstanceKind.Struct(struct)), false),
      )

      (struct, callMethod)
    })
  }

  func _isFunctionStruct(self, struct: Struct): (Struct, Function)? {
    if self._functionStructs[struct.label.name] |s| {
      if s[0] == struct Some(s) else None
    } else None
  }

  func _tupleStruct(self, arity: Int): Struct {
    val name = "Tuple$arity"

    self._tupleStructs.getOrInsert(name, () => {
      val dummyModuleId = 0
      val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      val typeParams = alphabet[:arity].split("")
      val fields = typeParams.map((p, idx) => ("_$idx", Type(kind: TypeKind.Generic(name: p))))
      Struct.makeDummy(moduleId: dummyModuleId, name: name, typeParams: typeParams, fields: fields)
    })
  }

  func _isTupleStruct(self, struct: Struct): Bool = if self._tupleStructs[struct.label.name] |s| s == struct else false

  func _getInstanceTypeForType(self, ty: Type): Result<(InstanceKind, Type[]), CompileError> {
    match ty.kind {
      TypeKind.CouldNotDetermine => unreachable("used for surfacing partial results; no module with this type should make it to the compilation phase")
      TypeKind.PrimitiveUnit => unreachable("getInstanceTypeForType: Unit")
      TypeKind.PrimitiveInt => Ok((InstanceKind.Struct(self._project.preludeIntStruct), []))
      TypeKind.PrimitiveFloat => Ok((InstanceKind.Struct(self._project.preludeFloatStruct), []))
      TypeKind.PrimitiveBool => Ok((InstanceKind.Struct(self._project.preludeBoolStruct), []))
      TypeKind.PrimitiveChar => Ok((InstanceKind.Struct(self._project.preludeCharStruct), []))
      TypeKind.PrimitiveString => Ok((InstanceKind.Struct(self._project.preludeStringStruct), []))
      TypeKind.Never => unreachable("getInstanceTypeForType: Never")
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getInstanceTypeForType(ty) else unreachable("failed to resolve generic: '$name'")
      }
      TypeKind.Instance(instanceKind, typeParams) => Ok((instanceKind, typeParams))
      TypeKind.Tuple(types) => {
        val struct = self._tupleStruct(types.length)
        Ok((InstanceKind.Struct(struct), types))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val hasReturn = returnType.kind != TypeKind.PrimitiveUnit
        val (struct, _) = self._functionStruct(paramTypes.length, hasReturn)

        val typeArgs = (if hasReturn { [returnType] } else []).concat(paramTypes.map(_p => _p[0]))
        Ok((InstanceKind.Struct(struct), typeArgs))
      }
      TypeKind.Type(instanceKind) => Ok((instanceKind, []))
      TypeKind.Hole => unreachable("getInstanceTypeForType: Hole")
    }
  }

  func _getReprForType(self, ty: Type): Result<String, CompileError> {
    match ty.kind {
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getReprForType(ty) else unreachable("failed to resolve generic repr: '$name'")
      }
      TypeKind.Instance(instanceKind, typeParams) => {
        val n = match instanceKind {
          InstanceKind.Struct(struct) => struct.label.name
          InstanceKind.Enum(_enum) => _enum.label.name
        }
        if !typeParams.isEmpty() {
          val params: String[] = []
          for p in typeParams {
            params.push(try self._getReprForType(p))
          }

          Ok("$n<${params.join(", ")}>")
        } else {
          Ok(n)
        }
      }
      TypeKind.Tuple(types) => {
        val struct = self._tupleStruct(types.length)
        self._getReprForType(Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), types)))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val hasReturn = returnType.kind != TypeKind.PrimitiveUnit
        val (struct, _) = self._functionStruct(paramTypes.length, hasReturn)

        val typeArgs = (if hasReturn { [returnType] } else []).concat(paramTypes.map(_p => _p[0]))
        self._getReprForType(Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), typeArgs)))
      }
      _ => Ok(ty.repr())
    }
  }

  func _getNameForType(self, ty: Type): Result<String, CompileError> {
    match ty.kind {
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getNameForType(ty) else unreachable("failed to resolve generic repr: '$name'")
      }
      TypeKind.Instance(instanceKind, typeParams) => {
        val n = match instanceKind {
          InstanceKind.Struct(struct) => struct.label.name
          InstanceKind.Enum(_enum) => _enum.label.name
        }
        if !typeParams.isEmpty() {
          val params: String[] = []
          for p in typeParams {
            params.push(try self._getNameForType(p))
          }

          Ok("$n.${params.join(".")}")
        } else {
          Ok(n)
        }
      }
      TypeKind.Tuple(types) => {
        val struct = self._tupleStruct(types.length)
        self._getNameForType(Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), types)))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val hasReturn = returnType.kind != TypeKind.PrimitiveUnit
        val (struct, _) = self._functionStruct(paramTypes.length, hasReturn)

        val typeArgs = (if hasReturn { [returnType] } else []).concat(paramTypes.map(_p => _p[0]))
        self._getNameForType(Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), typeArgs)))
      }
      _ => Ok(ty.repr())
    }
  }

  // Each module's root code is wrapped in a specially-named function; this function name
  // starts with two dots, which is not possible in ordinary Abra source code and will
  // thus introduce no conflicts (qbe doesn't care about function name rules).
  func _moduleWrapperFnName(self, module: TypedModule): String = "..module_${module.id}"

  func _globalVarName(self, modId: Int, name: String): String = "mod${modId}_${name}.slot"

  func _functionName(self, name: String, kind: FunctionKind): String {
    match kind {
      FunctionKind.Standalone => name
      FunctionKind.InstanceMethod(structOrEnumOpt, _) => match structOrEnumOpt {
        InstanceKind.Struct(s) => "${s.label.name}.$name"
        InstanceKind.Enum(e) => "${e.label.name}.$name"
        _ => name
      }
      FunctionKind.StaticMethod(instanceKind, _) => match instanceKind {
        InstanceKind.Struct(s) => "${s.label.name}#$name"
        InstanceKind.Enum(e) => "${e.label.name}#$name"
      }
    }
  }

  func _structTypeName(self, struct: Struct, excludeTypeParams = false): Result<String, CompileError> {
    val base = ".${struct.moduleId}.${struct.label.name}"
    val name = if !excludeTypeParams && !struct.typeParams.isEmpty() {
      val parts: String[] = []
      for name in struct.typeParams {
        val repr = if self._resolvedGenerics.resolveGeneric(name) |ty| {
          try self._getNameForType(ty)
        } else {
          unreachable("could not resolve '$name'")
        }
        parts.push(repr)
      }
      "$base.${parts.join(".")}"
    } else {
      base
    }

    // qbe limits its identifiers to 80 chars, so if the resulting type name is long, we instead use a randomly-generated alias
    // in place of the type. 16 chars seems like a good balance between long enough that there won't be any conflicts, but also
    // short enough that there's enough room for this type to be used as a generic in other types without making that type's or
    // function's identifier too long.
    if name.length >= 60 {
      val alias = self._aliasedTypeNames.getOrInsert(name, () => String.random(16))
      Ok(alias)
    } else {
      Ok(name)
    }
  }
  func _structInitializerFnName(self, struct: Struct): Result<String, CompileError> {
    val structTypeName = try self._structTypeName(struct)
    Ok("$structTypeName.init")
  }

  func _enumTypeNameBase(self, enum_: Enum): String = ".${enum_.moduleId}.${enum_.label.name}"
  func _enumTypeName(self, enum_: Enum, excludeTypeParams = false): Result<String, CompileError> {
    val base = self._enumTypeNameBase(enum_)
    val name = if !excludeTypeParams && !enum_.typeParams.isEmpty() {
      val parts: String[] = []
      for name in enum_.typeParams {
        val repr = if self._resolvedGenerics.resolveGeneric(name) |ty| {
          try self._getNameForType(ty)
        } else {
          unreachable("could not resolve '$name'")
        }
        parts.push(repr)
      }
      "$base.${parts.join(".")}"
    } else {
      base
    }

    // qbe limits its identifiers to 80 chars, so if the resulting type name is long, we instead use a randomly-generated alias
    // in place of the type. 16 chars seems like a good balance between long enough that there won't be any conflicts, but also
    // short enough that there's enough room for this type to be used as a generic in other types without making that type's or
    // function's identifier too long.
    if name.length >= 60 {
      val alias = self._aliasedTypeNames.getOrInsert(name, () => String.random(40))
      Ok(alias)
    } else {
      Ok(name)
    }
  }
  func _enumVariantFnName(self, enum_: Enum, variant: TypedEnumVariant): Result<String, CompileError> {
    val enumTypeName = try self._enumTypeName(enum_)
    Ok("$enumTypeName.${variant.label.name}")
  }

  func _fnName(self, fn: Function): String = ".${fn.label.name}"

  func _structMethodFnName(self, struct: Struct, fn: Function): Result<String, CompileError> {
    val sep = match fn.kind {
      FunctionKind.InstanceMethod => ".."
      _ => "."
    }
    val typeName = try self._structTypeName(struct, excludeTypeParams: sep == ".")
    val fnName = self._fnName(fn)
    Ok("${typeName}${sep}$fnName")
  }
  func _enumMethodFnName(self, enum_: Enum, fn: Function): Result<String, CompileError> {
    val sep = match fn.kind {
      FunctionKind.InstanceMethod => ".."
      _ => "."
    }
    val typeName = try self._enumTypeName(enum_, excludeTypeParams: sep == ".")
    val fnName = self._fnName(fn)
    Ok("${typeName}${sep}$fnName")
  }

  func _methodFnName(self, instanceKind: InstanceKind, fn: Function): Result<String, CompileError> {
    match instanceKind {
      InstanceKind.Struct(struct) => self._structMethodFnName(struct, fn)
      InstanceKind.Enum(enum_) => self._enumMethodFnName(enum_, fn)
    }
  }

  func _fnSignature(self, instanceKind: InstanceKind?, fn: Function, paramsNeedingDefaultValue: Bool[] = []): Result<String, CompileError> {
    val parts: String[] = []
    match instanceKind {
      InstanceKind.Struct(struct) => {
        parts.push(struct.label.name)
        if !struct.typeParams.isEmpty() {
          parts.push("<")
          for name, idx in struct.typeParams {
            val resolvedGeneric = try self._resolvedGenerics.resolveGeneric(name) else unreachable("(${struct.label.name}, ${fn.label.name}), could not resolve generic '$name'")
            parts.push(resolvedGeneric.repr())

            if idx != struct.typeParams.length - 1 { parts.push(", ") }
          }
          parts.push(">")
        }
        parts.push(match fn.kind { FunctionKind.InstanceMethod => "#", _ => "." })
      }
      InstanceKind.Enum(enum_) => {
        parts.push(enum_.label.name)
        if !enum_.typeParams.isEmpty() {
          parts.push("<")
          for name, idx in enum_.typeParams {
            val resolvedGeneric = try self._resolvedGenerics.resolveGeneric(name) else unreachable("(${enum_.label.name}, ${fn.label.name}), could not resolve generic '$name'")
            parts.push(resolvedGeneric.repr())

            if idx != enum_.typeParams.length - 1 { parts.push(", ") }
          }
          parts.push(">")
        }
        parts.push(match fn.kind { FunctionKind.InstanceMethod => "#", _ => "." })
      }
      None => {}
    }
    parts.push(fn.label.name)
    if !fn.typeParams.isEmpty() {
      parts.push("<")
      for (_, typeParamLabel), idx in fn.typeParams {
        val name = typeParamLabel.name
        val resolvedGeneric = try self._resolvedGenerics.resolveGeneric(name) else unreachable("could not resolve generic '$name'")
        parts.push(resolvedGeneric.repr())

        if idx != fn.typeParams.length - 1 { parts.push(", ") }
      }
      parts.push(">")
    }
    parts.push("(")

    val args: String[] = []
    match fn.kind {
      FunctionKind.InstanceMethod => args.push("self")
      _ => {}
    }
    for param, idx in fn.params {
      val paramTyRepr = try self._getReprForType(param.ty)
      val paramGivenDefaultValue = paramsNeedingDefaultValue[idx] ?: false
      val suffix = if !!param.defaultValue && paramGivenDefaultValue { " = default" } else ""
      args.push("${param.label.name}: $paramTyRepr$suffix")
    }
    parts.push(args.join(", "))
    parts.push(")")

    if fn.returnType.kind != TypeKind.PrimitiveUnit {
      val returnTyRepr = try self._getReprForType(fn.returnType)
      parts.push(": $returnTyRepr")
    }

    Ok(parts.join())
  }

  func _structSignature(self, struct: Struct, fieldsNeedingDefaultValue: Bool[] = []): Result<String[], CompileError> {
    val firstLine = ["type ${struct.label.name}"]
    if !struct.typeParams.isEmpty() {
      firstLine.push("<")
      for name, idx in struct.typeParams {
        val resolvedGeneric = try self._resolvedGenerics.resolveGeneric(name) else unreachable("could not resolve generic '$name'")
        firstLine.push("$name = ${resolvedGeneric.repr()}")

        if idx != struct.typeParams.length - 1 { firstLine.push(", ") }
      }
      firstLine.push(">")
    }
    val parts = ["${firstLine.join()} {"]
    for field, idx in struct.fields {
      val fieldGivenDefaultValue = fieldsNeedingDefaultValue[idx] ?: false
      val suffix = if !!field.initializer && fieldGivenDefaultValue { " = default" } else ""
      parts.push("  ${field.name.name}: ${field.ty.repr()}$suffix")
    }
    parts.push("}")

    Ok(parts)
  }

  func _enumVariantSignature(self, enum_: Enum, variant: TypedEnumVariant, fieldsNeedingDefaultValue: Bool[] = []): Result<String, CompileError> {
    val parts: String[] = [enum_.label.name, ".", variant.label.name]
    match variant.kind {
      EnumVariantKind.Container(fields) => {
        parts.push("(")
        for field, idx in fields {
          val fieldTyRepr = try self._getReprForType(field.ty)
          val fieldGivenDefaultValue = fieldsNeedingDefaultValue[idx] ?: false
          val suffix = if !!field.initializer && fieldGivenDefaultValue { " = default" } else ""
          parts.push("${field.name.name}: $fieldTyRepr$suffix")
          if idx != fields.length - 1 {
            parts.push(", ")
          }
        }
        parts.push(")")
      }
      _ => {}
    }

    Ok(parts.join())
  }

  func _getMethodFunctionByName(self, parent: InstanceKind, name: String, staticMethod = false): Function {
    val (parentName, methods) = match parent {
      InstanceKind.Struct(s) => (s.label.name, if staticMethod s.staticMethods else s.instanceMethods)
      InstanceKind.Enum(e) => (e.label.name, if staticMethod e.staticMethods else e.instanceMethods)
    }

    try methods.find(m => m.label.name == name) else {
      val sep = if staticMethod "." else "#"
      unreachable("$parentName$sep$name must exist")
    }
  }

  func _getEnumVariantByName(self, enum_: Enum, name: String): (TypedEnumVariant, Int) {
    try enum_.variants.findIndex(v => v.label.name == name) else unreachable("${enum_.label.name}.$name must exist")
  }

  func _typeIsInt(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveInt || ty.kind == TypeKind.Instance(InstanceKind.Struct(self._project.preludeIntStruct), [])
  func _typeIsFloat(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveFloat || ty.kind == TypeKind.Instance(InstanceKind.Struct(self._project.preludeFloatStruct), [])
  func _typeIsBool(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveBool || ty.kind == TypeKind.Instance(InstanceKind.Struct(self._project.preludeBoolStruct), [])
  func _typeIsChar(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveChar || ty.kind == TypeKind.Instance(InstanceKind.Struct(self._project.preludeCharStruct), [])
  func _typeIsString(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveString || ty.kind == TypeKind.Instance(InstanceKind.Struct(self._project.preludeStringStruct), [])

  // TODO: this is copied from Typechecker
  func _typeIsOption(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(instanceKind, generics) => {
        match instanceKind {
          InstanceKind.Enum(enum_) => {
            if enum_ != self._project.preludeOptionEnum return None
            if generics[0] |innerTy| {
              Some(innerTy)
            } else {
              None
            }
          }
          _ => None
        }
      }
      _ => None
    }
  }
}
