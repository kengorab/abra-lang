import "fs" as fs
import "process" as process
import Position from "./lexer"
import LiteralAstNode, UnaryOp, BinaryOp, AssignOp, BindingPattern, IndexingMode from "./parser"
import Project, TypedModule, Scope, ScopeKind, TypedAstNode, TypedAstNodeKind, Type, TypeKind, Field, Struct, StructOrEnum, TypedInvokee, Function, FunctionKind, Decorator, AccessorPathSegment, TypedAssignmentMode, Enum, TypedEnumVariant, EnumVariantKind, TypedIndexingNode, VariableAlias, TypedMatchCase, TypedMatchCaseKind, BuiltinModule, Variable, Terminator from "./typechecker"
import ModuleBuilder, Block, QbeType, Dest, QbeFunction, Value, Label, Callable, QbeData, QbeDataKind, Var from "./qbe"

type CompilationError {
  modulePath: String
  error: CompileError

  func getMessage(self): String {
    val contents = match fs.readFile(self.modulePath) {
      Ok(v) => v
      Err => return "Could not read file '${self.modulePath}'"
    }
    self.error.getMessage(self.modulePath, contents)
  }
}

type CompileError {
  position: Position
  kind: CompileErrorKind

  func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      CompileErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      CompileErrorKind.QbeError(message) => {
        // todo: somehow thread the `node` which generated the error through to the error message
        lines.push("Encountered error while generating qbe code:")
        lines.push(message)
      }
      CompileErrorKind.ResolvedGenericsError(context, message) => {
        // todo: somehow thread the `node` which generated the error through to the error message
        lines.push("Encountered error resolving generics for '$context':")
        lines.push(message)
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in range(len - cursorLength, len) {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      unreachable()
    }
  }
}

enum CompileErrorKind {
  NotYetImplemented(reason: String)
  QbeError(message: String)
  ResolvedGenericsError(context: String, message: String)
}

func qbeError<V>(message: String): Result<V, CompileError> = Err(CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(message)))

type ResolvedGenerics {
  _layers: (String, Map<String, Type>)[] = []

  func toString(self): String {
    val parts = ["ResolvedGenerics(_layers: ["]
    for (layerName, generics), idx in self._layers {
      parts.push("(\"$layerName\", { ")
      for (name, ty) in generics {
        parts.push("\"$name\": \"${ty.repr()}\", ")
      }
      parts.push("}")

      if idx != self._layers.length - 1 { parts.push(", ") }
    }
    parts.push("])")

    parts.join()
  }

  func resolveGeneric(self, name: String): Type? {
    var idx = self._layers.length - 1
    while self._layers[idx] |(_, generics)| {
      if generics[name] |ty| return Some(ty)
      idx -= 1
    }

    None
  }

  func _resolveType(self, ty: Type): Result<Type, String> {
    match ty.kind {
      TypeKind.Generic(genericName) => {
        if self.resolveGeneric(genericName) |resolved| {
          Ok(resolved)
        } else {
          Err("layer: could not resolve generic '$genericName'")
        }
      }
      TypeKind.Instance(structOrEnum, typeArgs) => {
        val resolvedGenerics: Type[] = []
        for typeArg in typeArgs {
          resolvedGenerics.push(try self._resolveType(typeArg))
        }
        Ok(Type(kind: TypeKind.Instance(structOrEnum, resolvedGenerics)))
      }
      TypeKind.Tuple(typeArgs) => {
        val resolvedGenerics: Type[] = []
        for typeArg in typeArgs {
          resolvedGenerics.push(try self._resolveType(typeArg))
        }
        Ok(Type(kind: TypeKind.Tuple(resolvedGenerics)))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val resolvedParams: (Type, Bool)[] = []
        for (paramType, paramIsRequired) in paramTypes {
          val ty = try self._resolveType(paramType)
          resolvedParams.push((ty, paramIsRequired))
        }
        val resolvedReturn = try self._resolveType(returnType)

        Ok(Type(kind: TypeKind.Func(resolvedParams, resolvedReturn)))
      }
      _ => Ok(ty)
    }
  }

  func addLayer(self, context: String, given: Map<String, Type>): Result<Int, String> {
    val newLayer: Map<String, Type> = {}
    for (name, ty) in given {
      newLayer[name] = try self._resolveType(ty)
    }

    self._layers.push((context, newLayer))

    Ok(0)
  }

  func popLayer(self) {
    self._layers.pop()
  }
}

func variableToVar(v: Variable): Var = Var(name: v.label.name, location: (v.label.position.line, v.label.position.col))

type CallframeContext {
  position: Position
  callee: String? // callee is None when the callee is an expression
}

export type Compiler {
  _project: Project
  _builder: ModuleBuilder
  _currentModule: TypedModule
  _currentFn: QbeFunction
  _currentFunction: Function?
  _currentNode: TypedAstNode?
  _argcPtr: Value
  _argvPtr: Value
  _callstack: (/* callstack: */ Value, /* ptr */ Value)
  _moduleNamesPtr: Value
  _functionNames: Map<String, Int> = {}
  _fnNamesPtr: Value
  _resolvedGenerics: ResolvedGenerics = ResolvedGenerics()
  _loopStack: (/* loopStart: */ Label, /* loopEnd: */ Label)[] = []
  // cached things
  _printf: QbeFunction = QbeFunction.spec(name: "printf", returnType: None, parameters: [], variadicIdx: Some(1))
  _snprintf: QbeFunction = QbeFunction.spec(name: "snprintf", returnType: Some(QbeType.U64), parameters: [], variadicIdx: Some(3))
  _memcpy: QbeFunction = QbeFunction.spec(name: "memcpy", returnType: None)
  _malloc: QbeFunction = QbeFunction.spec(name: "GC_malloc", returnType: Some(QbeType.Pointer))
  _realloc: QbeFunction = QbeFunction.spec(name: "GC_realloc", returnType: Some(QbeType.Pointer))
  _tupleStructs: Map<String, Struct> = {}
  _functionStructs: Map<String, Struct> = {}
  _aliasedTypeNames: Map<String, String> = {}

  func compile(project: Project): Result<ModuleBuilder, CompilationError> {
    val builder = ModuleBuilder()

    val mainFn = builder.buildFunction(name: "main", returnType: Some(QbeType.U32), exported: true)
    mainFn.addComment("main entrypoint function")
    val argcParam = mainFn.addParameter("argc", QbeType.U64)
    val argvParam = mainFn.addParameter("argv", QbeType.U64)

    val (argcPtr, _) = builder.addData(QbeData(name: "__argc", kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(0))])))
    mainFn.block.buildStoreL(argcParam, argcPtr)
    val (argvPtr, _) = builder.addData(QbeData(name: "__argv", kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(0))])))
    mainFn.block.buildStoreL(argvParam, argvPtr)

    val (callstack, _) = builder.addData(QbeData(name: "__callstack", kind: QbeDataKind.Zeros(size: 1024 * 8)))
    val (callstackPtr, _) = builder.addData(QbeData(name: "__callstackp", kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(0))])))

    val allModules = project.modules.values().sortBy(m => m.id)
    val (moduleNamesPtr, _) = builder.addData(QbeData(name: "__modnames", kind: QbeDataKind.Strings(allModules.map(m => m.name))))

    val (fnNamesPtr, fnNamesIdx) = builder.addData(QbeData(name: "__fnnames", kind: QbeDataKind.Strings([])))

    // Seed the RNG, for any future calls to `libc.rand()`
    val timeVal = match mainFn.block.buildCallRaw("time", QbeType.U64, [Value.Int(0)]) { Ok(v) => v, Err(e) => return Err(CompilationError(modulePath: "<entrypoint>", error: CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(e)))) }
    mainFn.block.buildVoidCallRaw("srand", [timeVal])

    mainFn.block.buildVoidCallRaw("GC_init", [])

    val dummyMod = TypedModule(id: -1, name: "dummy", code: [], rootScope: Scope.bogus())
    val compiler = Compiler(_project: project, _builder: builder, _currentModule: dummyMod, _currentFn: mainFn, _currentFunction: None, _currentNode: None, _argcPtr: argcPtr, _argvPtr: argvPtr, _callstack: (callstack, callstackPtr), _moduleNamesPtr: moduleNamesPtr, _fnNamesPtr: fnNamesPtr)

    for mod in allModules {
      val moduleFn = match compiler._compileModule(mod) {
        Ok(v) => v
        Err(e) => {
          // println(compiler._currentNode?.token)
          return Err(CompilationError(modulePath: mod.name, error: e))
        }
      }
      match moduleFn.block.verify() {
        Ok(v) => v
        Err(e) => return Err(CompilationError(modulePath: mod.name, error: CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(e))))
      }
      mainFn.block.buildVoidCall(Callable.Function(moduleFn), [])
    }

    mainFn.block.buildReturn(Some(Value.Int(0)))

    match mainFn.block.verify() {
      Ok(v) => v
      Err(e) => return Err(CompilationError(modulePath: "<entrypoint>", error: CompileError(position: Position(line: 0, col: 0), kind: CompileErrorKind.QbeError(e))))
    }

    val functionNames = compiler._functionNames.entries().asArray().sortBy(p => p[1])
    for (_, id), idx in functionNames {
      if id != idx unreachable("invalid _functionNames: gap at index $idx")
    }
    builder.setData(fnNamesIdx, QbeDataKind.Strings(functionNames.map(p => p[0])))

    Ok(builder)
  }

  func _compileModule(self, module: TypedModule): Result<QbeFunction, CompileError> {
    val modFnName = self._moduleWrapperFnName(module)
    self._currentModule = module

    val fn = self._builder.buildFunction(name: modFnName, returnType: None)
    fn.addComment(module.name)

    self._currentFn = fn

    for node, idx in module.code {
      val value = try self._compileStatement(node)
      // If the last statement in the module is an expression, call the `toString` method on that expression, and print the result using `printf`.
      if idx == module.code.length - 1 && node.ty.kind != TypeKind.PrimitiveUnit {
        if value |v| {
          self._currentFn.block.addComment("call `toString` on final expression, and `printf` the String's chars")
          val dataPtr = self._builder.buildGlobalString("%s\\n")
          val tostringMethod = try self._getOrCompileToStringMethod(node.ty)

          val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(node.ty))[0])))
          val frameCtx = CallframeContext(position: node.token.position, callee: Some(fnName))
          val tostringRepr = try self._buildCall(Some(frameCtx), Callable.Function(tostringMethod), [v])
          val reprCharsPtr = try self._currentFn.block.buildAdd(Value.Int(8), tostringRepr, Some("_repr_chars_ptr")) else |e| return qbeError(e)
          val reprChars = self._currentFn.block.buildLoadL(reprCharsPtr, Some("_repr_chars"))
          self._currentFn.block.buildVoidCall(Callable.Function(self._printf), [dataPtr, reprChars])
        }
      }
    }

    fn.block.buildReturn()

    try fn.block.verify() else |e| return qbeError(e)

    Ok(fn)
  }

  func _compileStatement(self, node: TypedAstNode): Result<Value?, CompileError> {
    val prevNode = self._currentNode
    self._currentNode = Some(node)

    val res: Result<Value?, CompileError> = match node.kind {
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if !isStatement {
          val res = try self._compileExpression(node)
          return Ok(Some(res))
        }

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        val condVal = try self._compileExpression(cond)
        val condExprIsOpt = self._typeIsOption(cond.ty)

        if condExprIsOpt {
          val variantIsOptionSome = try self._emitOptValueIsSomeVariant(condVal)
          self._currentFn.block.buildJnz(variantIsOptionSome, labelThen, if elseBlock.isEmpty() labelCont else labelElse)
        } else {
          self._currentFn.block.buildJnz(condVal, labelThen, if elseBlock.isEmpty() labelCont else labelElse)
        }

        self._currentFn.block.registerLabel(labelThen)
        if conditionBinding |(bindingPattern, vars)| {
          val variables = vars.keyBy(v => v.label.name)

          val bindingVal = if condExprIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            try self._emitOptValueGetValue(innerQbeType, condVal)
          } else {
            Value.Int(1)
          }
          try self._compileBindingPattern(bindingPattern, variables, Some(bindingVal))
        }

        for node in ifBlock {
          try self._compileStatement(node)
        }
        if !ifBlockTerminator {
          self._currentFn.block.buildJmp(labelCont)
        }

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node in elseBlock {
            try self._compileStatement(node)
          }
          if !elseBlockTerminator {
            self._currentFn.block.buildJmp(labelCont)
          }
        }

        self._currentFn.block.registerLabel(labelCont)

        Ok(None)
      }
      TypedAstNodeKind.Match(isStatement, expr, cases) => self._compileMatch(node, isStatement, expr, cases)
      TypedAstNodeKind.While(cond, conditionBinding, block, blockTerminator) => {
        val loopStartLabel = self._currentFn.block.addLabel("while_loop_start")
        val loopBodyLabel = self._currentFn.block.addLabel("while_loop_body")
        val loopEndLabel = self._currentFn.block.addLabel("while_loop_end")

        self._loopStack.push((loopStartLabel, loopEndLabel))

        self._currentFn.block.registerLabel(loopStartLabel)
        val condVal = try self._compileExpression(cond)
        val condExprIsOpt = self._typeIsOption(cond.ty)

        if condExprIsOpt {
          val variantIsOptionSome = try self._emitOptValueIsSomeVariant(condVal)
          self._currentFn.block.buildJnz(variantIsOptionSome, loopBodyLabel, loopEndLabel)
        } else {
          self._currentFn.block.buildJnz(condVal, loopBodyLabel, loopEndLabel)
        }

        self._currentFn.block.registerLabel(loopBodyLabel)
        if conditionBinding |(bindingPattern, vars)| {
          val variables = vars.keyBy(v => v.label.name)

          val bindingVal = if condExprIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            try self._emitOptValueGetValue(innerQbeType, condVal)
          } else {
            Value.Int(1)
          }
          try self._compileBindingPattern(bindingPattern, variables, Some(bindingVal))
        }

        for node in block {
          try self._compileStatement(node)
        }
        if !blockTerminator {
          self._currentFn.block.buildJmp(loopStartLabel)
        }

        self._currentFn.block.registerLabel(loopEndLabel)

        self._loopStack.pop()

        Ok(None)
      }
      TypedAstNodeKind.For(typedIterator, itemBindingPattern, indexBinding, block) => {
        val (instTy, typeArgs) = try self._getInstanceTypeForType(typedIterator.ty)

        val (iterVal, iterTy, nextFn, popAdditionalResolvedGenericsLayer) = match instTy {
          StructOrEnum.Struct(s) => {
            if s == self._project.preludeArrayStruct {
              val innerTy = if typeArgs[0] |t| t else unreachable("Array has 1 required type argument")
              match self._resolvedGenerics.addLayer("array literal", { "T": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "array literal", message: e))) }

              val arrayVal = try self._compileExpression(typedIterator)
              val instType = try self._addResolvedGenericsLayerForInstanceMethod(typedIterator.ty, "iterator", typedIterator.token.position)
              val iteratorFn = if s.instanceMethods.find(m => m.label.name == "iterator") |fn| fn else unreachable("Array#iterator must exist")
              val iteratorFnVal = try self._getOrCompileMethod(instType, iteratorFn)
              self._resolvedGenerics.popLayer()

              self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) iterator")
              val fnName = self._functionName(iteratorFn.label.name, iteratorFn.kind)
              val frameCtx = CallframeContext(position: typedIterator.token.position, callee: Some(fnName))
              val iter = try self._buildCall(Some(frameCtx), Callable.Function(iteratorFnVal), [arrayVal])

              val (structOrEnum, typeArgs) = try self._getInstanceTypeForType(iteratorFn.returnType)
              val instanceMethods = match structOrEnum {
                StructOrEnum.Struct(s) => s.instanceMethods
                StructOrEnum.Enum(e) => e.instanceMethods
              }
              val nextFn = if instanceMethods.find(m => m.label.name == "next") |fn| fn else unreachable("a type must have a 'next' method if it's to be iterable")

              val iterTy = Type(kind: TypeKind.Instance(structOrEnum, typeArgs))
              (iter, iterTy, nextFn, true)
            } else if s == self._project.preludeSetStruct {
              val innerTy = if typeArgs[0] |t| t else unreachable("Set has 1 required type argument")
              match self._resolvedGenerics.addLayer("set literal", { "T": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "set literal", message: e))) }

              val mapVal = try self._compileExpression(typedIterator)
              val instType = try self._addResolvedGenericsLayerForInstanceMethod(typedIterator.ty, "iterator", typedIterator.token.position)
              val iteratorFn = if s.instanceMethods.find(m => m.label.name == "iterator") |fn| fn else unreachable("Set#iterator must exist")
              val iteratorFnVal = try self._getOrCompileMethod(instType, iteratorFn)
              self._resolvedGenerics.popLayer()

              self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) iterator")
              val fnName = self._functionName(iteratorFn.label.name, iteratorFn.kind)
              val frameCtx = CallframeContext(position: typedIterator.token.position, callee: Some(fnName))
              val iter = try self._buildCall(Some(frameCtx), Callable.Function(iteratorFnVal), [mapVal])

              val (structOrEnum, typeArgs) = try self._getInstanceTypeForType(iteratorFn.returnType)
              val instanceMethods = match structOrEnum {
                StructOrEnum.Struct(s) => s.instanceMethods
                StructOrEnum.Enum(e) => e.instanceMethods
              }
              val nextFn = if instanceMethods.find(m => m.label.name == "next") |fn| fn else unreachable("a type must have a 'next' method if it's to be iterable")

              val iterTy = Type(kind: TypeKind.Instance(structOrEnum, typeArgs))
              (iter, iterTy, nextFn, true)
            } else if s == self._project.preludeMapStruct {
              val keyTy = if typeArgs[0] |t| t else unreachable("Map has 2 required type arguments")
              val valTy = if typeArgs[1] |t| t else unreachable("Map has 2 required type arguments")
              match self._resolvedGenerics.addLayer("map literal", { "K": keyTy, "V": valTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "map literal", message: e))) }

              val mapVal = try self._compileExpression(typedIterator)
              val instType = try self._addResolvedGenericsLayerForInstanceMethod(typedIterator.ty, "iterator", typedIterator.token.position)
              val iteratorFn = if s.instanceMethods.find(m => m.label.name == "iterator") |fn| fn else unreachable("Map#iterator must exist")
              val iteratorFnVal = try self._getOrCompileMethod(instType, iteratorFn)
              self._resolvedGenerics.popLayer()

              self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) iterator")
              val fnName = self._functionName(iteratorFn.label.name, iteratorFn.kind)
              val frameCtx = CallframeContext(position: typedIterator.token.position, callee: Some(fnName))
              val iter = try self._buildCall(Some(frameCtx), Callable.Function(iteratorFnVal), [mapVal])

              val (structOrEnum, typeArgs) = try self._getInstanceTypeForType(iteratorFn.returnType)
              val instanceMethods = match structOrEnum {
                StructOrEnum.Struct(s) => s.instanceMethods
                StructOrEnum.Enum(e) => e.instanceMethods
              }
              val nextFn = if instanceMethods.find(m => m.label.name == "next") |fn| fn else unreachable("a type must have a 'next' method if it's to be iterable")

              val iterTy = Type(kind: TypeKind.Instance(structOrEnum, typeArgs))
              (iter, iterTy, nextFn, true)
            } else {
              self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) iterator")
              val iter = try self._compileExpression(typedIterator)
              val nextFn = if s.instanceMethods.find(m => m.label.name == "next") |fn| fn else unreachable("a type must have a 'next' method if it's to be iterable")

              (iter, typedIterator.ty, nextFn, false)
            }
          }
          StructOrEnum.Enum(_enum) => todo("enum as for-loop target")
        }

        val nextItemTy = if self._typeIsOption(nextFn.returnType) |innerTy| innerTy else unreachable("a 'next' method must return an Option type")
        val iterInstTy = try self._addResolvedGenericsLayerForInstanceMethod(iterTy, "next", node.token.position)
        val nextItemQbeTy = try self._getQbeTypeForTypeExpect(nextItemTy, "unacceptable type for 'next' method return type")

        val nextFnVal = try self._getOrCompileMethod(iterInstTy, nextFn)
        self._resolvedGenerics.popLayer()
        if popAdditionalResolvedGenericsLayer self._resolvedGenerics.popLayer()

        val forLabelPrefix = "for_${node.token.position.line}_${node.token.position.col}"
        val loopStartLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_start")
        val loopBodyLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_body")
        val loopEndLabel = self._currentFn.block.addLabel("${forLabelPrefix}_loop_end")

        self._loopStack.push((loopStartLabel, loopEndLabel))

        val indexBindingSlot = if indexBinding |bindingVar| {
          val slotName = self._currentFn.block.addVar(variableToVar(bindingVar))
          val slot = self._buildStackAllocForQbeType(QbeType.U64, Some(slotName))
          self._currentFn.block.buildStoreL(Value.Int(-1), slot)
          Some(slot)
        } else {
          None
        }

        self._currentFn.block.registerLabel(loopStartLabel)
        val (iterateePattern, iterateeBindingVars) = itemBindingPattern
        val iterateeBindingVariables = iterateeBindingVars.keyBy(v => v.label.name)
        self._currentFn.block.addComment("for-loop (${node.token.position.line}, ${node.token.position.col}) next() ret value")
        val fnName = self._functionName(nextFn.label.name, nextFn.kind)
        val frameCtx = CallframeContext(position: node.token.position, callee: Some(fnName))
        val nextRet = try self._buildCall(Some(frameCtx), Callable.Function(nextFnVal), [iterVal])

        val variantIsOptionSome = try self._emitOptValueIsSomeVariant(nextRet)
        self._currentFn.block.buildJnz(variantIsOptionSome, loopBodyLabel, loopEndLabel)

        self._currentFn.block.registerLabel(loopBodyLabel)
        val optInnerValue = try self._emitOptValueGetValue(nextItemQbeTy, nextRet)
        try self._compileBindingPattern(iterateePattern, iterateeBindingVariables, Some(optInnerValue))
        if indexBindingSlot |idxSlot| {
          val idxVal = self._currentFn.block.buildLoadL(idxSlot)
          val idxIncrVal = try self._currentFn.block.buildAdd(Value.Int(1), idxVal) else |e| return qbeError(e)
          self._currentFn.block.buildStoreL(idxIncrVal, idxSlot)
        }

        for node in block {
          try self._compileStatement(node)
        }
        self._currentFn.block.buildJmp(loopStartLabel)

        self._currentFn.block.registerLabel(loopEndLabel)

        self._loopStack.pop()

        Ok(None)
      }
      TypedAstNodeKind.BindingDeclaration(bindingDeclNode) => {
        val variables = bindingDeclNode.variables.keyBy(v => v.label.name)
        val exprVal = if bindingDeclNode.expr |expr| {
          Some(try self._compileExpression(expr))
        } else {
          None
        }
        try self._compileBindingPattern(bindingDeclNode.bindingPattern, variables, exprVal)

        Ok(None)
      }
      TypedAstNodeKind.FunctionDeclaration(fn) => {
        if fn.isClosure() {
          val capturesMem = try self._createClosureCaptures(fn)
          val capturesSlot = self._buildStackAllocForQbeType(QbeType.Pointer, Some("${fn.label.name}.captures"))
          self._currentFn.block.buildStore(QbeType.Pointer, capturesMem, capturesSlot)
        }

        Ok(None)
      }
      TypedAstNodeKind.TypeDeclaration(struct) => {
        for fn in struct.instanceMethods {
          if fn.isClosure() {
            val capturesMem = try self._createClosureCaptures(fn)
            val methodName = "${struct.label.name}..${fn.label.name}"
            val capturesSlot = self._buildStackAllocForQbeType(QbeType.Pointer, Some("$methodName.captures"))
            self._currentFn.block.buildStore(QbeType.Pointer, capturesMem, capturesSlot)
          }
        }

        for fn in struct.staticMethods {
          if fn.isClosure() {
            val capturesMem = try self._createClosureCaptures(fn)
            val methodName = "${struct.label.name}.${fn.label.name}"
            val capturesSlot = self._buildStackAllocForQbeType(QbeType.Pointer, Some("$methodName.captures"))
            self._currentFn.block.buildStore(QbeType.Pointer, capturesMem, capturesSlot)
          }
        }

        Ok(None)
      }
      TypedAstNodeKind.EnumDeclaration => Ok(None)
      TypedAstNodeKind.Break => {
        if self._loopStack[-1] |(_, loopEndLabel)| {
          self._currentFn.block.buildJmp(loopEndLabel)

          Ok(None)
        } else {
          unreachable("cannot have a break statement outside of a loop")
        }
      }
      TypedAstNodeKind.Continue => {
        if self._loopStack[-1] |(loopStartLabel, _)| {
          self._currentFn.block.buildJmp(loopStartLabel)

          Ok(None)
        } else {
          unreachable("cannot have a continue statement outside of a loop")
        }
      }
      TypedAstNodeKind.Return(expr) => {
        if expr |expr| {
          val retVal = try self._compileExpression(expr)
          self._currentFn.block.buildReturn(Some(retVal))
        } else {
          self._currentFn.block.buildReturn(None)
        }

        Ok(None)
      }
      TypedAstNodeKind.Placeholder => unreachable("placeholder ast node emitted from typechecker")
      TypedAstNodeKind.Assignment(mode, op, expr) => {
        val res = try self._compileExpression(expr)

        match mode {
          TypedAssignmentMode.Variable(variable) => {
            if variable.isParameter unreachable("parameters cannot be reassigned to")

            val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
            // A top-level variable in a module is only hoisted to global if it's captured; otherwise it's effectively a local within the module wrapper function
            if variable.isCaptured {
              if variable.isGlobal() |modId| {
                val name = self._globalVarName(modId, variable.label.name)
                val slot = Value.Global(name, QbeType.Pointer)
                self._currentFn.block.buildStore(varTy, res, slot)
              } else {
                val ptr = try self._getCapturedVarPtr(variable)
                self._currentFn.block.addComment("overwrite ptr to captured '${variable.label.name}'")
                self._currentFn.block.buildStore(varTy, res, ptr)
              }
            } else {
              val slotName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else unreachable("Could not resolve name for variable '${variable.label.name}'")
              val slot = Value.Ident(slotName, QbeType.Pointer)
              self._currentFn.block.buildStore(varTy, res, slot)
            }
          }
          TypedAssignmentMode.Indexing(idxNode) => {
            match idxNode {
              TypedIndexingNode.ArrayLike(expr, indexingMode) => {
                match indexingMode {
                  IndexingMode.Single(idxExpr) => {
                    val exprVal = try self._compileExpression(expr)
                    val idxExprVal = try self._compileExpression(idxExpr)

                    val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "set", expr.token.position)
                    val (structOrEnum, _) = try self._getInstanceTypeForType(expr.ty)
                    val struct = match structOrEnum {
                      StructOrEnum.Struct(struct) => struct
                      StructOrEnum.Enum => unreachable("index-assignment only implemented for arrays")
                    }
                    if struct != self._project.preludeArrayStruct unreachable("index-assignment only implemented for arrays")

                    val setFn = if self._project.preludeArrayStruct.instanceMethods.find(m => m.label.name == "set") |fn| fn else unreachable("Array#set must exist")
                    val setFnVal = try self._getOrCompileMethod(instType, setFn)
                    self._resolvedGenerics.popLayer()

                    // Do not track Array#set in callframes
                    try self._buildCall(None, Callable.Function(setFnVal), [exprVal, idxExprVal, res])
                  }
                  _ => unreachable("cannot use range index in index-assignment")
                }
              }
              TypedIndexingNode.Map(expr, idxExpr) => {
                val exprVal = try self._compileExpression(expr)
                val idxExprVal = try self._compileExpression(idxExpr)

                val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "set", expr.token.position)
                val (structOrEnum, _) = try self._getInstanceTypeForType(expr.ty)
                val struct = match structOrEnum {
                  StructOrEnum.Struct(struct) => struct
                  StructOrEnum.Enum => unreachable("index-assignment only implemented for maps")
                }
                if struct != self._project.preludeMapStruct unreachable("index-assignment only implemented for map")

                val insertFn = if self._project.preludeMapStruct.instanceMethods.find(m => m.label.name == "insert") |fn| fn else unreachable("Map#insert must exist")
                val insertFnVal = try self._getOrCompileMethod(instType, insertFn)
                self._resolvedGenerics.popLayer()

                // Do not track Map#insert in callframes
                try self._buildCall(None, Callable.Function(insertFnVal), [exprVal, idxExprVal, res])
              }
              TypedIndexingNode.Tuple(_, _) => unreachable("tuples are not assignable via index-assignment")
            }
          }
          TypedAssignmentMode.Accessor(head, middle, tail) => {
            val ptr = try self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: false)
            self._currentFn.block.buildStore(res.ty(), res, ptr)
          }
        }

        Ok(None)
      }
      _ => {
        val v = try self._compileExpression(node)
        if node.ty.kind == TypeKind.PrimitiveUnit {
          Ok(None)
        } else {
          Ok(Some(v))
        }
      }
    }

    self._currentNode = prevNode

    res
  }

  func _compileExpression(self, node: TypedAstNode, resultLocalName: String? = None): Result<Value, CompileError> {
    val prevNode = self._currentNode
    self._currentNode = Some(node)

    val res: Result<Value, CompileError> = match node.kind {
      TypedAstNodeKind.Literal(lit) => {
        val (value, _) = try self._compileLiteral(lit)
        Ok(value)
      }
      TypedAstNodeKind.StringInterpolation(exprs) => {
        self._currentFn.block.addComment("begin string interpolation...")

        val strVals: Value[] = []
        var lenVal = Value.Int(0)
        for item in exprs {
          val itemVal = try self._compileExpression(item)

          val itemInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(item.ty, "toString", item.token.position)
          val itemToStringFnVal = try self._getOrCompileToStringMethod(itemInstanceType)
          self._resolvedGenerics.popLayer()

          val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(item.ty))[0])))
          val frameCtx = CallframeContext(position: item.token.position, callee: Some(fnName))
          val toStringVal = try self._buildCall(Some(frameCtx), Callable.Function(itemToStringFnVal), [itemVal])
          strVals.push(toStringVal)

          val stringLength = self._currentFn.block.buildLoadL(toStringVal)
          lenVal = try self._currentFn.block.buildAdd(lenVal, stringLength) else |e| return qbeError(e)
        }

        val stringWithLengthFn = if self._project.preludeStringStruct.staticMethods.find(m => m.label.name == "withLength") |fn| fn else unreachable("String.withLength must exist")
        val stringWithLengthFnVal = try self._getOrCompileMethod(Type(kind: TypeKind.Type(StructOrEnum.Struct(self._project.preludeStringStruct))), stringWithLengthFn)
        // Do not track String.withLength in callframes
        val newString = try self._buildCall(None, Callable.Function(stringWithLengthFnVal), [lenVal])
        var newBuffer = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), newString) else |e| return qbeError(e))

        for strVal, idx in strVals {
          val strValLen = self._currentFn.block.buildLoadL(strVal)
          val strValBuf = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), strVal) else |e| return qbeError(e))

          self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newBuffer, strValBuf, strValLen])
          if idx != strVals.length {
            newBuffer = try self._currentFn.block.buildAdd(newBuffer, strValLen) else |e| return qbeError(e)
          }
        }

        self._currentFn.block.addComment("...string interpolation end")

        Ok(newString)
      }
      TypedAstNodeKind.Unary(op, expr) => {
        match op {
          UnaryOp.Minus => {
            val exprVal = try self._compileExpression(expr)
            val res = try self._currentFn.block.buildNeg(exprVal) else |e| return qbeError(e)

            Ok(res)
          }
          UnaryOp.Negate => {
            val exprVal = try self._compileExpression(expr)
            val exprIsOpt = self._typeIsOption(expr.ty)
            if exprIsOpt {
              val variantIsNotOptionSome = try self._emitOptValueIsSomeVariant(exprVal: exprVal, negate: true)
              val res = self._currentFn.block.buildExt(variantIsNotOptionSome, false)
              Ok(res)
            } else {
              val plusOneVal = try self._currentFn.block.buildAdd(Value.Int(1), exprVal) else |e| return qbeError(e)
              val res = try self._currentFn.block.buildRem(plusOneVal, Value.Int(2)) else |e| return qbeError(e)
              Ok(res)
            }
          }
        }
      }
      TypedAstNodeKind.Binary(left, op, right) => {
        match op {
          BinaryOp.Add => {
            val leftIsString = self._typeIsString(left.ty)
            val rightIsString = self._typeIsString(right.ty)

            if leftIsString || rightIsString {
              self._currentFn.block.addComment("begin string concatenation...")
              var leftVal = try self._compileExpression(left)
              if !leftIsString {
                val leftInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(left.ty, "toString", left.token.position)
                val leftToStringFnVal = try self._getOrCompileToStringMethod(leftInstanceType)
                self._resolvedGenerics.popLayer()

                val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(left.ty))[0])))
                val frameCtx = CallframeContext(position: left.token.position, callee: Some(fnName))
                leftVal = try self._buildCall(Some(frameCtx), Callable.Function(leftToStringFnVal), [leftVal])
              }

              var rightVal = try self._compileExpression(right)
              if !rightIsString {
                val rightInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(right.ty, "toString", right.token.position)
                val rightToStringFnVal = try self._getOrCompileToStringMethod(rightInstanceType)
                self._resolvedGenerics.popLayer()

                val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(right.ty))[0])))
                val frameCtx = CallframeContext(position: right.token.position, callee: Some(fnName))
                rightVal = try self._buildCall(Some(frameCtx), Callable.Function(rightToStringFnVal), [rightVal])
              }

              val stringWithLengthFn = if self._project.preludeStringStruct.staticMethods.find(m => m.label.name == "withLength") |fn| fn else unreachable("String.withLength must exist")
              val stringWithLengthFnVal = try self._getOrCompileMethod(Type(kind: TypeKind.Type(StructOrEnum.Struct(self._project.preludeStringStruct))), stringWithLengthFn)
              val leftLength = self._currentFn.block.buildLoadL(leftVal)
              val rightLength = self._currentFn.block.buildLoadL(rightVal)
              val totalLength = try self._currentFn.block.buildAdd(leftLength, rightLength) else |e| return qbeError(e)
              // Do not track String.withLength in callframes
              val newString = try self._buildCall(None, Callable.Function(stringWithLengthFnVal), [totalLength])

              var newBuffer = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), newString) else |e| return qbeError(e))

              val leftBuffer = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), leftVal) else |e| return qbeError(e))
              self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newBuffer, leftBuffer, leftLength])

              val rightBuffer = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), rightVal) else |e| return qbeError(e))
              newBuffer = try self._currentFn.block.buildAdd(newBuffer, leftLength) else |e| return qbeError(e)
              self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newBuffer, rightBuffer, rightLength])

              self._currentFn.block.addComment("...string concatenation end")

              return Ok(newString)
            }

            val (lval, rval) = try self._compileBinaryOperands(left, right, "+")
            val res = try self._currentFn.block.buildAdd(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.Sub => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, "-")
            val res = try self._currentFn.block.buildSub(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.Mul => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, "*")
            val res = try self._currentFn.block.buildMul(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.Div => {
            var leftVal = try self._compileExpression(left)
            var rightVal = try self._compileExpression(right)

            if !self._typeIsFloat(left.ty)
              leftVal = self._currentFn.block.buildLToF(leftVal)
            if !self._typeIsFloat(right.ty)
              rightVal = self._currentFn.block.buildLToF(rightVal)

            val res = try self._currentFn.block.buildDiv(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.Mod => {
            var leftVal = try self._compileExpression(left)
            var rightVal = try self._compileExpression(right)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val res = try self._currentFn.block.buildRem(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
              Ok(res)
            } else {
              if !self._typeIsFloat(left.ty)
                leftVal = self._currentFn.block.buildLToF(leftVal)
              if !self._typeIsFloat(right.ty)
                rightVal = self._currentFn.block.buildLToF(rightVal)

              val res = try self._currentFn.block.buildCallRaw("fmod", QbeType.F64, [leftVal, rightVal]) else |e| return qbeError(e)
              Ok(res)
            }
          }
          BinaryOp.Pow => {
            var leftVal = try self._compileExpression(left)
            var rightVal = try self._compileExpression(right)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              leftVal = self._currentFn.block.buildLToF(leftVal)
              rightVal = self._currentFn.block.buildLToF(rightVal)
              val res = try self._currentFn.block.buildCallRaw("pow", QbeType.F64, [leftVal, rightVal]) else |e| return qbeError(e)
              Ok(res)
            } else {
              // if a < 0 { -(-a ** b) } else { a ** b }
              if !self._typeIsFloat(left.ty)
                leftVal = self._currentFn.block.buildLToF(leftVal)
              if !self._typeIsFloat(right.ty)
                rightVal = self._currentFn.block.buildLToF(rightVal)

              val labelThen = self._currentFn.block.addLabel("fpow_l_neg")
              val labelElse = self._currentFn.block.addLabel("fpow_l_pos")
              val labelCont = self._currentFn.block.addLabel("fpow_cont")
              val cond = try self._currentFn.block.buildCompareLt(leftVal, Value.Float(0.0)) else |e| return qbeError(e)
              self._currentFn.block.buildJnz(cond, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              val leftValNeg = try self._currentFn.block.buildMul(leftVal, Value.Float(-1.0)) else |e| return qbeError(e)
              val thenValNeg = try self._currentFn.block.buildCallRaw("pow", QbeType.F64, [leftValNeg, rightVal]) else |e| return qbeError(e)
              val thenVal = try self._currentFn.block.buildMul(thenValNeg, Value.Float(-1.0)) else |e| return qbeError(e)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              val elseVal = try self._currentFn.block.buildCallRaw("pow", QbeType.F64, [leftVal, rightVal]) else |e| return qbeError(e)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(labelThen, thenVal), (labelElse, elseVal)]
              val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)

              Ok(res)
            }
          }
          BinaryOp.And => {
            val leftVal = try self._compileExpression(left)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val rightVal = try self._compileExpression(right)

              val res = try self._currentFn.block.buildAnd(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
              Ok(res)
            } else {
              val labelThen = self._currentFn.block.addLabel("bool_and_then")
              val labelElse = self._currentFn.block.addLabel("bool_and_else")
              val labelCont = self._currentFn.block.addLabel("bool_and_cont")

              self._currentFn.block.buildJnz(leftVal, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              val rightVal = try self._compileExpression(right)
              val rightLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(rightLabel, rightVal), (labelElse, leftVal)]
              val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)

              Ok(res)
            }
          }
          BinaryOp.Or => {
            val leftVal = try self._compileExpression(left)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) {
              val rightVal = try self._compileExpression(right)

              val res = try self._currentFn.block.buildOr(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
              Ok(res)
            } else {
              val labelThen = self._currentFn.block.addLabel("bool_or_then")
              val labelElse = self._currentFn.block.addLabel("bool_or_else")
              val labelCont = self._currentFn.block.addLabel("bool_or_cont")

              self._currentFn.block.buildJnz(leftVal, labelThen, labelElse)

              self._currentFn.block.registerLabel(labelThen)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelElse)
              val rightVal = try self._compileExpression(right)
              val rightLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(labelThen, leftVal), (rightLabel, rightVal)]
              val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)

              Ok(res)
            }
          }
          BinaryOp.Xor => {
            val leftVal = try self._compileExpression(left)
            val rightVal = try self._compileExpression(right)

            if self._typeIsInt(left.ty) && self._typeIsInt(right.ty) || self._typeIsBool(left.ty) && self._typeIsBool(right.ty) {
              val res = try self._currentFn.block.buildXor(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
              Ok(res)
            } else {
              unreachable("unknown operator '^' between types '${left.ty.repr()}' and '${right.ty.repr()}")
            }
          }
          BinaryOp.Coalesce => {
            val leftVal = try self._compileExpression(left)

            val labelThen = self._currentFn.block.addLabel("coalesce_then")
            val labelElse = self._currentFn.block.addLabel("coalesce_else")
            val labelCont = self._currentFn.block.addLabel("coalesce_cont")

            val isSome = try self._emitOptValueIsSomeVariant(leftVal)

            self._currentFn.block.buildJnz(isSome, labelThen, labelElse)

            self._currentFn.block.registerLabel(labelThen)
            val innerTy = if self._typeIsOption(left.ty) |innerTy| innerTy else unreachable()
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            val innerVal = try self._emitOptValueGetValue(innerQbeType, leftVal)
            val leftLabel = self._currentFn.block.currentLabel
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.registerLabel(labelElse)
            val rightVal = try self._compileExpression(right)
            val rightLabel = self._currentFn.block.currentLabel
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.registerLabel(labelCont)

            val phiCases = [(leftLabel, innerVal), (rightLabel, rightVal)]
            val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)

            Ok(res)
          }
          BinaryOp.Eq => self._compileBinaryEq(left, right)
          BinaryOp.Neq => self._compileBinaryEq(left: left, right: right, negate: true)
          BinaryOp.LT => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, "<")
            val res = try self._currentFn.block.buildCompareLt(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(self._currentFn.block.buildExt(res, false))
          }
          BinaryOp.LTE => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, "<=")
            val res = try self._currentFn.block.buildCompareLte(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(self._currentFn.block.buildExt(res, false))
          }
          BinaryOp.Shl => {
            val leftVal = try self._compileExpression(left)
            val rightVal = try self._compileExpression(right)

            val res = try self._currentFn.block.buildShl(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
          BinaryOp.GT => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, ">")
            val res = try self._currentFn.block.buildCompareGt(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(self._currentFn.block.buildExt(res, false))
          }
          BinaryOp.GTE => {
            val (lval, rval) = try self._compileBinaryOperands(left, right, ">=")
            val res = try self._currentFn.block.buildCompareGte(lval, rval, resultLocalName) else |e| return qbeError(e)
            Ok(self._currentFn.block.buildExt(res, false))
          }
          BinaryOp.Shr => {
            val leftVal = try self._compileExpression(left)
            val rightVal = try self._compileExpression(right)

            val res = try self._currentFn.block.buildShr(leftVal, rightVal, resultLocalName) else |e| return qbeError(e)
            Ok(res)
          }
        }
      }
      TypedAstNodeKind.Grouped(inner) => self._compileExpression(inner, resultLocalName)
      TypedAstNodeKind.Identifier(name, variable, fnAliasTypeHint, varImportModule) => {
        // If a variable is function parameter, it can just be referenced by name as a temporary/local, otherwise it can be obtained by
        // loading the value pointed to by the temporary/local with that name.
        // TODO: handle captured variables in closures, global variables, etc).
        val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
        if variable.isParameter {
          if variable.isCaptured {
            if variable.mutable unreachable("parameters cannot be mutable")
            val value = try self._getCapturedVarPtr(variable)
            Ok(value)
          } else {
            val varName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else unreachable("Could not resolve name for variable '${variable.label.name}'")
            Ok(Value.Ident(varName, varTy))
          }
        } else {
          match variable.alias {
            VariableAlias.Function(fn) => {
              val targetParamTypes = if fnAliasTypeHint |hint| {
                val paramTypes = match hint.kind {
                  TypeKind.Func(paramTypes, _) => Some(paramTypes)
                  TypeKind.Any => None // if the function value is being treated as an Any, then no param type info needs to be known later anyway
                  _ => unreachable("fnAliasTypeKind must be TypeKind.Func")
                }
                paramTypes
              } else {
                None
              }

              val capturesMem = if !fn.isClosure() None else {
                val mem = try self._getCapturesArrForClosure(fn)
                Some(mem)
              }

              self._compileFunctionValue(node.token.position, fn, targetParamTypes, capturesMem, None)
            }
            _ => {
              if varImportModule |mod| {
                val name = self._globalVarName(mod.id, name)
                val slot = Value.Global(name, QbeType.Pointer)
                val res = self._currentFn.block.buildLoad(varTy, slot)
                Ok(res)
              } else if variable.isCaptured {
                // A top-level variable in a module is only hoisted to global if it's captured; otherwise it's effectively a local within the module wrapper function
                val res = if variable.isGlobal() |modId| {
                  val name = self._globalVarName(modId, name)
                  val slot = Value.Global(name, QbeType.Pointer)
                  self._currentFn.block.buildLoad(varTy, slot)
                } else {
                  val ptr = try self._getCapturedVarPtr(variable)
                  if variable.mutable {
                    self._currentFn.block.addComment("deref ptr to captured mutable '${variable.label.name}'")
                    self._currentFn.block.buildLoad(varTy, ptr)
                  } else {
                    ptr
                  }
                }

                Ok(res)
              } else {
                val slotName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else unreachable("Could not resolve name for variable '${variable.label.name}'")
                val slot = Value.Ident(slotName, QbeType.Pointer)
                val res = self._currentFn.block.buildLoad(varTy, slot)
                Ok(res)
              }
            }
          }
        }
      }
      TypedAstNodeKind.Accessor(head, middle, tail) => self._followAccessorPath(head: head, middle: middle, tail: tail, loadFinal: true, localName: resultLocalName)
      TypedAstNodeKind.Invocation(invokee, arguments, resolvedGenerics) => {
        val args: Value[] = []
        var optSafeCtx: (Label, Value?, QbeFunction, Label)? = None
        var closureEnvCtx: (Value, Bool)? = None
        var closureSelfCtx: Value? = None

        val (fnVal, frameCtx) = match invokee {
          TypedInvokee.Function(fn) => {
            match self._resolvedGenerics.addLayer(fn.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: fn.label.name, message: e))) }

            if fn.label.name == "println" || fn.label.name == "print" {
              val res = self._invokePrint(arguments: arguments, withNewline: fn.label.name == "println")
              self._resolvedGenerics.popLayer()
              return res
            }

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "Intrinsic")
            if intrinsicDec |dec| {
              val res = self._invokeIntrinsicFn(dec, fn, arguments)
              self._resolvedGenerics.popLayer()
              return res
            }

            val cBindingDec = fn.decorators.find(dec => dec.label.name == "CBinding")
            if cBindingDec |dec| {
              val res = self._invokeCBindingFn(dec, fn, arguments)
              self._resolvedGenerics.popLayer()
              return res
            }

            if fn.isClosure() {
              val capturesArr = try self._getCapturesArrForClosure(fn)
              closureEnvCtx = Some((capturesArr, false))
            }

            val paramsNeedingDefaultValue = arguments.map((arg, idx) => {
              if fn.params[idx] |param| { !!param.defaultValue && !arg } else { false }
            })
            val fnVal = match fn.kind {
              FunctionKind.StaticMethod(parentTy) => {
                try self._getOrCompileMethod(Type(kind: TypeKind.Type(parentTy)), fn, paramsNeedingDefaultValue)
              }
              FunctionKind.Standalone => {
                try self._getOrCompileFunction(fn, paramsNeedingDefaultValue)
              }
              FunctionKind.InstanceMethod => unreachable("instance methods handled in the following block")
            }

            self._resolvedGenerics.popLayer()

            val frameCtx = CallframeContext(position: node.token.position, callee: Some(self._functionName(fn.label.name, fn.kind)))
            (Callable.Function(fnVal), Some(frameCtx))
          }
          TypedInvokee.Method(fn, selfExpr, isOptSafe) => {
            var selfInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(selfExpr.ty, fn.label.name, node.token.position, resolvedGenerics)

            val intrinsicDec = fn.decorators.find(dec => dec.label.name == "Intrinsic")
            if intrinsicDec |dec| {
              if isOptSafe unreachable("cannot have opt-safe intrinsic method calls")
              val res = self._invokeIntrinsicFn(dec, fn, [Some(selfExpr)].concat(arguments))
              self._resolvedGenerics.popLayer()
              return res
            }

            if fn.isClosure() {
              val capturesArr = try self._getCapturesArrForClosure(fn)
              closureEnvCtx = Some((capturesArr, false))
            }

            val selfVal = if isOptSafe {
              val innerTy = if self._typeIsOption(selfInstanceType) |innerTy| innerTy else unreachable("an opt-safe invocation needs to have an Option type as its lhs")
              selfInstanceType = innerTy

              val selfVal = try self._compileExpression(selfExpr)
              val variantIsOptionSome = try self._emitOptValueIsSomeVariant(selfVal)

              val labelIsSome = self._currentFn.block.addLabel("optsafe_call_is_some")
              val labelIsNone = self._currentFn.block.addLabel("optsafe_call_is_none")
              val labelCont = self._currentFn.block.addLabel("optsafe_call_cont")

              self._currentFn.block.addComment("begin opt-safe call...")
              self._currentFn.block.buildJnz(variantIsOptionSome, labelIsSome, labelIsNone)

              self._currentFn.block.registerLabel(labelIsNone)
              val noneRes = if fn.returnType.kind != TypeKind.PrimitiveUnit {
                val optNoneVariant = if self._project.preludeOptionEnum.variants.find(v => v.label.name == "None") |v| v else unreachable("Option.None must exist")
                val noneRes = try self._getOrCompileEnumVariantConst(self._project.preludeOptionEnum, optNoneVariant)
                Some(noneRes)
              } else None
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelIsSome)
              val optSomeVariant = if self._project.preludeOptionEnum.variants.find(v => v.label.name == "Some") |v| v else unreachable("Option.Some must exist")
              match self._resolvedGenerics.addLayer("Option.Some", { "V": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "Option.Some", message: e))) }
              val someVariantFn = try self._getOrCompileEnumVariantFn(self._project.preludeOptionEnum, optSomeVariant)
              self._resolvedGenerics.popLayer()

              optSafeCtx = Some((labelIsNone, noneRes, someVariantFn, labelCont))

              val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
              try self._emitOptValueGetValue(innerQbeType, selfVal)
            } else {
              try self._compileExpression(selfExpr)
            }

            val paramsNeedingDefaultValue = arguments.map((arg, idx) => {
              if fn.params[idx] |param| { !!param.defaultValue && !arg } else { false }
            })
            val fnVal = try self._getOrCompileMethod(selfInstanceType, fn, paramsNeedingDefaultValue)
            args.push(selfVal)

            self._resolvedGenerics.popLayer()

            val frameCtx = CallframeContext(position: node.token.position, callee: Some(self._functionName(fn.label.name, fn.kind)))
            (Callable.Function(fnVal), Some(frameCtx))
          }
          TypedInvokee.Struct(struct) => {
            match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }

            val fieldsNeedingDefaultValue = arguments.map((arg, idx) => {
              if struct.fields[idx] |field| { !!field.initializer && !arg } else { false }
            })
            val fnVal = try self._getOrCompileStructInitializer(struct, fieldsNeedingDefaultValue)

            self._resolvedGenerics.popLayer()

            val hasOptionalField = struct.fields.any(f => !!f.initializer)
            val frameCtx = if hasOptionalField {
              Some(CallframeContext(position: node.token.position, callee: Some(struct.label.name)))
            } else {
              None
            }
            (Callable.Function(fnVal), frameCtx)
          }
          TypedInvokee.EnumVariant(enum_, variant) => {
            match self._resolvedGenerics.addLayer(variant.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: variant.label.name, message: e))) }

            match variant.kind {
              EnumVariantKind.Container(fields) => {
                val fieldsNeedingDefaultValue = arguments.map((arg, idx) => {
                  if fields[idx] |field| { !!field.initializer && !arg } else { false }
                })
                val enumVariantFn = try self._getOrCompileEnumVariantFn(enum_, variant, fieldsNeedingDefaultValue)
                self._resolvedGenerics.popLayer()

                val hasOptionalField = fields.any(f => !!f.initializer)
                val frameCtx = if hasOptionalField {
                  Some(CallframeContext(position: node.token.position, callee: Some("${enum_.label.name}.${variant.label.name}")))
                } else {
                  None
                }
                (Callable.Function(enumVariantFn), frameCtx)
              }
              _ => unreachable("cannot invoke constant enum variant ${enum_.label.name}.${variant.label.name}")
            }
          }
          TypedInvokee.Expr(expr) => {
            val fnObj = try self._compileExpression(expr)
            val envPtr = self._currentFn.block.buildLoadL(fnObj)
            closureEnvCtx = Some((envPtr, true))

            val selfPtrSlot = try self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size() * 2), fnObj) else |e| return qbeError(e)
            val selfPtr = self._currentFn.block.buildLoadL(selfPtrSlot)
            closureSelfCtx = Some(selfPtr)

            val fnValPtrSlot = try self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size()), fnObj) else |e| return qbeError(e)
            val fnValPtr = self._currentFn.block.buildLoadL(fnValPtrSlot)

            val retTypeQbe = if node.ty.kind == TypeKind.PrimitiveUnit {
              None
            } else {
              val ty = try self._getQbeTypeForTypeExpect(node.ty, "unacceptable return type", None)
              Some(ty)
            }
            (Callable.Value(fnValPtr, retTypeQbe), Some(CallframeContext(position: node.token.position, callee: None)))
          }
        }

        for arg, idx in arguments {
          if arg |node| {
            args.push(try self._compileExpression(node))
          }
        }

        // TODO: yikes...
        var res = if fnVal.returnType() {
          if closureEnvCtx |(closureEnvPtr, needsNullCheck)| {
            if needsNullCheck {
              val labelCallWithEnv = self._currentFn.block.addLabel("call_fn_val_with_env")
              val labelCallWithoutEnv = self._currentFn.block.addLabel("call_fn_val_without_env")
              val labelCont = self._currentFn.block.addLabel("call_fn_val_cont")

              self._currentFn.block.buildJnz(closureEnvPtr, labelCallWithEnv, labelCallWithoutEnv)

              self._currentFn.block.registerLabel(labelCallWithEnv)
              val resWithEnv = if closureSelfCtx |selfVal| {
                val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_with_env_with_self")
                val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_with_env_without_self")
                val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_with_env")

                self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

                self._currentFn.block.registerLabel(labelCallWithSelf)
                val resWithSelf = try self._buildCall(frameCtx, fnVal, [selfVal].concat(args), resultLocalName, Some(closureEnvPtr))
                val resWithSelfLabel = self._currentFn.block.currentLabel
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCallWithoutSelf)
                val resWithoutSelf = try self._buildCall(frameCtx, fnVal, args, resultLocalName, Some(closureEnvPtr))
                val resWithoutSelfLabel = self._currentFn.block.currentLabel
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCont)

                val phiCases = [(resWithSelfLabel, resWithSelf), (resWithoutSelfLabel, resWithoutSelf)]
                try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)
              } else {
                try self._buildCall(frameCtx, fnVal, args, resultLocalName, Some(closureEnvPtr))
              }
              val resWithEnvLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCallWithoutEnv)
              val resWithoutEnv = if closureSelfCtx |selfVal| {
                val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_without_env_with_self")
                val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_without_env_without_self")
                val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_without_env")

                self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

                self._currentFn.block.registerLabel(labelCallWithSelf)
                val resWithSelf = try self._buildCall(frameCtx, fnVal, [selfVal].concat(args), resultLocalName)
                val resWithSelfLabel = self._currentFn.block.currentLabel
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCallWithoutSelf)
                val resWithoutSelf = try self._buildCall(frameCtx, fnVal, args, resultLocalName)
                val resWithoutSelfLabel = self._currentFn.block.currentLabel
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCont)

                val phiCases = [(resWithSelfLabel, resWithSelf), (resWithoutSelfLabel, resWithoutSelf)]
                try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)
              } else {
                try self._buildCall(frameCtx, fnVal, args, resultLocalName)
              }
              val resWithoutEnvLabel = self._currentFn.block.currentLabel
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)

              val phiCases = [(resWithEnvLabel, resWithEnv), (resWithoutEnvLabel, resWithoutEnv)]

              try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)
            } else {
              try self._buildCall(frameCtx, fnVal, args, resultLocalName, Some(closureEnvPtr))
            }
          } else {
            try self._buildCall(frameCtx, fnVal, args, resultLocalName)
          }
        } else {
          if closureEnvCtx |(closureEnvPtr, needsNullCheck)| {
            if needsNullCheck {
              val labelCallWithEnv = self._currentFn.block.addLabel("call_fn_val_with_env")
              val labelCallWithoutEnv = self._currentFn.block.addLabel("call_fn_val_without_env")
              val labelCont = self._currentFn.block.addLabel("call_fn_val_cont")

              self._currentFn.block.buildJnz(closureEnvPtr, labelCallWithEnv, labelCallWithoutEnv)

              self._currentFn.block.registerLabel(labelCallWithEnv)
              if closureSelfCtx |selfVal| {
                val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_with_env_with_self")
                val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_with_env_without_self")
                val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_with_env")

                self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

                self._currentFn.block.registerLabel(labelCallWithSelf)
                try self._buildVoidCall(frameCtx, fnVal, [selfVal].concat(args), Some(closureEnvPtr))
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCallWithoutSelf)
                try self._buildVoidCall(frameCtx, fnVal, args, Some(closureEnvPtr))
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCont)
              } else {
                try self._buildVoidCall(frameCtx, fnVal, args, Some(closureEnvPtr))
              }
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCallWithoutEnv)
              if closureSelfCtx |selfVal| {
                val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_without_env_with_self")
                val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_without_env_without_self")
                val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_without_env")

                self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

                self._currentFn.block.registerLabel(labelCallWithSelf)
                try self._buildVoidCall(frameCtx, fnVal, [selfVal].concat(args))
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCallWithoutSelf)
                try self._buildVoidCall(frameCtx, fnVal, args)
                self._currentFn.block.buildJmp(labelCont)

                self._currentFn.block.registerLabel(labelCont)
              } else {
                try self._buildVoidCall(frameCtx, fnVal, args, Some(closureEnvPtr))
              }
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)
            } else {
              try self._buildVoidCall(frameCtx, fnVal, args, Some(closureEnvPtr))
            }
          } else {
            if closureSelfCtx |selfVal| {
              val labelCallWithSelf = self._currentFn.block.addLabel("call_fn_val_with_env_with_self")
              val labelCallWithoutSelf = self._currentFn.block.addLabel("call_fn_val_with_env_without_self")
              val labelCont = self._currentFn.block.addLabel("call_fn_val_cont_with_env")

              self._currentFn.block.buildJnz(selfVal, labelCallWithSelf, labelCallWithoutSelf)

              self._currentFn.block.registerLabel(labelCallWithSelf)
              try self._buildVoidCall(frameCtx, fnVal, [selfVal].concat(args))
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCallWithoutSelf)
              try self._buildVoidCall(frameCtx, fnVal, args)
              self._currentFn.block.buildJmp(labelCont)

              self._currentFn.block.registerLabel(labelCont)
            } else {
              try self._buildVoidCall(frameCtx, fnVal, args)
            }
          }

          Value.Ident("bogus", QbeType.F32)
        }

        if optSafeCtx |(labelIsNone, noneRes, someVariantFn, labelCont)| {
          val labelIsSome = if noneRes |noneRes| {
            val labelIsSome = self._currentFn.block.currentLabel
            // Do not track Option.Some in callframes
            val someRes = try self._buildCall(None, Callable.Function(someVariantFn), [res])
            Some((labelIsSome, someRes, noneRes))
          } else None
          self._currentFn.block.buildJmp(labelCont)

          self._currentFn.block.addComment("...opt-safe call end")
          self._currentFn.block.registerLabel(labelCont)

          if labelIsSome |(labelIsSome, someRes, noneRes)| {
            val phiCases = [(labelIsNone, noneRes), (labelIsSome, someRes)]
            res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)
          }
        }

        if node.ty.kind == TypeKind.Never {
          self._currentFn.block.buildHalt()
        }

        Ok(res)
      }
      TypedAstNodeKind.Array(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val inner = if generics[0] |t| t else unreachable("Array has 1 required type argument")
            match self._resolvedGenerics.addLayer("array literal", { "T": inner }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "array literal", message: e))) }
          }
          _ => unreachable("we know it's an array instance here")
        }

        val arrayWithCapacityFn = if self._project.preludeArrayStruct.staticMethods.find(m => m.label.name == "withCapacity") |fn| fn else unreachable("Array.withCapacity must exist")
        val arrayWithCapacityFnVal = try self._getOrCompileMethod(node.ty, arrayWithCapacityFn)

        val sizeVal = Value.Int(items.length.nextPowerOf2())
        // Do not track Array.withCapacity in callframes
        val arrayInstance = try self._buildCall(None, Callable.Function(arrayWithCapacityFnVal), [sizeVal], resultLocalName)
        self._currentFn.block.addCommentBefore("${arrayInstance.repr()}: ${node.ty.repr()}")

        val arrayPushFn = if self._project.preludeArrayStruct.instanceMethods.find(m => m.label.name == "push") |fn| fn else unreachable("Array#push must exist")
        val arrayPushFnVal = try self._getOrCompileMethod(node.ty, arrayPushFn)

        for item in items {
          val itemVal = try self._compileExpression(item)
          // Do not track Array#push in callframes
          try self._buildVoidCall(None, Callable.Function(arrayPushFnVal), [arrayInstance, itemVal])
        }

        self._resolvedGenerics.popLayer()

        Ok(arrayInstance)
      }
      TypedAstNodeKind.Set(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val inner = if generics[0] |t| t else unreachable("Set has 1 required type argument")
            match self._resolvedGenerics.addLayer("set literal", { "T": inner }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "set literal", message: e))) }
          }
          _ => unreachable("we know it's a set instance here")
        }

        val setNewFn = if self._project.preludeSetStruct.staticMethods.find(m => m.label.name == "new") |fn| fn else unreachable("Set.new must exist")
        val setNewFnVal = try self._getOrCompileMethod(node.ty, setNewFn, [true])

        // Do not track Set.new in callframes
        val setInstance = try self._buildCall(None, Callable.Function(setNewFnVal), [], resultLocalName)
        self._currentFn.block.addCommentBefore("${setInstance.repr()}: ${node.ty.repr()}")

        val setInsertFn = if self._project.preludeSetStruct.instanceMethods.find(m => m.label.name == "insert") |fn| fn else unreachable("Set#insert must exist")
        val setInsertFnVal = try self._getOrCompileMethod(node.ty, setInsertFn)

        for item in items {
          val itemVal = try self._compileExpression(item)
          // Do not track Set#insert in callframes
          try self._buildVoidCall(None, Callable.Function(setInsertFnVal), [setInstance, itemVal])
        }

        self._resolvedGenerics.popLayer()

        Ok(setInstance)
      }
      TypedAstNodeKind.Map(items) => {
        match node.ty.kind {
          TypeKind.Instance(_, generics) => {
            val key = if generics[0] |t| t else unreachable("Map has 2 required type arguments")
            val value = if generics[1] |t| t else unreachable("Map has 2 required type arguments")
            match self._resolvedGenerics.addLayer("map literal", { "K": key, "V": value }) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: "map literal", message: e))) }
          }
          _ => unreachable("we know it's a map instance here")
        }

        val mapNewFn = if self._project.preludeMapStruct.staticMethods.find(m => m.label.name == "new") |fn| fn else unreachable("Map.new must exist")
        val mapNewFnVal = try self._getOrCompileMethod(node.ty, mapNewFn, [true])

        val fnName = self._functionName(mapNewFn.label.name, mapNewFn.kind)
        // Do not track Map.new in callframes
        val mapInstance = try self._buildCall(None, Callable.Function(mapNewFnVal), [], resultLocalName)
        self._currentFn.block.addCommentBefore("${mapInstance.repr()}: ${node.ty.repr()}")

        val mapInsertFn = if self._project.preludeMapStruct.instanceMethods.find(m => m.label.name == "insert") |fn| fn else unreachable("Map#insert must exist")
        val mapInsertFnVal = try self._getOrCompileMethod(node.ty, mapInsertFn)

        for (keyExpr, valExpr) in items {
          val keyVal = try self._compileExpression(keyExpr)
          val valueVal = try self._compileExpression(valExpr)
          // Do not track Map#insert in callframes
          try self._buildCall(None, Callable.Function(mapInsertFnVal), [mapInstance, keyVal, valueVal])
        }

        self._resolvedGenerics.popLayer()

        Ok(mapInstance)
      }
      TypedAstNodeKind.Tuple(items) => {
        val tupleStruct = self._tupleStruct(items.length)
        val selfType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(tupleStruct), items.map(node => node.ty)))

        val resolvedGenerics: Map<String, Type> = {}
        val template = Type(kind: TypeKind.Instance(StructOrEnum.Struct(tupleStruct), tupleStruct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        for (name, ty) in selfType.extractGenerics(template) {
          resolvedGenerics[name] = ty
        }
        match self._resolvedGenerics.addLayer(tupleStruct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: tupleStruct.label.name, message: e))) }
        val fnVal = try self._getOrCompileStructInitializer(tupleStruct)

        self._resolvedGenerics.popLayer()

        val itemVals: Value[] = []
        for item in items {
          val itemVal = try self._compileExpression(item)
          itemVals.push(itemVal)
        }

        // Do not track Tuple.init in callframes
        self._buildCall(None, Callable.Function(fnVal), itemVals)
      }
      TypedAstNodeKind.Indexing(indexingNode) => {
        match indexingNode {
          TypedIndexingNode.ArrayLike(expr, indexingMode) => {
            val exprVal = try self._compileExpression(expr)

            match indexingMode {
              IndexingMode.Single(idxExpr) => {
                val idxExprVal = try self._compileExpression(idxExpr)

                val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "get", expr.token.position)
                val (structOrEnum, _) = try self._getInstanceTypeForType(expr.ty)
                val getFn = match structOrEnum {
                  StructOrEnum.Struct(struct) => if struct.instanceMethods.find(m => m.label.name == "get") |fn| fn else unreachable("#get must exist for array-like indexing")
                  StructOrEnum.Enum => unreachable("array-like indexing never applies to enum instances")
                }
                val getFnVal = try self._getOrCompileMethod(instType, getFn)
                self._resolvedGenerics.popLayer()

                // Do not track Array#get in callframes
                self._buildCall(None, Callable.Function(getFnVal), [exprVal, idxExprVal])
              }
              IndexingMode.Range(startExpr, endExpr) => {
                val params = [exprVal]
                val paramsNeedingDefaultValue: Bool[] = []
                if startExpr |startExpr| {
                  paramsNeedingDefaultValue.push(false)
                  params.push(try self._compileExpression(startExpr))
                } else {
                  paramsNeedingDefaultValue.push(true)
                }
                if endExpr |endExpr| {
                  paramsNeedingDefaultValue.push(false)
                  params.push(try self._compileExpression(endExpr))
                } else {
                  paramsNeedingDefaultValue.push(true)
                }

                val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "getRange", expr.token.position)
                val (structOrEnum, _) = try self._getInstanceTypeForType(expr.ty)
                val getRangeFn = match structOrEnum {
                  StructOrEnum.Struct(struct) => if struct.instanceMethods.find(m => m.label.name == "getRange") |fn| fn else unreachable("#getRange must exist for array-like indexing")
                  StructOrEnum.Enum => unreachable("array-like indexing never applies to enum instances")
                }
                val getRangeFnVal = try self._getOrCompileMethod(instType, getRangeFn, paramsNeedingDefaultValue)
                self._resolvedGenerics.popLayer()

                // Do not track Array#getRange in callframes
                self._buildCall(None, Callable.Function(getRangeFnVal), params)
              }
            }
          }
          TypedIndexingNode.Map(expr, idxExpr) => {
            val exprVal = try self._compileExpression(expr)
            val idxExprVal = try self._compileExpression(idxExpr)

            val instType = try self._addResolvedGenericsLayerForInstanceMethod(expr.ty, "get", expr.token.position)
            val (structOrEnum, _) = try self._getInstanceTypeForType(expr.ty)
            val struct = match structOrEnum {
              StructOrEnum.Struct(struct) => struct
              StructOrEnum.Enum => unreachable("map indexing never applies to enum instances")
            }
            if struct != self._project.preludeMapStruct unreachable("map indexing only implemented for map")

            val getFn = if self._project.preludeMapStruct.instanceMethods.find(m => m.label.name == "get") |fn| fn else unreachable("Map#get must exist")
            val getFnVal = try self._getOrCompileMethod(instType, getFn)
            self._resolvedGenerics.popLayer()

            // Do not track Map#get in callframes
            self._buildCall(None, Callable.Function(getFnVal), [exprVal, idxExprVal])
          }
          TypedIndexingNode.Tuple(tupleExpr, idx) => {
            val exprVal = try self._compileExpression(tupleExpr)

            val (structOrEnum, typeArgs) = try self._getInstanceTypeForType(tupleExpr.ty)
            val struct = match structOrEnum {
              StructOrEnum.Struct(struct) => struct
              StructOrEnum.Enum => unreachable("tuples are represented as structs")
            }

            val selfType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs))

            val resolvedGenerics: Map<String, Type> = {}
            val template = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
            for (name, ty) in selfType.extractGenerics(template) {
              resolvedGenerics[name] = ty
            }
            match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: node.token.position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }

            var offset = 0
            for f, fieldIdx in struct.fields {
              if fieldIdx == idx break

              val fieldTy = try self._getQbeTypeForTypeExpect(f.ty, "unacceptable type for field", Some(f.name.position))
              offset += fieldTy.size()
            }

            self._resolvedGenerics.popLayer()

            val ptr = try self._currentFn.block.buildAdd(Value.Int(offset), exprVal) else |e| return qbeError(e)
            val res = self._currentFn.block.buildLoadL(ptr)
            self._currentFn.block.addCommentBefore("${res.repr()}: ${exprVal.repr()}.$idx")
            Ok(res)
          }
        }
      }
      TypedAstNodeKind.Lambda(fn, typeHint) => {
        val targetParamTypes = if typeHint |hint| {
          val paramTypes = match hint.kind {
            TypeKind.Func(paramTypes, _) => Some(paramTypes)
            TypeKind.Any => None // if the function value is being treated as an Any, then no param type info needs to be known later anyway
            _ => unreachable("typeKind must be TypeKind.Func")
          }
          paramTypes
        } else {
          None
        }

        val capturesMem = if !fn.isClosure() None else {
          val mem = try self._createClosureCaptures(fn)
          Some(mem)
        }

        self._compileFunctionValue(node.token.position, fn, targetParamTypes, capturesMem, None)
      }
      TypedAstNodeKind.If(isStatement, cond, conditionBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if isStatement unreachable("if-statements are handled elsewhere")
        if elseBlock.isEmpty() unreachable("if-expressions must not have empty else-blocks")

        val labelThen = self._currentFn.block.addLabel("then")
        val labelElse = self._currentFn.block.addLabel("else")
        val labelCont = self._currentFn.block.addLabel("cont")

        val condVal = try self._compileExpression(cond)
        val condExprIsOpt = self._typeIsOption(cond.ty)
        if condExprIsOpt {
          val variantIsOptionSome = try self._emitOptValueIsSomeVariant(condVal)
          self._currentFn.block.buildJnz(variantIsOptionSome, labelThen, labelElse)
        } else {
          self._currentFn.block.buildJnz(condVal, labelThen, labelElse)
        }

        val phiCases: (Label, Value)[] = []

        self._currentFn.block.registerLabel(labelThen)
        if conditionBinding |(bindingPattern, vars)| {
          val variables = vars.keyBy(v => v.label.name)

          val bindingVal = if condExprIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            val optInnerValue = try self._emitOptValueGetValue(innerQbeType, condVal)
            optInnerValue
          } else {
            Value.Int(1)
          }
          try self._compileBindingPattern(bindingPattern, variables, Some(bindingVal))
        }
        for node, idx in ifBlock {
          val res = try self._compileStatement(node)
          if idx == ifBlock.length - 1 {
            if !ifBlockTerminator {
              if res |res| {
                val label = self._currentFn.block.currentLabel
                phiCases.push((label, res))
              } else {
                unreachable("last statement in if-expr block has no value and is not a terminator")
              }
            }
          }
        }
        if !ifBlockTerminator {
          self._currentFn.block.buildJmp(labelCont)
        }

        if !elseBlock.isEmpty() {
          self._currentFn.block.registerLabel(labelElse)
          for node, idx in elseBlock {
            val res = try self._compileStatement(node)
            if idx == elseBlock.length - 1 {
              if !elseBlockTerminator {
                if res |res| {
                  val label = self._currentFn.block.currentLabel
                  phiCases.push((label, res))
                } else {
                  unreachable("last statement in if-expr else block has no value and is not a terminator")
                }
              }
            }
          }
          if !elseBlockTerminator {
            self._currentFn.block.buildJmp(labelCont)
          }
        }

        self._currentFn.block.registerLabel(labelCont)

        if !phiCases.isEmpty() {
          val res = try self._currentFn.block.buildPhi(phiCases, resultLocalName) else |e| return qbeError(e)
          Ok(res)
        } else {
          self._currentFn.block.buildHalt()
          Ok(Value.Ident("bogus", QbeType.F32))
        }
      }
      TypedAstNodeKind.Match(isStatement, expr, cases) => {
        val res = try self._compileMatch(node, isStatement, expr, cases)
        if res |res| Ok(res) else unreachable("match expression needs a resulting value")
      }
      TypedAstNodeKind.Try(expr, elseClause) => {
        val exprVal = try self._compileExpression(expr)
        val isErr = try self._emitResultValueIsOkVariant(exprVal, negate: true)

        val labelIsErr = self._currentFn.block.addLabel("isErr")
        val labelCont = self._currentFn.block.addLabel("cont")

        if elseClause |clause| {
          val phiCases: (Label, Value)[] = []

          val labelIsOk = self._currentFn.block.addLabel("isOk")
          self._currentFn.block.buildJnz(isErr, labelIsErr, labelIsOk)

          self._currentFn.block.registerLabel(labelIsErr)
          if clause.pattern |(bindingPattern, vars)| {
            val variables = vars.keyBy(v => v.label.name)

            val errorQbeType = try self._getQbeTypeForTypeExpect(clause.errorType, "unacceptable type", None)
            val bindingVal = try self._emitOptValueGetValue(errorQbeType, exprVal)
            try self._compileBindingPattern(bindingPattern, variables, Some(bindingVal))
          }
          for node, idx in clause.block {
            val res = try self._compileStatement(node)
            if idx == clause.block.length - 1 {
              if res |res| {
                val label = self._currentFn.block.currentLabel
                phiCases.push((label, res))
              } else if !clause.terminator {
                unreachable("last statement in try-else block has no value and is not a terminator")
              }
            }
          }
          if !clause.terminator {
            self._currentFn.block.buildJmp(labelCont)
          }

          self._currentFn.block.registerLabel(labelIsOk)
          val okQbeType = try self._getQbeTypeForTypeExpect(node.ty, "unacceptable type", None)
          val okVal = try self._emitOptValueGetValue(okQbeType, exprVal)
          val label = self._currentFn.block.currentLabel
          phiCases.push((label, okVal))
          self._currentFn.block.buildJmp(labelCont)

          self._currentFn.block.registerLabel(labelCont)
          val res = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)
          Ok(res)
        } else {
          self._currentFn.block.buildJnz(isErr, labelIsErr, labelCont)

          self._currentFn.block.registerLabel(labelIsErr)
          self._currentFn.block.buildReturn(Some(exprVal))

          self._currentFn.block.registerLabel(labelCont)
          val okValTy = try self._getQbeTypeForTypeExpect(node.ty, "unacceptable type", None)
          val okValue = try self._emitResultValueGetValue(okValTy, exprVal)

          Ok(okValue)
        }
      }
      _ => unreachable("node must be a statement")
    }

    self._currentNode = prevNode

    res
  }

  func _compileLiteral(self, lit: LiteralAstNode): Result<(Value, Type), CompileError> {
    Ok(match lit {
      LiteralAstNode.Int(v) => (Value.Int(v), Type(kind: TypeKind.PrimitiveInt))
      LiteralAstNode.Float(f) => (Value.Float(f), Type(kind: TypeKind.PrimitiveFloat))
      LiteralAstNode.Bool(b) => (Value.Int(if b 1 else 0), Type(kind: TypeKind.PrimitiveBool))
      LiteralAstNode.String(s) => {
        val dataPtr = self._builder.buildGlobalString(s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"").replaceAll("\n", "\\n").replaceAll("\r", "\\r"))
        val instancePtr = try self._constructString(dataPtr, Value.Int(s.length))
        (instancePtr, Type(kind: TypeKind.PrimitiveString))
      }
    })
  }

  func _compileMatch(self, node: TypedAstNode, isStatement: Bool, expr: TypedAstNode, cases: TypedMatchCase[]): Result<Value?, CompileError> {
    val exprVal = try self._compileExpression(expr)

    val matchLabelPrefix = "match_${node.token.position.line}_${node.token.position.col}"
    val endLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_end")
    var seenNoneCase = false
    val exprTypeIsOpt = self._typeIsOption(expr.ty)

    val resValSlotCtx = if !isStatement {
      val slotName = "${matchLabelPrefix}_result.slot"
      val nodeTypeQbe = try self._getQbeTypeForTypeExpect(node.ty, "qbe type should exist", Some(node.token.position))
      val slot = self._buildStackAllocForQbeType(nodeTypeQbe, Some(slotName))
      Some((slot, nodeTypeQbe))
    } else None

    for case, idx in cases {
      val (nextCaseLabel, exprVal, exprType) = match case.kind {
        TypedMatchCaseKind.Literal(lit) => {
          val nextCaseLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__next")

          val (exprVal, exprType) = if exprTypeIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            if seenNoneCase {
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)
              (optInnerValue, innerTy)
            } else {
              val isSomeCond = try self._emitOptValueIsSomeVariant(exprVal)
              val isSomeLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__issome")
              self._currentFn.block.buildJnz(isSomeCond, isSomeLabel, nextCaseLabel)
              self._currentFn.block.registerLabel(isSomeLabel)
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)
              (optInnerValue, innerTy)
            }
          } else {
            (exprVal, expr.ty)
          }

          val (litVal, litType) = try self._compileLiteral(lit)

          if !self._project.typesAreEquivalent(exprType, litType) unreachable("equality operators require matching types")

          val cond = try self._compileEqLogic(exprVal, litVal, litType, expr.token.position)
          val isEqLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_iseq")

          self._currentFn.block.buildJnz(cond, isEqLabel, nextCaseLabel)
          self._currentFn.block.registerLabel(isEqLabel)

          (Some(nextCaseLabel), exprVal, exprType)
        }
        TypedMatchCaseKind.None_ => {
          seenNoneCase = true

          val isNoneCond = try self._emitOptValueIsSomeVariant(exprVal: exprVal, negate: true)
          val isNoneLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_isnone")
          val nextCaseLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_next_$idx")

          self._currentFn.block.buildJnz(isNoneCond, isNoneLabel, nextCaseLabel)
          self._currentFn.block.registerLabel(isNoneLabel)

          (Some(nextCaseLabel), exprVal, expr.ty)
        }
        TypedMatchCaseKind.EnumVariant(enum_, variant, variantIdx, destructuredVariables) => {
          val nextCaseLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__next")
          val (exprVal, exprType) = if exprTypeIsOpt |innerTy| {
            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            if seenNoneCase {
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)
              (optInnerValue, innerTy)
            } else {
              val isSomeCond = try self._emitOptValueIsSomeVariant(exprVal)
              val isSomeLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_case_${idx}__issome")
              self._currentFn.block.buildJnz(isSomeCond, isSomeLabel, nextCaseLabel)
              self._currentFn.block.registerLabel(isSomeLabel)
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)
              (optInnerValue, innerTy)
            }
          } else {
            (exprVal, expr.ty)
          }

          val exprValVariantIdxVal = self._emitGetEnumVariantIdx(exprVal)
          val cond = try self._currentFn.block.buildCompareEq(exprValVariantIdxVal, Value.Int(variantIdx)) else |e| return qbeError(e)
          val isVariantLabel = self._currentFn.block.addLabel("${matchLabelPrefix}_is${variant.label.name}")

          self._currentFn.block.buildJnz(cond, isVariantLabel, nextCaseLabel)
          self._currentFn.block.registerLabel(isVariantLabel)

          if !destructuredVariables.isEmpty() {
            try self._addResolvedGenericsLayerForEnumVariant(exprType, variant.label.name, node.token.position)
            val variantFields = match variant.kind {
              EnumVariantKind.Container(fields) => fields
              _ => unreachable("cannot destructure a non-container enum variant")
            }

            var memCursor = try self._emitGetEnumVariantValueStart(exprVal)
            for v, idx in destructuredVariables {
              val field = if variantFields[idx] |f| f else unreachable("this should be caught during typechecking")
              val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))

              val fieldVal = self._currentFn.block.buildLoad(fieldTy, memCursor)
              val slotName = self._currentFn.block.addVar(variableToVar(v))
              val slot = self._buildStackAllocForQbeType(fieldTy, Some(slotName))
              self._currentFn.block.buildStore(fieldTy, fieldVal, slot)

              if idx != destructuredVariables.length - 1 {
                val offset = fieldTy.size()
                memCursor = try self._currentFn.block.buildAdd(Value.Int(offset), memCursor) else |e| return qbeError(e)
              }
            }

            self._resolvedGenerics.popLayer()
          }

          (Some(nextCaseLabel), exprVal, exprType)
        }
        TypedMatchCaseKind.Else => {
          val (exprVal, exprType) = if exprTypeIsOpt |innerTy| {
            if seenNoneCase {
              val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
              val optInnerValue = try self._emitOptValueGetValue(innerQbeType, exprVal)

              (optInnerValue, innerTy)
            } else {
              (exprVal, expr.ty)
            }
          } else (exprVal, expr.ty)

          // No nextCaseLabel, since the `else` case will always be the last case if present
          (None, exprVal, exprType)
        }
        _ => todo("other match case types")
      }

      if case.binding |v| {
        val slotName = self._currentFn.block.addVar(variableToVar(v))
        val bindingTypeQbe = try self._getQbeTypeForTypeExpect(exprType, "qbe type should exist", Some(v.label.position))
        val slot = self._buildStackAllocForQbeType(bindingTypeQbe, Some(slotName))
        self._currentFn.block.buildStore(bindingTypeQbe, exprVal, slot)
      }

      for node, idx in case.body {
        val res = try self._compileStatement(node)
        if idx == case.body.length - 1 {
          if resValSlotCtx |(slot, slotTy)| {
            if !case.terminator {
              if res |res| {
                self._currentFn.block.buildStore(slotTy, res, slot)
              }
            }
          }
        }
      }
      if !case.terminator {
        self._currentFn.block.buildJmp(endLabel)
      }

      if nextCaseLabel |nextCaseLabel| {
        self._currentFn.block.registerLabel(nextCaseLabel)
      }
    }

    self._currentFn.block.registerLabel(endLabel)

    val result = if resValSlotCtx |(slot, slotTy)| {
      val res = self._currentFn.block.buildLoad(slotTy, slot)
      Some(res)
    } else {
      None
    }

    Ok(result)
  }

  func _compileBindingPattern(self, pattern: BindingPattern, variables: Map<String, Variable>, exprVal: Value?): Result<Int, CompileError> {
    val varName = match pattern {
      BindingPattern.Variable(label) => label.name
      BindingPattern.Tuple(_, patterns) => {
        val tuplePtr = if exprVal |v| v else return Ok(0)

        for pat, idx in patterns {
          val tupleItemSlot = try self._currentFn.block.buildAdd(Value.Int(idx * QbeType.Pointer.size()), tuplePtr) else |e| return qbeError(e)
          val tupleItemSlotTy = match pat {
            BindingPattern.Variable(label) => {
              val variable = if variables[label.name] |v| v else unreachable("expected binding '${label.name}', but missing from variables")
              val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
              varTy
            }
            _ => QbeType.Pointer
          }
          val tupleItemVal = self._currentFn.block.buildLoad(tupleItemSlotTy, tupleItemSlot)
          try self._compileBindingPattern(pat, variables, Some(tupleItemVal))
        }

        return Ok(0)
      }
    }

    val variable = if variables[varName] |v| v else unreachable("expected binding '$varName', but missing from variables")
    val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))

    val v = if exprVal |v| v else return Ok(0)

    // A top-level variable in a module is only hoisted to global if it's captured; otherwise it's effectively a local within the module wrapper function
    val isGlobal = !!variable.isGlobal()
    if variable.isExported || (variable.isCaptured && isGlobal) {
      val name = self._globalVarName(self._currentModule.id, variable.label.name)
      self._currentFn.block.addVar(variableToVar(variable))
      val (slot, _) = self._builder.addData(QbeData(name: name, kind: QbeDataKind.Constants([(varTy, varTy.zeroValue())])))
      self._currentFn.block.buildStore(varTy, v, slot)
      return Ok(0)
    }

    val slotName = self._currentFn.block.addVar(variableToVar(variable))
    if variable.isCaptured && variable.mutable && !isGlobal {
      // Only move captured variables to the heap if they're mutable - captured immutable variables can just have their value present in
      // a closure's captures array, but a mutable variable needs an additional layer of indirection to handle possible reassignment.
      self._currentFn.block.addComment("move captured mutable '${variable.label.name}' to heap")
      val size = varTy.size()
      val heapMem = try self._callMalloc(Value.Int(size), Some("${variable.label.name}.mem"))
      self._currentFn.block.buildStore(varTy, v, heapMem)

      val slot = self._buildStackAllocForQbeType(QbeType.Pointer, Some(slotName))
      self._currentFn.block.buildStore(QbeType.Pointer, heapMem, slot)
    } else {
      val slot = self._buildStackAllocForQbeType(varTy, Some(slotName))
      self._currentFn.block.buildStore(varTy, v, slot)
    }

    Ok(0)
  }

  func _getCapturedVarPtr(self, variable: Variable): Result<Value, CompileError> {
    if variable.isGlobal() unreachable("Global variables are never included in a function's captures")

    if self._currentFunction |fn| {
      if self._currentFn._env |env| {
        for v, idx in fn.captures {
          if v.label.name == variable.label.name {
            // When loading the captured variable from the closure env, if the captured variable is immutable then we
            // don't need to dereference the value of `env[idx]`; only mutable variables need to be stored using an
            // additional indirection layer to account for reassignment.
            val captureSlot = try self._currentFn.block.buildAdd(Value.Int(idx * QbeType.Pointer.size()), env) else |e| return qbeError(e)
            var varTy = if variable.mutable {
              self._currentFn.block.addComment("get ptr to captured mutable '${variable.label.name}'")
              QbeType.Pointer
            } else {
              self._currentFn.block.addComment("get captured '${variable.label.name}'")
              try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
            }
            val ptrOrValue = self._currentFn.block.buildLoad(varTy, captureSlot)
            return Ok(ptrOrValue)
          }
        }
      }
    }

    // If the captured variable is a parameter but we're not currently referencing it from a closure, then it can be resolved as any ordinary
    // parameter (simply by name) since it's an immutable variable that has not been moved to the heap.
    if variable.isParameter {
      val slotName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else unreachable("Could not resolve name for variable '${variable.label.name}'")
      val varTy = try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
      return Ok(Value.Ident(slotName, varTy))
    }

    // If we're not currently in a function body, or if the captured variable is not a capture of the current function, then
    // we may need to undo the extra layer of pointer indirection which comes as a result of being captured by some other function,
    // if the captured variable is mutable. If it's not mutable then it will not have been moved to the heap, so no additional pointer
    // needs to be dereferenced.
    val slotName = if self._currentFn.block.lookupVarName(variableToVar(variable)) |varName| varName else unreachable("Could not resolve name for variable '${variable.label.name}'")
    val slot = Value.Ident(slotName, QbeType.Pointer)
    var varTy = if variable.mutable {
      self._currentFn.block.addComment("get ptr to captured mutable '${variable.label.name}'")
      QbeType.Pointer
    } else {
      self._currentFn.block.addComment("get captured '${variable.label.name}'")
      try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
    }
    val ptrOrValue = self._currentFn.block.buildLoad(varTy, slot)
    Ok(ptrOrValue)
  }

  func _createClosureCaptures(self, fn: Function): Result<Value, CompileError> {
    val size = QbeType.Pointer.size() * (fn.captures.length + fn.capturedClosures.length)
    val capturesMem = try self._callMalloc(Value.Int(size), Some("${fn.label.name}_captures.mem"))
    var cursor = capturesMem

    for variable in fn.captures {
      val ptr = try self._getCapturedVarPtr(variable)
      var varTy = if variable.mutable {
        self._currentFn.block.addComment("store ptr to captured mutable '${variable.label.name}' in captures")
        QbeType.Pointer
      } else {
        self._currentFn.block.addComment("store captured '${variable.label.name}' in captures")
        try self._getQbeTypeForTypeExpect(variable.ty, "unacceptable type for variable", Some(variable.label.position))
      }
      self._currentFn.block.buildStore(varTy, ptr, cursor)
      if fn.captures.length > 1 || fn.capturedClosures.length > 0 {
        cursor = try self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size()), cursor) else |e| return qbeError(e)
      }
    }

    for capturedFn in fn.capturedClosures {
      val capturesArr = try self._getCapturesArrForClosure(capturedFn)
      self._currentFn.block.buildStore(QbeType.Pointer, capturesArr, cursor)
      if fn.capturedClosures.length > 1 {
        cursor = try self._currentFn.block.buildAdd(Value.Int(QbeType.Pointer.size()), cursor) else |e| return qbeError(e)
      }
    }

    Ok(capturesMem)
  }

  func _getCapturesArrForClosure(self, fn: Function): Result<Value, CompileError> {
    val fnInvocationIsAtDeclaredScope = if self._currentFunction |currentFunc| {
      fn.scope.parent == Some(currentFunc.scope)
    } else {
      true
    }

    val res = if !fnInvocationIsAtDeclaredScope {
      val currentFunc = if self._currentFunction |currentFn| currentFn else unreachable("we must be within a function to enter this case")

      val idx = if currentFunc.capturedClosures.findIndex(f => f.label.name == fn.label.name) |(_, idx)| idx else unreachable("closure '${fn.label.name}' called within function '${currentFunc.label.name}', but not tracked in its capturedClosures")
      val env = if self._currentFn._env |env| env else unreachable("expected currentFn ('${self._currentFn.name}') to have an `_env`, but it didn't")
      val offset = QbeType.Pointer.size() * (currentFunc.captures.length + idx)

      val ptr = try self._currentFn.block.buildAdd(Value.Int(offset), env) else |e| return qbeError(e)
      self._currentFn.block.buildLoadL(ptr)
    } else {
      // If the closure is being called in the same scope in which it was declared, then the `*.captures` value is visible as a stack local.
      val prefix = match fn.kind {
        FunctionKind.InstanceMethod(structOrEnum) => {
          if structOrEnum |structOrEnum| {
            val typeName = match structOrEnum {
              StructOrEnum.Struct(struct) => struct.label.name
              StructOrEnum.Enum(enum_) => enum_.label.name
            }
            "$typeName.."
          } else unreachable("an instance method should have a structOrEnum")
        }
        FunctionKind.StaticMethod(structOrEnum) => {
          val typeName = match structOrEnum {
            StructOrEnum.Struct(struct) => struct.label.name
            StructOrEnum.Enum(enum_) => enum_.label.name
          }
          "$typeName."
        }
        _ => ""
      }
      val capturesName = "$prefix${fn.label.name}.captures"
      self._currentFn.block.buildLoadL(Value.Ident(capturesName, QbeType.Pointer))
    }

    Ok(res)
  }

  func _compileBinaryOperands(self, left: TypedAstNode, right: TypedAstNode, op: String): Result<(Value, Value), CompileError> {
    var leftVal = try self._compileExpression(left)
    var rightVal = try self._compileExpression(right)

    if !self._project.typesAreEquivalent(left.ty, right.ty) {
      val leftIsFloat = self._typeIsFloat(left.ty)
      val rightIsFloat = self._typeIsFloat(right.ty)
      if leftIsFloat && !rightIsFloat {
        rightVal = self._currentFn.block.buildLToF(rightVal)
      } else if rightIsFloat && !leftIsFloat {
        leftVal = self._currentFn.block.buildLToF(leftVal)
      } else {
        unreachable("unknown operator '$op' between types '${left.ty.repr()}' and '${right.ty.repr()}'")
      }
    }

    Ok((leftVal, rightVal))
  }

  func _compileBinaryEq(self, left: TypedAstNode, right: TypedAstNode, localName: String? = None, negate = false): Result<Value, CompileError> {
    var leftVal = try self._compileExpression(left)
    var rightVal = try self._compileExpression(right)

    if !self._project.typesAreEquivalent(left.ty, right.ty) unreachable("equality operators require matching types")

    self._compileEqLogic(leftVal, rightVal, left.ty, left.token.position, localName, negate)
  }

  func _compileEqLogic(self, leftVal: Value, rightVal: Value, ty: Type, position: Position, localName: String? = None, negate = false): Result<Value, CompileError> {
    if self._typeIsInt(ty) || self._typeIsFloat(ty) || self._typeIsBool(ty) {
      val res = if negate {
        val res = try self._currentFn.block.buildCompareNeq(leftVal, rightVal, localName) else |e| return qbeError(e)
        self._currentFn.block.buildExt(res, false)
      } else {
        val res = try self._currentFn.block.buildCompareEq(leftVal, rightVal, localName) else |e| return qbeError(e)
        self._currentFn.block.buildExt(res, false)
      }
      return Ok(res)
    }

    val instType = try self._addResolvedGenericsLayerForInstanceMethod(ty, "eq", position)
    val eqFnVal = try self._getOrCompileEqMethod(instType)
    self._resolvedGenerics.popLayer()

    val fnName = self._functionName("eq", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(ty))[0])))
    val frameCtx = CallframeContext(position: position, callee: Some(fnName))
    val res = try self._buildCall(Some(frameCtx), Callable.Function(eqFnVal), [leftVal, rightVal], localName)
    if negate {
      val plusOneVal = try self._currentFn.block.buildAdd(Value.Int(1), res) else |e| return qbeError(e)
      val res = try self._currentFn.block.buildRem(plusOneVal, Value.Int(2)) else |e| return qbeError(e)
      Ok(res)
    } else {
      Ok(res)
    }
  }

  func _compileFunctionValue(
    self,
    position: Position,
    fn: Function,
    targetParamTypes: (Type, Bool)[]?,
    capturesPtr: Value?,
    capturedSelf: (Value, Type)?,
  ): Result<Value, CompileError> {
    val closureEnvPtr = capturesPtr ?: Value.Int(0)

    val (selfVal, selfType, selfTy) = if capturedSelf |(selfVal, selfType)| {
      val selfTy = try self._getQbeTypeForTypeExpect(selfType, "unacceptable type for param", Some(position))
      (selfVal, Some(selfType), Some(selfTy))
    } else {
      (Value.Int(0), None, None)
    }

    val fnValParamTypes = if targetParamTypes |paramTypes| {
      paramTypes.filter(_p => _p[1]).map(_p => _p[0])
    } else {
      fn.params.filter(p => !p.defaultValue).map(p => p.ty)
    }
    val targetArity = fnValParamTypes.length

    val fnVal = if targetArity == fn.params.length {
      if selfType |selfType| {
        try self._getOrCompileMethod(selfType, fn)
      } else {
        try self._getOrCompileFunction(fn)
      }
    } else if targetArity < fn.params.length {
      val targetParamTypes = targetParamTypes ?: []
      val paramsNeedingDefaultValue = fn.params.map((param, idx) => {
        if targetParamTypes[idx] {
          false
        } else {
          if !param.defaultValue unreachable("creating fn val for fn '${fn.label}' with arity $targetArity param '${param.label.name}' to be optional (at $position)")
          true
        }
      })

      if selfType |selfType| {
        try self._getOrCompileMethod(selfType, fn, paramsNeedingDefaultValue)
      } else {
        try self._getOrCompileFunction(fn, paramsNeedingDefaultValue)
      }
    } else {
      val baseFn = if selfType |selfType| {
        try self._getOrCompileMethod(selfType, fn)
      } else {
        try self._getOrCompileFunction(fn)
      }

      val fnName = self._fnName(fn) + ".discard"
      val returnTypeQbe = try self._getQbeTypeForType(fn.returnType)
      val fnVal = self._builder.buildFunction(name: fnName, returnType: returnTypeQbe)
      if fn.isClosure() fnVal.addEnv()

      val prevFn = self._currentFn
      self._currentFn = fnVal
      val prevFunction = self._currentFunction
      self._currentFunction = Some(fn)

      val argsForUnderlying: Value[] = []
      for param, idx in fn.params {
        val paramTy = try self._getQbeTypeForTypeExpect(param.ty, "unacceptable type for param", Some(param.label.position))

        val paramVal = fnVal.addParameter(param.label.name, paramTy)
        argsForUnderlying.push(paramVal)
      }
      fnVal.isVariadic = true

      var retVal = if fn.returnType.kind != TypeKind.PrimitiveUnit {
        val ret = try self._buildCall(None, Callable.Function(baseFn), argsForUnderlying)
        Some(ret)
      } else {
        try self._buildVoidCall(None, Callable.Function(baseFn), argsForUnderlying)
        None
      }

      if fn.scope.terminator != Some(Terminator.Returning) {
        fnVal.block.buildReturn(retVal)
      }

      self._currentFn = prevFn
      self._currentFunction = prevFunction

      fnVal
    }

    val hasReturn = fn.returnType.kind != TypeKind.PrimitiveUnit
    val struct = self._functionStruct(targetArity, hasReturn)
    val typeArgs = (if hasReturn { [fn.returnType] } else []).concat(fnValParamTypes)
    val fnStructSelfType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs))

    val resolvedGenerics: Map<String, Type> = {}
    val template = Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
    for (name, ty) in fnStructSelfType.extractGenerics(template) {
      resolvedGenerics[name] = ty
    }
    match self._resolvedGenerics.addLayer(struct.label.name, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: struct.label.name, message: e))) }
    val initFnVal = try self._getOrCompileStructInitializer(struct)

    self._resolvedGenerics.popLayer()

    // Do not track Function.init in callframes
    self._buildCall(None, Callable.Function(initFnVal), [closureEnvPtr, Value.Global(fnVal.name, QbeType.Pointer), selfVal])
  }

  func _constructString(self, ptrVal: Value, lenVal: Value, localName: String? = None): Result<Value, CompileError> {
    val fnVal = try self._getOrCompileStructInitializer(self._project.preludeStringStruct, [false, false])
    val structTy = if fnVal.returnType |ty| ty else unreachable("initializer functions must have return types specified")

    // Do not track String.init in callframes
    self._buildCall(None, Callable.Function(fnVal), [lenVal, ptrVal], localName)
  }

  func _getQbeTypeForType(self, ty: Type): Result<QbeType?, CompileError> {
    match ty.kind {
      TypeKind.PrimitiveUnit => Ok(None)
      TypeKind.PrimitiveInt => Ok(Some(QbeType.U64))
      TypeKind.PrimitiveFloat => Ok(Some(QbeType.F64))
      TypeKind.PrimitiveBool => Ok(Some(QbeType.U64))
      TypeKind.PrimitiveString => Ok(Some(QbeType.Pointer))
      TypeKind.Never => Ok(None)
      TypeKind.Any => todo("TypeKind.Any")
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getQbeTypeForType(ty) else unreachable("unexpected generic '$name' at this point")
      }
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => {
            if struct == self._project.preludeIntStruct return Ok(Some(QbeType.U64))
            if struct == self._project.preludeFloatStruct return Ok(Some(QbeType.F64))

            if struct.builtin == Some(BuiltinModule.Intrinsics) {
              if struct.label.name == "Byte" return Ok(Some(QbeType.U64))
              if struct.label.name == "Pointer" return Ok(Some(QbeType.Pointer))
            }
          }
          _ => {}
        }

        Ok(Some(QbeType.Pointer))
      }
      TypeKind.Func(paramTypes, returnType) => Ok(Some(QbeType.Pointer))
      TypeKind.Type(type_) => todo("TypeKind.Type")
      TypeKind.Tuple(_) => Ok(Some(QbeType.Pointer))
      TypeKind.Hole => unreachable("unexpected hole in emitted typed ast")
    }
  }

  func _getQbeTypeForTypeExpect(self, ty: Type, reason: String, position: Position? = None): Result<QbeType, CompileError> {
    val _ty = try self._getQbeTypeForType(ty)
    if _ty |ty| Ok(ty) else if position |pos| unreachable("($pos) reason") else unreachable(reason)
  }

  func _followAccessorPath(self, head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment, loadFinal: Bool, localName: String? = None): Result<Value, CompileError> {
    val segs = middle.concat([tail])
    var instTy = StructOrEnum.Struct(self._project.preludeBoolStruct)
    var instType = Type(kind: TypeKind.Instance(StructOrEnum.Struct(self._project.preludeBoolStruct), []))
    var curVal = Value.Ident("bogus", QbeType.F32)
    match segs[0] {
      AccessorPathSegment.Field => {
        // TODO: assert that `head.ty` is a pointer type (attempting to do pointer arithmetic later on will fail otherwise)
        val (_instTy, typeArgs) = try self._getInstanceTypeForType(head.ty)
        instTy = _instTy
        instType = Type(kind: TypeKind.Instance(instTy, typeArgs))

        curVal = try self._compileExpression(head)
        self._currentFn.block.addCommentBefore("${curVal.repr()}: ${head.ty.repr()}")
      }
      AccessorPathSegment.Method(_, fn, _, _) => {
        match fn.kind {
          FunctionKind.InstanceMethod => {
            // TODO: assert that `head.ty` is a pointer type (attempting to do pointer arithmetic later on will fail otherwise)
            val (_instTy, typeArgs) = try self._getInstanceTypeForType(head.ty)
            instTy = _instTy
            instType = Type(kind: TypeKind.Instance(instTy, typeArgs))

            curVal = try self._compileExpression(head)
            self._currentFn.block.addCommentBefore("${curVal.repr()}: ${head.ty.repr()}")
          }
          _ => {}
        }
      }
      _ => {}
    }

    for seg, idx in segs {
      match seg {
        AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => {
          match variant.kind {
            EnumVariantKind.Container => unreachable("non-constant enum variant missing instantation")
            _ => {}
          }

          curVal = try self._getOrCompileEnumVariantConst(enum_, variant)

          instTy = StructOrEnum.Enum(enum_)
        }
        AccessorPathSegment.Method(label, fn, isOptSafe, fnAliasTypeHint) => {
          if isOptSafe todo("opt-safe method accessor")

          val selfInstType = match fn.kind {
            FunctionKind.InstanceMethod => {
              val selfInstType = try self._addResolvedGenericsLayerForInstanceMethod(instType, fn.label.name, label.position)
              Some(selfInstType)
            }
            _ => None
          }

          val capturesMem = if fn.isClosure() {
            val capturesArr = try self._getCapturesArrForClosure(fn)
            Some(capturesArr)
          } else {
            None
          }

          val targetParamTypes = if fnAliasTypeHint |hint| {
            val paramTypes = match hint.kind {
              TypeKind.Func(paramTypes, _) => Some(paramTypes)
              TypeKind.Any => None // if the function value is being treated as an Any, then no param type info needs to be known later anyway
              _ => unreachable("fnAliasTypeKind must be TypeKind.Func")
            }
            paramTypes
          } else {
            None
          }

          self._resolvedGenerics.popLayer()

          val selfVal = if selfInstType |selfInstType| Some((curVal, selfInstType)) else None
          curVal = try self._compileFunctionValue(label.position, fn, targetParamTypes, capturesMem, selfVal)
        }
        AccessorPathSegment.Field(label, ty, field, isOptSafe) => {
          var optSafeCtx: (Label, Value, QbeFunction, Label)? = None

          if isOptSafe {
            val innerTy = if self._typeIsOption(ty) |innerTy| innerTy else unreachable("an opt-safe field accessor needs to have an Option type as its lhs")
            val unwrappedInstType = if self._typeIsOption(instType) |innerTy| innerTy else unreachable("an opt-safe field accessor needs to have an Option type as its lhs")
            instType = unwrappedInstType
            val (_instTy, _) = try self._getInstanceTypeForType(unwrappedInstType)
            instTy = _instTy

            val variantIsOptionSome = try self._emitOptValueIsSomeVariant(curVal)
            val labelIsSome = self._currentFn.block.addLabel("optsafe_field_is_some")
            val labelIsNone = self._currentFn.block.addLabel("optsafe_field_is_none")
            val labelCont = self._currentFn.block.addLabel("optsafe_field_cont")

            self._currentFn.block.addComment("begin opt-safe field accessor...")
            self._currentFn.block.buildJnz(variantIsOptionSome, labelIsSome, labelIsNone)

            self._currentFn.block.registerLabel(labelIsNone)
            val optNoneVariant = if self._project.preludeOptionEnum.variants.find(v => v.label.name == "None") |v| v else unreachable("Option.None must exist")
            val noneRes = try self._getOrCompileEnumVariantConst(self._project.preludeOptionEnum, optNoneVariant)
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.registerLabel(labelIsSome)
            val optSomeVariant = if self._project.preludeOptionEnum.variants.find(v => v.label.name == "Some") |v| v else unreachable("Option.Some must exist")
            match self._resolvedGenerics.addLayer("Option.Some", { "V": innerTy }) { Ok => {}, Err(e) => return Err(CompileError(position: label.position, kind: CompileErrorKind.ResolvedGenericsError(context: "Option.Some", message: e))) }
            val someVariantFn = try self._getOrCompileEnumVariantFn(self._project.preludeOptionEnum, optSomeVariant)
            self._resolvedGenerics.popLayer()

            optSafeCtx = Some((labelIsNone, noneRes, someVariantFn, labelCont))

            val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
            curVal = try self._emitOptValueGetValue(innerQbeType, curVal)
          }

          match instTy {
            StructOrEnum.Struct(struct) => {
              var offset = 0
              var fieldTyQbe = QbeType.F32 // placeholder sentinel value
              for f in struct.fields {
                val fieldTy = try self._getQbeTypeForTypeExpect(f.ty, "unacceptable type for field", Some(f.name.position))
                if f.name.name == field.name.name {
                  fieldTyQbe = fieldTy
                  break
                }

                offset += fieldTy.size()
              }
              if fieldTyQbe == QbeType.F32 unreachable("fieldTyQbe == QbeType.F32")

              val ptr = try self._currentFn.block.buildAdd(Value.Int(offset), curVal) else |e| return qbeError(e)
              if idx == segs.length - 1 {
                if !loadFinal {
                  curVal = ptr
                } else {
                  val nextVal = self._currentFn.block.buildLoad(fieldTyQbe, ptr, localName)
                  self._currentFn.block.addCommentBefore("${nextVal.repr()}: ${curVal.repr()}.${field.name.name}")
                  curVal = nextVal
                }
              } else {
                val nextVal = self._currentFn.block.buildLoad(fieldTyQbe, ptr)
                self._currentFn.block.addCommentBefore("${nextVal.repr()}: ${curVal.repr()}.${field.name.name}")
                curVal = nextVal
              }
            }
            StructOrEnum.Enum(_enum) => todo("enum field accessor")
          }

          if optSafeCtx |(labelIsNone, noneRes, someVariantFn, labelCont)| {
            val labelIsSome = self._currentFn.block.currentLabel
            // Do not track Option.Some in callframes
            val someRes = try self._buildCall(None, Callable.Function(someVariantFn), [curVal])
            self._currentFn.block.buildJmp(labelCont)

            self._currentFn.block.addComment("...opt-safe field accessor end")
            self._currentFn.block.registerLabel(labelCont)

            val phiCases = [(labelIsNone, noneRes), (labelIsSome, someRes)]
            curVal = try self._currentFn.block.buildPhi(phiCases, localName) else |e| return qbeError(e)
          }

          val (_instTy, typeArgs) = try self._getInstanceTypeForType(ty)
          instTy = _instTy
          instType = Type(kind: TypeKind.Instance(instTy, typeArgs))
        }
      }
    }

    Ok(curVal)
  }

  func _getOrCompileStructInitializer(self, struct: Struct, fieldsNeedingDefaultValue: Bool[] = []): Result<QbeFunction, CompileError> {
    val defaultValuesFlag = fieldsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    var fnName = try self._structInitializerFnName(struct)
    if defaultValuesFlag != 0 { fnName += ".$defaultValuesFlag" }
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: fnName, returnType: Some(QbeType.Pointer))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    fnVal.addCommentMultiline(try self._structSignature(struct, fieldsNeedingDefaultValue))

    val argsForUnderlying: Value[] = []
    var anyFieldNeedsDefault = false
    var size = 0
    for field, idx in struct.fields {
      val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))
      size += fieldTy.size()

      val fieldVal = if field.initializer |initializerNode| {
        val fieldNeedsDefault = fieldsNeedingDefaultValue[idx] ?: false
        if fieldNeedsDefault {
          anyFieldNeedsDefault = true
          try self._compileExpression(initializerNode, Some(field.name.name))
        } else {
          fnVal.addParameter(field.name.name, fieldTy)
        }
      } else {
        fnVal.addParameter(field.name.name, fieldTy)
      }
      argsForUnderlying.push(fieldVal)
    }

    val retVal = if anyFieldNeedsDefault {
      val baseFn = try self._getOrCompileStructInitializer(struct)
      try self._buildCall(None, Callable.Function(baseFn), argsForUnderlying)
    } else {
      val memLocal = try self._callMalloc(Value.Int(size), Some("struct.mem"))

      var offset = 0
      for field in struct.fields {
        val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))
        val param = Value.Ident(field.name.name, fieldTy)

        val localName = "mem_offset_${field.name.name}"
        val memCursorLocal = try fnVal.block.buildAdd(Value.Int(offset), memLocal, Some(localName)) else |e| return qbeError(e)
        fnVal.block.buildStore(fieldTy, param, memCursorLocal)

        offset += fieldTy.size()
      }

      memLocal
    }
    fnVal.block.buildReturn(Some(retVal))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileEnumVariantConst(self, enum_: Enum, variant: TypedEnumVariant): Result<Value, CompileError> {
    val base = self._enumTypeNameBase(enum_)
    val variantDataName = "$base.${variant.label.name}"
    if self._builder.getData(variantDataName) |v| return Ok(v)

    val variantIdx = if enum_.variants.findIndex(v => v.label.name == variant.label.name) |(_, idx)| idx else unreachable("variant '${variant.label.name}' must exist")
    val (slot, _) = self._builder.addData(QbeData(name: variantDataName, kind: QbeDataKind.Constants([(QbeType.U64, Value.Int(variantIdx))])))

    Ok(slot)
  }

  func _getOrCompileEnumVariantFn(self, enum_: Enum, variant: TypedEnumVariant, fieldsNeedingDefaultValue: Bool[] = []): Result<QbeFunction, CompileError> {
    val defaultValuesFlag = fieldsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    var variantFnName = try self._enumVariantFnName(enum_, variant)
    if defaultValuesFlag != 0 { variantFnName += ".$defaultValuesFlag" }

    if self._builder.getFunction(variantFnName) |fn| return Ok(fn)

    // TODO: constant variants shouldn't be a function - it should just be a `data` segment with the proper idx set
    val fn = self._builder.buildFunction(name: variantFnName, returnType: Some(QbeType.Pointer))
    val prevFn = self._currentFn
    self._currentFn = fn
    fn.addComment(try self._enumVariantSignature(enum_, variant, fieldsNeedingDefaultValue))

    val fields = match variant.kind {
      EnumVariantKind.Container(fields) => fields
      _ => unreachable("constant enum variants are not backed by functions, see _getOrCompileEnumVariantConst")
    }

    val argsForUnderlying: Value[] = []
    var anyFieldNeedsDefault = false
    var size = 0
    size += QbeType.U64.size() // account for space for variant idx slot
    for field, idx in fields {
      val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))
      size += fieldTy.size()

      val fieldVal = if field.initializer |initializerNode| {
        val fieldNeedsDefault = fieldsNeedingDefaultValue[idx] ?: false
        if fieldNeedsDefault {
          anyFieldNeedsDefault = true
          try self._compileExpression(initializerNode, Some(field.name.name))
        } else {
          fn.addParameter(field.name.name, fieldTy)
        }
      } else {
        fn.addParameter(field.name.name, fieldTy)
      }
      argsForUnderlying.push(fieldVal)
    }

    val retVal = if anyFieldNeedsDefault {
      val baseFn = try self._getOrCompileEnumVariantFn(enum_, variant)
      try self._buildCall(None, Callable.Function(baseFn), argsForUnderlying)
    } else {
      val memLocal = try self._callMalloc(Value.Int(size), Some("enum_variant.mem"))

      val variantIdx = if enum_.variants.findIndex(v => v.label.name == variant.label.name) |(_, idx)| idx else unreachable("variant '${variant.label.name}' must exist")
      fn.block.buildStoreL(Value.Int(variantIdx), memLocal) // Store variant idx at designated slot
      var offset = QbeType.U64.size() // begin inserting any fields after that variant idx slot

      for field in fields {
        val fieldTy = try self._getQbeTypeForTypeExpect(field.ty, "unacceptable type for field", Some(field.name.position))
        val param = Value.Ident(field.name.name, fieldTy)

        val localName = "mem_offset_${field.name.name}"
        val memCursorLocal = try fn.block.buildAdd(Value.Int(offset), memLocal, Some(localName)) else |e| return qbeError(e)
        fn.block.buildStore(fieldTy, param, memCursorLocal)

        offset += fieldTy.size()
      }

      memLocal
    }

    fn.block.buildReturn(Some(retVal))

    self._currentFn = prevFn

    Ok(fn)
  }

  func _invokePrint(self, arguments: TypedAstNode?[], withNewline = false): Result<Value, CompileError> {
    val fnName = if withNewline "println" else "print"
    self._currentFn.block.addComment("begin $fnName...")
    val varargItems = if arguments[0] |node| {
      if node |node| {
        val items = match node.kind {
          TypedAstNodeKind.Array(items) => items
          _ => unreachable("`$fnName` receives an array of its variadic arguments")
        }
        items
      } else unreachable("`$fnName` receives an array of its variadic arguments")
    } else []

    val stdoutWriteFn = if self._project.preludeScope.functions.find(fn => fn.label.name == "stdoutWrite") |fn| fn else unreachable("`stdoutWrite` must exist in prelude")
    val stdoutWriteFnVal = try self._getOrCompileFunction(stdoutWriteFn)

    val space = self._builder.buildGlobalString(" ")
    val spaceStr = try self._constructString(space, Value.Int(1))

    for item, idx in varargItems {
      val itemVal = try self._compileExpression(item)

      val itemInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(item.ty, "toString", item.token.position)
      val itemToStringFnVal = try self._getOrCompileToStringMethod(itemInstanceType)
      self._resolvedGenerics.popLayer()

      val fnName = self._functionName("eq", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(item.ty))[0])))
      val frameCtx = CallframeContext(position: item.token.position, callee: Some(fnName))
      val toStringVal = try self._buildCall(Some(frameCtx), Callable.Function(itemToStringFnVal), [itemVal])

      self._currentFn.block.buildVoidCall(Callable.Function(stdoutWriteFnVal), [toStringVal])

      if idx != varargItems.length - 1 {
        self._currentFn.block.buildVoidCall(Callable.Function(stdoutWriteFnVal), [spaceStr])
      }
    }

    if withNewline {
      val newline = self._builder.buildGlobalString("\\n")
      val newlineStr = try self._constructString(newline, Value.Int(1))
      self._currentFn.block.buildVoidCall(Callable.Function(stdoutWriteFnVal), [newlineStr])
    }

    self._currentFn.block.addComment("...$fnName end")

    Ok(Value.Ident("bogus", QbeType.F32))
  }

  func _invokeCBindingFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val cFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => unreachable("@CBinding decorator requires 1 string argument for the name")
    }

    val args: Value[] = []
    for arg in arguments {
      if arg |node| {
        val arg = try self._compileExpression(node)
        args.push(arg)
      } else {
        unreachable("functions with @CBinding decorator cannot have optional parameters")
      }
    }

    val returnTypeQbe = try self._getQbeTypeForType(fn.returnType)
    val res = if returnTypeQbe |returnTy| {
      val res = try self._currentFn.block.buildCallRaw(cFnName, returnTy, args) else |e| return qbeError(e)
      res
    } else {
      self._currentFn.block.buildVoidCallRaw(cFnName, args)
      Value.Ident("bogus", QbeType.F32)
    }
    Ok(res)
  }

  func _pointerSize(self, ty: Type): Result<Int, CompileError> {
    val isByte = match ty.kind {
      TypeKind.Generic(name) => unreachable("unresolved generic '$name'")
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Struct(struct) => struct.builtin == Some(BuiltinModule.Intrinsics) && struct.label.name == "Byte"
          _ => false
        }
      }
      _ => false
    }
    val size = if isByte 1 else 8

    Ok(size)
  }

  func _invokeIntrinsicFn(self, dec: Decorator, fn: Function, arguments: TypedAstNode?[]): Result<Value, CompileError> {
    val intrinsicFnName = match dec.arguments[0] {
      LiteralAstNode.String(value) => value
      _ => unreachable("@Intrinsic decorator requires 1 string argument for the name")
    }

    match intrinsicFnName {
      "pointer_null" => {
        self._currentFn.block.addComment("begin pointer_null...")

        try self._currentFn.block.buildAdd(Value.Int(0), Value.Int(0), Some("__pointer_null__")) else |e| return qbeError(e)

        self._currentFn.block.addComment("...pointer_null end")

        Ok(Value.Ident("__pointer_null__", QbeType.Pointer))
      }
      "pointer_is_null" => {
        self._currentFn.block.addComment("begin pointer_is_null...")

        val _ptr = if arguments[0] |arg| arg else unreachable("'pointer_is_null' has 1 required argument")
        val ptr = if _ptr |arg| arg else unreachable("'pointer_is_null' has 1 required argument")
        val ptrVal = try self._compileExpression(ptr)

        val labelIsNull = self._currentFn.block.addLabel("ptr_is_null")
        val labelIsNotNull = self._currentFn.block.addLabel("ptr_is_not_null")
        val labelCont = self._currentFn.block.addLabel("ptr_null_cont")

        self._currentFn.block.buildJnz(ptrVal, labelIsNotNull, labelIsNull)

        self._currentFn.block.registerLabel(labelIsNotNull)
        val f = Value.Int(0)
        self._currentFn.block.buildJmp(labelCont)
        self._currentFn.block.registerLabel(labelIsNull)
        val t = Value.Int(1)
        self._currentFn.block.buildJmp(labelCont)
        self._currentFn.block.registerLabel(labelCont)

        val phiCases = [(labelIsNotNull, f), (labelIsNull, t)]
        val ptrIsNull = try self._currentFn.block.buildPhi(phiCases) else |e| return qbeError(e)

        self._currentFn.block.addComment("...pointer_is_null end")

        Ok(ptrIsNull)
      }
      "pointer_malloc" => {
        self._currentFn.block.addComment("begin pointer_malloc...")

        val _count = if arguments[0] |arg| arg else unreachable("'pointer_malloc' has 1 required argument")
        val count = if _count |arg| arg else unreachable("'pointer_malloc' has 1 required argument")
        val countVal = try self._compileExpression(count)

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else unreachable("(pointer_malloc) could not resolve T for Pointer<T>")
        val innerTySize = try self._pointerSize(innerTy)
        val sizeVal = try self._currentFn.block.buildMul(Value.Int(innerTySize), countVal) else |e| return qbeError(e)

        val mem = try self._callMalloc(sizeVal, Some("ptr.mem"))

        self._currentFn.block.addComment("...pointer_malloc end")

        Ok(mem)
      }
      "pointer_realloc" => {
        self._currentFn.block.addComment("begin pointer_realloc...")

        val _ptr = if arguments[0] |arg| arg else unreachable("'pointer_realloc' has 2 required arguments")
        val ptr = if _ptr |arg| arg else unreachable("'pointer_realloc' has 2 required arguments")
        val ptrVal = try self._compileExpression(ptr)

        val _count = if arguments[1] |arg| arg else unreachable("'pointer_realloc' has 2 required arguments")
        val count = if _count |arg| arg else unreachable("'pointer_realloc' has 2 required arguments")
        val countVal = try self._compileExpression(count)

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else unreachable("(pointer_realloc) could not resolve T for Pointer<T>")
        val innerTySize = try self._pointerSize(innerTy)
        val sizeVal = try self._currentFn.block.buildMul(Value.Int(innerTySize), countVal) else |e| return qbeError(e)

        val mem = try self._currentFn.block.buildCall(Callable.Function(self._realloc), [ptrVal, sizeVal], Some("mem")) else |e| return qbeError(e)

        self._currentFn.block.addComment("...pointer_realloc end")

        Ok(mem)
      }
      "pointer_store" => {
        self._currentFn.block.addComment("begin pointer_store...")

        val _ptr = if arguments[0] |arg| arg else unreachable("'pointer_store' has 2 required arguments")
        val ptr = if _ptr |arg| arg else unreachable("'pointer_store' has 2 required arguments")
        val ptrVal = try self._compileExpression(ptr)

        val _value = if arguments[1] |arg| arg else unreachable("'pointer_store' has 2 required arguments")
        val value = if _value |arg| arg else unreachable("'pointer_store' has 2 required arguments")
        val valueVal = try self._compileExpression(value)

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else unreachable("(pointer_store) could not resolve T for Pointer<T>")
        val innerTySize = try self._pointerSize(innerTy)
        if innerTySize == 1 {
          self._currentFn.block.buildStoreB(valueVal, ptrVal)
        } else {
          val innerQbeType = try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)
          self._currentFn.block.buildStore(innerQbeType, valueVal, ptrVal)
        }

        self._currentFn.block.addComment("...pointer_store end")

        Ok(Value.Ident("bogus", QbeType.F32))
      }
      "pointer_offset" => {
        self._currentFn.block.addComment("begin pointer_offset...")

        val _ptr = if arguments[0] |arg| arg else unreachable("'pointer_offset' has 2 required arguments")
        val ptr = if _ptr |arg| arg else unreachable("'pointer_offset' has 2 required arguments")
        val ptrVal = try self._compileExpression(ptr)

        val _offset = if arguments[1] |arg| arg else unreachable("'pointer_offset' has 2 required arguments")
        val offset = if _offset |arg| arg else unreachable("'pointer_offset' has 2 required arguments")
        val offsetVal = try self._compileExpression(offset)

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else unreachable("(pointer_offset) could not resolve T for Pointer<T>")
        val innerTySize = try self._pointerSize(innerTy)
        val sizeVal = try self._currentFn.block.buildMul(Value.Int(innerTySize), offsetVal) else |e| return qbeError(e)

        val mem = try self._currentFn.block.buildAdd(sizeVal, ptrVal) else |e| return qbeError(e)

        self._currentFn.block.addComment("...pointer_offset end")

        Ok(mem)
      }
      "pointer_load" => {
        self._currentFn.block.addComment("begin pointer_load...")

        val _ptr = if arguments[0] |arg| arg else unreachable("'pointer_load' has 1 required argument")
        val ptr = if _ptr |arg| arg else unreachable("'pointer_load' has 1 required argument")
        val ptrVal = try self._compileExpression(ptr)

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else unreachable("(pointer_load) could not resolve T for Pointer<T>")

        val innerTySize = try self._pointerSize(innerTy)
        val innerQbeType = if innerTySize == 1 QbeType.U8 else try self._getQbeTypeForTypeExpect(innerTy, "unacceptable type", None)

        val v = self._currentFn.block.buildLoad(innerQbeType, ptrVal)

        self._currentFn.block.addComment("...pointer_load end")

        Ok(v)
      }
      "pointer_copy_from" => {
        self._currentFn.block.addComment("begin pointer_copy_from...")

        val _ptr = if arguments[0] |arg| arg else unreachable("'pointer_copy_from' has 3 required arguments")
        val ptr = if _ptr |arg| arg else unreachable("'pointer_copy_from' has 3 required arguments")
        val ptrVal = try self._compileExpression(ptr)

        val _other = if arguments[1] |arg| arg else unreachable("'pointer_copy_from' has 3 required arguments")
        val other = if _other |arg| arg else unreachable("'pointer_copy_from' has 3 required arguments")
        val otherVal = try self._compileExpression(other)

        val _size = if arguments[2] |arg| arg else unreachable("'pointer_copy_from' has 3 required arguments")
        val size = if _size |arg| arg else unreachable("'pointer_copy_from' has 3 required arguments")
        val sizeArg = try self._compileExpression(size)

        val innerTy = if self._resolvedGenerics.resolveGeneric("T") |ty| ty else unreachable("(pointer_copy_from) could not resolve T for Pointer<T>")
        val innerTySize = try self._pointerSize(innerTy)
        val sizeVal = try self._currentFn.block.buildMul(Value.Int(innerTySize), sizeArg) else |e| return qbeError(e)

        self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [ptrVal, otherVal, sizeVal])

        self._currentFn.block.addComment("...pointer_copy_from end")

        Ok(Value.Ident("bogus", QbeType.F32))
      }
      "errno" => {
        self._currentFn.block.addComment("begin errno...")

        val errnoFnName = match process.uname().sysname {
          "Linux" => "__errno_location"
          "Darwin" => "__error"
          _ sysname => todo("[errno] unsupported system " + sysname)
        }
        val errnoPtr = try self._currentFn.block.buildCallRaw(errnoFnName, QbeType.Pointer, []) else |e| return qbeError(e)
        val errnoVal = self._currentFn.block.buildLoadW(errnoPtr)
        val res = self._currentFn.block.buildExt(value: errnoVal, signed: false)

        self._currentFn.block.addComment("...errno end")

        Ok(res)
      }
      "byte_from_int" => {
        self._currentFn.block.addComment("begin byte_from_int...")

        val _arg = if arguments[0] |arg| arg else unreachable("'byte_from_int' has 1 required argument")
        val arg = if _arg |arg| arg else unreachable("'byte_from_int' has 1 required argument")
        val argVal = try self._compileExpression(arg)

        self._currentFn.block.addComment("...byte_from_int end")

        Ok(argVal)
      }
      "byte_as_int" => {
        self._currentFn.block.addComment("begin byte_as_int...")

        val _arg = if arguments[0] |arg| arg else unreachable("'byte_as_int' has 1 required argument")
        val arg = if _arg |arg| arg else unreachable("'byte_as_int' has 1 required argument")
        val argVal = try self._compileExpression(arg)

        self._currentFn.block.addComment("...byte_as_int end")

        Ok(argVal)
      }
      "u64_to_string" => {
        self._currentFn.block.addComment("begin u64_to_string...")
        val _arg = if arguments[0] |arg| arg else unreachable("'u64_to_string' has 1 required argument")
        val arg = if _arg |arg| arg else unreachable("'u64_to_string' has 1 required argument")
        val argVal = try self._compileExpression(arg)

        val intFmtPtr = self._builder.buildGlobalString("%llu")
        val sizeVal = try self._currentFn.block.buildCall(Callable.Function(self._snprintf), [Value.Int(0), Value.Int(0), intFmtPtr, argVal]) else |e| return qbeError(e)
        val mallocSizeVal = try self._currentFn.block.buildAdd(Value.Int(1), sizeVal) else |e| return qbeError(e)

        val mem = try self._callMalloc(mallocSizeVal)
        try self._currentFn.block.buildCall(Callable.Function(self._snprintf), [mem, mallocSizeVal, intFmtPtr, argVal]) else |e| return qbeError(e)
        val str = try self._constructString(mem, sizeVal)

        self._currentFn.block.addComment("...u64_to_string end")

        Ok(str)
      }
      "int_as_float" => {
        self._currentFn.block.addComment("begin int_as_float...")

        val _arg = if arguments[0] |arg| arg else unreachable("'int_as_float' has 1 required argument")
        val arg = if _arg |arg| arg else unreachable("'int_as_float' has 1 required argument")
        val argVal = try self._compileExpression(arg)

        val res = self._currentFn.block.buildLToF(argVal)

        self._currentFn.block.addComment("...int_as_float end")

        Ok(res)
      }
      "float_as_int" => {
        self._currentFn.block.addComment("begin float_as_int...")

        val _arg = if arguments[0] |arg| arg else unreachable("'float_as_int' has 1 required argument")
        val arg = if _arg |arg| arg else unreachable("'float_as_int' has 1 required argument")
        val argVal = try self._compileExpression(arg)

        val res = self._currentFn.block.buildFToL(argVal)

        self._currentFn.block.addComment("...float_as_int end")

        Ok(res)
      }
      "float_floor" => {
        self._currentFn.block.addComment("begin float_floor...")

        val _arg = if arguments[0] |arg| arg else unreachable("'float_floor' has 1 required argument")
        val arg = if _arg |arg| arg else unreachable("'float_floor' has 1 required argument")
        val argVal = try self._compileExpression(arg)

        val floorRes = try self._currentFn.block.buildCallRaw("floor", QbeType.F64, [argVal]) else |e| return qbeError(e)
        val res = self._currentFn.block.buildFToL(floorRes)

        self._currentFn.block.addComment("...float_floor end")

        Ok(res)
      }
      "float_ceil" => {
        self._currentFn.block.addComment("begin float_ceil...")

        val _arg = if arguments[0] |arg| arg else unreachable("'float_ceil' has 1 required argument")
        val arg = if _arg |arg| arg else unreachable("'float_ceil' has 1 required argument")
        val argVal = try self._compileExpression(arg)

        val ceilRes = try self._currentFn.block.buildCallRaw("ceil", QbeType.F64, [argVal]) else |e| return qbeError(e)
        val res = self._currentFn.block.buildFToL(ceilRes)

        self._currentFn.block.addComment("...float_ceil end")

        Ok(res)
      }
      "float_round" => {
        self._currentFn.block.addComment("begin float_round...")

        val _arg = if arguments[0] |arg| arg else unreachable("'float_round' has 1 required argument")
        val arg = if _arg |arg| arg else unreachable("'float_round' has 1 required argument")
        val argVal = try self._compileExpression(arg)

        val roundRes = try self._currentFn.block.buildCallRaw("round", QbeType.F64, [argVal]) else |e| return qbeError(e)
        val res = self._currentFn.block.buildFToL(roundRes)

        self._currentFn.block.addComment("...float_round end")

        Ok(res)
      }
      "argc" => {
        self._currentFn.block.addComment("begin argc...")
        val res = self._currentFn.block.buildLoadL(self._argcPtr)
        self._currentFn.block.addComment("...argc end")

        Ok(res)
      }
      "argv" => {
        self._currentFn.block.addComment("begin argv...")
        val res = self._currentFn.block.buildLoadL(self._argvPtr)
        self._currentFn.block.addComment("...argv end")

        Ok(res)
      }
      "__callstack" => {
        self._currentFn.block.addComment("begin __callstack...")
        val res = try self._currentFn.block.buildAdd(Value.Int(0), self._callstack[0]) else |e| return qbeError(e)
        self._currentFn.block.addComment("...__callstack end")

        Ok(res)
      }
      "__callstackp" => {
        self._currentFn.block.addComment("begin __callstackp...")
        val res = self._currentFn.block.buildLoadL(self._callstack[1])
        self._currentFn.block.addComment("...__callstackp end")

        Ok(res)
      }
      "modulenames" => {
        self._currentFn.block.addComment("begin modulenames...")
        val res = try self._currentFn.block.buildAdd(Value.Int(0), self._moduleNamesPtr) else |e| return qbeError(e)
        self._currentFn.block.addComment("...modulenames end")

        Ok(res)
      }
      "functionnames" => {
        self._currentFn.block.addComment("begin functionnames...")
        val res = try self._currentFn.block.buildAdd(Value.Int(0), self._fnNamesPtr) else |e| return qbeError(e)
        self._currentFn.block.addComment("...functionnames end")

        Ok(res)
      }
      _ => unreachable("unsupported intrinsic '$intrinsicFnName'")
    }
  }

  func _buildCall(self, ctx: CallframeContext?, callable: Callable, arguments: Value[], dst: String? = None, envPtr: Value? = None): Result<Value, CompileError> {
    if ctx |ctx| try self._emitCallstackPush(ctx.callee, ctx.position)
    val v = try self._currentFn.block.buildCall(callable, arguments, dst, envPtr) else |e| return qbeError(e)
    if ctx try self._emitCallstackPop()

    Ok(v)
  }

  func _buildVoidCall(self, ctx: CallframeContext?, callable: Callable, arguments: Value[], envPtr: Value? = None): Result<Int, CompileError> {
    if ctx |ctx| try self._emitCallstackPush(ctx.callee, ctx.position)
    self._currentFn.block.buildVoidCall(callable, arguments, envPtr)
    if ctx try self._emitCallstackPop()

    Ok(0) // <-- unnecessary int
  }

  func _emitCallstackPush(self, calleeName: String?, position: Position): Result<Int, CompileError> {
    self._currentFn.block.addComment("begin __callstack push...")
    val (stack, stackPtr) = self._callstack

    val moduleId = if self._currentFunction |fn| {
      var modId = 0 // a moduleId of 0 represents <builtin> code
      var scope = Some(fn.scope)
      while scope |sc| {
        match sc.kind {
          ScopeKind.Module(id) => {
            modId = id + 1
            break
          }
          _ => {
            scope = sc.parent
          }
        }
      }

      modId
    } else {
      self._currentModule.id + 1
    }

    // a fnId of 0 represents <expression> callee
    val fnId = if calleeName |name| {
      if self._functionNames[name] |fnId| {
        fnId + 1
      } else {
        val fnId = self._functionNames.size
        self._functionNames[name] = fnId
        fnId + 1
      }
    } else {
      0
    }

    var frame = position.line || (moduleId << 16) || (fnId << 32)

    val stackPtrVal = self._currentFn.block.buildLoadL(stackPtr)
    val ptr = try self._currentFn.block.buildAdd(stackPtrVal, stack) else |e| return qbeError(e)
    self._currentFn.block.buildStoreL(Value.IntU64(frame), ptr)
    val ptrInc = try self._currentFn.block.buildAdd(Value.Int(8), stackPtrVal) else |e| return qbeError(e)
    self._currentFn.block.buildStoreL(ptrInc, stackPtr)

    self._currentFn.block.addComment("...__callstack push end")

    Ok(0) // <-- unnecessary int
  }

  func _emitCallstackPop(self): Result<Int, CompileError> {
    self._currentFn.block.addComment("begin __callstack pop...")
    val (_, stackPtr) = self._callstack

    val stackPtrVal = self._currentFn.block.buildLoadL(stackPtr)
    val ptrDec = try self._currentFn.block.buildSub(stackPtrVal, Value.Int(8)) else |e| return qbeError(e)
    self._currentFn.block.buildStoreL(ptrDec, stackPtr)

    self._currentFn.block.addComment("...__callstack pop end")

    Ok(0) // <-- unnecessary int
  }

  func _getOrCompileFunction(self, fn: Function, paramsNeedingDefaultValue: Bool[] = []): Result<QbeFunction, CompileError> {
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    val fnName = if defaultValuesFlag == 0 { self._fnName(fn) } else { self._fnName(fn) + ".$defaultValuesFlag" }
    if self._builder.getFunction(fnName) |fn| return Ok(fn)

    val returnTypeQbe = try self._getQbeTypeForType(fn.returnType)
    val fnVal = self._builder.buildFunction(name: fnName, returnType: returnTypeQbe)
    if fn.isClosure() fnVal.addEnv()

    try self._compileFunc(None, fnVal, fn, paramsNeedingDefaultValue)
    fnVal.addComment(try self._fnSignature(None, fn, paramsNeedingDefaultValue))

    Ok(fnVal)
  }

  func _getOrCompileMethod(self, selfType: Type, fn: Function, paramsNeedingDefaultValue: Bool[] = []): Result<QbeFunction, CompileError> {
    val isInstanceMethod = match fn.kind { FunctionKind.InstanceMethod => true, _ => false }
    if isInstanceMethod && fn.label.name == "toString" && fn.isGenerated return self._getOrCompileToStringMethod(selfType)
    if isInstanceMethod && fn.label.name == "eq" && fn.isGenerated return self._getOrCompileEqMethod(selfType)
    if isInstanceMethod && fn.label.name == "hash" && fn.isGenerated return self._getOrCompileHashMethod(selfType)

    val (selfTy, _) = try self._getInstanceTypeForType(selfType)
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    var methodName = try self._methodFnName(selfTy, fn)
    if defaultValuesFlag != 0 { methodName += ".$defaultValuesFlag" }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val returnTypeQbe = try self._getQbeTypeForType(fn.returnType)
    val fnVal = self._builder.buildFunction(name: methodName, returnType: returnTypeQbe)
    if fn.isClosure() fnVal.addEnv()

    val selfCtx = if isInstanceMethod {
      val selfTyQbe = try self._getQbeTypeForTypeExpect(selfType, "unacceptable type for self")
      val selfParam = fnVal.addParameter("self", selfTyQbe)
      val selfVariable = if fn.scope.variables.find(v => v.label.name == "self") |selfVariable| selfVariable else unreachable("Function '${fn.label.name}' is an instance method but does not have a variable 'self' in its scope")
      fnVal.block.addVar(variableToVar(selfVariable), Some("self"))
      (selfType, Some(selfParam))
    } else {
      (selfType, None)
    }
    try self._compileFunc(Some(selfCtx), fnVal, fn, paramsNeedingDefaultValue)
    fnVal.addComment(try self._fnSignature(Some(selfTy), fn, paramsNeedingDefaultValue))

    Ok(fnVal)
  }

  func _compileFunc(self, selfCtx: (Type, Value?)?, fnVal: QbeFunction, fn: Function, paramsNeedingDefaultValue: Bool[] = []): Result<Int, CompileError> {
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val argsForUnderlying = if selfCtx |(_, selfParam)| {
      if selfParam |v| [v] else []
    } else {
      []
    }
    var anyParamNeedsDefault = false
    for param, idx in fn.params {
      val paramTy = try self._getQbeTypeForTypeExpect(param.ty, "unacceptable type for param", Some(param.label.position))
      self._currentFn.block.addVar(variableToVar(param.variable), Some(param.label.name))

      val paramVal = if param.defaultValue |defaultValueNode| {
        val paramNeedsDefault = paramsNeedingDefaultValue[idx] ?: false
        if paramNeedsDefault {
          anyParamNeedsDefault = true
          try self._compileExpression(defaultValueNode, Some(param.label.name))
        } else {
          fnVal.addParameter(param.label.name, paramTy)
        }
      } else {
        fnVal.addParameter(param.label.name, paramTy)
      }
      argsForUnderlying.push(paramVal)
    }

    var retVal: Value? = None
    if anyParamNeedsDefault {
      val baseFn = if selfCtx |(selfType, _)| {
        try self._getOrCompileMethod(selfType, fn)
      } else {
        try self._getOrCompileFunction(fn)
      }
      retVal = if fn.returnType.kind != TypeKind.PrimitiveUnit {
        val ret = try self._buildCall(None, Callable.Function(baseFn), argsForUnderlying)
        Some(ret)
      } else {
        try self._buildVoidCall(None, Callable.Function(baseFn), argsForUnderlying)
        None
      }
    } else {
      for node, idx in fn.body {
        val res = try self._compileStatement(node)
        if idx == fn.body.length - 1 && fn.returnType.kind != TypeKind.PrimitiveUnit {
          retVal = res
        }
      }
    }

    if fn.scope.terminator != Some(Terminator.Returning) {
      fnVal.block.buildReturn(retVal)
    }

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(0)
  }

  func _getOrCompileToStringMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val (selfTy, typeArgs) = try self._getInstanceTypeForType(ty)
    val (methodName, fn) = match selfTy {
      StructOrEnum.Struct(struct) => {
        if struct == self._project.preludeIntStruct return self._getOrCompileIntToStringMethod()
        if struct == self._project.preludeFloatStruct return self._getOrCompileFloatToStringMethod()
        if struct == self._project.preludeStringStruct return self._getOrCompileStringToStringMethod()
        if struct == self._project.preludeBoolStruct return self._getOrCompileBoolToStringMethod()

        val _fn = struct.instanceMethods.find(m => m.label.name == "toString")
        val fn = if _fn |f| f else unreachable("every struct has a toString method defined")

        (try self._structMethodFnName(struct, fn), fn)
      }
      StructOrEnum.Enum(enum_) => {
        val _fn = enum_.instanceMethods.find(m => m.label.name == "toString")
        val fn = if _fn |f| f else unreachable("every enum has a toString method defined")

        (try self._enumMethodFnName(enum_, fn), fn)
      }
    }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated return self._compileGeneratedToStringMethod(ty, fn)

    self._getOrCompileMethod(ty, fn)
  }

  func _compileGeneratedToStringMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")

    val (selfTy, typeArgs) = try self._getInstanceTypeForType(selfType)
    val selfInstanceTy = Type(kind: TypeKind.Instance(selfTy, typeArgs))

    val methodName = try self._methodFnName(selfTy, fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val selfTyQbe = try self._getQbeTypeForTypeExpect(selfInstanceTy, "unacceptable type for self")
    val selfParamVal = fnVal.addParameter("self", selfTyQbe)

    match selfTy {
      StructOrEnum.Struct(struct) => {
        val data: (String, Position, Type)[] = []

        if self._isFunctionStruct(struct) {
          val str = self._builder.buildGlobalString("<#function>")
          val res = try self._constructString(str, Value.Int(11))

          self._currentFn.block.buildReturn(Some(res))
        } else {
          val isTuple = self._isTupleStruct(struct)
          for field in struct.fields {
            val fieldName = if isTuple "" else field.name.name
            data.push((fieldName, field.name.position, field.ty))
          }

          val prefix = if isTuple "" else struct.label.name
          val res = try self._emitToStringLogicForStructuredData(prefix, selfParamVal, data)
          self._currentFn.block.buildReturn(Some(res))
        }
      }
      StructOrEnum.Enum(enum_) => {
        val variantIdxVal = self._emitGetEnumVariantIdx(selfParamVal)

        var labelElse = self._currentFn.block.addLabel("__initial")
        val labelEnd = self._currentFn.block.addLabel("unreachable")

        for variant, idx in enum_.variants {
          if idx != 0 {
            self._currentFn.block.registerLabel(labelElse)
          }

          val cond = try self._currentFn.block.buildCompareEq(Value.Int(idx), variantIdxVal) else |e| return qbeError(e)

          val labelThen = self._currentFn.block.addLabel("variant_${variant.label.name}")
          if idx != enum_.variants.length - 1 {
            labelElse = self._currentFn.block.addLabel("next")
            self._currentFn.block.buildJnz(cond, labelThen, labelElse)
          } else {
            self._currentFn.block.buildJnz(cond, labelThen, labelEnd)
          }

          self._currentFn.block.registerLabel(labelThen)
          val variantName = "${enum_.label.name}.${variant.label.name}"
          match variant.kind {
            EnumVariantKind.Constant => {
              val variantNameStr = self._builder.buildGlobalString(variantName)
              val retVal = try self._constructString(variantNameStr, Value.Int(variantName.length))
              self._currentFn.block.buildReturn(Some(retVal))
            }
            EnumVariantKind.Container(fields) => {
              val data: (String, Position, Type)[] = []
              for field in fields {
                data.push((field.name.name, field.name.position, field.ty))
              }
              val ptr = try self._emitGetEnumVariantValueStart(selfParamVal)
              val retVal = try self._emitToStringLogicForStructuredData(variantName, ptr, data)
              self._currentFn.block.buildReturn(Some(retVal))
            }
          }
        }

        self._currentFn.block.registerLabel(labelEnd)
        self._currentFn.block.buildHalt()
      }
    }

    fnVal.addComment(try self._fnSignature(Some(selfTy), fn))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(fnVal)
  }

  func _emitToStringLogicForStructuredData(self, prefix: String, selfPtr: Value, data: (String, Position, Type)[]): Result<Value, CompileError> {
    val prefixStr = self._builder.buildGlobalString(prefix)
    var len = prefix.length + 2 + (data.length - 1) * 2 // account for '(' and ')', as well as ',' and ' ' between items
    var lenVal = Value.Int(0)

    val reprVals: (String, Value, Bool)[] = []
    var offset = 0
    for (itemName, itemPosition, itemType), idx in data {
      // If the item label is meant to be output, account for the label as well as ':' and ' ' between the label and the value
      if !itemName.isEmpty() { len += (itemName.length + 2) }

      val itemInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(itemType, "toString", itemPosition)
      val itemToStringFnVal = try self._getOrCompileToStringMethod(itemInstanceType)
      self._resolvedGenerics.popLayer()

      val itemTy = try self._getQbeTypeForTypeExpect(itemType, "unacceptable type for item", Some(itemPosition))
      val itemIsString = self._typeIsString(itemInstanceType)

      val memCursorLocalName = if itemName.isEmpty() "$idx" else itemName
      val memCursorLocal = try self._currentFn.block.buildAdd(Value.Int(offset), selfPtr, Some("mem_offset_$memCursorLocalName")) else |e| return qbeError(e)
      val itemVal = self._currentFn.block.buildLoad(itemTy, memCursorLocal)

      offset += itemTy.size()

      val fnName = self._functionName("toString", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(itemType))[0])))
      val frameCtx = CallframeContext(position: itemPosition, callee: Some(fnName))
      val itemToStringVal = try self._buildCall(Some(frameCtx), Callable.Function(itemToStringFnVal), [itemVal])
      val itemToStringLengthVal = self._currentFn.block.buildLoadL(itemToStringVal)
      lenVal = try self._currentFn.block.buildAdd(lenVal, itemToStringLengthVal, Some("length_total")) else |e| return qbeError(e)
      if itemIsString {
        self._currentFn.block.addComment("account for opening and closing \"'s")
        lenVal = try self._currentFn.block.buildAdd(lenVal, Value.Int(2), Some("length_total")) else |e| return qbeError(e)
      }

      reprVals.push((itemName, itemToStringVal, itemIsString))
    }

    val totalLengthVal = try self._currentFn.block.buildAdd(Value.Int(len), lenVal) else |e| return qbeError(e)
    val stringWithLengthFn = if self._project.preludeStringStruct.staticMethods.find(m => m.label.name == "withLength") |fn| fn else unreachable("String.withLength must exist")
    val stringWithLengthFnVal = try self._getOrCompileMethod(Type(kind: TypeKind.Type(StructOrEnum.Struct(self._project.preludeStringStruct))), stringWithLengthFn)
    // Do not track String.withLength in callframes
    val newStr = try self._buildCall(None, Callable.Function(stringWithLengthFnVal), [totalLengthVal])

    var newStrBuf = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), newStr) else |e| return qbeError(e))
    if !prefix.isEmpty() {
      self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [newStrBuf, prefixStr, Value.Int(prefix.length)])
    }
    var cursor = try self._currentFn.block.buildAdd(newStrBuf, Value.Int(prefix.length), Some("str_cursor")) else |e| return qbeError(e)
    self._currentFn.block.addComment("'('")
    self._currentFn.block.buildStoreB(Value.Int(40), cursor)
    cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)

    for (fieldName, strVal, isString), idx in reprVals {
      if !fieldName.isEmpty() {
        val fieldNameStr = self._builder.buildGlobalString(fieldName)
        self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [cursor, fieldNameStr, Value.Int(fieldName.length)])
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(fieldName.length), Some("str_cursor")) else |e| return qbeError(e)
        self._currentFn.block.addComment("\": \"")
        self._currentFn.block.buildStoreB(Value.Int(58), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
        self._currentFn.block.buildStoreB(Value.Int(32), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
      }

      if isString {
        self._currentFn.block.addComment("'\"'")
        self._currentFn.block.buildStoreB(Value.Int(34), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
      }

      val strValLen = self._currentFn.block.buildLoadL(strVal)
      val strValChars = self._currentFn.block.buildLoadL(try self._currentFn.block.buildAdd(Value.Int(8), strVal) else |e| return qbeError(e))
      self._currentFn.block.buildVoidCall(Callable.Function(self._memcpy), [cursor, strValChars, strValLen])
      cursor = try self._currentFn.block.buildAdd(cursor, strValLen, Some("str_cursor")) else |e| return qbeError(e)

      if isString {
        self._currentFn.block.addComment("'\"'")
        self._currentFn.block.buildStoreB(Value.Int(34), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
      }

      if idx != reprVals.length - 1 {
        self._currentFn.block.addComment("\", \"")
        self._currentFn.block.buildStoreB(Value.Int(44), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
        self._currentFn.block.buildStoreB(Value.Int(32), cursor)
        cursor = try self._currentFn.block.buildAdd(cursor, Value.Int(1), Some("str_cursor")) else |e| return qbeError(e)
      }
    }

    self._currentFn.block.addComment("')'")
    self._currentFn.block.buildStoreB(Value.Int(41), cursor)

    Ok(newStr)
  }

  func _getOrCompileIntToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")
    val intTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist")

    val typeName = try self._structTypeName(self._project.preludeIntStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Int#toString(self): String")
    val selfParam = fnVal.addParameter("self", intTypeQbe)

    val intFmtPtr = self._builder.buildGlobalString("%lld")
    val sizeVal = try fnVal.block.buildCall(Callable.Function(self._snprintf), [Value.Int(0), Value.Int(0), intFmtPtr, selfParam]) else |e| return qbeError(e)
    val mallocSizeVal = try fnVal.block.buildAdd(Value.Int(1), sizeVal) else |e| return qbeError(e)

    val mem = try self._callMalloc(mallocSizeVal)
    try fnVal.block.buildCall(Callable.Function(self._snprintf), [mem, mallocSizeVal, intFmtPtr, selfParam]) else |e| return qbeError(e)

    val str = try self._constructString(mem, sizeVal)
    fnVal.block.buildReturn(Some(str))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileFloatToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")
    val floatTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist")

    val typeName = try self._structTypeName(self._project.preludeFloatStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Float#toString(self): String")
    val selfParam = fnVal.addParameter("self", floatTypeQbe)

    val floatFmtPtr = self._builder.buildGlobalString("%g")
    val sizeVal = try fnVal.block.buildCall(Callable.Function(self._snprintf), [Value.Int(0), Value.Int(0), floatFmtPtr, selfParam]) else |e| return qbeError(e)
    val mallocSizeVal = try fnVal.block.buildAdd(Value.Int(1), sizeVal) else |e| return qbeError(e)

    val mem = try self._callMalloc(mallocSizeVal)
    try fnVal.block.buildCall(Callable.Function(self._snprintf), [mem, mallocSizeVal, floatFmtPtr, selfParam]) else |e| return qbeError(e)

    val str = try self._constructString(mem, sizeVal)
    fnVal.block.buildReturn(Some(str))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileBoolToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")
    val boolTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist")

    val typeName = try self._structTypeName(self._project.preludeBoolStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("Bool#toString(self): String")
    val selfParam = fnVal.addParameter("self", boolTypeQbe)

    val labelIfTrue = fnVal.block.addLabel("if_true")
    val labelIfFalse = fnVal.block.addLabel("if_false")
    fnVal.block.buildJnz(selfParam, labelIfTrue, labelIfFalse)

    fnVal.block.registerLabel(labelIfTrue)
    val trueStrData = self._builder.buildGlobalString("true")
    val trueStr = try self._constructString(trueStrData, Value.Int(4))
    fnVal.block.buildReturn(Some(trueStr))

    fnVal.block.registerLabel(labelIfFalse)
    val falseStrData = self._builder.buildGlobalString("false")
    val falseStr = try self._constructString(falseStrData, Value.Int(5))
    fnVal.block.buildReturn(Some(falseStr))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileStringToStringMethod(self): Result<QbeFunction, CompileError> {
    val stringTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveString), "string qbe type should exist")

    val typeName = try self._structTypeName(self._project.preludeStringStruct)
    val methodName = "$typeName..toString"
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(stringTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal

    fnVal.addComment("String#toString(self): String")
    val selfParam = fnVal.addParameter("self", stringTypeQbe)
    fnVal.block.buildReturn(Some(selfParam))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn

    Ok(fnVal)
  }

  func _getOrCompileEqMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val (selfTy, _) = try self._getInstanceTypeForType(ty)
    val (methodName, fn) = match selfTy {
      StructOrEnum.Struct(struct) => {
        val boolTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist")

        // TODO: surely there's a cleaner way to represent these built-in eq methods
        if struct == self._project.preludeIntStruct {
          val intTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist")

          val methodName = "Int..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Int#eq(self, other: Int): Bool")
          val selfParam = fnVal.addParameter("self", intTypeQbe)
          val otherParam = fnVal.addParameter("other", intTypeQbe)
          val res = try self._currentFn.block.buildCompareEq(selfParam, otherParam) else |e| return qbeError(e)
          fnVal.block.buildReturn(Some(self._currentFn.block.buildExt(res, false)))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeFloatStruct {
          val floatTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist")

          val methodName = "Float..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Float#eq(self, other: Float): Bool")
          val selfParam = fnVal.addParameter("self", floatTypeQbe)
          val otherParam = fnVal.addParameter("other", floatTypeQbe)
          val res = try self._currentFn.block.buildCompareEq(selfParam, otherParam) else |e| return qbeError(e)
          fnVal.block.buildReturn(Some(self._currentFn.block.buildExt(res, false)))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeBoolStruct {
          val methodName = "Bool..eq"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Bool#eq(self, other: Bool): Bool")
          val selfParam = fnVal.addParameter("self", boolTypeQbe)
          val otherParam = fnVal.addParameter("other", boolTypeQbe)
          val res = try self._currentFn.block.buildCompareEq(selfParam, otherParam) else |e| return qbeError(e)
          fnVal.block.buildReturn(Some(self._currentFn.block.buildExt(res, false)))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }

        val _fn = struct.instanceMethods.find(m => m.label.name == "eq")
        val fn = if _fn |f| f else unreachable("every struct has an eq method defined")

        (try self._structMethodFnName(struct, fn), fn)
      }
      StructOrEnum.Enum(enum_) => {
        val _fn = enum_.instanceMethods.find(m => m.label.name == "eq")
        val fn = if _fn |f| f else unreachable("every enum has an eq method defined")

        (try self._enumMethodFnName(enum_, fn), fn)
      }
    }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated return self._compileGeneratedEqMethod(ty, fn)

    self._getOrCompileMethod(ty, fn)
  }

  func _compileGeneratedEqMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val boolTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist")

    val (selfTy, typeArgs) = try self._getInstanceTypeForType(selfType)
    val selfInstanceTy = Type(kind: TypeKind.Instance(selfTy, typeArgs))

    val methodName = try self._methodFnName(selfTy, fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(boolTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val selfTyQbe = try self._getQbeTypeForTypeExpect(selfInstanceTy, "unacceptable type for self")
    val selfParamVal = fnVal.addParameter("self", selfTyQbe)
    val otherParamVal = fnVal.addParameter("other", selfTyQbe)

    match selfTy {
      StructOrEnum.Struct(struct) => {
        val data: (String, Position, Type)[] = []

        val isTuple = self._isTupleStruct(struct)
        for field in struct.fields {
          val fieldName = if isTuple "" else field.name.name
          data.push((fieldName, field.name.position, field.ty))
        }

        try self._emitEqLogicForStructuredData(selfParamVal, otherParamVal, data)
      }
      StructOrEnum.Enum(enum_) => {
        val selfVariantIdxVal = self._emitGetEnumVariantIdx(selfParamVal)
        val otherVariantIdxVal = self._emitGetEnumVariantIdx(otherParamVal)

        val labelVariantsNeq = self._currentFn.block.addLabel("variants_not_eq")
        val labelVariantsEq = self._currentFn.block.addLabel("variants_eq")

        val cond = try self._currentFn.block.buildCompareEq(selfVariantIdxVal, otherVariantIdxVal) else |e| return qbeError(e)
        self._currentFn.block.buildJnz(cond, labelVariantsEq, labelVariantsNeq)

        self._currentFn.block.registerLabel(labelVariantsNeq)
        self._currentFn.block.addComment("return false")
        self._currentFn.block.buildReturn(Some(Value.Int(0)))

        self._currentFn.block.registerLabel(labelVariantsEq)

        var labelElse = self._currentFn.block.addLabel("__initial")
        val labelEnd = self._currentFn.block.addLabel("unreachable")

        for variant, idx in enum_.variants {
          if idx != 0 {
            self._currentFn.block.registerLabel(labelElse)
          }

          val cond = try self._currentFn.block.buildCompareEq(Value.Int(idx), selfVariantIdxVal) else |e| return qbeError(e)

          val labelThen = self._currentFn.block.addLabel("variant_${variant.label.name}")
          if idx != enum_.variants.length - 1 {
            labelElse = self._currentFn.block.addLabel("next")
            self._currentFn.block.buildJnz(cond, labelThen, labelElse)
          } else {
            self._currentFn.block.buildJnz(cond, labelThen, labelEnd)
          }

          self._currentFn.block.registerLabel(labelThen)
          match variant.kind {
            EnumVariantKind.Constant => {
              self._currentFn.block.addComment("return true")
              self._currentFn.block.buildReturn(Some(Value.Int(1)))
            }
            EnumVariantKind.Container(fields) => {
              val data: (String, Position, Type)[] = []
              for field in fields {
                data.push((field.name.name, field.name.position, field.ty))
              }
              val selfPtr = try self._emitGetEnumVariantValueStart(selfParamVal)
              val otherPtr = try self._emitGetEnumVariantValueStart(otherParamVal)
              try self._emitEqLogicForStructuredData(selfPtr, otherPtr, data)
            }
          }
        }

        self._currentFn.block.registerLabel(labelEnd)
        self._currentFn.block.buildHalt()
      }
    }

    fnVal.addComment(try self._fnSignature(Some(selfTy), fn))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(fnVal)
  }

  func _emitEqLogicForStructuredData(self, selfPtr: Value, otherPtr: Value, data: (String, Position, Type)[]): Result<Int, CompileError> {
    var offset = 0
    for (itemName, itemPosition, itemType) in data {
      val itemTy = try self._getQbeTypeForTypeExpect(itemType, "unacceptable type for item", Some(itemPosition))

      val selfMemCursor = try self._currentFn.block.buildAdd(Value.Int(offset), selfPtr, Some("self_mem_offset_$itemName")) else |e| return qbeError(e)
      val selfItemVal = self._currentFn.block.buildLoad(itemTy, selfMemCursor)
      val otherMemCursor = try self._currentFn.block.buildAdd(Value.Int(offset), otherPtr, Some("other_mem_offset_$itemName")) else |e| return qbeError(e)
      val otherItemVal = self._currentFn.block.buildLoad(itemTy, otherMemCursor)

      val labelNeq = self._currentFn.block.addLabel("${itemName}_vals_not_equal")
      val labelEq = self._currentFn.block.addLabel("${itemName}_vals_equal")

      val fieldsEqVal = try self._compileEqLogic(selfItemVal, otherItemVal, itemType, itemPosition)
      self._currentFn.block.buildJnz(fieldsEqVal, labelEq, labelNeq)

      self._currentFn.block.registerLabel(labelNeq)
      self._currentFn.block.addComment("return false")
      self._currentFn.block.buildReturn(Some(Value.Int(0)))

      self._currentFn.block.registerLabel(labelEq)

      offset += itemTy.size()
    }

    self._currentFn.block.addComment("return true")
    self._currentFn.block.buildReturn(Some(Value.Int(1)))

    Ok(0)
  }

  func _getOrCompileHashMethod(self, ty: Type): Result<QbeFunction, CompileError> {
    val (selfTy, _) = try self._getInstanceTypeForType(ty)
    val (methodName, fn) = match selfTy {
      StructOrEnum.Struct(struct) => {
        val intTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist")

        // TODO: surely there's a cleaner way to represent these built-in hash methods
        if struct == self._project.preludeIntStruct {
          val methodName = "Int..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Int#hash(self): Int")
          val selfParam = fnVal.addParameter("self", intTypeQbe)
          fnVal.block.buildReturn(Some(selfParam))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeFloatStruct {
          val floatTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveFloat), "float qbe type should exist")

          val methodName = "Float..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Float#hash(self): Int")
          val selfParam = fnVal.addParameter("self", floatTypeQbe)
          val res = self._currentFn.block.buildCastD(selfParam)
          fnVal.block.buildReturn(Some(res))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }
        if struct == self._project.preludeBoolStruct {
          val boolTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveBool), "bool qbe type should exist")

          val methodName = "Bool..hash"
          if self._builder.getFunction(methodName) |fn| return Ok(fn)

          val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
          val prevFn = self._currentFn
          self._currentFn = fnVal

          fnVal.addComment("Bool#hash(self): Int")
          val selfParam = fnVal.addParameter("self", boolTypeQbe)
          val res = self._currentFn.block.buildExt(value: selfParam, signed: false)
          fnVal.block.buildReturn(Some(res))

          try fnVal.block.verify() else |e| return qbeError(e)

          self._currentFn = prevFn

          return Ok(fnVal)
        }

        val _fn = struct.instanceMethods.find(m => m.label.name == "hash")
        val fn = if _fn |f| f else unreachable("every struct has a hash method defined")

        (try self._structMethodFnName(struct, fn), fn)
      }
      StructOrEnum.Enum(enum_) => {
        val _fn = enum_.instanceMethods.find(m => m.label.name == "hash")
        val fn = if _fn |f| f else unreachable("every enum has a hash method defined")

        (try self._enumMethodFnName(enum_, fn), fn)
      }
    }
    if self._builder.getFunction(methodName) |fn| return Ok(fn)

    if fn.isGenerated return self._compileGeneratedHashMethod(ty, fn)

    self._getOrCompileMethod(ty, fn)
  }

  func _compileGeneratedHashMethod(self, selfType: Type, fn: Function): Result<QbeFunction, CompileError> {
    val intTypeQbe = try self._getQbeTypeForTypeExpect(Type(kind: TypeKind.PrimitiveInt), "int qbe type should exist")

    val (selfTy, typeArgs) = try self._getInstanceTypeForType(selfType)
    val selfInstanceTy = Type(kind: TypeKind.Instance(selfTy, typeArgs))

    val methodName = try self._methodFnName(selfTy, fn)

    val fnVal = self._builder.buildFunction(name: methodName, returnType: Some(intTypeQbe))
    val prevFn = self._currentFn
    self._currentFn = fnVal
    val prevFunction = self._currentFunction
    self._currentFunction = Some(fn)

    val selfTyQbe = try self._getQbeTypeForTypeExpect(selfInstanceTy, "unacceptable type for self")
    val selfParamVal = fnVal.addParameter("self", selfTyQbe)

    match selfTy {
      StructOrEnum.Struct(struct) => {
        val data: (String, Position, Type)[] = []
        val isTuple = self._isTupleStruct(struct)
        for field in struct.fields {
          val fieldName = if isTuple "" else field.name.name
          data.push((fieldName, field.name.position, field.ty))
        }

        try self._emitHashLogicForStructuredData(selfParamVal, data)
      }
      StructOrEnum.Enum(enum_) => {
        val variantIdxVal = self._emitGetEnumVariantIdx(selfParamVal)

        var labelElse = self._currentFn.block.addLabel("__initial")
        val labelEnd = self._currentFn.block.addLabel("unreachable")

        for variant, idx in enum_.variants {
          if idx != 0 {
            self._currentFn.block.registerLabel(labelElse)
          }

          val cond = try self._currentFn.block.buildCompareEq(Value.Int(idx), variantIdxVal) else |e| return qbeError(e)

          val labelThen = self._currentFn.block.addLabel("variant_${variant.label.name}")
          if idx != enum_.variants.length - 1 {
            labelElse = self._currentFn.block.addLabel("next")
            self._currentFn.block.buildJnz(cond, labelThen, labelElse)
          } else {
            self._currentFn.block.buildJnz(cond, labelThen, labelEnd)
          }

          self._currentFn.block.registerLabel(labelThen)
          match variant.kind {
            EnumVariantKind.Constant => {
              self._currentFn.block.buildReturn(Some(variantIdxVal))
            }
            EnumVariantKind.Container(fields) => {
              val data: (String, Position, Type)[] = []
              for field in fields {
                data.push((field.name.name, field.name.position, field.ty))
              }
              val selfPtr = try self._emitGetEnumVariantValueStart(selfParamVal)
              try self._emitHashLogicForStructuredData(selfPtr, data)
            }
          }
        }

        self._currentFn.block.registerLabel(labelEnd)
        self._currentFn.block.buildHalt()
      }
    }

    fnVal.addComment(try self._fnSignature(Some(selfTy), fn))

    try fnVal.block.verify() else |e| return qbeError(e)

    self._currentFn = prevFn
    self._currentFunction = prevFunction

    Ok(fnVal)
  }

  func _emitHashLogicForStructuredData(self, selfPtr: Value, data: (String, Position, Type)[]): Result<Int, CompileError> {
    var retVal = Value.Int(1)
    var offset = 0
    for (itemName, itemPosition, itemType) in data {
      val itemTy = try self._getQbeTypeForTypeExpect(itemType, "unacceptable type for item", Some(itemPosition))

      val memCursor = try self._currentFn.block.buildAdd(Value.Int(offset), selfPtr, Some("self_mem_offset_$itemName")) else |e| return qbeError(e)
      val itemVal = self._currentFn.block.buildLoad(itemTy, memCursor)

      val itemInstanceType = try self._addResolvedGenericsLayerForInstanceMethod(itemType, "hash", itemPosition)
      val itemHashFnVal = try self._getOrCompileHashMethod(itemType)
      self._resolvedGenerics.popLayer()

      val fnName = self._functionName("hash", FunctionKind.InstanceMethod(Some((try self._getInstanceTypeForType(itemType))[0])))
      val frameCtx = CallframeContext(position: itemPosition, callee: Some(fnName))
      val itemHashVal = try self._buildCall(Some(frameCtx), Callable.Function(itemHashFnVal), [itemVal])
      val newPart = try self._currentFn.block.buildMul(Value.Int(31), itemHashVal) else |e| return qbeError(e)
      retVal = try self._currentFn.block.buildAdd(retVal, newPart) else |e| return qbeError(e)

      offset += itemTy.size()
    }

    self._currentFn.block.buildReturn(Some(retVal))

    Ok(0)
  }

  func _callMalloc(self, sizeVal: Value, localName: String? = None): Result<Value, CompileError> {
    val mem = try self._currentFn.block.buildCall(Callable.Function(self._malloc), [sizeVal], localName) else |e| return qbeError(e)

    // val labelIsZero = self._currentFn.block.addLabel("malloc_is_zero")
    // val labelCont = self._currentFn.block.addLabel("malloc_is_nonzero")
    // self._currentFn.block.buildJnz(mem, labelCont, labelIsZero)

    // self._currentFn.block.registerLabel(labelIsZero)
    // self._currentFn.block.buildHalt()

    // self._currentFn.block.registerLabel(labelCont)

    Ok(mem)
  }

  func _buildStackAllocForQbeType(self, ty: QbeType, name: String? = None): Value {
    match ty {
      QbeType.U8 => self._currentFn.block.buildAlloc8(1, name)      // 'b'
      QbeType.U16 => self._currentFn.block.buildAlloc4(1, name)     // 'h'
      QbeType.U32 => self._currentFn.block.buildAlloc4(1, name)     // 'w'
      QbeType.U64 => self._currentFn.block.buildAlloc8(1, name)     // 'l'
      QbeType.Pointer => self._currentFn.block.buildAlloc8(1, name) // 'l'
      QbeType.F32 => self._currentFn.block.buildAlloc4(1, name)     // 's'
      QbeType.F64 => self._currentFn.block.buildAlloc8(1, name)     // 'd'
    }
  }

  func _emitGetEnumVariantIdx(self, enumVariantVal: Value): Value = self._currentFn.block.buildLoadL(enumVariantVal)
  func _emitGetEnumVariantValueStart(self, enumVariantVal: Value): Result<Value, CompileError> {
    val res = try self._currentFn.block.buildAdd(Value.Int(QbeType.U64.size()), enumVariantVal) else |e| return qbeError(e)
    Ok(res)
  }

  func _emitOptValueIsSomeVariant(self, exprVal: Value, negate = false): Result<Value, CompileError> {
    val variantIdx = self._emitGetEnumVariantIdx(exprVal)
    val optionSomeVariantIdx = if self._project.preludeOptionEnum.variants.findIndex(v => v.label.name == "Some") |(_, idx)| idx else unreachable("Option.Some must exist")
    if negate {
      val res = try self._currentFn.block.buildCompareNeq(variantIdx, Value.Int(optionSomeVariantIdx)) else |e| return qbeError(e)
      Ok(res)
    } else {
      val res = try self._currentFn.block.buildCompareEq(variantIdx, Value.Int(optionSomeVariantIdx)) else |e| return qbeError(e)
      Ok(res)
    }
  }

  func _emitOptValueGetValue(self, ty: QbeType, exprVal: Value): Result<Value, CompileError> {
    val valueSlot = try self._emitGetEnumVariantValueStart(exprVal)
    val value = self._currentFn.block.buildLoad(ty, valueSlot)

    Ok(value)
  }

  func _emitResultValueIsOkVariant(self, exprVal: Value, negate = false): Result<Value, CompileError> {
    val variantIdx = self._emitGetEnumVariantIdx(exprVal)
    val resultOkVariantIdx = if self._project.preludeResultEnum.variants.findIndex(v => v.label.name == "Ok") |(_, idx)| idx else unreachable("Result.Ok must exist")
    if negate {
      val res = try self._currentFn.block.buildCompareNeq(variantIdx, Value.Int(resultOkVariantIdx)) else |e| return qbeError(e)
      Ok(res)
    } else {
      val res = try self._currentFn.block.buildCompareEq(variantIdx, Value.Int(resultOkVariantIdx)) else |e| return qbeError(e)
      Ok(res)
    }
  }

  func _emitResultValueGetValue(self, ty: QbeType, exprVal: Value): Result<Value, CompileError> {
    val valueSlot = try self._emitGetEnumVariantValueStart(exprVal)
    val value = self._currentFn.block.buildLoad(ty, valueSlot)

    Ok(value)
  }

  func _addResolvedGenericsLayerForInstanceMethod(self, ty: Type, methodName: String, position: Position, resolvedGenerics: Map<String, Type> = {}): Result<Type, CompileError> {
    val (structOrEnum, typeArgs) = try self._getInstanceTypeForType(ty)
    val (template, selfInstanceType) = match structOrEnum {
      StructOrEnum.Struct(struct) => {
        val template = Type(kind: TypeKind.Instance(structOrEnum, struct.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val inst = Type(kind: TypeKind.Instance(structOrEnum, typeArgs))

        (template, inst)
      }
      StructOrEnum.Enum(enum_) => {
        val template = Type(kind: TypeKind.Instance(structOrEnum, enum_.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val inst = Type(kind: TypeKind.Instance(structOrEnum, typeArgs))

        (template, inst)
      }
    }
    for (name, ty) in selfInstanceType.extractGenerics(template) {
      resolvedGenerics[name] = ty
    }
    val layerName = match structOrEnum {
      StructOrEnum.Struct(struct) => "${struct.label.name}.$methodName"
      StructOrEnum.Enum(enum_) => "${enum_.label.name}.$methodName"
    }
    match self._resolvedGenerics.addLayer(layerName, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: layerName, message: e))) }

    Ok(selfInstanceType)
  }

  func _addResolvedGenericsLayerForEnumVariant(self, ty: Type, variantName: String, position: Position, resolvedGenerics: Map<String, Type> = {}): Result<Type, CompileError> {
    val (structOrEnum, typeArgs) = try self._getInstanceTypeForType(ty)
    match structOrEnum {
      StructOrEnum.Struct => unreachable("type should always be an enum here")
      StructOrEnum.Enum(enum_) => {
        val template = Type(kind: TypeKind.Instance(structOrEnum, enum_.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
        val selfInstanceType = Type(kind: TypeKind.Instance(structOrEnum, typeArgs))

        for (name, ty) in selfInstanceType.extractGenerics(template) {
          resolvedGenerics[name] = ty
        }

        val layerName = "${enum_.label.name}.$variantName"
        match self._resolvedGenerics.addLayer(layerName, resolvedGenerics) { Ok => {}, Err(e) => return Err(CompileError(position: position, kind: CompileErrorKind.ResolvedGenericsError(context: layerName, message: e))) }

        Ok(selfInstanceType)
      }
    }
  }

  func _functionStruct(self, arity: Int, hasReturnType: Bool): Struct {
    val name = if hasReturnType "Function$arity" else "UnitFunction$arity"

    if self._functionStructs[name] |struct| struct else {
      val dummyModuleId = 0
      val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      val typeParams = (if hasReturnType { ["_R"] } else []).concat(alphabet[:arity].split(""))
      val fields = [("_env", Type(kind: TypeKind.PrimitiveInt)), ("_ptr", Type(kind: TypeKind.PrimitiveInt)), ("_self", Type(kind: TypeKind.PrimitiveInt))]
      val struct = Struct.makeDummy(moduleId: dummyModuleId, name: name, typeParams: typeParams, fields: fields)

      self._functionStructs[name] = struct

      struct
    }
  }

  func _isFunctionStruct(self, struct: Struct): Bool = if self._functionStructs[struct.label.name] |s| s == struct else false

  func _tupleStruct(self, arity: Int): Struct {
    val name = "Tuple$arity"

    if self._tupleStructs[name] |struct| struct else {
      val dummyModuleId = 0
      val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      val typeParams = alphabet[:arity].split("")
      val fields = typeParams.map((p, idx) => ("_$idx", Type(kind: TypeKind.Generic(name: p))))
      val struct = Struct.makeDummy(moduleId: dummyModuleId, name: name, typeParams: typeParams, fields: fields)

      self._tupleStructs[name] = struct

      struct
    }
  }

  func _isTupleStruct(self, struct: Struct): Bool = if self._tupleStructs[struct.label.name] |s| s == struct else false

  func _getInstanceTypeForType(self, ty: Type): Result<(StructOrEnum, Type[]), CompileError> {
    match ty.kind {
      TypeKind.Any => unreachable("getInstanceTypeForType: Any")
      TypeKind.PrimitiveUnit => unreachable("getInstanceTypeForType: Unit")
      TypeKind.PrimitiveInt => Ok((StructOrEnum.Struct(self._project.preludeIntStruct), []))
      TypeKind.PrimitiveFloat => Ok((StructOrEnum.Struct(self._project.preludeFloatStruct), []))
      TypeKind.PrimitiveBool => Ok((StructOrEnum.Struct(self._project.preludeBoolStruct), []))
      TypeKind.PrimitiveString => Ok((StructOrEnum.Struct(self._project.preludeStringStruct), []))
      TypeKind.Never => unreachable("getInstanceTypeForType: Never")
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getInstanceTypeForType(ty) else unreachable("failed to resolve generic: '$name'")
      }
      TypeKind.Instance(structOrEnum, typeParams) => Ok((structOrEnum, typeParams))
      TypeKind.Tuple(types) => {
        val struct = self._tupleStruct(types.length)
        Ok((StructOrEnum.Struct(struct), types))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val hasReturn = returnType.kind != TypeKind.PrimitiveUnit
        val struct = self._functionStruct(paramTypes.length, hasReturn)

        val typeArgs = (if hasReturn { [returnType] } else []).concat(paramTypes.map(_p => _p[0]))
        Ok((StructOrEnum.Struct(struct), typeArgs))
      }
      TypeKind.Type(structOrEnum) => Ok((structOrEnum, []))
      TypeKind.Hole => unreachable("getInstanceTypeForType: Hole")
    }
  }

  func _getReprForType(self, ty: Type): Result<String, CompileError> {
    match ty.kind {
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getReprForType(ty) else unreachable("failed to resolve generic repr: '$name'")
      }
      TypeKind.Instance(structOrEnum, typeParams) => {
        val n = match structOrEnum {
          StructOrEnum.Struct(struct) => struct.label.name
          StructOrEnum.Enum(_enum) => _enum.label.name
        }
        if !typeParams.isEmpty() {
          val params: String[] = []
          for p in typeParams {
            params.push(try self._getReprForType(p))
          }

          Ok("$n<${params.join(", ")}>")
        } else {
          Ok(n)
        }
      }
      TypeKind.Tuple(types) => {
        val struct = self._tupleStruct(types.length)
        self._getReprForType(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), types)))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val hasReturn = returnType.kind != TypeKind.PrimitiveUnit
        val struct = self._functionStruct(paramTypes.length, hasReturn)

        val typeArgs = (if hasReturn { [returnType] } else []).concat(paramTypes.map(_p => _p[0]))
        self._getReprForType(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs)))
      }
      _ => Ok(ty.repr())
    }
  }

  func _getNameForType(self, ty: Type): Result<String, CompileError> {
    match ty.kind {
      TypeKind.Generic(name) => {
        if self._resolvedGenerics.resolveGeneric(name) |ty| self._getNameForType(ty) else unreachable("failed to resolve generic repr: '$name'")
      }
      TypeKind.Instance(structOrEnum, typeParams) => {
        val n = match structOrEnum {
          StructOrEnum.Struct(struct) => struct.label.name
          StructOrEnum.Enum(_enum) => _enum.label.name
        }
        if !typeParams.isEmpty() {
          val params: String[] = []
          for p in typeParams {
            params.push(try self._getNameForType(p))
          }

          Ok("$n.${params.join(".")}")
        } else {
          Ok(n)
        }
      }
      TypeKind.Tuple(types) => {
        val struct = self._tupleStruct(types.length)
        self._getNameForType(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), types)))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val hasReturn = returnType.kind != TypeKind.PrimitiveUnit
        val struct = self._functionStruct(paramTypes.length, hasReturn)

        val typeArgs = (if hasReturn { [returnType] } else []).concat(paramTypes.map(_p => _p[0]))
        self._getNameForType(Type(kind: TypeKind.Instance(StructOrEnum.Struct(struct), typeArgs)))
      }
      _ => Ok(ty.repr())
    }
  }

  // Each module's root code is wrapped in a specially-named function; this function name
  // starts with two dots, which is not possible in ordinary Abra source code and will
  // thus introduce no conflicts (qbe doesn't care about function name rules).
  func _moduleWrapperFnName(self, module: TypedModule): String = "..module_${module.id}"

  func _globalVarName(self, modId: Int, name: String): String = "mod${modId}_${name}.slot"

  func _functionName(self, name: String, kind: FunctionKind): String {
    match kind {
      FunctionKind.Standalone => name
      FunctionKind.InstanceMethod(structOrEnumOpt) => match structOrEnumOpt {
        StructOrEnum.Struct(s) => "${s.label.name}.$name"
        StructOrEnum.Enum(e) => "${e.label.name}.$name"
        _ => name
      }
      FunctionKind.StaticMethod(structOrEnum) => match structOrEnum {
        StructOrEnum.Struct(s) => "${s.label.name}#$name"
        StructOrEnum.Enum(e) => "${e.label.name}#$name"
      }
    }
  }

  func _structTypeName(self, struct: Struct): Result<String, CompileError> {
    val base = ".${struct.moduleId}.${struct.label.name}"
    val name = if !struct.typeParams.isEmpty() {
      val parts: String[] = []
      for name in struct.typeParams {
        val repr = if self._resolvedGenerics.resolveGeneric(name) |ty| {
          try self._getNameForType(ty)
        } else {
          unreachable("could not resolve '$name'")
        }
        parts.push(repr)
      }
      "$base.${parts.join(".")}"
    } else {
      base
    }

    // qbe limits its identifiers to 80 chars, so if the resulting type name is long, we instead use a randomly-generated alias
    // in place of the type. 16 chars seems like a good balance between long enough that there won't be any conflicts, but also
    // short enough that there's enough room for this type to be used as a generic in other types without making that type's or
    // function's identifier too long.
    if name.length >= 70 {
      val alias = if self._aliasedTypeNames[name] |alias| alias else {
        val replacement = String.random(16)
        self._aliasedTypeNames[name] = replacement
        replacement
      }
      Ok(alias)
    } else {
      Ok(name)
    }
  }
  func _structInitializerFnName(self, struct: Struct): Result<String, CompileError> {
    val structTypeName = try self._structTypeName(struct)
    Ok("$structTypeName.init")
  }

  func _enumTypeNameBase(self, enum_: Enum): String = ".${enum_.moduleId}.${enum_.label.name}"
  func _enumTypeName(self, enum_: Enum): Result<String, CompileError> {
    val base = self._enumTypeNameBase(enum_)
    val name = if !enum_.typeParams.isEmpty() {
      val parts: String[] = []
      for name in enum_.typeParams {
        val repr = if self._resolvedGenerics.resolveGeneric(name) |ty| {
          try self._getNameForType(ty)
        } else {
          unreachable("could not resolve '$name'")
        }
        parts.push(repr)
      }
      "$base.${parts.join(".")}"
    } else {
      base
    }

    // qbe limits its identifiers to 80 chars, so if the resulting type name is long, we instead use a randomly-generated alias
    // in place of the type. 16 chars seems like a good balance between long enough that there won't be any conflicts, but also
    // short enough that there's enough room for this type to be used as a generic in other types without making that type's or
    // function's identifier too long.
    if name.length >= 80 {
      val alias = if self._aliasedTypeNames[name] |alias| alias else {
        val replacement = String.random(40)
        self._aliasedTypeNames[name] = replacement
        replacement
      }
      Ok(alias)
    } else {
      Ok(name)
    }
  }
  func _enumVariantFnName(self, enum_: Enum, variant: TypedEnumVariant): Result<String, CompileError> {
    val enumTypeName = try self._enumTypeName(enum_)
    Ok("$enumTypeName.${variant.label.name}")
  }

  func _fnName(self, fn: Function): String = ".${fn.label.name}"
  func _structMethodFnName(self, struct: Struct, fn: Function): Result<String, CompileError> {
    val typeName = try self._structTypeName(struct)
    val sep = match fn.kind {
      FunctionKind.InstanceMethod => ".."
      _ => "."
    }
    Ok("${typeName}${sep}${fn.label.name}")
  }
  func _enumMethodFnName(self, enum_: Enum, fn: Function): Result<String, CompileError> {
    val typeName = try self._enumTypeName(enum_)
    val sep = match fn.kind {
      FunctionKind.InstanceMethod => ".."
      _ => "."
    }
    Ok("${typeName}${sep}${fn.label.name}")
  }

  func _methodFnName(self, structOrEnum: StructOrEnum, fn: Function): Result<String, CompileError> {
    match structOrEnum {
      StructOrEnum.Struct(struct) => self._structMethodFnName(struct, fn)
      StructOrEnum.Enum(enum_) => self._enumMethodFnName(enum_, fn)
    }
  }

  func _fnSignature(self, structOrEnum: StructOrEnum?, fn: Function, paramsNeedingDefaultValue: Bool[] = []): Result<String, CompileError> {
    val parts: String[] = []
    match structOrEnum {
      StructOrEnum.Struct(struct) => {
        parts.push(struct.label.name)
        if !struct.typeParams.isEmpty() {
          parts.push("<")
          for name, idx in struct.typeParams {
            val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else unreachable("(${struct.label.name}, ${fn.label.name}), could not resolve generic '$name'")
            parts.push(resolvedGeneric.repr())

            if idx != struct.typeParams.length - 1 { parts.push(", ") }
          }
          parts.push(">")
        }
        parts.push(match fn.kind { FunctionKind.InstanceMethod => "#", _ => "." })
      }
      StructOrEnum.Enum(enum_) => {
        parts.push(enum_.label.name)
        if !enum_.typeParams.isEmpty() {
          parts.push("<")
          for name, idx in enum_.typeParams {
            val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else unreachable("(${enum_.label.name}, ${fn.label.name}), could not resolve generic '$name'")
            parts.push(resolvedGeneric.repr())

            if idx != enum_.typeParams.length - 1 { parts.push(", ") }
          }
          parts.push(">")
        }
        parts.push(match fn.kind { FunctionKind.InstanceMethod => "#", _ => "." })
      }
      None => {}
    }
    parts.push(fn.label.name)
    if !fn.typeParams.isEmpty() {
      parts.push("<")
      for (_, typeParamLabel), idx in fn.typeParams {
        val name = typeParamLabel.name
        val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else unreachable("could not resolve generic '$name'")
        parts.push(resolvedGeneric.repr())

        if idx != fn.typeParams.length - 1 { parts.push(", ") }
      }
      parts.push(">")
    }
    parts.push("(")

    val args: String[] = []
    match fn.kind {
      FunctionKind.InstanceMethod => args.push("self")
      _ => {}
    }
    for param, idx in fn.params {
      val paramTyRepr = try self._getReprForType(param.ty)
      val paramGivenDefaultValue = paramsNeedingDefaultValue[idx] ?: false
      val suffix = if !!param.defaultValue && paramGivenDefaultValue { " = default" } else ""
      args.push("${param.label.name}: $paramTyRepr$suffix")
    }
    parts.push(args.join(", "))
    parts.push(")")

    if fn.returnType.kind != TypeKind.PrimitiveUnit {
      val returnTyRepr = try self._getReprForType(fn.returnType)
      parts.push(": $returnTyRepr")
    }

    Ok(parts.join())
  }

  func _structSignature(self, struct: Struct, fieldsNeedingDefaultValue: Bool[] = []): Result<String[], CompileError> {
    val firstLine = ["type ${struct.label.name}"]
    if !struct.typeParams.isEmpty() {
      firstLine.push("<")
      for name, idx in struct.typeParams {
        val resolvedGeneric = if self._resolvedGenerics.resolveGeneric(name) |ty| ty else unreachable("could not resolve generic '$name'")
        firstLine.push("$name = ${resolvedGeneric.repr()}")

        if idx != struct.typeParams.length - 1 { firstLine.push(", ") }
      }
      firstLine.push(">")
    }
    val parts = ["${firstLine.join()} {"]
    for field, idx in struct.fields {
      val fieldGivenDefaultValue = fieldsNeedingDefaultValue[idx] ?: false
      val suffix = if !!field.initializer && fieldGivenDefaultValue { " = default" } else ""
      parts.push("  ${field.name.name}: ${field.ty.repr()}$suffix")
    }
    parts.push("}")

    Ok(parts)
  }

  func _enumVariantSignature(self, enum_: Enum, variant: TypedEnumVariant, fieldsNeedingDefaultValue: Bool[] = []): Result<String, CompileError> {
    val parts: String[] = [enum_.label.name, ".", variant.label.name]
    match variant.kind {
      EnumVariantKind.Container(fields) => {
        parts.push("(")
        for field, idx in fields {
          val fieldTyRepr = try self._getReprForType(field.ty)
          val fieldGivenDefaultValue = fieldsNeedingDefaultValue[idx] ?: false
          val suffix = if !!field.initializer && fieldGivenDefaultValue { " = default" } else ""
          parts.push("${field.name.name}: $fieldTyRepr$suffix")
          if idx != fields.length - 1 {
            parts.push(", ")
          }
        }
        parts.push(")")
      }
      _ => {}
    }

    Ok(parts.join())
  }

  func _typeIsInt(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveInt || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeIntStruct), [])
  func _typeIsFloat(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveFloat || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeFloatStruct), [])
  func _typeIsBool(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveBool || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeBoolStruct), [])
  func _typeIsString(self, ty: Type): Bool = ty.kind == TypeKind.PrimitiveString || ty.kind == TypeKind.Instance(StructOrEnum.Struct(self._project.preludeStringStruct), [])

  // TODO: this is copied from Typechecker
  func _typeIsOption(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(structOrEnum, generics) => {
        match structOrEnum {
          StructOrEnum.Enum(enum_) => {
            if enum_ != self._project.preludeOptionEnum return None
            if generics[0] |innerTy| {
              Some(innerTy)
            } else {
              None
            }
          }
          _ => None
        }
      }
      _ => None
    }
  }
}
