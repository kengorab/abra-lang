// When executed directly, this will perform typechecking and compilation, using qbe[^1] as a
// simple backend. This file assumes it'll be called via the top-level `abra` script in the
// directory above, as that script takes the output ssa file and runs it through qbe, and then
// through clang to produce a binary, and then executes that binary.
// Eventually, that wrapper script will be unnecessary, but there currently isn't a way to shell
// out from within Abra.
//
// This is split out into a separate runnable file so that the test-specific code is never compiled into
// the actual resulting binary; this results in a separate binary being compiled which is only used for
// testing.
//
// [^1] https://c9x.me/compile

import "fs" as fs
import "process" as process
import getAbsolutePath from "./utils"
import ModuleLoader, Project, Typechecker from "./typechecker"
import Compiler from "./compiler"
import ComptimeFunctionEvaluator from "./comptime_evaluator"

func main() {
  val abraStdRoot = try process.getEnvVar("ABRA_HOME") else {
    stdoutWriteln("Could not find ABRA_HOME (make sure \$ABRA_HOME environment variable is set)")
    process.exit(1)
  }

  val args = process.args()

  if args[1] |fileName| {
    val absPathSegs = getAbsolutePath(fileName)
    val filePathAbs = "/" + absPathSegs.join("/")

    val moduleLoader = ModuleLoader(stdRoot: abraStdRoot)
    val project = Project()
    val comptimeFuncEvaluator = ComptimeFunctionEvaluator.init(project)

    val typechecker = Typechecker(
      moduleLoader: moduleLoader,
      project: project,
      comptimeFuncEvaluator: comptimeFuncEvaluator.eval,
    )
    val entryMod = typechecker.typecheckEntrypoint(filePathAbs)

    val readFileErrors: String[] = []
    val errorMessages: String[] = []
    for mod in project.modules.values().sortBy(m => -m.id) {
      if mod.readFileError {
        readFileErrors.push(mod.name)
        continue
      }
      val contents = try moduleLoader.loadFileContents(mod.name) else {
        readFileErrors.push(mod.name)
        continue
      }

      for err in mod.lexParseErrors {
        errorMessages.push(err.getMessage(mod.name, contents))
      }

      for err in mod.typeErrors {
        errorMessages.push(err.getMessage(mod.name, contents))
      }
    }

    if !errorMessages.isEmpty() {
      for msg, idx in errorMessages {
        stdoutWriteln(msg)
        if idx != errorMessages.length - 1 stdoutWriteln("") // spacer
      }
      process.exit(1)
    } else if !readFileErrors.isEmpty() {
      for path, idx in readFileErrors {
        stdoutWriteln("Could not read file '$path'")
        if idx != readFileErrors.length - 1 stdoutWriteln("") // spacer
      }
      process.exit(1)
    }

    val builder = match Compiler.compile(project, entryMod) {
      Ok(v) => v
      Err(e) => {
        stdoutWriteln(e.getMessage())
        process.exit(1)
      }
    }

    // TODO: right now the code assumes that the output file and directory will exist prior to writing
    // to it. Instead, we should create the directory and file if we need to.
    val cwd = fs.getCurrentWorkingDirectory()
    val ssaOutFileName = args[2] ?: "_main"
    val ssaOutPath = "$cwd/._abra/$ssaOutFileName.ssa"
    val ssaOutFile = match fs.openFile(ssaOutPath, fs.AccessMode.WriteOnly) {
      Ok(v) => v
      Err(e) => {
        stdoutWriteln(e.toString())
        process.exit(1)
      }
    }
    builder.writeToFile(ssaOutFile)
  } else {
    stdoutWriteln("Missing required argument <file-name>")
    process.exit(1)
  }
}

main()
