import "fs" as fs
import "meta" as meta
import getAbsolutePath, resolveRelativePath from "./utils"
import Lexer, LexerError, Token, TokenKind, Position from "./lexer"
import Parser, ParsedModule, ParseError, AstNode, AstNodeKind, LiteralAstNode, UnaryAstNode, UnaryOp, BinaryAstNode, BinaryOp, BindingDeclarationNode, BindingPattern, TypeIdentifier, Label, IdentifierKind, FunctionDeclarationNode, FunctionParam, InvocationAstNode, InvocationArgument, TypeDeclarationNode, EnumDeclarationNode, EnumVariant, AccessorAstNode, IndexingMode, AssignOp, AssignmentMode, ImportNode, ImportKind, DecoratorNode, LambdaNode, MatchCase, MatchCaseKind, ForIterKind from "./parser"

enum TokenizeAndParseError {
  ReadFileError(path: String)
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)
}

pub type ModuleLoader {
  pub stdRoot: String
  parsedModules: Map<String, ParsedModule> = {}
  _virtualFileSystem: Map<String, String>? = None

  func usingVirtualFileSystem(stdRoot: String, fileMap: Map<String, String>): ModuleLoader =
    ModuleLoader(stdRoot: stdRoot, _virtualFileSystem: Some(fileMap))

  func resolvePath(self, modulePath: String, relativeTo: String?): String {
    if relativeTo |relativeTo| {
      val pathParts = resolveRelativePath(path: modulePath, relativeTo: relativeTo)
      "/" + pathParts.join("/")
    } else {
      modulePath
    }
  }

  func hasSeenModule(self, modulePathAbs: String): Bool = self.parsedModules.containsKey(modulePathAbs)

  pub func invalidateModule(self, modulePathAbs: String) {
    self.parsedModules.remove(modulePathAbs)
  }

  pub func loadFileContents(self, modulePathAbs: String): String? {
    if self._virtualFileSystem |vfs| {
      val inMemContents = vfs[modulePathAbs]
      if inMemContents return inMemContents
    }

    match fs.readFile(modulePathAbs) {
      Ok(contents) => Some(contents)
      Err => None
    }
  }

  func tokenizeAndParse(self, modulePath: String): Result<ParsedModule, TokenizeAndParseError> {
    if self.parsedModules[modulePath] |m| return Ok(m)

    val contents = try self.loadFileContents(modulePath) else return Err(TokenizeAndParseError.ReadFileError(modulePath))
    val parsedModule = try tokenizeAndParse(contents) else |e| {
      return match e {
        LexerOrParseError.LexerError(e) => Err(TokenizeAndParseError.LexerError(e))
        LexerOrParseError.ParseError(e) => Err(TokenizeAndParseError.ParseError(e))
      }
    }
    self.parsedModules[modulePath] = parsedModule

    Ok(parsedModule)
  }
}

func tokenizeAndParse(contents: String): Result<ParsedModule, LexerOrParseError> {
  val tokens = try Lexer.tokenize(contents) else |e| return Err(LexerOrParseError.LexerError(e))
  val parsedModule = try Parser.parse(tokens) else |e| return Err(LexerOrParseError.ParseError(e))
  Ok(parsedModule)
}

pub enum Export {
  Variable(variable: Variable)
  Function(aliasVar: Variable)
  Type(instanceKind: InstanceKind, aliasVar: Variable)
}

pub type Import {
  label: Label
  kind: TypedImportKind
}

enum TypedImportKind {
  Variable(variable: Variable)
  Function(aliasVar: Variable)
  Type(instanceKind: InstanceKind, aliasVar: Variable)
}

type ImportedModule {
  aliases: Label[] = []
  imports: Map<String, Import> = {}
}

pub enum IdentifierKindMeta {
  Variable(mutable: Bool, typeRepr: String)
  Function(typeParams: String[], params: String[], returnTypeRepr: String, methodTy: (Bool, String)?)
  Type(isEnum: Bool, typeParams: String[])
  Module(moduleFilePath: String)
  Field(fieldTy: String, parentTypeRepr: String)
  EnumVariant(parentRepr: String, fields: String[])
}

pub enum IdentifierMetaModule {
  Prelude
  Module(filePath: String)
}

pub type IdentifierMeta {
  pub name: String
  pub kind: IdentifierKindMeta
  pub definitionPosition: (IdentifierMetaModule, Position)? = None
}

pub type TypedModule {
  pub id: Int
  pub name: String
  pub code: TypedAstNode[]
  pub rootScope: Scope
  pub isEntry: Bool = false
  complete: Bool = false
  imports: Map<String, ImportedModule> = {}
  pub exports: Map<String, Export> = {}
  pub identsByLine: Map<Int, (Int, Int, IdentifierMeta)[]> = {}
  pub readFileError: Bool = false
  pub startsCircDep: Bool = false
  pub lexParseErrors: LexerOrParseError[] = []
  pub typeErrors: TypeError[] = []

  func bogus(): TypedModule = TypedModule(id: -1, name: "bogus", code: [], rootScope: Scope.bogus())

  func addTypeError(self, err: TypeError) {
    self.typeErrors.push(err)
  }

  func hasError(self): Bool {
    if self.readFileError return true
    if self.startsCircDep return true
    if !self.lexParseErrors.isEmpty() return true
    if !self.typeErrors.isEmpty() return true

    false
  }
}

pub enum VariableAlias {
  Function(fn: Function)
  Struct(struct: Struct)
  Enum(enum_: Enum)
}

pub type Variable {
  pub label: Label
  pub scope: Scope
  pub mutable: Bool
  pub ty: Type
  pub alias: VariableAlias? = None
  pub isExported: Bool = false
  pub isParameter: Bool = false
  pub isCaptured: Bool = false

  func bogus(): Variable {
    val label = Label(name: "_bogus", position: Position.bogus())
    Variable(label: label, scope: Scope.bogus(), mutable: false, ty: Type(kind: TypeKind.Never))
  }

  pub func isGlobal(self): Int? = match self.scope.kind { ScopeKind.Module(id, _) => Some(id), _ => None }
}

pub enum Terminator {
  Returning
  NonReturning

  func combine(t1: Terminator?, t2: Terminator?): Terminator? {
    if t1 == Some(Terminator.Returning) && t2 == Some(Terminator.Returning) {
      Some(Terminator.Returning)
    } else if (t1 == Some(Terminator.NonReturning) && !!t2) || (t2 == Some(Terminator.NonReturning) && !!t1) {
      Some(Terminator.NonReturning)
    } else {
      None
    }
  }
}

pub enum ScopeKind {
  Root
  Module(id: Int, name: String)
  Func
  If
  MatchCase
  While
  For
  Type
  Try
}

pub type Scope {
  pub name: String
  pub variables: Variable[] = []
  pub functions: Function[] = []
  pub types: Type[] = []
  pub structs: Struct[] = []
  pub enums: Enum[] = []
  pub kind: ScopeKind = ScopeKind.Root
  pub parent: Scope? = None
  pub terminator: Terminator? = None
  pub idxInFn: Int = 0
  numLambdas: Int = 0

  pub func bogus(name = ""): Scope {
    val scopeName = if name == "" "bogus" else "bogus($name)"
    Scope(name: scopeName)
  }

  pub func eq(self, other: Scope): Bool = self.name == other.name

  pub func makeChild(self, name: String, kind: ScopeKind, idxInFn: Int = 0): Scope =
    Scope(name: "${self.name}::$name", kind: kind, parent: Some(self), idxInFn: idxInFn)

  func contains(self, other: Scope): Bool {
    var child = Some(other)
    while child |ch| {
      if self == ch return true
      child = ch.parent
    }

    false
  }

  pub func findParentModule(self): (Int, String)? {
    var sc = Some(self)
    while sc |s| {
      match s.kind {
        ScopeKind.Module(id, name) => return Some((id, name))
        else => sc = s.parent
      }
    }

    None
  }
}

pub enum BuiltinModule {
  Prelude
  Intrinsics
  Meta
}

pub type Field {
  pub name: Label
  pub ty: Type
  pub initializer: TypedAstNode?
  pub isPublic: Bool
}

pub type Struct {
  pub moduleId: Int
  pub label: Label
  pub scope: Scope
  pub typeParams: String[] = []
  pub fields: Field[] = []
  pub instanceMethods: Function[] = []
  pub staticMethods: Function[] = []
  pub builtin: BuiltinModule? = None
  pub isDecoratorType: Bool = false

  pub func makeDummy(moduleId: Int, name: String, typeParams: String[] = [], fields: (String, Type)[] = []): Struct {
    val bogusPosition = Position.bogus()
    val bogusScope = Scope.bogus(name)

    val struct = Struct(
      moduleId: moduleId,
      label: Label(name: name, position: bogusPosition),
      scope: bogusScope,
      typeParams: typeParams,
      fields: fields.map(_f => Field(name: Label(name: _f[0], position: bogusPosition), ty: _f[1], initializer: None, isPublic: false)),
      instanceMethods: [],
      staticMethods: [],
    )

    val instanceKind = InstanceKind.Struct(struct)
    val selfInstanceType = struct.asInstanceType()

    struct.instanceMethods.push(Function.generated(bogusScope, "toString", [], Type(kind: TypeKind.PrimitiveString), FunctionKind.InstanceMethod(Some(instanceKind), true)))
    struct.instanceMethods.push(Function.generated(bogusScope, "hash", [], Type(kind: TypeKind.PrimitiveInt), FunctionKind.InstanceMethod(Some(instanceKind), true)))
    struct.instanceMethods.push(Function.generated(bogusScope, "eq", [("other", selfInstanceType)], Type(kind: TypeKind.PrimitiveBool), FunctionKind.InstanceMethod(Some(instanceKind), true)))

    struct
  }

  // Override toString method since default implementation recurses infinitely (scope -> variables -> TypeKind.Struct)
  pub func toString(self): String = "Struct(moduleId: ${self.moduleId}, label: ${self.label}, ...)"

  // Override eq method since default implementation recurses infinitely (scope -> variables -> TypeKind.Struct)
  pub func eq(self, other: Struct): Bool = self.moduleId == other.moduleId && self.label == other.label

  // Override hash method since default implementation recurses infinitely (scope -> variables -> TypeKind.Struct)
  pub func hash(self): Int = self.moduleId + self.label.hash() * 17

  func asInstanceType(self): Type {
    val typeArgs = self.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
    Type(kind: TypeKind.Instance(InstanceKind.Struct(self), typeArgs))
  }
}

pub type TypedEnumVariant {
  pub label: Label
  pub kind: EnumVariantKind
}

pub enum EnumVariantKind {
  Constant
  Container(fields: Field[])
}

pub type Enum {
  pub moduleId: Int
  pub label: Label
  pub scope: Scope
  pub typeParams: String[] = []
  pub variants: TypedEnumVariant[] = []
  pub instanceMethods: Function[] = []
  pub staticMethods: Function[] = []
  builtin: BuiltinModule? = None

  func toString(self): String = "Enum(moduleId: ${self.moduleId}, label: ${self.label})"

  // Override eq method since default implementation recurses infinitely (scope -> variables -> TypeKind.Enum)
  func eq(self, other: Enum): Bool = self.moduleId == other.moduleId && self.label == other.label

  // Enums are used as Map keys when tracking completeness in match cases, and moduleId + label is enough to
  // uniquely identify an Enum and save work recursively hashing all other members
  func hash(self): Int = self.moduleId + self.label.hash() * 17

  func asInstanceType(self): Type {
    val typeArgs = self.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
    Type(kind: TypeKind.Instance(InstanceKind.Enum(self), typeArgs))
  }
}

// TODO: is type type necessary? can't it just basically be InstanceKind
enum Instantiatable {
  Struct(struct: Struct)
  EnumContainerVariant(enum_: Enum, variant: TypedEnumVariant, fields: Field[])
}

pub type Project {
  pub modules: Map<String, TypedModule> = {}
  pub preludeModule: TypedModule = TypedModule.bogus()
  pub preludeIntStruct: Struct = Struct(moduleId: 0, label: Label(name: "Int", position: Position.bogus()), scope: Scope(name: "Int"))
  pub preludeFloatStruct: Struct = Struct(moduleId: 0, label: Label(name: "Float", position: Position.bogus()), scope: Scope(name: "Float"))
  pub preludeBoolStruct: Struct = Struct(moduleId: 0, label: Label(name: "Bool", position: Position.bogus()), scope: Scope(name: "Bool"))
  pub preludeCharStruct: Struct = Struct(moduleId: 0, label: Label(name: "Char", position: Position.bogus()), scope: Scope(name: "Char"))
  pub preludeStringStruct: Struct = Struct(moduleId: 0, label: Label(name: "String", position: Position.bogus()), scope: Scope(name: "String"))
  pub preludeArrayStruct: Struct = Struct(moduleId: 0, label: Label(name: "Array", position: Position.bogus()), scope: Scope(name: "Array"), typeParams: ["T"])
  pub preludeMapStruct: Struct = Struct(moduleId: 0, label: Label(name: "Map", position: Position.bogus()), scope: Scope(name: "Array"), typeParams: ["K", "V"])
  pub preludeSetStruct: Struct = Struct(moduleId: 0, label: Label(name: "Set", position: Position.bogus()), scope: Scope(name: "Set"), typeParams: ["T"])
  pub preludeOptionEnum: Enum = Enum(moduleId: 0, label: Label(name: "Option", position: Position.bogus()), scope: Scope(name: "Option"), typeParams: ["T"])
  pub preludeResultEnum: Enum = Enum(moduleId: 0, label: Label(name: "Result", position: Position.bogus()), scope: Scope(name: "Result"), typeParams: ["V", "E"])
  pub metaMacroDecorator: Struct = Struct(moduleId: 0, label: Label(name: "macro", position: Position.bogus()), scope: Scope(name: "macro"))
  pub metaExprStruct: Struct = Struct(moduleId: 0, label: Label(name: "Expr", position: Position.bogus()), scope: Scope(name: "Expr"))
  pub metaInjectedCodeStruct: Struct = Struct(moduleId: 0, label: Label(name: "InjectedCode", position: Position.bogus()), scope: Scope(name: "InjectedCode"))

  pub func typesAreEquivalent(self, ty: Type, other: Type): Bool {
    if other.kind == TypeKind.CouldNotDetermine return true

    match ty.kind {
      TypeKind.CouldNotDetermine => true
      TypeKind.Hole => other.kind == TypeKind.Hole
      TypeKind.Generic(n1) => match other.kind {
        TypeKind.Generic(n2) => n1 == n2
        _ => false
      }
      TypeKind.PrimitiveInt => match other.kind {
        TypeKind.PrimitiveInt => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.preludeIntStruct)
        _ => false
      }
      TypeKind.PrimitiveFloat => match other.kind {
        TypeKind.PrimitiveFloat => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.preludeFloatStruct)
        _ => false
      }
      TypeKind.PrimitiveBool => match other.kind {
        TypeKind.PrimitiveBool => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.preludeBoolStruct)
        _ => false
      }
      TypeKind.PrimitiveChar => match other.kind {
        TypeKind.PrimitiveChar => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.preludeCharStruct)
        _ => false
      }
      TypeKind.PrimitiveString => match other.kind {
        TypeKind.PrimitiveString => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.preludeStringStruct)
        _ => false
      }
      TypeKind.Func(reqParamTypes, reqRetType) => match ty.kind {
        TypeKind.Func(paramTypes, retType) => {
          if !self.typesAreEquivalent(ty: retType, other: reqRetType) return false

          var idx = 0
          for (reqParamType, _), i in reqParamTypes {
            val (paramType, _) = try paramTypes[i] else return true
            if !self.typesAreEquivalent(ty: paramType, other: reqParamType) return false

            idx = i
          }
          if paramTypes[idx + 1] |(_, isRequired)| {
            if isRequired return false
          }

          true
        }
        _ => false
      }
      TypeKind.Instance(reqStructOrEnum, reqTypeArgs) => match ty.kind {
        TypeKind.Instance(instanceKind, typeArgs) => {
          if reqStructOrEnum != instanceKind return false
          if reqTypeArgs.length != typeArgs.length return false
          for reqTypeArg, i in reqTypeArgs {
            val typeArg = try typeArgs[i] else return true
            if !self.typesAreEquivalent(ty: typeArg, other: reqTypeArg) return false
          }

          true
        }
        TypeKind.PrimitiveInt => reqStructOrEnum == InstanceKind.Struct(self.preludeIntStruct)
        TypeKind.PrimitiveFloat => reqStructOrEnum == InstanceKind.Struct(self.preludeFloatStruct)
        TypeKind.PrimitiveBool => reqStructOrEnum == InstanceKind.Struct(self.preludeBoolStruct)
        TypeKind.PrimitiveChar => reqStructOrEnum == InstanceKind.Struct(self.preludeCharStruct)
        TypeKind.PrimitiveString => reqStructOrEnum == InstanceKind.Struct(self.preludeStringStruct)
        _ => false
      }
      TypeKind.Tuple(reqTypes) => match ty.kind {
        TypeKind.Tuple(types) => {
          if reqTypes.length != types.length return false
          for reqTy, i in reqTypes {
            val ty = try types[i] else unreachable("length verified above to be equal")
            if !self.typesAreEquivalent(ty: ty, other: reqTy) return false
          }

          true
        }
        _ => false
      }
      _ => false
    }
  }

  pub func typeIsOption(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(instanceKind, generics) => {
        match instanceKind {
          InstanceKind.Enum(enum_) => {
            if enum_ != self.preludeOptionEnum return None
            if generics[0] |innerTy| {
              Some(innerTy)
            } else {
              None
            }
          }
          _ => None
        }
      }
      _ => None
    }
  }

  pub func sortedModules(self): TypedModule[] {
    val modules = self.modules.values()
    val entry = try modules.find(m => m.isEntry) else {
      return self.modules.values().sortBy(m => m.id)
    }

    val visited: Set<Int> = #{}
    val result: TypedModule[] = Array.withCapacity(modules.length)
    self.dfs(self.preludeModule, visited, result)
    self.dfs(entry, visited, result)

    result
  }

  func dfs(self, mod: TypedModule, visited: Set<Int>, result: TypedModule[]) {
    if visited.contains(mod.id) return
    visited.insert(mod.id)

    for (importedModName, _) in mod.imports {
      val importedMod = try self.modules[importedModName] else unreachable("import '$importedModName' expected to exist")
      if !visited.contains(importedMod.id) {
        self.dfs(importedMod, visited, result)
      }
    }

    result.push(mod)
  }
}

pub type Type {
  pub kind: TypeKind

  pub func repr(self, shorthand = true): String {
    match self.kind {
      TypeKind.CouldNotDetermine => "<unknown>"
      TypeKind.PrimitiveUnit => "Unit"
      TypeKind.PrimitiveInt => "Int"
      TypeKind.PrimitiveFloat => "Float"
      TypeKind.PrimitiveBool => "Bool"
      TypeKind.PrimitiveChar => "Char"
      TypeKind.PrimitiveString => "String"
      TypeKind.Never => "Never"
      TypeKind.Generic(name) => name
      TypeKind.Instance(instanceKind, typeParams) => {
        match instanceKind {
          InstanceKind.Struct(struct) => {
            if shorthand && struct.builtin == Some(BuiltinModule.Prelude) && struct.label.name == "Array" {
              val innerRepr = typeParams[0]?.repr() ?: "<unknown>"
              "$innerRepr[]"
            } else {
              val genericsRepr = if typeParams.isEmpty() "" else {
                val reprs = typeParams.map(t => t.repr()).join(", ")
                "<$reprs>"
              }
              "${struct.label.name}$genericsRepr"
            }
          }
          InstanceKind.Enum(enum_) => {
            if shorthand && enum_.builtin == Some(BuiltinModule.Prelude) && enum_.label.name == "Option" {
              val innerRepr = typeParams[0]?.repr() ?: "<unknown>"
              "$innerRepr?"
            } else {
              val genericsRepr = if typeParams.isEmpty() "" else {
                val reprs = typeParams.map(t => t.repr()).join(", ")
                "<$reprs>"
              }
              "${enum_.label.name}$genericsRepr"
            }
          }
        }
      }
      TypeKind.Tuple(types) => "(${types.map(t => t.repr()).join(", ")})"
      TypeKind.Func(paramTypes, returnType) => {
        val paramsRepr = paramTypes.filter(p => p[1]).map(p => p[0].repr()).join(", ")
        val returnTypeRepr = returnType.repr()
        "($paramsRepr) => $returnTypeRepr"
      }
      TypeKind.Type(instanceKind) => match instanceKind {
        InstanceKind.Struct(struct) => "<#type ${struct.label.name}>"
        InstanceKind.Enum(enum_) => "<#enum ${enum_.label.name}>"
      }
      TypeKind.Hole => "<unknown>"
    }
  }

  func hasUnfilledHoles(self): Bool = match self.kind {
    TypeKind.CouldNotDetermine => false
    TypeKind.PrimitiveUnit => false
    TypeKind.PrimitiveInt => false
    TypeKind.PrimitiveFloat => false
    TypeKind.PrimitiveBool => false
    TypeKind.PrimitiveChar => false
    TypeKind.PrimitiveString => false
    TypeKind.Never => false
    TypeKind.Generic => false
    TypeKind.Instance(_, generics) => generics.any(t => t.hasUnfilledHoles())
    TypeKind.Tuple(types) => types.any(t => t.hasUnfilledHoles())
    TypeKind.Func(paramTypes, returnType) => paramTypes.any(t => t[0].hasUnfilledHoles()) || returnType.hasUnfilledHoles()
    TypeKind.Type => false
    TypeKind.Hole => true
  }

  func isInvalidValueType(self): Bool = self.kind == TypeKind.PrimitiveUnit || self.kind == TypeKind.Never || self.hasUnfilledHoles()

  func tryFillHoles(self, other: Type) {
    // TODO: this code is pretty ugly - I really need a way of destructuring multiple values simultaneously in `match`es
    match self.kind {
      TypeKind.Instance(selfStructOrEnum, selfTypeArgs) => {
        match other.kind {
          TypeKind.Instance(otherStructOrEnum, otherTypeArgs) => {
            if selfStructOrEnum != otherStructOrEnum return

            for typeArg, idx in selfTypeArgs {
              typeArg.tryFillHoles(otherTypeArgs[idx] ?: Type(kind: TypeKind.Hole))
            }
          }
          _ => {}
        }
      }
      TypeKind.Tuple(selfTypeArgs) => {
        match other.kind {
          TypeKind.Tuple(otherTypeArgs) => {
            for typeArg, idx in selfTypeArgs {
              typeArg.tryFillHoles(otherTypeArgs[idx] ?: Type(kind: TypeKind.Hole))
            }
          }
          _ => {}
        }
      }
      _ => {
        if self.kind == TypeKind.Hole {
          self.kind = other.kind
        }
      }
    }
  }

  func withSubstitutedGenerics(self, resolvedGenerics: Map<String, Type>, retainUnknown: Bool, genericsInScope: Set<String>): Type {
    val resultType = match self.kind {
      TypeKind.Generic(name) => {
        if resolvedGenerics[name] |substitute| {
          substitute
        } else if retainUnknown || genericsInScope.contains(name) {
          self
        } else {
          Type(kind: TypeKind.Hole)
        }
      }
      TypeKind.Instance(instanceKind, typeArgs) => {
        val substTypeArgs = typeArgs.map(ty => ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope))
        Type(kind: TypeKind.Instance(instanceKind, substTypeArgs))
      }
      TypeKind.Tuple(typeArgs) => {
        val substTypeArgs = typeArgs.map(ty => ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope))
        Type(kind: TypeKind.Tuple(substTypeArgs))
      }
      TypeKind.Func(paramTypes, returnType) => {
        val substParamTypes = paramTypes.map(p => {
          val t = p[0].withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)
          (t, p[1])
        })
        val substReturnType = returnType.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)
        Type(kind: TypeKind.Func(substParamTypes, substReturnType))
      }
      _ => self
    }

    resultType
  }

  func containsGenerics(self): Bool {
    match self.kind {
      TypeKind.Generic(name) => true
      TypeKind.Instance(_, typeArgs) => typeArgs.any(t => t.containsGenerics())
      TypeKind.Tuple(typeArgs) => typeArgs.any(t => t.containsGenerics())
      TypeKind.Func(paramTypes, returnType) => {
        if returnType.containsGenerics() return true

        paramTypes.any(p => p[0].containsGenerics())
      }
      _ => false
    }
  }

  func _extractGenerics(self, template: Type, extracted: (String, Type)[]): Bool {
    match template.kind {
      TypeKind.Generic(name) => {
        extracted.push((name, self))
      }
      TypeKind.Instance(templateStructOrEnum, templateTypeArgs) => {
        match self.kind {
          TypeKind.Instance(sourceStructOrEnum, sourceTypeArgs) => {
            if templateStructOrEnum != sourceStructOrEnum return false

            for tplTypeArg, idx in templateTypeArgs {
              val srcTypeArg = try sourceTypeArgs[idx] else unreachable("templateTypeArgs.length != sourceTypeArgs.length")
              if !srcTypeArg._extractGenerics(template: tplTypeArg, extracted: extracted) return false
            }
          }
          else => return false
        }
      }
      TypeKind.Tuple(templateTypes) => {
        match self.kind {
          TypeKind.Tuple(sourceTypes) => {
            for tplType, idx in templateTypes {
              val srcType = try sourceTypes[idx] else break
              if !srcType._extractGenerics(template: tplType, extracted: extracted) return false
            }
          }
          else => return false
        }
      }
      TypeKind.Func(templateParamTypes, templateReturnType) => {
        match self.kind {
          TypeKind.Func(sourceParamTypes, sourceReturnType) => {
            if !sourceReturnType._extractGenerics(template: templateReturnType, extracted: extracted) return false

            for (tplParamType, _), idx in templateParamTypes {
              val (srcParamType, _) = try sourceParamTypes[idx] else break
              if !srcParamType._extractGenerics(template: tplParamType, extracted: extracted) return false
            }
          }
          else => return false
        }
      }
      else => {}
    }

    true
  }

  pub func extractGenerics(self, template: Type): (String, Type)[] {
    val extracted: (String, Type)[] = []
    if !self._extractGenerics(template, extracted) return []

    extracted
  }
}

pub enum InstanceKind {
  Struct(struct: Struct)
  Enum(enum_: Enum)

  pub func asInstanceType(self): Type {
    match self {
      InstanceKind.Struct(s) => s.asInstanceType()
      InstanceKind.Enum(e) => e.asInstanceType()
    }
  }
}

pub enum TypeKind {
  CouldNotDetermine
  PrimitiveUnit
  PrimitiveInt
  PrimitiveFloat
  PrimitiveBool
  PrimitiveChar
  PrimitiveString
  Never
  Generic(name: String)
  Instance(instanceKind: InstanceKind, generics: Type[])
  Func(paramTypes: (Type, Bool)[], returnType: Type)
  Type(type_: InstanceKind)
  Tuple(types: Type[])
  Hole
}

pub type TypedAstNode {
  pub token: Token
  pub ty: Type
  pub kind: TypedAstNodeKind
}

pub type Decorator {
  pub backingStruct: Struct
  pub label: Label
  pub arguments: LiteralAstNode[]
}

pub type TypedBindingDeclarationNode {
  pub bindingPattern: BindingPattern
  pub variables: Variable[]
  pub expr: TypedAstNode?
}

type TypedFunctionParam {
  pub label: Label
  pub ty: Type
  pub defaultValue: TypedAstNode? = None
  pub isVariadic: Bool = false
  pub variable: Variable
}

pub enum FunctionKind {
  Standalone
  InstanceMethod(instanceKind: InstanceKind?, isPublic: Bool)
  StaticMethod(instanceKind: InstanceKind, isPublic: Bool)
}

pub type Function {
  pub label: Label
  pub scope: Scope
  pub kind: FunctionKind
  pub typeParams: (Type, Label)[] = []
  pub params: TypedFunctionParam[] = []
  pub returnType: Type
  pub body: TypedAstNode[] = []
  pub isGenerated: Bool = false
  isLambda: Bool = false
  pub decorators: Decorator[] = []
  pub captures: Variable[] = []
  pub capturedClosures: Function[] = []
  numScopes: Int = 0
  pub isMacro: Bool = false

  pub func generated(
    scope: Scope,
    name: String,
    params: (String, Type)[],
    returnType: Type,
    kind: FunctionKind,
    typeParams: (Type, Label)[] = [],
  ): Function {
    val bogusPosition = Position.bogus()

    val label = Label(name: name, position: bogusPosition)
    val fnScope = scope.makeChild(name, ScopeKind.Func)
    val fnParams = params.map(p => TypedFunctionParam(label: Label(name: p[0], position: bogusPosition), ty: p[1], variable: Variable.bogus()))
    Function(label: label, scope: fnScope, kind: kind, typeParams: typeParams, params: fnParams, returnType: returnType, body: [], isGenerated: true)
  }

  func initializer(
    scope: Scope,
    struct: Struct,
  ): Function {
    val bogusPosition = Position.bogus()

    val fnScope = scope.makeChild(struct.label.name, ScopeKind.Func)
    val structTypeParams = struct.typeParams.map(t => (Type(kind: TypeKind.Generic(t)), Label(name: t, position: bogusPosition)))
    val params = struct.fields.map(f => TypedFunctionParam(label: Label(name: f.name.name, position: bogusPosition), ty: f.ty, defaultValue: f.initializer, variable: Variable.bogus()))
    val typeArgs = struct.typeParams.map(t => Type(kind: TypeKind.Generic(t)))
    val returnType = Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), typeArgs))

    Function(label: struct.label, scope: fnScope, kind: FunctionKind.Standalone, typeParams: structTypeParams, params: params, returnType: returnType, body: [], isGenerated: true)
  }

  func forEnumVariant(
    scope: Scope,
    enum_: Enum,
    variantLabel: Label,
    variantFields: Field[],
  ): Function {
    val bogusPosition = Position.bogus()

    val fnScope = scope.makeChild("${enum_.label.name}.${variantLabel.name}", ScopeKind.Func)
    val typeParams = enum_.typeParams.map(t => (Type(kind: TypeKind.Generic(t)), Label(name: t, position: bogusPosition)))
    val params = variantFields.map(f => TypedFunctionParam(label: Label(name: f.name.name, position: bogusPosition), ty: f.ty, defaultValue: f.initializer, variable: Variable.bogus()))
    val typeArgs = enum_.typeParams.map(t => Type(kind: TypeKind.Generic(t)))
    val returnType = Type(kind: TypeKind.Instance(InstanceKind.Enum(enum_), typeArgs))

    Function(label: variantLabel, scope: fnScope, kind: FunctionKind.Standalone, typeParams: typeParams, params: params, returnType: returnType, body: [], isGenerated: true)
  }

  pub func getType(self): Type = Type(kind: TypeKind.Func(paramTypes: self.params.map(p => (p.ty, !p.defaultValue)), returnType: self.returnType))

  func withSubstitutedGenerics(self, resolvedGenerics: Map<String, Type>, retainUnknown: Bool, genericsInScope: Set<String>): Function {
    val params = self.params.map(p => {
      val ty = p.ty.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)
      TypedFunctionParam(label: p.label, ty: ty, defaultValue: p.defaultValue, isVariadic: p.isVariadic, variable: p.variable)
    })
    val returnType = self.returnType.withSubstitutedGenerics(resolvedGenerics, retainUnknown, genericsInScope)

    Function(
      label: self.label,
      scope: self.scope,
      kind: self.kind,
      typeParams: self.typeParams,
      params: params,
      returnType: returnType,
      body: self.body,
      isGenerated: self.isGenerated,
      isLambda: self.isLambda,
      decorators: self.decorators,
      captures: self.captures,
      capturedClosures: self.capturedClosures,
    )
  }

  pub func isClosure(self): Bool = !self.captures.isEmpty() || !self.capturedClosures.isEmpty()
}

pub enum TypedInvokee {
  Method(fn: Function, selfVal: TypedAstNode, isOptSafe: Bool)
  Function(fn: Function)
  Struct(struct: Struct)
  Expr(expr: TypedAstNode)
  EnumVariant(enum_: Enum, variant: TypedEnumVariant)
}

pub enum TypedIndexingNode {
  ArrayLike(expr: TypedAstNode, indexingMode: IndexingMode<TypedAstNode>)
  Map(expr: TypedAstNode, idx: TypedAstNode)
  Tuple(tupleExpr: TypedAstNode, idx: Int)
}

pub enum TypedAssignmentMode {
  Variable(variable: Variable)
  Indexing(node: TypedIndexingNode)
  Accessor(head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment)
}

pub enum TypedMatchCaseKind {
  Literal(value: LiteralAstNode)
  Type(ty: Type)
  EnumVariant(enum_: Enum, variant: TypedEnumVariant, variantIdx: Int, destructuredVariables: Variable[])
  None_
  Else
}

pub type TypedMatchCase {
  pub kind: TypedMatchCaseKind
  pub binding: Variable?
  pub body: TypedAstNode[]
  pub terminator: Terminator?
}

pub type TypedTryElseClause {
  pub pattern: (BindingPattern, Variable[])?
  pub errorType: Type
  pub block: TypedAstNode[]
  pub terminator: Terminator?
}

pub enum TypedForIterKind {
  Expr(expr: TypedAstNode)
  Range(startExpr: TypedAstNode, endExpr: TypedAstNode)
}

pub enum TypedAstNodeKind {
  Literal(value: LiteralAstNode)
  StringInterpolation(exprs: TypedAstNode[])
  Unary(op: UnaryOp, expr: TypedAstNode)
  Binary(left: TypedAstNode, op: BinaryOp, right: TypedAstNode)
  Grouped(inner: TypedAstNode)
  Identifier(name: String, variable: Variable, fnAliasTypeHint: Type?, varImportModule: TypedModule?)
  Accessor(head: TypedAstNode, middle: AccessorPathSegment[], tail: AccessorPathSegment)
  Invocation(invokee: TypedInvokee, arguments: TypedAstNode?[], resolvedGenerics: Map<String, Type>)
  Array(items: TypedAstNode[])
  Set(items: TypedAstNode[])
  Map(items: (TypedAstNode, TypedAstNode)[])
  Tuple(items: TypedAstNode[])
  Indexing(node: TypedIndexingNode)
  Lambda(fn: Function, typeHint: Type?)
  Assignment(mode: TypedAssignmentMode, op: AssignOp, expr: TypedAstNode)
  If(isStatement: Bool, typedCondition: TypedAstNode, conditionBinding: (BindingPattern, Variable[])?, typedIfBlock: TypedAstNode[], ifBlockTerminator: Terminator?, typedElseBlock: TypedAstNode[], elseBlockTerminator: Terminator?)
  Match(isStatement: Bool, expr: TypedAstNode, cases: TypedMatchCase[])
  Try(typedExpr: TypedAstNode, typedElseClause: TypedTryElseClause?)
  While(typedCondition: TypedAstNode, conditionBinding: (BindingPattern, Variable[])?, block: TypedAstNode[], terminator: Terminator?)
  For(typedForIterKind: TypedForIterKind, itemBinding: (BindingPattern, Variable[]), indexBinding: Variable?, block: TypedAstNode[], terminator: Terminator?)
  BindingDeclaration(node: TypedBindingDeclarationNode)
  FunctionDeclaration(fn: Function)
  TypeDeclaration(struct: Struct)
  EnumDeclaration(enum_: Enum)
  Break
  Continue
  Return(expr: TypedAstNode?)

  Placeholder
}

pub enum AccessorPathSegment {
  EnumVariant(label: Label, ty: Type, enum_: Enum, variant: TypedEnumVariant)
  Method(label: Label, fn: Function, optSafe: Bool, typeHint: Type?)
  Field(label: Label, ty: Type, f: Field, optSafe: Bool)

  func getType(self): Type {
    match self {
      AccessorPathSegment.EnumVariant(_, ty, _, _) => ty
      AccessorPathSegment.Method(_, fn, _, _) => fn.getType()
      AccessorPathSegment.Field(_, ty, _, _) => ty
    }
  }
}

pub enum LexerOrParseError {
  LexerError(inner: LexerError)
  ParseError(inner: ParseError)

  pub func getMessage(self, modulePath: String, contents: String): String {
    match self {
      LexerOrParseError.LexerError(inner) => inner.getMessage(modulePath, contents)
      LexerOrParseError.ParseError(inner) => inner.getMessage(modulePath, contents)
    }
  }
}

type TypeError {
  pub position: Position
  kind: TypeErrorKind

  // Note: this is different than `Typechecker#_typeIsOption`, because we don't have access to the Project here to
  // compare against `project.preludeOptionEnum`. However, the functionality should be equivalent since the
  // comparison here is roughly the same as `Enum#eq`.
  func _typeIsOption(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(instanceKind, generics) => match instanceKind {
        InstanceKind.Enum(enum_) => if enum_.builtin == Some(BuiltinModule.Prelude) && enum_.label.name == "Option" {
          generics[0]
        } else {
          None
        }
        _ => None
      }
      _ => None
    }
  }

  pub func getMessage(self, filePath: String, contents: String): String {
    val lines = ["Error at $filePath:${self.position.line}:${self.position.col}"]

    match self.kind {
      TypeErrorKind.NotYetImplemented(reason) => {
        lines.push("Not yet implemented:")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Reason: $reason")
      }
      TypeErrorKind.TypeMismatch(expected, received) => {
        lines.push("Type mismatch")
        lines.push(self._getCursorLine(self.position, contents))

        val expectedReprs = expected.map(t => t.repr()).join(", ")
        if expected.length == 1 {
          lines.push("Expected: " + expectedReprs)
        } else {
          lines.push("Expected one of: " + expectedReprs)
        }
        lines.push("but instead found: " + received.repr())
      }
      TypeErrorKind.DuplicateName(original) => {
        lines.push("Duplicate name '${original.name}'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This name is also declared at (${original.position.line}:${original.position.col})")
        lines.push(self._getCursorLine(original.position, contents))
      }
      TypeErrorKind.UnknownName(name, kind) => {
        lines.push("Unknown $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        if name == "_" {
          lines.push("The '_' identifier is a special name used to discard values, and it cannot be referenced")
        } else {
          lines.push("No $kind with that name is visible in current scope")
        }
      }
      TypeErrorKind.UnknownField(ty, name, specialCase) => {
        lines.push("Unknown field '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        match ty.kind {
          TypeKind.Func => lines.push("Functions don't have any fields or methods")
          _ => {
            match specialCase {
              UnknownFieldSpecialCase.ExistsButTypeIsNullable(isViaOptChaining) => {
                val nonOptVersion = try self._typeIsOption(ty) else unreachable("ty should be Option<?> here")

                if isViaOptChaining {
                  lines.push("Type '${nonOptVersion.repr()}' has field '$name', but lhs here is of type '${ty.repr()}' due to prior '?.'")
                } else {
                  lines.push("Type '${nonOptVersion.repr()}' has field '$name', but lhs is of type '${ty.repr()}'")
                }
                lines.push("(You can use the '?.' operator instead of '.')")
              }
              UnknownFieldSpecialCase.StaticFieldReferencedAsInstance => {
                lines.push("No field '$name' found on instance of type ${ty.repr()}")
                lines.push("'$name' is a static member of ${ty.repr()}, did you mean to write ${ty.repr()}.$name?")
              }
              None =>  {
                lines.push("No field '$name' found on type ${ty.repr()}")
              }
            }
          }
        }
      }
      TypeErrorKind.IllegalAccess(name, kind, parentTy) => {
        lines.push("Illegal access for $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))

        val capitalized = kind[0].toUpper() + kind[1:]
        lines.push("$capitalized '$name' is not marked as 'pub' within type '${parentTy.repr()}'")
      }
      TypeErrorKind.MissingValExpr(name) => {
        if name |name| {
          lines.push("Missing initializer for immutable variable '$name'")
        } else {
          lines.push("Missing initializer for immutable variables")
        }
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.MissingVarExprAndTypeAnn(name) => {
        if name |name| {
          lines.push("Could not determine type of mutable variable '$name'")
        } else {
          lines.push("Could not determine type of mutable variables")
        }
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("A 'var' must have either an initial value or a type annotation (or both)")
      }
      TypeErrorKind.IllegalNonConstantEnumVariant => {
        lines.push("Forbidden value")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This enum variant is non-constant and must be constructed")
      }
      TypeErrorKind.IllegalValueType(ty, purpose) => {
        match ty.kind {
          TypeKind.PrimitiveUnit => {
            lines.push("Forbidden type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Instances of type ${ty.repr()} cannot be used as $purpose values")
          }
          TypeKind.Never => {
            lines.push("Forbidden type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Expression has type ${ty.repr()}, which can never be used for $purpose")
          }
          TypeKind.Type => {
            lines.push("Forbidden type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Expression has type ${ty.repr()}, which cannot be used as a value")
          }
          _ => {
            lines.push("Could not determine type for $purpose")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Type '${ty.repr()}' has unfilled holes. Please use an explicit type annotation to denote the type")
          }
        }
      }
      TypeErrorKind.IllegalControlFlowType(ty, purpose) => {
        if purpose == "if" || purpose == "while" {
          lines.push("Forbidden type for $purpose-condition")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Conditions must either be Bool or Option types")
          lines.push("but instead found " + ty.repr())
        } else if purpose == "for" {
          lines.push("Forbidden type for for-loop target")
          lines.push(self._getCursorLine(self.position, contents))
          if ty.hasUnfilledHoles() {
            lines.push("Type '${ty.repr()}' has unfilled holes")
          } else {
            lines.push("Type ${ty.repr()} is not iterable")
          }
        }
      }
      TypeErrorKind.MissingRequiredBlock(exprKind, clause, missing) => {
        lines.push("Incomplete $exprKind expression")
        lines.push(self._getCursorLine(self.position, contents))
        if missing {
          lines.push("The $clause-block must exist and contain a value")
        } else {
          lines.push("The $clause-block must contain a value")
        }
      }
      TypeErrorKind.DuplicateParameter(name) => {
        lines.push("Duplicate parameter '$name'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.InvalidParamPosition(purpose) => {
        match purpose {
          "vararg" => {
            lines.push("Invalid location for variadic parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Variadic parameters must be the last in the parameter list")
          }
          "required" => {
            lines.push("Invalid location for required parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Required parameters must all be listed before any optional parameters")
          }
          "self" => {
            lines.push("Invalid usage of `self` parameter")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("`self` can only appear within methods on types")
          }
          _ => { /* no other cases */ }
        }
      }
      TypeErrorKind.InvalidVarargType(ty) => {
        lines.push("Invalid type for vararg parameter")
        lines.push(self._getCursorLine(self.position, contents))
        if self._typeIsOption(ty) {
          lines.push("Vararg parameters must be a non-Option Array type, but got ${ty.repr()}")
        } else {
          lines.push("Vararg parameters must be an Array type, but got ${ty.repr()}")
        }
      }
      TypeErrorKind.ReturnTypeMismatch(fnName, expected, received) => {
        if fnName |name| {
          lines.push("Return type mismatch for function '$name'")
        } else {
          lines.push("Return type mismatch for lambda function")
        }

        lines.push(self._getCursorLine(self.position, contents))

        lines.push("Expected ${expected.repr()}")
        if received |received| {
          lines.push("but instead found ${received.repr()}")
        } else {
          lines.push("but function had empty body")
        }
      }
      TypeErrorKind.InvalidTerminatorPosition(terminator) => {
        lines.push("Invalid location for $terminator statement")
        lines.push(self._getCursorLine(self.position, contents))
        match terminator {
          "return" => lines.push("Return statements can only be used within function bodies")
          "break" => lines.push("Break statements can only be used within loop bodies")
          "continue" => lines.push("Continue statements can only be used within loop bodies")
          _ => { /* unreachable */ }
        }
      }
      TypeErrorKind.UnreachableCode => {
        lines.push("Unreachable code")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Control flow exits before this code is reached")
      }
      TypeErrorKind.WrongInvocationArity(expected, given) => {
        val argumentsStr = if expected == 1 "argument" else "arguments"
        val verbStr = if given == 1 "was" else "were"

        if given > expected {
          lines.push("Too many arguments for invocation")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("Expected no more than $expected $argumentsStr, but $given $verbStr passed")
        } else {
          lines.push("Not enough arguments for invocation")
          lines.push(self._getCursorLine(self.position, contents))
          lines.push("$expected $argumentsStr required, but $given $verbStr passed")
        }
      }
      TypeErrorKind.ParameterLabelMismatch(expected, given) => {
        lines.push("Incorrect label for parameter")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The parameter's name is '$expected', but instead found '$given'")
      }
      TypeErrorKind.IllegalParameterLabel => {
        lines.push("Incorrect use of label for parameter")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Parameter labels are not allowed here because parameters' names cannot be determined")
      }
      TypeErrorKind.MixedArgumentType(label) => {
        lines.push("Cannot mix labeled and positional optional arguments")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This argument requires a label because a prior optional parameter has been labeled:")
        lines.push(self._getCursorLine(label.position, contents))
        lines.push("(Optional parameters may be listed positionally until a label is encountered. After that point, parameter values cannot be unambiguously determined without labels)")
      }
      TypeErrorKind.MissingRequiredArgumentLabel => {
        lines.push("Invalid instantiation")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Calls of type constructors must include argument labels")
      }
      TypeErrorKind.MissingRequiredFields(names) => {
        lines.push("Invalid instantiation")
        lines.push(self._getCursorLine(self.position, contents))

        val maxToShow = 3
        val missing = names[:maxToShow].map(n => "'$n'")
        if names.length > maxToShow {
          missing.push("and ${names.length - maxToShow} more")
        }
        lines.push("The following required fields are missing: ${missing.join(", ")}")
      }
      TypeErrorKind.UnknownParameterName(name) => {
        lines.push("Unknown parameter label")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This function doesn't have a parameter named '$name'")
      }
      TypeErrorKind.UnknownParameterType(name) => {
        lines.push("Could not determine type for parameter '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Consider adding a type annotation")
      }
      TypeErrorKind.ParameterTypeMismatch(name, expected, given) => {
        if name |name| {
          lines.push("Type mismatch for parameter '$name'")
        } else {
          lines.push("Type mismatch for parameter")
        }
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Expected: ${expected.repr()}")
        lines.push("but instead found: ${given.repr()}")
      }
      TypeErrorKind.IllegalCallableType(ty) => {
        lines.push("Cannot invoke target as function")
        lines.push(self._getCursorLine(self.position, contents))
        match ty.kind {
          TypeKind.Instance(instanceKind, _) => {
            match instanceKind {
              InstanceKind.Enum => lines.push("This is a constant enum variant, and it accepts no arguments")
              _ => unreachable()
            }
          }
          _ => lines.push("Type '${ty.repr()}' is not callable")
        }
      }
      TypeErrorKind.IllegalDecoratorType(ty) => {
        lines.push("Cannot use non-decorator type as a decorator")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.WrongTypeArgumentArity(expected, given) => {
        val verbStr = if given == 1 "was" else "were"

        lines.push("Incorrect number of type arguments")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Expected $expected, but $given $verbStr passed")
      }
      TypeErrorKind.NoSuchOperator(leftTy, op, rightTy) => {
        lines.push("Illegal operator")
        lines.push(self._getCursorLine(self.position, contents))
        val isCoalesceError = op == BinaryOp.Coalesce && !self._typeIsOption(leftTy)
        if isCoalesceError {
          lines.push("The '${op.repr()}' operator can only be used on an Option type")
          lines.push("(The lhs value's type here is ${leftTy.repr()}, not Option<${leftTy.repr()}>)")
        } else {
          lines.push("No operator '${op.repr()}' exists between types ${leftTy.repr()} and ${rightTy.repr()}")
        }
      }
      TypeErrorKind.IllegalIndexableType(ty, isRange) => {
        lines.push("Unsupported indexing operation")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Type '${ty.repr()}' is not indexable" + if isRange " as a range" else "")
      }
      TypeErrorKind.IllegalTupleIndexing(ty, reason) => {
        lines.push("Unsupported tuple indexing operation")
        lines.push(self._getCursorLine(self.position, contents))
        match reason {
          IllegalTupleIndexingReason.IndexOutOfBounds => {
            lines.push("No value at index for tuple of type '${ty.repr()}'")
            match ty.kind {
              TypeKind.Tuple(types) => lines.push("(Valid index values are from 0-${types.length - 1}, inclusive)")
              _ => unreachable("The type here should always be a tuple")
            }
          }
          IllegalTupleIndexingReason.IndexNegative => {
            lines.push("Tuple index values must always be a non-negative integer")
            match ty.kind {
              TypeKind.Tuple(types) => lines.push("(Valid index values are from 0-${types.length - 1}, inclusive)")
              _ => unreachable("The type here should always be a tuple")
            }
          }
          IllegalTupleIndexingReason.NotIntLiteral => lines.push("Cannot use non-Int literal as index value. Tuple index values must always be Int literals")
          IllegalTupleIndexingReason.NotLiteralNode => lines.push("Cannot use this expression as index value. Tuple index values must always be Int literals")
        }
      }
      TypeErrorKind.UnnecessaryOptSafety => {
        lines.push("Unnecessary use of '?.' operator")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("(The lhs value's type here is known to be a non-Option type)")
      }
      TypeErrorKind.InvalidTraitMethodSignature(givenFn) => {
        lines.push("Invalid signature for method '${givenFn.label.name}'")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.IllegalAssignment(kind, name, reason) => {
        lines.push("Cannot assign to $kind '$name'")
        lines.push(self._getCursorLine(self.position, contents))
        match reason {
          IllegalAssignmentReason.ImmutableVariable => lines.push("'$name' is declared as immutable")
          IllegalAssignmentReason.TypeAlias => lines.push("'$name' is a type, which cannot be overwritten")
          IllegalAssignmentReason.FunctionAlias => lines.push("'$name' is a function, which cannot be overwritten")
          IllegalAssignmentReason.EnumVariant => lines.push("'$name' is an enum variant, which cannot be overwritten")
          IllegalAssignmentReason.Method => lines.push("'$name' is a method, which cannot be overwritten")
          IllegalAssignmentReason.StaticMethod => lines.push("'$name' is a static method, which cannot be overwritten")
          IllegalAssignmentReason.Import => lines.push("'$name' is an import, which cannot be overwritten")
        }
      }
      TypeErrorKind.UnknownModule(modulePath, isRelativeImport) => {
        lines.push("Could not import module")
        lines.push(self._getCursorLine(self.position, contents))
        if isRelativeImport {
          lines.push("No file exists at path '$modulePath'")
        } else {
          lines.push("Could not find module named '$modulePath'")
        }
      }
      TypeErrorKind.CircularDependency => {
        lines.push("Could not import module due to circular dependency")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The current module is itself imported by this module (or one of its imports), resulting in a cycle")
      }
      TypeErrorKind.IllegalExportScope => {
        lines.push("Invalid visibility modifier")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Exported values may only appear at the top level scope in a module")
      }
      TypeErrorKind.UnknownImport(moduleName, importName) => {
        lines.push("Invalid import")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("There's no exported value named '$importName' in module '$moduleName'")
      }
      TypeErrorKind.UnknownImportForAlias(importName, alias) => {
        lines.push("Unknown member '$importName'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("There's no exported value named '$importName' in module aliased as '${alias.name}' at:")
        lines.push(self._getCursorLine(alias.position, contents))
      }
      TypeErrorKind.DuplicateMatchCase => {
        lines.push("Duplicate match case")
        lines.push(self._getCursorLine(self.position, contents))
      }
      TypeErrorKind.UnreachableMatchCase(reason, subjectTy) => {
        lines.push("Unreachable match case")
        lines.push(self._getCursorLine(self.position, contents))
        match reason {
          UnreachableMatchCaseReason.NoOverlap(caseTy) => {
            if caseTy |caseTy| {
              lines.push("No overlap between case type '${caseTy.repr()}' and match target type '${subjectTy.repr()}'")
            } else {
              lines.push("Match target type '${subjectTy.repr()}' can never be None")
            }
          }
          UnreachableMatchCaseReason.AlreadyCovered(exhaustive) => {
            if exhaustive {
              lines.push("The previous case(s) cover all possibilities for match target type '${subjectTy.repr()}'")
            } else {
              lines.push("This case has already been covered by a previous case")
            }
          }
        }
      }
      TypeErrorKind.EmptyMatchBlock => {
        lines.push("Empty block for match case")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Each case in a match expression must result in a value")
      }
      TypeErrorKind.NonExhaustiveMatch(subjectTy) => {
        lines.push("Non-exhaustive match expression")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Match target type '${subjectTy.repr()}' is not covered by all cases")
        lines.push("(You can use a wildcard to capture remaining cases)")
      }
      TypeErrorKind.InvalidMatchCaseDestructuring(reason) => {
        match reason {
          InvalidMatchCaseDestructuringReason.NonEnum => {
            lines.push("Destructuring is not supported for types in match cases (aside from enum variants)")
            lines.push(self._getCursorLine(self.position, contents))
          }
          InvalidMatchCaseDestructuringReason.NonEnumContainer => {
            lines.push("This variant is a constant enum variant, which cannot be destructured")
            lines.push(self._getCursorLine(self.position, contents))
          }
          InvalidMatchCaseDestructuringReason.InvalidArity(expected, given) => {
            val verbStr = if given == 1 "was" else "were"

            lines.push("Incorrect number of destructuring arguments")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Expected $expected, but $given $verbStr passed")
            if given < expected {
              lines.push("(You can use '_' to denote positions that you wish to discard)")
            }
          }
        }
      }
      TypeErrorKind.InvalidDestructuring(reason) => {
        match reason {
          InvalidDestructuringReason.NonTupleAsTuple(ty) => {
            lines.push("Invalid destructuring")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("A value of type '${ty.repr()}' cannot be destructured as a tuple")
          }
          InvalidDestructuringReason.InvalidTupleArity(expected, given) => {
            val verbStr = if given == 1 "was" else "were"

            lines.push("Incorrect number of destructuring arguments for tuple")
            lines.push(self._getCursorLine(self.position, contents))
            lines.push("Expected $expected, but $given $verbStr provided")
            if given < expected {
              lines.push("(You can use '_' to denote positions that you wish to discard)")
            }
          }
        }
      }
      TypeErrorKind.InvalidTryLocation(reason) => {
        lines.push("Invalid location for try expression")
        lines.push(self._getCursorLine(self.position, contents))

        match reason {
          InvalidTryLocationReason.NotWithinFunction => {
            lines.push("Try expressions can only be used inside of function bodies")
          }
          InvalidTryLocationReason.InvalidFunctionReturnType(fnLabel, tryType, returnType, kind) => {
            lines.push("The containing function '${fnLabel.name}' has return type '${returnType.repr()}', which is incompatible with the try expression's type '${tryType.repr()}'.")
            lines.push(self._getCursorLine(fnLabel.position, contents))
            match kind {
              InvalidFunctionReturnTypeKind.IsResult => {
                lines.push("To be compatible, '${fnLabel.name}' must return a Result whose error type matches that of the try expression")
              }
              InvalidFunctionReturnTypeKind.IsOption => {
                lines.push("To be compatible, '${fnLabel.name}' must return an Option type")
              }
            }
          }
        }
      }
      TypeErrorKind.InvalidTryTarget(subjectTy) => {
        lines.push("Invalid subject for try expression")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This value has type '${subjectTy.repr()}', which is not Try-able")
      }
      TypeErrorKind.TryReturnTypeMismatch(fnLabel, tryType, tryErrType, retErrType) => {
        lines.push("Return type mismatch for function containing try expression")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The containing function '${fnLabel.name}' returns a Result whose error type is '${retErrType.repr()}', which is incompatible with the try expression.")
        lines.push(self._getCursorLine(fnLabel.position, contents))
        lines.push("To be compatible, the return type of '${fnLabel.name}' must have '${tryErrType.repr()}' as its error type.")
        lines.push("Hint: You can use an else-clause to transform the error value into a compatible value and return it")
      }
      TypeErrorKind.NonComptimeDecoratorFieldType(decoratorName, fieldName, fieldTy) => {
        lines.push("Forbidden field type for decorator '$decoratorName'")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("This field has type '${fieldTy.repr()}', which is not allowed for fields of decorators.")
        // lines.push("Decorators' fields must have types whose values are known at compile-time")
        lines.push("Decorators' fields must be one of: Int, Float, Bool, String")
      }
      TypeErrorKind.ErrorWithinMacroFunction(macroFn) => {
        lines.push("Macro '${macroFn.label.name}' cannot produce valid code at this invocation site")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The module in which the macro is defined has errors")
      }
      TypeErrorKind.ErrorWithinMacroOutput(macroName, generatedContents, innerError) => {
        lines.push("Macro '$macroName' produced invalid code at this invocation site")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("The generated code contains the following error:\n")

        val fakeModulePath = "<generated by macro '$macroName'>"
        val innerMessage = match innerError {
          ErrorWithinMacroOutputKind.LexerOrParseError(e) => e.getMessage(fakeModulePath, generatedContents)
          ErrorWithinMacroOutputKind.TypeError(e) => e.getMessage(fakeModulePath, generatedContents)
        }
        lines.push(innerMessage.trim())
      }
      TypeErrorKind.InvalidMacroParamType(exprStruct) => {
        lines.push("Invalid parameter type for @macro function")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Macro parameters must be of type 'meta.${exprStruct.label.name}'")
      }
      TypeErrorKind.InvalidMacroReturnType(injectedCodeStruct) => {
        lines.push("Invalid return type for @macro function")
        lines.push(self._getCursorLine(self.position, contents))
        lines.push("Macros must return an instance of 'meta.${injectedCodeStruct.label.name}'")
      }
    }

    lines.join("\n")
  }

  // TODO: This is duplicated from Lexer, pull this out
  func _getCursorLine(self, position: Position, contents: String, cursorLength = 1): String {
    if contents.lines()[position.line - 1] |line| {
      val len = position.col - 1 + cursorLength
      val cursor = Array.fill(len, " ")
      for i in (len - cursorLength):len {
        cursor[i] = "^"
      }
      "  |  $line\n     ${cursor.join()}"
    } else {
      unreachable()
    }
  }
}

enum UnknownFieldSpecialCase {
  ExistsButTypeIsNullable(isViaOptChaining: Bool)
  StaticFieldReferencedAsInstance
}

enum IllegalTupleIndexingReason {
  IndexOutOfBounds
  IndexNegative
  NotIntLiteral
  NotLiteralNode
}

enum IllegalAssignmentReason {
  ImmutableVariable
  TypeAlias
  FunctionAlias
  EnumVariant
  Method
  StaticMethod
  Import
}

enum UnreachableMatchCaseReason {
  NoOverlap(caseTy: Type?)
  AlreadyCovered(exhaustive: Bool)
}

enum InvalidMatchCaseDestructuringReason {
  NonEnum
  NonEnumContainer
  InvalidArity(expected: Int, given: Int)
}

enum InvalidDestructuringReason {
  NonTupleAsTuple(ty: Type)
  InvalidTupleArity(expected: Int, given: Int)
}

enum InvalidFunctionReturnTypeKind {
  IsResult
  IsOption
  IsNotTryable
}

enum InvalidTryLocationReason {
  NotWithinFunction
  InvalidFunctionReturnType(fnLabel: Label, tryType: Type, returnType: Type, kind: InvalidFunctionReturnTypeKind)
}

enum ErrorWithinMacroOutputKind {
  LexerOrParseError(inner: LexerOrParseError)
  TypeError(inner: TypeError)
}

enum TypeErrorKind {
  NotYetImplemented(reason: String)
  TypeMismatch(expected: Type[], received: Type)
  DuplicateName(original: Label)
  UnknownName(name: String, kind: String)
  UnknownField(ty: Type, name: String, specialCase: UnknownFieldSpecialCase?)
  IllegalAccess(name: String, kind: String, parentTy: Type)
  MissingValExpr(name: String?)
  MissingVarExprAndTypeAnn(name: String?)
  IllegalNonConstantEnumVariant
  IllegalValueType(ty: Type, purpose: String)
  IllegalControlFlowType(ty: Type, purpose: String)
  MissingRequiredBlock(exprKind: String, clause: String, missing: Bool)
  InvalidParamPosition(purpose: String)
  DuplicateParameter(name: String)
  InvalidVarargType(ty: Type)
  ReturnTypeMismatch(fnName: String?, expected: Type, received: Type?)
  InvalidTerminatorPosition(terminator: String)
  UnreachableCode
  WrongInvocationArity(expected: Int, given: Int)
  ParameterLabelMismatch(expected: String, given: String)
  IllegalParameterLabel
  MixedArgumentType(label: Label)
  MissingRequiredArgumentLabel
  MissingRequiredFields(names: String[])
  UnknownParameterName(name: String)
  UnknownParameterType(name: String)
  ParameterTypeMismatch(name: String?, expected: Type, given: Type)
  IllegalCallableType(ty: Type)
  IllegalDecoratorType(ty: Type)
  WrongTypeArgumentArity(expected: Int, given: Int)
  NoSuchOperator(leftTy: Type, op: BinaryOp, rightTy: Type)
  IllegalIndexableType(ty: Type, isRange: Bool)
  IllegalTupleIndexing(ty: Type, reason: IllegalTupleIndexingReason)
  UnnecessaryOptSafety
  InvalidTraitMethodSignature(fn: Function)
  IllegalAssignment(kind: String, name: String, reason: IllegalAssignmentReason)
  UnknownModule(modulePath: String, isRelativeImport: Bool)
  CircularDependency
  IllegalExportScope
  UnknownImport(moduleName: String, importName: String)
  UnknownImportForAlias(importName: String, alias: Label)
  DuplicateMatchCase
  UnreachableMatchCase(reason: UnreachableMatchCaseReason, subjectTy: Type)
  EmptyMatchBlock
  NonExhaustiveMatch(subjectTy: Type)
  InvalidMatchCaseDestructuring(reason: InvalidMatchCaseDestructuringReason)
  InvalidDestructuring(reason: InvalidDestructuringReason)
  InvalidTryLocation(reason: InvalidTryLocationReason)
  InvalidTryTarget(subjectTy: Type)
  TryReturnTypeMismatch(fnLabel: Label, tryType: Type, tryErrType: Type, retErrType: Type)
  NonComptimeDecoratorFieldType(decoratorName: String, fieldName: String, fieldTy: Type)
  ErrorWithinMacroFunction(macroName: Function)
  ErrorWithinMacroOutput(macroName: String, generatedContents: String, innerError: ErrorWithinMacroOutputKind)
  InvalidMacroParamType(exprStruct: Struct)
  InvalidMacroReturnType(injectedCodeStruct: Struct)
}

type ParamDefaultValueContext {
  exprContainsFunctionCall: Bool = false
  exprContainsVariableRef: Bool = false
}

pub type Typechecker {
  pub moduleLoader: ModuleLoader
  pub project: Project
  pub comptimeFuncEvaluator: (Function, TypedAstNode?[], Map<String, Type>) => Result<meta.InjectedCode, String>
  currentModule: TypedModule = TypedModule.bogus()
  currentScope: Scope = Scope(name: "\$root")
  currentTypeDecl: InstanceKind? = None
  currentFunction: Function? = None
  paramDefaultValueContext: ParamDefaultValueContext? = None
  isStructOrEnumValueAllowed: Bool = false
  isEnumContainerValueAllowed: Bool = false
  numLambdas: Int = 0
  numRootLevelScopes: Int = 0
  typecheckingBuiltin: BuiltinModule? = None
  pub lspMode: Bool = false
  identsByLine: Map<Int, (Int, Int, IdentifierMeta)[]> = {}

  pub func typecheckEntrypoint(self, modulePathAbs: String) {
    val preludeModulePathSegs = getAbsolutePath(self.moduleLoader.stdRoot + "/prelude.abra")
    val preludeModulePathAbs = "/" + preludeModulePathSegs.join("/")

    if !self.project.modules[preludeModulePathAbs] {
      val lspMode = self.lspMode
      self.lspMode = false
      self._typecheckModule(preludeModulePathAbs)
      self.lspMode = lspMode

      for (_, mod) in self.project.modules {
        if mod.hasError() return
      }

      val preludeStructs = [
        self.project.preludeIntStruct,
        self.project.preludeFloatStruct,
        self.project.preludeBoolStruct,
        self.project.preludeCharStruct,
        self.project.preludeStringStruct,
        self.project.preludeArrayStruct,
        self.project.preludeMapStruct,
        self.project.preludeSetStruct,
      ]
      for struct in preludeStructs {
        if struct.label.position == Position.bogus() unreachable("Improperly initialized prelude struct ${struct.label.name}")
      }

      val preludeEnums = [
        self.project.preludeOptionEnum,
        self.project.preludeResultEnum,
      ]
      for enum_ in preludeEnums {
        if enum_.label.position == Position.bogus() unreachable("Improperly initialized prelude enum ${enum_.label.name}")
      }
    }

    val mod = self._typecheckModule(modulePathAbs)
    mod.isEntry = true
  }

  func _verifyNameUniqueInScope(self, label: Label, scope: Scope): TypeError? {
    for (_, importedModule) in self.currentModule.imports {
      for alias in importedModule.aliases {
        if alias.name == label.name {
          return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: alias)))
        }
      }
      for (name, imp) in importedModule.imports {
        if name == label.name {
          return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: imp.label)))
        }
      }
    }

    for v in scope.variables {
      if v.label.name == label.name {
        return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: v.label)))
      }
    }

    for f in scope.functions {
      if f.label.name == label.name {
        return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: f.label)))
      }
    }

    for s in scope.structs {
      if s.label.name == label.name {
        return Some(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original: s.label)))
      }
    }

    None
  }

  func addVariableToScope(self, variable: Variable, scope = self.currentScope): Result<Int, TypeError> {
    if variable.label.name == "_" return Ok(0) // <- unnecessary 0

    if self._verifyNameUniqueInScope(variable.label, scope) |e| return Err(e)
    scope.variables.push(variable)

    Ok(0) // <- unnecessary 0
  }

  func addFunctionToScope(self, fn: Function, scope = self.currentScope): Result<Int, TypeError> {
    if self._verifyNameUniqueInScope(fn.label, scope) |e| return Err(e)
    scope.functions.push(fn)

    Ok(0) // <- unnecessary 0
  }

  func addStructToScope(self, struct: Struct, isExported: Bool, scope = self.currentScope): Result<Int, TypeError> {
    val structTy = Type(kind: TypeKind.Type(type_: InstanceKind.Struct(struct)))
    self.currentScope.types.push(structTy)

    val variable = Variable(label: struct.label, scope: scope, mutable: false, ty: structTy, alias: Some(VariableAlias.Struct(struct)))
    try self.addVariableToScope(variable)

    scope.structs.push(struct)

    if isExported {
      variable.isExported = true
      self.currentModule.exports[struct.label.name] = Export.Type(InstanceKind.Struct(struct), variable)
    }

    Ok(0) // <- unnecessary 0
  }

  func addEnumToScope(self, enum_: Enum, isExported: Bool, scope = self.currentScope): Result<Int, TypeError> {
    val enumTy = Type(kind: TypeKind.Type(type_: InstanceKind.Enum(enum_)))
    self.currentScope.types.push(enumTy)

    val variable = Variable(label: enum_.label, scope: scope, mutable: false, ty: enumTy, alias: Some(VariableAlias.Enum(enum_)))
    try self.addVariableToScope(variable)

    scope.enums.push(enum_)

    if isExported {
      variable.isExported = true
      self.currentModule.exports[enum_.label.name] = Export.Type(InstanceKind.Enum(enum_), variable)
    }

    Ok(0) // <- unnecessary 0
  }

  func findModuleByAlias(self, name: String): (TypedModule, Label)? {
    for (importModulePath, importedModule) in self.currentModule.imports {
      if importedModule.aliases.find(a => a.name == name) |alias| {
        val mod = try self.project.modules[importModulePath] else unreachable("unknown module '$importModulePath'")
        return Some((mod, alias))
      }
    }

    None
  }

  func _verifyNumTypeArgs(self, position: Position, typeArguments: TypeIdentifier[], num: Int): Result<Type[], TypeError> {
    if typeArguments.length != num {
      return Err(TypeError(position: position, kind: TypeErrorKind.WrongTypeArgumentArity(expected: num, given: typeArguments.length)))
    }

    val types: Type[] = []
    for i in 0:num {
      val typeIdent = try typeArguments.get(i) else unreachable("verified above that typeArguments.length == num")
      val ty = try self.resolveTypeIdentifier(typeIdent)
      types.push(ty)
    }

    Ok(types)
  }

  func _resolveInstanceTypeIdentifier(self, importMod: TypedModule?, instanceKind: InstanceKind, label: Label, typeArguments: TypeIdentifier[]): Result<Type?, TypeError> {
    match instanceKind {
      InstanceKind.Struct(struct) => {
        if self.lspMode {
          self._addLSPIdentForStruct(label.position, struct, importMod)
        }

        val instanceTypeArgs = try self._verifyNumTypeArgs(label.position, typeArguments, struct.typeParams.length)
        return Ok(Some(Type(kind: TypeKind.Instance(InstanceKind.Struct(struct), instanceTypeArgs))))
      }
      InstanceKind.Enum(enum_) => {
        if self.lspMode {
          self._addLSPIdentForEnum(label.position, enum_, importMod)
        }

        val instanceTypeArgs = try self._verifyNumTypeArgs(label.position, typeArguments, enum_.typeParams.length)
        return Ok(Some(Type(kind: TypeKind.Instance(InstanceKind.Enum(enum_), instanceTypeArgs))))
      }
    }

    Ok(None)
  }

  func findTypeByNameInScope(self, name: String, startingScope = self.currentScope): (Type, TypedModule?)? {
    match name {
      "Unit" => Some((Type(kind: TypeKind.PrimitiveUnit), None))
      "Int" => Some((Type(kind: TypeKind.PrimitiveInt), None))
      "Float" => Some((Type(kind: TypeKind.PrimitiveFloat), None))
      "Bool" => Some((Type(kind: TypeKind.PrimitiveBool), None))
      "Char" => Some((Type(kind: TypeKind.PrimitiveChar), None))
      "String" => Some((Type(kind: TypeKind.PrimitiveString), None))
      "Map" => Some((Type(kind: TypeKind.Type(InstanceKind.Struct(self.project.preludeMapStruct))), None))
      "Set" => Some((Type(kind: TypeKind.Type(InstanceKind.Struct(self.project.preludeSetStruct))), None))
      _ => {
        var scope = Some(self.currentScope)
        while scope |sc| {
          for ty in sc.types {
            match ty.kind {
              TypeKind.Generic(genericName) => if name == genericName return Some((ty, None))
              TypeKind.Type(instanceKind) => {
                match instanceKind {
                  InstanceKind.Struct(struct) => if name == struct.label.name return Some((ty, None))
                  InstanceKind.Enum(enum_) => if name == enum_.label.name return Some((ty, None))
                }
              }
              _ => continue
            }
          }
          scope = sc.parent
        }

        for ty in self.project.preludeModule.rootScope.types {
          match ty.kind {
            TypeKind.Generic(genericName) => if name == genericName return Some((ty, None))
            TypeKind.Type(instanceKind) => {
              match instanceKind {
                InstanceKind.Struct(struct) => if name == struct.label.name return Some((ty, None))
                InstanceKind.Enum(enum_) => if name == enum_.label.name return Some((ty, None))
              }
            }
            _ => continue
          }
        }

        for (moduleName, importedModule) in self.currentModule.imports {
          for (importName, imp) in importedModule.imports {
            if importName == name {
              match imp.kind {
                TypedImportKind.Type(instanceKind, _) => {
                  val ty = Type(kind: TypeKind.Type(instanceKind))

                  val importMod = self.project.modules[moduleName]
                  match instanceKind {
                    InstanceKind.Struct(struct) => if name == struct.label.name return Some((ty, importMod))
                    InstanceKind.Enum(enum_) => if name == enum_.label.name return Some((ty, importMod))
                  }
                }
                _ => continue
              }
            }
          }
        }

        None
      }
    }
  }

  func resolveTypeIdentifier(self, typeIdent: TypeIdentifier): Result<Type, TypeError> {
    val ty = match typeIdent {
      TypeIdentifier.Normal(label, typeArguments, path) => {
        if path[0] |firstSeg| {
          val (mod, aliasLabel) = try self.findModuleByAlias(firstSeg.name) else {
            return Err(TypeError(position: firstSeg.position, kind: TypeErrorKind.UnknownName(firstSeg.name, "module")))
          }

          if path[1] |seg| return Err(TypeError(position: seg.position, kind: TypeErrorKind.NotYetImplemented("qualified type paths longer than 2")))

          if self.lspMode {
            val ident = IdentifierMeta(
              name: aliasLabel.name,
              kind: IdentifierKindMeta.Module(mod.name),
              definitionPosition: Some((IdentifierMetaModule.Module(self.currentModule.name), aliasLabel.position)),
            )
            self._addLSPIdent(firstSeg.position, ident)
          }

          val foundTy = match mod.exports[label.name] {
            None => return Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownImportForAlias(label.name, aliasLabel)))
            Export.Type(instanceKind, _) => {
              try self._resolveInstanceTypeIdentifier(Some(mod), instanceKind, label, typeArguments)
            }
            _ => None
          }

          return if foundTy |ty| Ok(ty) else Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
        }

        val (ty, importMod) = try self.findTypeByNameInScope(label.name) else {
          return Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
        }
        match ty.kind {
          TypeKind.Type(instanceKind) => {
            val ty = try self._resolveInstanceTypeIdentifier(importMod, instanceKind, label, typeArguments)
            try ty else unreachable()
          }
          TypeKind.PrimitiveInt => {
            if self.lspMode self._addLSPIdentForStruct(label.position, self.project.preludeIntStruct, None)
            try self._verifyNumTypeArgs(label.position, typeArguments, 0)
            ty
          }
          TypeKind.PrimitiveFloat => {
            if self.lspMode self._addLSPIdentForStruct(label.position, self.project.preludeFloatStruct, None)
            try self._verifyNumTypeArgs(label.position, typeArguments, 0)
            ty
          }
          TypeKind.PrimitiveBool => {
            if self.lspMode self._addLSPIdentForStruct(label.position, self.project.preludeBoolStruct, None)
            try self._verifyNumTypeArgs(label.position, typeArguments, 0)
            ty
          }
          TypeKind.PrimitiveChar => {
            if self.lspMode self._addLSPIdentForStruct(label.position, self.project.preludeCharStruct, None)
            try self._verifyNumTypeArgs(label.position, typeArguments, 0)
            ty
          }
          TypeKind.PrimitiveString => {
            if self.lspMode self._addLSPIdentForStruct(label.position, self.project.preludeStringStruct, None)
            try self._verifyNumTypeArgs(label.position, typeArguments, 0)
            ty
          }
          _ => {
            try self._verifyNumTypeArgs(label.position, typeArguments, 0)
            ty
          }
        }
      }
      TypeIdentifier.Array(inner) => {
        val innerTy = try self.resolveTypeIdentifier(inner)
        Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeArrayStruct), [innerTy]))
      }
      TypeIdentifier.Option(inner) => {
        val innerTy = try self.resolveTypeIdentifier(inner)
        Type(kind: TypeKind.Instance(InstanceKind.Enum(self.project.preludeOptionEnum), [innerTy]))
      }
      TypeIdentifier.Tuple(typeIdents) => {
        val types: Type[] = []
        for typeIdent in typeIdents {
          val ty = try self.resolveTypeIdentifier(typeIdent)
          types.push(ty)
        }

        Type(kind: TypeKind.Tuple(types))
      }
      TypeIdentifier.Function(params, ret) => {
        val paramTypes: (Type, Bool)[] = []
        for p in params {
          val typeIdent = try self.resolveTypeIdentifier(p)
          paramTypes.push((typeIdent, true))
        }

        val returnType = try self.resolveTypeIdentifier(ret)
        Type(kind: TypeKind.Func(paramTypes, returnType))
      }
    }

    Ok(ty)
  }

  // TODO: At some point, make this work with module alias types (eg. `foo.Bar` and `foo.Baz.Qux` for a module `foo` containing type `Bar` and enum `Baz`)
  //       This can perhaps be called in place of the current body for `TypeIdentifier.Normal` in `resolveTypeIdentifier` above, and fail if the result
  //       if Right (because enum variants are not (yet?) valid individually-addressable types).
  func _resolveTypeOrEnumVariant(self, path: Label[], last: Label): Result<Either<Type, (Enum, TypedEnumVariant, Int)>, TypeError> {
    match path[0] {
      None => {
        val (ty, importMod) = try self.findTypeByNameInScope(last.name) else {
          return Err(TypeError(position: last.position, kind: TypeErrorKind.UnknownName(last.name, "type")))
        }
        val t = match ty.kind {
          TypeKind.Type(instanceKind) => Type(kind: TypeKind.Instance(instanceKind, []))
          _ => ty
        }

        if self.lspMode {
          if self._getLSPTypeData(t) |(definitionModule, instanceKind)| {
            match instanceKind {
              InstanceKind.Struct(struct) => self._addLSPIdentForStruct(last.position, struct, importMod)
              InstanceKind.Enum(enum_) => self._addLSPIdentForEnum(last.position, enum_, importMod)
            }
          }
        }

        return Ok(Either.Left(t))
      }
      _ first => {
        match self.findModuleByAlias(first.name) {
          None => {
            val (ty, importMod) = try self.findTypeByNameInScope(first.name) else {
              return Err(TypeError(position: first.position, kind: TypeErrorKind.UnknownName(first.name, "type")))
            }
            val label = if path[1] |seg| {
              return Err(TypeError(position: seg.position, kind: TypeErrorKind.UnknownName(seg.name, "type")))
            } else {
              last
            }

            match ty.kind {
              TypeKind.Type(instanceKind) => {
                match instanceKind {
                  InstanceKind.Enum(enum_) => {
                    if enum_.variants.findIndex(v => v.label.name == label.name) |(variant, variantIdx)| {
                      if self.lspMode {
                        self._addLSPIdentForEnum(first.position, enum_, importMod)
                        self._addLSPIdentForEnumVariant(label.position, enum_, variant)
                      }

                      return Ok(Either.Right((enum_, variant, variantIdx)))
                    }
                  }
                  _ => {}
                }
              }
              _ => {}
            }

            Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownName(label.name, "type")))
          }
          _ => todo("module aliases")
        }
      }
    }
  }

  func _resolveIdentifier(self, ident: String): (Variable, TypedModule?)? {
    val currentFnScope = self.currentFunction?.scope
    var scope: Scope? = Some(self.currentScope)
    var fnBarrierBreached = false

    while scope |s| {
      for v in s.variables {
        if v.label.name == ident {
          if !v.alias && fnBarrierBreached {
            v.isCaptured = true
            if self.currentFunction |fn| {
              // Captured top-level variables in a module are marked as captured but are not included in a function's captures
              if !v.isGlobal() && !fn.captures.contains(v) {
                fn.captures.push(v)
              }
            }
          }

          return Some((v, None))
        }
      }

      scope = s.parent
      if currentFnScope |currentFnScope| {
        if scope == currentFnScope.parent {
          fnBarrierBreached = true
        }
      }
    }

    for v in self.project.preludeModule.rootScope.variables {
      if v.label.name == ident {
        if !v.alias && fnBarrierBreached {
          v.isCaptured = true
          if !v.isGlobal() unreachable("Exported variable 'prelude:${v.label.name}' is not marked as a global")
        }

        return Some((v, None))
      }
    }

    for (name, importedModule) in self.currentModule.imports {
      for (importedName, importedValue) in importedModule.imports {
        if importedName == ident {
          val v = match importedValue.kind {
            TypedImportKind.Variable(v) => {
              if !v.alias && fnBarrierBreached {
                v.isCaptured = true
                if !v.isGlobal() unreachable("Exported variable '$name:${v.label.name}' is not marked as a global")
              }

              v
            }
            TypedImportKind.Function(aliasVar) => aliasVar
            TypedImportKind.Type(_, aliasVar) => aliasVar
          }

          return Some((v, self.project.modules[name]))
        }
      }
    }

    None
  }

  func _typeSatisfiesRequired(self, ty: Type, required: Type): Bool {
    if required.kind == TypeKind.CouldNotDetermine || ty.kind == TypeKind.CouldNotDetermine return true
    if required.kind == TypeKind.Hole return true
    if required.kind == TypeKind.Never || ty.kind == TypeKind.Never return true

    match required.kind {
      TypeKind.PrimitiveInt => match ty.kind {
        TypeKind.PrimitiveInt => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.project.preludeIntStruct)
        _ => false
      }
      TypeKind.PrimitiveFloat => match ty.kind {
        TypeKind.PrimitiveFloat => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.project.preludeFloatStruct)
        _ => false
      }
      TypeKind.PrimitiveBool => match ty.kind {
        TypeKind.PrimitiveBool => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.project.preludeBoolStruct)
        _ => false
      }
      TypeKind.PrimitiveChar => match ty.kind {
        TypeKind.PrimitiveChar => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.project.preludeCharStruct)
        _ => false
      }
      TypeKind.PrimitiveString => match ty.kind {
        TypeKind.PrimitiveString => true
        TypeKind.Instance(instanceKind, _) => instanceKind == InstanceKind.Struct(self.project.preludeStringStruct)
        _ => false
      }
      TypeKind.Func(reqParamTypes, reqRetType) => match ty.kind {
        TypeKind.Func(paramTypes, retType) => {
          if !self._typeSatisfiesRequired(ty: retType, required: reqRetType) return false

          var idx = 0
          for (reqParamType, _), i in reqParamTypes {
            val (paramType, _) = try paramTypes[i] else return true
            if !self._typeSatisfiesRequired(ty: paramType, required: reqParamType) return false

            idx = i
          }
          if paramTypes[idx + 1] |(_, isRequired)| {
            if isRequired return false
          }

          true
        }
        _ => false
      }
      TypeKind.Instance(reqStructOrEnum, reqTypeArgs) => match ty.kind {
        TypeKind.Instance(instanceKind, typeArgs) => {
          if reqStructOrEnum != instanceKind return false

          if reqTypeArgs.length != typeArgs.length return false
          for reqTypeArg, i in reqTypeArgs {
            val typeArg = try typeArgs[i] else return true
            if !self._typeSatisfiesRequired(ty: typeArg, required: reqTypeArg) return false
          }

          true
        }
        TypeKind.PrimitiveInt => reqStructOrEnum == InstanceKind.Struct(self.project.preludeIntStruct)
        TypeKind.PrimitiveFloat => reqStructOrEnum == InstanceKind.Struct(self.project.preludeFloatStruct)
        TypeKind.PrimitiveBool => reqStructOrEnum == InstanceKind.Struct(self.project.preludeBoolStruct)
        TypeKind.PrimitiveChar => reqStructOrEnum == InstanceKind.Struct(self.project.preludeCharStruct)
        TypeKind.PrimitiveString => reqStructOrEnum == InstanceKind.Struct(self.project.preludeStringStruct)
        _ => false
      }
      TypeKind.Tuple(reqTypes) => match ty.kind {
        TypeKind.Tuple(types) => {
          if reqTypes.length != types.length return false
          for reqTy, i in reqTypes {
            val ty = try types[i] else unreachable("length verified above to be equal")
            if !self._typeSatisfiesRequired(ty: ty, required: reqTy) return false
          }

          true
        }
        _ => false
      }
      _ => {
        ty.kind == required.kind
      }
    }
  }

  func _genericsInScope(self): Set<String> {
    val genericsInScope: Set<String> = #{}
    if self.currentFunction |fn| {
      for (ty, _) in fn.typeParams {
        match ty.kind {
          TypeKind.Generic(name) => genericsInScope.insert(name)
          _ => unreachable("typeParam.kind != TypeKind.Generic")
        }
      }

      match fn.kind {
        FunctionKind.InstanceMethod(typeDecl, _) => {
          val genericNames = match typeDecl {
            InstanceKind.Struct(struct) => struct.typeParams,
            InstanceKind.Enum(enum_) => enum_.typeParams,
            None => []
          }
          for name in genericNames {
            genericsInScope.insert(name)
          }
        }
        _ => {}
      }
    }

    genericsInScope
  }

  func _typeAsInstance1(self, ty: Type, struct: Struct): Type? {
    match ty.kind {
      TypeKind.Instance(s, generics) => if s == InstanceKind.Struct(struct) { generics[0] } else None
      _ => None
    }
  }

  func _typeAsInstance2(self, ty: Type, struct: Struct): (Type, Type)? {
    match ty.kind {
      TypeKind.Instance(s, generics) => if s == InstanceKind.Struct(struct) {
        if generics[0] |g1| (if generics[1] |g2| Some((g1, g2)) else None) else None
      } else None
      _ => None
    }
  }

  func ensureValidExportScope(self, pubToken: Token): TypeError? {
    match self.currentScope.kind {
      ScopeKind.Module => None
      _ => Some(TypeError(position: pubToken.position, kind: TypeErrorKind.IllegalExportScope))
    }
  }

  func _isIllegalAccessForMember(self, memberModuleId: Int): Bool {
    // Non-public members are only allowed to be accessed within the file in which they're defined
    if memberModuleId == self.currentModule.id return false

    // For performance reasons, all members within standard lib modules are visible to each other
    if self.currentModule.name.startsWith(self.moduleLoader.stdRoot) return false

    true
  }

  func _nextLambdaName(self): String {
    val name = "lambda_${self.currentModule.id}_${self.numLambdas}"
    self.numLambdas += 1
    name
  }

  func beginChildScope(self, name: String, kind: ScopeKind): Scope {
    val newScope = self.currentScope.makeChild(name, kind)
    newScope.idxInFn = if self.currentFunction |f| {
      f.numScopes += 1
      f.numScopes
    } else {
      self.numRootLevelScopes += 1
      self.numRootLevelScopes
    }
    val prevScope = self.currentScope
    self.currentScope = newScope
    prevScope
  }

  // Start LSP helpers

  func _addLSPIdentForStruct(self, position: Position, struct: Struct, importMod: TypedModule?) {
    val defMod = if struct.scope.parent == Some(self.project.preludeModule.rootScope) {
      IdentifierMetaModule.Prelude
    } else {
      IdentifierMetaModule.Module(importMod?.name ?: self.currentModule.name)
    }

    val ident = IdentifierMeta(
      name: struct.label.name,
      kind: IdentifierKindMeta.Type(isEnum: false, typeParams: struct.typeParams),
      definitionPosition: Some((defMod, struct.label.position)),
    )

    self._addLSPIdent(position, ident)
  }

  func _addLSPIdentForEnum(self, position: Position, enum_: Enum, importMod: TypedModule?) {
    val defMod = if enum_.scope.parent == Some(self.project.preludeModule.rootScope) {
      IdentifierMetaModule.Prelude
    } else {
      IdentifierMetaModule.Module(importMod?.name ?: self.currentModule.name)
    }

    val ident = IdentifierMeta(
      name: enum_.label.name,
      kind: IdentifierKindMeta.Type(isEnum: true, typeParams: enum_.typeParams),
      definitionPosition: Some((defMod, enum_.label.position)),
    )

    self._addLSPIdent(position, ident)
  }

  func _addLSPIdentForEnumVariant(self, position: Position, enum_: Enum, variant: TypedEnumVariant) {
    val definitionModule = if enum_.scope.parent == Some(self.project.preludeModule.rootScope) {
      IdentifierMetaModule.Prelude
    } else {
      match enum_.scope.parent?.kind {
        ScopeKind.Module(_, name) => IdentifierMetaModule.Module(name)
        _ => unreachable()
      }
    }

    val enumTypeRepr = enum_.asInstanceType().repr(shorthand: false)

    val fields = match variant.kind {
      EnumVariantKind.Constant => []
      EnumVariantKind.Container(fields) => {
        fields.map(f => "${f.name.name}${if f.initializer "?" else ""}: ${f.ty.repr()}")
      }
    }

    val ident = IdentifierMeta(
      name: variant.label.name,
      kind: IdentifierKindMeta.EnumVariant(enumTypeRepr, fields),
      definitionPosition: Some((definitionModule, variant.label.position)),
    )
    self._addLSPIdent(position, ident)
  }

  func _addLSPIdent(self, position: Position, ident: IdentifierMeta) {
    val v = (position.col - 1, position.col + ident.name.length - 1, ident)
    if self.identsByLine[position.line - 1] |idents| {
      idents.push(v)
    } else {
      self.identsByLine[position.line - 1] = [v]
    }
  }

  func _getLSPTypeData(self, ty: Type): (IdentifierMetaModule, InstanceKind)? {
    val instanceKind = match ty.kind {
      TypeKind.PrimitiveInt => InstanceKind.Struct(self.project.preludeIntStruct)
      TypeKind.PrimitiveFloat => InstanceKind.Struct(self.project.preludeFloatStruct)
      TypeKind.PrimitiveBool => InstanceKind.Struct(self.project.preludeBoolStruct)
      TypeKind.PrimitiveChar => InstanceKind.Struct(self.project.preludeCharStruct)
      TypeKind.PrimitiveString => InstanceKind.Struct(self.project.preludeStringStruct)
      TypeKind.Type(type_) => type_
      TypeKind.Instance(instanceKind, _) => instanceKind
      else => return None
    }

    val scope = match instanceKind {
      InstanceKind.Struct(struct) => struct.scope
      InstanceKind.Enum(enum_) => enum_.scope
    }

    val mod = if scope.parent == Some(self.project.preludeModule.rootScope) {
      IdentifierMetaModule.Prelude
    } else {
      match scope.parent?.kind {
        ScopeKind.Module(_, name) => IdentifierMetaModule.Module(name)
        _ => unreachable()
      }
    }

    Some((mod, instanceKind))
  }

  // End LSP helpers

  func _typecheckModule(self, modulePathAbs: String): TypedModule {
    if self.project.modules[modulePathAbs] |mod| return mod

    self.typecheckingBuiltin = if modulePathAbs == self.moduleLoader.stdRoot + "/prelude.abra" {
      Some(BuiltinModule.Prelude)
    } else if modulePathAbs == self.moduleLoader.stdRoot + "/_intrinsics.abra" {
      Some(BuiltinModule.Intrinsics)
    } else if modulePathAbs == self.moduleLoader.stdRoot + "/meta.abra" {
      Some(BuiltinModule.Meta)
    } else {
      None
    }

    // Insert module with placeholder scope and moduleId. These values will be filled in after typechecking
    // this module's imports; this ensures that sorting the final list of modules by id results in a resolved
    // dependency graph.
    val mod = TypedModule(id: -1, name: modulePathAbs, code: [], rootScope: Scope.bogus())
    self.currentModule = mod
    self.project.modules[modulePathAbs] = mod
    if self.typecheckingBuiltin == Some(BuiltinModule.Prelude) {
      self.project.preludeModule = mod
      self.project.preludeModule.rootScope = self.currentScope.makeChild("module_prelude", ScopeKind.Module(id: -1, name: modulePathAbs))
    }

    val parsedModule = try self.moduleLoader.tokenizeAndParse(modulePathAbs) else |e| {
      match e {
        TokenizeAndParseError.ReadFileError => {
          // Mark the module as having an reading error, and also as complete since it's gone as far as it can go
          mod.readFileError = true
          mod.complete = true
        }
        TokenizeAndParseError.LexerError(inner) => mod.lexParseErrors.push(LexerOrParseError.LexerError(inner))
        TokenizeAndParseError.ParseError(inner) => mod.lexParseErrors.push(LexerOrParseError.ParseError(inner))
      }

      // TODO: recover from this error?
      // Maybe, for ParseErrors perhaps if we emit garbage. That may be a good way to implement intellisense in LSP
      return mod
    }

    // An Err return value here means we saw a circular dependency, and we need to bail
    val imports = try self.processImports(Some(modulePathAbs), parsedModule) else return mod

    val moduleId = self.project.modules.values().filter(m => m.id != -1).length
    val moduleScope = if self.typecheckingBuiltin == Some(BuiltinModule.Prelude) {
      self.project.preludeModule.rootScope.kind = ScopeKind.Module(id: moduleId, name: modulePathAbs)
      self.project.preludeModule.rootScope
    } else {
      self.currentScope.makeChild("module_$moduleId", ScopeKind.Module(id: moduleId, name: modulePathAbs))
    }
    val prevScope = self.currentScope
    self.currentScope = moduleScope
    mod.id = moduleId
    mod.rootScope = moduleScope

    for (typedImportModule, importNode) in imports {
      val errors = self._typecheckImport(typedImportModule, importNode)
      for err in errors {
        mod.addTypeError(err)
      }
    }

    match self.typecheckBlock(parsedModule.nodes) {
      Ok(v) => mod.code = v
      Err(e) => mod.addTypeError(e)
    }

    self.currentScope = prevScope
    mod.complete = true
    mod.identsByLine = self.identsByLine
    if self.typecheckingBuiltin {
      self.typecheckingBuiltin = None
    }

    mod
  }

  func typecheckDecoratorNode(self, dec: DecoratorNode): Result<Decorator, TypeError> {
    val decName = dec.name.name
    val (foundTy, _) = try self.findTypeByNameInScope(decName) else {
      return Err(TypeError(position: dec.name.position, kind: TypeErrorKind.UnknownName(decName, "decorator")))
    }
    val struct = match foundTy.kind {
      TypeKind.Type(instanceKind) => match instanceKind {
        InstanceKind.Struct(s) => if !s.isDecoratorType None else Some(s)
        InstanceKind.Enum => None
      }
      else => None
    }
    val decoratorStruct = try struct else return Err(TypeError(position: dec.name.position, kind: TypeErrorKind.IllegalDecoratorType(ty: foundTy)))

    val initializerFn = Function.initializer(self.currentScope, decoratorStruct)
    val bogusTok = Token(position: dec.name.position, kind: TokenKind.LParen(false))
    val res = try self.typecheckInvocationOfFunction(bogusTok, dec.name.position, initializerFn, [], dec.arguments, None, None, Some(Instantiatable.Struct(decoratorStruct)))
    val typedArgs = match res.kind {
      TypedAstNodeKind.Invocation(_, typedArgs, _) => typedArgs
      else => unreachable("must be TypedAstNodeKind.Invocation")
    }

    val args: LiteralAstNode[] = []
    for arg in typedArgs {
      match arg?.kind {
        None => todo("default-valued decorator fields")
        TypedAstNodeKind.Literal(litNode) => args.push(litNode)
        else => unreachable("non-literal decorator argument, should have been caught during parsing")
      }
    }

    Ok(Decorator(backingStruct: decoratorStruct, label: dec.name, arguments: args))
  }

  func typecheckFunctionPass1(self, node: FunctionDeclarationNode): Result<Function, TypeError> {
    val decorators: Decorator[] = []
    var isMacro = false
    for d in node.decorators {
      val dec = try self.typecheckDecoratorNode(d) else |err| {
        // Report error and recover
        self.currentModule.addTypeError(err)
        continue
      }
      decorators.push(dec)

      if dec.backingStruct == self.project.metaMacroDecorator {
        isMacro = true
      }
    }

    val prevScope = self.beginChildScope(node.name.name, ScopeKind.Func)
    val fnScope = self.currentScope

    val typeParams: (Type, Label)[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        self.currentModule.addTypeError(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      } else {
        seenTypeParams[label.name] = label

        val generic = Type(kind: TypeKind.Generic(label.name))
        self.currentScope.types.push(generic)
        typeParams.push((generic, label))
      }
    }

    val returnType = if node.returnTypeAnnotation |typeAnn| {
      try self.resolveTypeIdentifier(typeAnn) else |err| {
        self.currentModule.addTypeError(err)
        Type(kind: TypeKind.CouldNotDetermine)
      }
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    if isMacro {
      if !self._typeSatisfiesRequired(ty: returnType, required: Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.metaInjectedCodeStruct), []))) {
        self.currentModule.addTypeError(TypeError(position: node.name.position, kind: TypeErrorKind.InvalidMacroReturnType(self.project.metaInjectedCodeStruct)))
      }
    }

    self.currentScope = prevScope

    val selfParam = if node.params[0] |param| { if param.label.name == "self" Some(param) else None } else None
    val fnKind = if selfParam |selfParam| {
      if self.currentTypeDecl |selfType| {
        FunctionKind.InstanceMethod(Some(selfType), !!node.pubToken)
      } else {
        return Err(TypeError(position: selfParam.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))
      }
    } else if self.currentTypeDecl |parentType| {
      FunctionKind.StaticMethod(parentType, !!node.pubToken)
    } else {
      FunctionKind.Standalone
    }

    val fn = Function(label: node.name, scope: fnScope, kind: fnKind, typeParams: typeParams, params: [], returnType: returnType, body: [], decorators: decorators, isMacro: isMacro)
    try self.addFunctionToScope(fn)

    Ok(fn)
  }

  func typecheckFunctionParam(self, param: FunctionParam, typeHint: Type?, allowSelf: Bool, isRevisit = false): Result<(TypedFunctionParam, Bool), TypeError> {
    if param.label.name == "self" {
      if !allowSelf return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))

      if self.currentTypeDecl |instanceKind| {
        val ty = instanceKind.asInstanceType()

        val variable = Variable(label: param.label, scope: self.currentScope, mutable: false, ty: ty, isParameter: true)
        try self.addVariableToScope(variable)

        val typedParam = TypedFunctionParam(label: param.label, ty: ty, defaultValue: None, isVariadic: false, variable: variable)
        return Ok((typedParam, false))
      }

      return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "self")))
    }

    val paramType = if param.typeAnnotation |typeAnn| {
      val ty = try self.resolveTypeIdentifier(typeAnn) else |err| {
        self.currentModule.addTypeError(err)
        Type(kind: TypeKind.CouldNotDetermine)
      }
      if typeHint |hintTy| {
        if !self._typeSatisfiesRequired(ty: ty, required: hintTy) {
          return Err(TypeError(position: param.label.position, kind: TypeErrorKind.TypeMismatch([hintTy], ty)))
        }
      }
      Some(ty)
    } else if typeHint |hintTy| {
      Some(hintTy)
    } else {
      None
    }

    var defaultValue: TypedAstNode? = None
    if param.defaultValue |node| {
      if isRevisit {
        match self._typecheckExpression(node, paramType) {
          Ok(expr) => { defaultValue = Some(expr) }
          Err(err) => {
            self.currentModule.addTypeError(err)
          }
        }
      } else {
        // TODO: There has to be a cleaner way of representing this
        val ctx = ParamDefaultValueContext()
        self.paramDefaultValueContext = Some(ctx)
        val expr = match self._typecheckExpression(node, paramType) {
          Ok(v) => v
          Err(e) => {
            self.paramDefaultValueContext = None
            if ctx.exprContainsFunctionCall || ctx.exprContainsVariableRef {
              val placeholder = Some(TypedAstNode(token: node.token, ty: Type(kind: TypeKind.Hole), kind: TypedAstNodeKind.Placeholder))
              val typedParam = TypedFunctionParam(label: param.label, ty: Type(kind: TypeKind.Hole), defaultValue: placeholder, isVariadic: param.isVariadic, variable: Variable.bogus())
              return Ok((typedParam, true))
            }
            return Err(e)
          }
        }
        self.paramDefaultValueContext = None
        if ctx.exprContainsFunctionCall || ctx.exprContainsVariableRef {
          val typedParam = TypedFunctionParam(label: param.label, ty: paramType ?: expr.ty, defaultValue: Some(expr), isVariadic: param.isVariadic, variable: Variable.bogus())
          return Ok((typedParam, true))
        }
        defaultValue = Some(expr)
      }
    }

    var ty = if paramType |paramType| {
      if defaultValue |defaultValue| {
        if !self._typeSatisfiesRequired(ty: defaultValue.ty, required: paramType) {
          return Err(TypeError(position: defaultValue.token.position, kind: TypeErrorKind.TypeMismatch([paramType], defaultValue.ty)))
        }

        if paramType.kind == TypeKind.CouldNotDetermine {
          defaultValue.ty
        } else {
          paramType
        }
      } else {
        paramType
      }
    } else {
      if defaultValue |defaultValue| {
        defaultValue.ty
      } else {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.UnknownParameterType(param.label.name)))
      }
    }

    val variable = Variable(label: param.label, scope: self.currentScope, mutable: false, ty: ty, isParameter: true)
    try self.addVariableToScope(variable)

    if param.isVariadic {
      if self._typeAsInstance1(ty, self.project.preludeArrayStruct) |innerType| {
        ty = innerType
      } else {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidVarargType(ty)))
      }
    }

    if ty.hasUnfilledHoles() {
      return Err(TypeError(position: param.label.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "parameter")))
    }

    val typedParam = TypedFunctionParam(label: param.label, ty: ty, defaultValue: defaultValue, isVariadic: param.isVariadic, variable: variable)
    Ok((typedParam, false))
  }

  func typecheckFunctionPass2(self, fn: Function, allowSelf: Bool, params: FunctionParam[], paramHints: Type[] = []): Result<Int[], TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope

    val paramsNeedingRevisit: Int[] = []
    val seenParamNames: Set<String> = #{}
    var startedOptionalParams = false
    for param, idx in params {
      if param.isVariadic && idx != params.length - 1 {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "vararg")))
      }

      if seenParamNames.contains(param.label.name) {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.DuplicateParameter(param.label.name)))
      }
      seenParamNames.insert(param.label.name)

      if param.defaultValue {
        startedOptionalParams = true
      } else if startedOptionalParams {
        return Err(TypeError(position: param.label.position, kind: TypeErrorKind.InvalidParamPosition(purpose: "required")))
      }

      val hint = paramHints[idx]
      val (typedParam, needsRevisit) = try self.typecheckFunctionParam(param, hint, allowSelf)
      if fn.isMacro {
        if !self._typeSatisfiesRequired(ty: typedParam.ty, required: Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.metaExprStruct), []))) {
          self.currentModule.addTypeError(TypeError(position: typedParam.label.position, kind: TypeErrorKind.InvalidMacroParamType(self.project.metaExprStruct)))
        }
      }
      val paramName = typedParam.label.name
      // This is a bit messy - if param is `self` then don't add here; it's already denoted as an instance method via its FunctionKind
      if paramName != "self" { fn.params.push(typedParam) }
      // Adjust the index value if we're in an instance method, since `self` isn't included in the fn.params array
      if needsRevisit {
        val paramIdx = match fn.kind { FunctionKind.InstanceMethod => idx - 1, _ => idx }
        paramsNeedingRevisit.push(paramIdx)
      }
    }

    self.currentScope = prevScope

    Ok(paramsNeedingRevisit)
  }

  func typecheckFunctionPass3(self, fn: Function, allowSelf: Bool, params: FunctionParam[], body: AstNode[], paramsNeedingRevisit: Int[], paramHints: Type[] = []): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = fn.scope
    val prevFn = self.currentFunction
    self.currentFunction = Some(fn)

    val hasReturnValue = fn.returnType.kind != TypeKind.PrimitiveUnit && fn.returnType.kind != TypeKind.CouldNotDetermine
    if hasReturnValue && body.isEmpty() {
      if !fn.decorators.find(dec => dec.label.name == "intrinsic" || dec.label.name == "external")
        return Err(TypeError(position: fn.label.position, kind: TypeErrorKind.ReturnTypeMismatch(Some(fn.label.name), fn.returnType, None)))
    }

    for param, idx in fn.params {
      if !paramsNeedingRevisit.contains(idx) continue

      // Since `self` is not included in the fn.params array, but it is in the untyped AST, when referring to the untyped AST, we need to adjust
      val origNodeParamIdx = match fn.kind { FunctionKind.InstanceMethod => idx + 1, _ => idx }
      val paramNode = try params[origNodeParamIdx] else unreachable("there should be as many parameter nodes as typed parameters")
      val defaultValueNode = try paramNode.defaultValue else unreachable("the only way a parameter needs revisiting is if it has a default value")

      val hint = paramHints[idx]
      val (typedParam, needsRevisit) = try self.typecheckFunctionParam(param: paramNode, typeHint: hint, allowSelf: allowSelf, isRevisit: true)
      if needsRevisit unreachable("parameters should not need to be revisited more than once")
      fn.params[idx] = typedParam
    }

    for node, idx in body {
      if self.currentScope.terminator == Some(Terminator.Returning) return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = if idx == body.length - 1 && hasReturnValue {
        val fnName = if fn.isLambda None else Some(fn.label.name)
        val err = TypeError(position: node.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Some(Type(kind: TypeKind.PrimitiveUnit))))
        match node.kind {
          AstNodeKind.While => return Err(err)
          AstNodeKind.For => return Err(err)
          AstNodeKind.BindingDeclaration => return Err(err)
          AstNodeKind.FunctionDeclaration => return Err(err)
          AstNodeKind.TypeDeclaration => return Err(err)
          AstNodeKind.EnumDeclaration => return Err(err)
          _ => {}
        }

        // Typecheck final expression, passing the function's returnType as the hint if it doesn't have any unfilled holes (when typechecking
        // a lambda function, its returnType will always start off as a Hole). Once we have a typechecked expression, attempt to fill any holes
        // that may exist in the function's returnType as well as the expression; this bidirectional hole-filling is necessary to support this
        // case, for example:
        //   val fn = () => {
        //     if true return Err("hello")
        //     Ok(123)
        //   }
        val hint = if fn.returnType.hasUnfilledHoles() None else Some(fn.returnType)
        val expr = try self._typecheckExpressionOrTerminator(node, hint)
        if fn.returnType.hasUnfilledHoles() {
          fn.returnType.tryFillHoles(expr.ty)
        }
        if expr.ty.hasUnfilledHoles() {
          expr.ty.tryFillHoles(fn.returnType)
        }
        if !self._typeSatisfiesRequired(ty: expr.ty, required: fn.returnType) {
          val fnName = if fn.isLambda None else Some(fn.label.name)
          self.currentModule.addTypeError(TypeError(position: expr.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Some(expr.ty))))
          TypedAstNode(token: expr.token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder)
        } else {
          expr
        }
      } else {
        self.typecheckStatement(node, None)
      }
      fn.body.push(typedNode)
    }

    self.currentFunction = prevFn
    self.currentScope = prevScope

    Ok(0)
  }

  func typecheckStructPass1(self, node: TypeDeclarationNode): Result<Struct, TypeError> {
    val isPublic = if node.pubToken |pubToken| {
      // If not in a valid export scope, report error and treat it as if not marked `pub`
      if self.ensureValidExportScope(pubToken) |err| {
        self.currentModule.addTypeError(err)
        false
      } else {
        true
      }
    } else {
      false
    }

    val prevScope = self.beginChildScope(node.name.name, ScopeKind.Type)
    val typeScope = self.currentScope

    val typeParams: String[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        self.currentModule.addTypeError(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      } else {
        seenTypeParams[label.name] = label

        self.currentScope.types.push(Type(kind: TypeKind.Generic(label.name)))
        typeParams.push(label.name)
      }
    }

    self.currentScope = prevScope

    val currentModuleId = self.currentModule.id
    val struct = Struct(moduleId: currentModuleId, label: node.name, scope: typeScope, typeParams: typeParams, builtin: self.typecheckingBuiltin)
    try self.addStructToScope(struct, isPublic)

    Ok(struct)
  }

  func _typecheckStructPass2_1(self, struct: Struct, node: TypeDeclarationNode): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(InstanceKind.Struct(struct))

    val seenFields: Map<String, Label> = {}
    for field in node.fields {
      if seenFields[field.name.name] |original| {
        return Err(TypeError(position: field.name.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenFields[field.name.name] = field.name

      val ty = try self.resolveTypeIdentifier(field.typeAnnotation)
      if struct.isDecoratorType && !self.typeIsCompileTimeKnown(ty) {
        self.currentModule.addTypeError(TypeError(position: field.name.position, kind: TypeErrorKind.NonComptimeDecoratorFieldType(struct.label.name, field.name.name, ty)))
      }
      struct.fields.push(Field(name: field.name, ty: ty, initializer: None, isPublic: !!field.pubToken))
    }

    for funcDeclNode in node.methods {
      val fn = try self.typecheckFunctionPass1(funcDeclNode)
      match fn.kind {
        FunctionKind.InstanceMethod => struct.instanceMethods.push(fn)
        FunctionKind.StaticMethod => struct.staticMethods.push(fn)
        FunctionKind.Standalone => unreachable("method has invalid function kind at this point")
      }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(0)
  }

  func _typecheckMethodsPass2(self, instanceKind: InstanceKind, funcDeclNodes: FunctionDeclarationNode[]): Result<Map<Label, Int[]>, TypeError> {
    val allParamsNeedingRevisit: Map<Label, Int[]> = {}

    val (scope, instanceMethods, staticMethods) = match instanceKind {
      InstanceKind.Struct(struct) => (struct.scope, struct.instanceMethods, struct.staticMethods)
      InstanceKind.Enum(enum_) => (enum_.scope, enum_.instanceMethods, enum_.staticMethods)
    }

    val selfInstanceType = match instanceKind {
      InstanceKind.Struct(struct) => struct.asInstanceType()
      InstanceKind.Enum(enum_) => Type(kind: TypeKind.Instance(InstanceKind.Enum(enum_), []))
    }

    val instanceMethodsByName = instanceMethods.keyBy(f => f.label)
    val staticMethodsByName = staticMethods.keyBy(f => f.label)
    var toStringFn: Function? = None
    var hashFn: Function? = None
    var eqFn: Function? = None
    for funcDeclNode in funcDeclNodes {
      var isToString = false
      var isHash = false
      var isEq = false
      val fn = if instanceMethodsByName[funcDeclNode.name] |fn| {
        isToString = fn.label.name == "toString"
        isHash = fn.label.name == "hash"
        isEq = fn.label.name == "eq"
        fn
      } else if staticMethodsByName[funcDeclNode.name] |fn| {
        fn
      } else {
        unreachable("could not find function among instance/static methods")
      }
      val paramsNeedingRevisit = try self.typecheckFunctionPass2(fn: fn, allowSelf: true, params: funcDeclNode.params)
      allParamsNeedingRevisit[fn.label] = paramsNeedingRevisit

      if isToString {
        val required = Type(kind: TypeKind.Func([], Type(kind: TypeKind.PrimitiveString)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        toStringFn = Some(fn)
      }
      if isHash {
        val required = Type(kind: TypeKind.Func([], Type(kind: TypeKind.PrimitiveInt)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        hashFn = Some(fn)
      }
      if isEq {
        val required = Type(kind: TypeKind.Func([(selfInstanceType, true)], Type(kind: TypeKind.PrimitiveBool)))
        if !self._typeSatisfiesRequired(ty: fn.getType(), required: required) {
          return Err(TypeError(position: fn.label.position, kind: TypeErrorKind.InvalidTraitMethodSignature(fn)))
        }
        eqFn = Some(fn)
      }
    }

    // Ensure toString/hash/eq methods exist (include generated stubs if not), and sure the proper order
    val reorderedInstanceMethods = [
      toStringFn ?: Function.generated(scope, "toString", [], Type(kind: TypeKind.PrimitiveString), FunctionKind.InstanceMethod(Some(instanceKind), true)),
      hashFn ?: Function.generated(scope, "hash", [], Type(kind: TypeKind.PrimitiveInt), FunctionKind.InstanceMethod(Some(instanceKind), true)),
      eqFn ?: Function.generated(scope, "eq", [("other", selfInstanceType)], Type(kind: TypeKind.PrimitiveBool), FunctionKind.InstanceMethod(Some(instanceKind), true)),
    ]
    for m in instanceMethods {
      if m.label.name == "toString" || m.label.name == "hash" || m.label.name == "eq" continue
      reorderedInstanceMethods.push(m)
    }

    match instanceKind {
      InstanceKind.Struct(struct) => struct.instanceMethods = reorderedInstanceMethods
      InstanceKind.Enum(enum_) => enum_.instanceMethods = reorderedInstanceMethods
    }

    Ok(allParamsNeedingRevisit)
  }

  func _typecheckStructPass2_2(self, struct: Struct, node: TypeDeclarationNode): Result<Map<Label, Int[]>, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(InstanceKind.Struct(struct))

    val allParamsNeedingRevisit = try self._typecheckMethodsPass2(InstanceKind.Struct(struct), node.methods)

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(allParamsNeedingRevisit)
  }

  func _typecheckStructPass3(self, struct: Struct, node: TypeDeclarationNode, paramsNeedingRevisit: Map<Label, Int[]>): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = struct.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(InstanceKind.Struct(struct))

    for field, idx in node.fields {
      val initializer = try field.initializer else continue
      val structField = try struct.fields[idx] else unreachable()

      val typedInitializer = try self._typecheckExpression(initializer, Some(structField.ty))
      if !self._typeSatisfiesRequired(ty: typedInitializer.ty, required: structField.ty) {
        return Err(TypeError(position: initializer.token.position, kind: TypeErrorKind.TypeMismatch([structField.ty], typedInitializer.ty)))
      }
      structField.initializer = Some(typedInitializer)
    }

    val instanceMethods = struct.instanceMethods.keyBy(f => f.label)
    val staticMethods = struct.staticMethods.keyBy(f => f.label)
    for funcDeclNode in node.methods {
      val fnLabel = funcDeclNode.name
      val fn = if instanceMethods[fnLabel] |f| {
        f
      } else if staticMethods[fnLabel] |f| {
        f
      } else {
        unreachable("method not visited in prior pass")
      }

      val toRevisit = try paramsNeedingRevisit[fnLabel] else unreachable("params improperly visited in prior pass")
      try self.typecheckFunctionPass3(fn: fn, allowSelf: true, params: funcDeclNode.params, body: funcDeclNode.body, paramsNeedingRevisit: toRevisit)
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(0)
  }

  func typecheckEnumPass1(self, node: EnumDeclarationNode): Result<Enum, TypeError> {
    val isPublic = if node.pubToken |pubToken| {
      // If not in a valid export scope, report error and treat it as if not marked `pub`
      if self.ensureValidExportScope(pubToken) |err| {
        self.currentModule.addTypeError(err)
        false
      } else {
        true
      }
    } else {
      false
    }

    val prevScope = self.beginChildScope(node.name.name, ScopeKind.Type)
    val typeScope = self.currentScope

    val typeParams: String[] = []
    val seenTypeParams: Map<String, Label> = {}
    for label in node.typeParams {
      if seenTypeParams[label.name] |original| {
        self.currentModule.addTypeError(TypeError(position: label.position, kind: TypeErrorKind.DuplicateName(original)))
      } else {
        seenTypeParams[label.name] = label

        self.currentScope.types.push(Type(kind: TypeKind.Generic(label.name)))
        typeParams.push(label.name)
      }
    }

    self.currentScope = prevScope

    val currentModuleId = self.currentModule.id
    val enum_ = Enum(moduleId: currentModuleId, label: node.name, scope: typeScope, typeParams: typeParams, builtin: self.typecheckingBuiltin)
    try self.addEnumToScope(enum_, isPublic)

    Ok(enum_)
  }

  func _typecheckEnumPass2_1(self, enum_: Enum, node: EnumDeclarationNode): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = enum_.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(InstanceKind.Enum(enum_))

    var allVariantsConstant = true
    val seenVariants: Map<String, Label> = {}
    for variant, idx in node.variants {
      val variantLabel = match variant { EnumVariant.Constant(label) => label, EnumVariant.Container(label, _) => label }
      if seenVariants[variantLabel.name] |original| {
        return Err(TypeError(position: variantLabel.position, kind: TypeErrorKind.DuplicateName(original)))
      }
      seenVariants[variantLabel.name] = variantLabel

      match variant {
        EnumVariant.Constant(label) => {
          enum_.variants.push(TypedEnumVariant(label: label, kind: EnumVariantKind.Constant))
        }
        EnumVariant.Container(label, fields) => {
          allVariantsConstant = false

          val typedFields: Field[] = []
          val seenFields: Map<String, Label> = {}
          for field in fields {
            if seenFields[field.name.name] |original| {
              return Err(TypeError(position: field.name.position, kind: TypeErrorKind.DuplicateName(original)))
            }
            seenFields[field.name.name] = field.name

            val ty = try self.resolveTypeIdentifier(field.typeAnnotation)
            // The initializer (if present) will be filled in during the next pass
            typedFields.push(Field(name: field.name, ty: ty, initializer: None, isPublic: true))
          }

          enum_.variants.push(TypedEnumVariant(label: label, kind: EnumVariantKind.Container(typedFields)))
        }
      }
    }

    for funcDeclNode in node.methods {
      val fn = try self.typecheckFunctionPass1(funcDeclNode)
      match fn.kind {
        FunctionKind.InstanceMethod => enum_.instanceMethods.push(fn)
        FunctionKind.StaticMethod => enum_.staticMethods.push(fn)
        FunctionKind.Standalone => unreachable("method has invalid function kind at this point")
      }
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(0)
  }

  func _typecheckEnumPass2_2(self, enum_: Enum, node: EnumDeclarationNode): Result<Map<Label, Int[]>, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = enum_.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(InstanceKind.Enum(enum_))

    for typedVariant, idx in enum_.variants {
      match typedVariant.kind {
        EnumVariantKind.Constant => continue
        EnumVariantKind.Container(typedFields) => {
          val fields = match node.variants[idx] {
            EnumVariant.Container(_, fields) => fields
            _ => unreachable("the untyped enum variant must exist at index, and must also be a Container")
          }

          for typedField, idx in typedFields {
            val field = try fields[idx] else unreachable("the untyped field must exist at index")
            if field.initializer |initializer| {
              val typedInitializer = try self._typecheckExpression(initializer, Some(typedField.ty))
              if !self._typeSatisfiesRequired(ty: typedInitializer.ty, required: typedField.ty) {
                return Err(TypeError(position: typedInitializer.token.position, kind: TypeErrorKind.TypeMismatch([typedField.ty], typedInitializer.ty)))
              }

              typedField.initializer = Some(typedInitializer)
            } else {
              continue
            }
          }
        }
      }
    }

    val allParamsNeedingRevisit = try self._typecheckMethodsPass2(InstanceKind.Enum(enum_), node.methods)

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(allParamsNeedingRevisit)
  }

  func _typecheckEnumPass3(self, enum_: Enum, node: EnumDeclarationNode, paramsNeedingRevisit: Map<Label, Int[]>): Result<Int, TypeError> {
    val prevScope = self.currentScope
    self.currentScope = enum_.scope
    val prevTypeDecl = self.currentTypeDecl
    self.currentTypeDecl = Some(InstanceKind.Enum(enum_))

    val instanceMethods = enum_.instanceMethods.keyBy(f => f.label)
    val staticMethods = enum_.staticMethods.keyBy(f => f.label)
    for funcDeclNode in node.methods {
      val fnLabel = funcDeclNode.name
      val fn = if instanceMethods[fnLabel] |f| {
        f
      } else if staticMethods[fnLabel] |f| {
        f
      } else {
        unreachable("method not visited in prior pass")
      }

      val toRevisit = try paramsNeedingRevisit[fnLabel] else unreachable("params improperly visited in prior pass")
      try self.typecheckFunctionPass3(fn: fn, allowSelf: true, params: funcDeclNode.params, body: funcDeclNode.body, paramsNeedingRevisit: toRevisit)
    }

    self.currentTypeDecl = prevTypeDecl
    self.currentScope = prevScope

    Ok(0)
  }

  func processImports(self, modulePathAbs: String?, parsedModule: ParsedModule): Result<(TypedModule, ImportNode)[], Position> {
    val imports: (TypedModule, ImportNode)[] = []
    for importNode in parsedModule.imports {
      var importNodePath = importNode.moduleName.name
      val isRelativeImport = importNodePath.startsWith(".")
      if !importNodePath.endsWith(".abra") importNodePath += ".abra"

      val importPathAbs = if !isRelativeImport {
        self.moduleLoader.stdRoot + "/" + importNodePath
      } else {
        if !modulePathAbs unreachable("missing absolute path for non-relative import '$importNodePath'")

        self.moduleLoader.resolvePath(modulePath: importNodePath, relativeTo: modulePathAbs)
      }

      val typedImportModule = if self.project.modules[importPathAbs] |m| {
        if !m.complete {
          // If a module attempts to import a module that is not yet complete, then we've found a circular dependency.
          // Flag that imported module since it's the module whose imports began the cycle.
          m.startsCircDep = true
          // if circular dependency detected, return import position as Err. can we recover from this error? i don't think so
          return Err(importNode.moduleName.position)
        }

        m
      } else {
        val childTypechecker = Typechecker(moduleLoader: self.moduleLoader, project: self.project, comptimeFuncEvaluator: self.comptimeFuncEvaluator)
        childTypechecker._typecheckModule(importPathAbs)
      }

      if typedImportModule.readFileError {
        val kind = if isRelativeImport {
          TypeErrorKind.UnknownModule(importPathAbs, true)
        } else {
          TypeErrorKind.UnknownModule(importNode.moduleName.name, false)
        }

        self.currentModule.addTypeError(TypeError(position: importNode.moduleName.position, kind: kind))
      } else if self.currentModule.startsCircDep {
        // If the imported module can be read but the current module has been flagged as having started a circular
        // dependency, we need to add that error to the current module so it can be surfaced.
        self.currentModule.addTypeError(TypeError(position: importNode.moduleName.position, kind: TypeErrorKind.CircularDependency))
      }

      imports.push((typedImportModule, importNode))
    }

    Ok(imports)
  }

  func _typecheckImport(self, mod: TypedModule, node: ImportNode): TypeError[] {
    val importedModule = self.currentModule.imports.getOrInsert(mod.name, () => ImportedModule())

    val errors: TypeError[] = []
    match node.kind {
      ImportKind.List(importNames) => {
        for imp in importNames {
          for (_, importedModule) in self.currentModule.imports {
            for (importedName, importedValue) in importedModule.imports {
              if importedName == imp.name {
                errors.push(TypeError(position: imp.position, kind: TypeErrorKind.DuplicateName(original: importedValue.label)))
              }
            }
          }

          val typedImportKind = match mod.exports[imp.name] {
            Export.Variable(v) => TypedImportKind.Variable(v)
            Export.Function(v) => TypedImportKind.Function(v)
            Export.Type(instanceKind, v) => TypedImportKind.Type(instanceKind, v)
            None => {
              // If the imported module could not be read, then let's not emit UnknownImport. Likewise for when the current module
              // has been flagged as having started a cycle. In both cases, these errors aren't very actionable and are just noisy.
              if !mod.readFileError && !self.currentModule.startsCircDep {
                errors.push(TypeError(position: imp.position, kind: TypeErrorKind.UnknownImport(moduleName: node.moduleName.name, importName: imp.name)))
              }
              continue
            }
          }

          importedModule.imports[imp.name] = Import(label: imp, kind: typedImportKind)
        }
      }
      ImportKind.Alias(alias) => {
        if self._verifyNameUniqueInScope(alias, self.currentScope) |e| {
          errors.push(e)
        } else {
          importedModule.aliases.push(alias)
        }
      }
    }

    errors
  }

  func typecheckBlock(self, nodes: AstNode[]): Result<TypedAstNode[], TypeError> {
    val funcDecls: FunctionDeclarationNode[] = []
    val typeDecls: TypeDeclarationNode[] = []
    val enumDecls: EnumDeclarationNode[] = []
    for node in nodes {
      match node.kind {
        AstNodeKind.FunctionDeclaration(node) => funcDecls.push(node)
        AstNodeKind.TypeDeclaration(node) => typeDecls.push(node)
        AstNodeKind.EnumDeclaration(node) => enumDecls.push(node)
        _ => {}
      }
    }

    // --- Pass 1 for types, enums, and functions

    val structsPass1: (Struct?, TypeDeclarationNode)[] = []
    val decoratorStructs: (Struct, TypeDeclarationNode)[] = []
    for node in typeDecls {
      val struct = try self.typecheckStructPass1(node) else |err| {
        self.currentModule.addTypeError(err)
        structsPass1.push((None, node))
        continue
      }
      match self.typecheckingBuiltin {
        BuiltinModule.Prelude => {
          match struct.label.name {
            "Int" => self.project.preludeIntStruct = struct
            "Float" => self.project.preludeFloatStruct = struct
            "Bool" => self.project.preludeBoolStruct = struct
            "Char" => self.project.preludeCharStruct = struct
            "String" => self.project.preludeStringStruct = struct
            "Array" => self.project.preludeArrayStruct = struct
            "Set" => self.project.preludeSetStruct = struct
            "Map" => self.project.preludeMapStruct = struct
          }
        }
        BuiltinModule.Meta => {
          match struct.label.name {
            "macro" => self.project.metaMacroDecorator = struct
            "Expr" => self.project.metaExprStruct = struct
            "InjectedCode" => self.project.metaInjectedCodeStruct = struct
          }
        }
      }
      structsPass1.push((Some(struct), node))

      if node.isDecorator {
        decoratorStructs.push((struct, node))
      }
    }

    val enumsPass1: (Enum?, EnumDeclarationNode)[] = []
    for node in enumDecls {
      val enum_ = try self.typecheckEnumPass1(node) else |err| {
        self.currentModule.addTypeError(err)
        enumsPass1.push((None, node))
        continue
      }
      match self.typecheckingBuiltin {
        BuiltinModule.Prelude => {
          match enum_.label.name {
            "Option" => self.project.preludeOptionEnum = enum_
            "Result" => self.project.preludeResultEnum = enum_
          }
        }
      }
      enumsPass1.push((Some(enum_), node))
    }

    for (struct, node) in decoratorStructs {
      struct.isDecoratorType = true
      try self._typecheckStructPass2_1(struct, node)
      val toRevisit = try self._typecheckStructPass2_2(struct, node)
      try self._typecheckStructPass3(struct, node, toRevisit)
    }

    val functionsPass1: ((Function, Variable)?, FunctionDeclarationNode)[] = []
    for node in funcDecls {
      val isPublic = if node.pubToken |pubToken| {
        // If not in a valid export scope, report error and treat it as if not marked `pub`
        if self.ensureValidExportScope(pubToken) |err| {
          self.currentModule.addTypeError(err)
          false
        } else {
          true
        }
      } else {
        false
      }

      val fn = try self.typecheckFunctionPass1(node) else |err| {
        self.currentModule.addTypeError(err)
        functionsPass1.push((None, node))
        continue
      }
      val aliasVar = Variable(label: fn.label, scope: self.currentScope, mutable: false, ty: fn.getType(), alias: Some(VariableAlias.Function(fn)))
      self.currentScope.variables.push(aliasVar)
      functionsPass1.push((Some((fn, aliasVar)), node))
      if isPublic {
        aliasVar.isExported = true
        self.currentModule.exports[fn.label.name] = Export.Function(aliasVar)
      }
    }

    // --- Pass 2 for types, enums, and functions

    val structsPass2_1: (Struct?, TypeDeclarationNode)[] = []
    for (structOpt, node) in structsPass1 {
      if structOpt |struct| {
        if !struct.isDecoratorType {
          try self._typecheckStructPass2_1(struct, node)
        }
      }

      structsPass2_1.push((structOpt, node))
    }

    val enumsPass2_1: (Enum?, EnumDeclarationNode)[] = []
    for (enumOpt, node) in enumsPass1 {
      if enumOpt |enum_| {
        try self._typecheckEnumPass2_1(enum_, node)
      }

      enumsPass2_1.push((enumOpt, node))
    }

    val structsPass2_2: (Struct?, Map<Label, Int[]>)[] = []
    for (structOpt, node) in structsPass1 {
      val toRevisit = if structOpt |struct| {
        if !struct.isDecoratorType {
          try self._typecheckStructPass2_2(struct, node)
        } else {
          {}
        }
      } else {
        {}
      }

      structsPass2_2.push((structOpt, toRevisit))
    }

    val enumsPass2_2: (Enum?, Map<Label, Int[]>)[] = []
    for (enumOpt, node) in enumsPass2_1 {
      val toRevisit = if enumOpt |enum_| {
        try self._typecheckEnumPass2_2(enum_, node)
      } else {
        {}
      }

      enumsPass2_2.push((enumOpt, toRevisit))
    }

    val functionsPass2: (Function?, Int[])[] = []
    for (fnOpt, node) in functionsPass1 {
      if fnOpt |(fn, aliasVar)| {
        val paramsNeedingRevisit = try self.typecheckFunctionPass2(fn: fn, allowSelf: false, params: node.params)
        aliasVar.ty = fn.getType()
        paramsNeedingRevisit
        functionsPass2.push((Some(fn), paramsNeedingRevisit))
      } else {
        functionsPass2.push((None, []))
      }
    }

    val functionsIter = functionsPass2.iterator()
    val structsIter = structsPass2_2.iterator()
    val enumsIter = enumsPass2_2.iterator()

    val typedNodes: TypedAstNode[] = []
    for node in nodes {
      val typedNode = match node.kind {
        AstNodeKind.FunctionDeclaration(fnDeclNode) => {
          val typedNode = if functionsIter.next() |(fnOpt, paramsNeedingRevisit)| {
            if fnOpt |fn| {
              try self.typecheckFunctionPass3(fn: fn, allowSelf: false, params: fnDeclNode.params, body: fnDeclNode.body, paramsNeedingRevisit: paramsNeedingRevisit) else |err| {
                self.currentModule.addTypeError(err)
                continue
              }
              TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.FunctionDeclaration(fn))
            } else {
              continue
            }
          } else {
            unreachable("there should be as many functions as there are functiondecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        AstNodeKind.TypeDeclaration(typeDeclNode) => {
          val typedNode = if structsIter.next() |(structOpt, toRevisit)| {
            if structOpt |struct| {
              if !struct.isDecoratorType {
                try self._typecheckStructPass3(struct, typeDeclNode, toRevisit)
              }

              TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.TypeDeclaration(struct))
            } else {
              continue
            }
          } else {
            unreachable("there should be as many types as there are typedecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        AstNodeKind.EnumDeclaration(enumDeclNode) => {
          val typedNode = if enumsIter.next() |(enumOpt, toRevisit)| {
            if enumOpt |enum_| {
              try self._typecheckEnumPass3(enum_, enumDeclNode, toRevisit)
              TypedAstNode(token: node.token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.EnumDeclaration(enum_))
            } else {
              continue
            }
          } else {
            unreachable("there should be as many enums as there are enumdecl nodes")
          }

          typedNodes.push(typedNode)
          continue
        }
        _ => {
          if self.currentScope.terminator return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))
          self.typecheckStatement(node: node, typeHint: None)
        }
      }

      typedNodes.push(typedNode)
    }

    return Ok(typedNodes)
  }

  func typecheckStatement(self, node: AstNode, typeHint: Type?): TypedAstNode {
    val token = node.token

    val res = match node.kind {
      AstNodeKind.Assignment(expr, op, mode) => self._typecheckAssignment(token, expr, op, mode)
      AstNodeKind.While(condition, conditionBinding, block) => self._typecheckWhile(token, condition, conditionBinding, block)
      AstNodeKind.For(itemPattern, indexPattern, subject, block) => self.typecheckFor(token, itemPattern, indexPattern, subject, block)
      AstNodeKind.BindingDeclaration(node) => self.typecheckBindingDeclaration(token, node)
      AstNodeKind.Break => self._typecheckBreak(token)
      AstNodeKind.Continue => self._typecheckContinue(token)
      AstNodeKind.Return(expr) => self._typecheckReturn(token, expr)
      _ => self._typecheckExpression(node, Some(Type(kind: TypeKind.PrimitiveUnit)))
    }

    match res {
      Ok(node) => node
      Err(err) => {
        self.currentModule.addTypeError(err)
        TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder)
      }
    }
  }

  func typecheckBindingPattern(self, mutable: Bool, pattern: BindingPattern, ty: Type): Variable[] {
    match pattern {
      BindingPattern.Variable(label) => {
        val variable = Variable(label: label, scope: self.currentScope, mutable: mutable, ty: ty)
        val variables = match self.addVariableToScope(variable) {
          Ok => [variable]
          Err(err) => {
            self.currentModule.addTypeError(err)
            []
          }
        }

        if self.lspMode {
          val ident = IdentifierMeta(
            name: label.name,
            kind: IdentifierKindMeta.Variable(mutable: mutable, typeRepr: ty.repr()),
            definitionPosition: Some((IdentifierMetaModule.Module(self.currentModule.name), label.position)),
          )
          self._addLSPIdent(label.position, ident)
        }

        variables
      }
      BindingPattern.Tuple(lParenTok, patterns) => {
        val innerTypes = match ty.kind {
          TypeKind.Tuple(innerTypes) => innerTypes
          TypeKind.CouldNotDetermine => patterns.map(() => Type(kind: TypeKind.CouldNotDetermine))
          _ => {
            self.currentModule.addTypeError(TypeError(position: lParenTok.position, kind: TypeErrorKind.InvalidDestructuring(InvalidDestructuringReason.NonTupleAsTuple(ty))))
            patterns.map(() => Type(kind: TypeKind.CouldNotDetermine))
          }
        }

        if patterns[innerTypes.length] |invalidPat| {
          val kind = TypeErrorKind.InvalidDestructuring(InvalidDestructuringReason.InvalidTupleArity(expected: innerTypes.length, given: patterns.length))
          self.currentModule.addTypeError(TypeError(position: invalidPat.position(), kind: kind))
        }

        val variables: Variable[] = []
        for innerType, idx in innerTypes {
          val pat = try patterns[idx] else {
            val kind = TypeErrorKind.InvalidDestructuring(InvalidDestructuringReason.InvalidTupleArity(expected: innerTypes.length, given: patterns.length))
            self.currentModule.addTypeError(TypeError(position: lParenTok.position, kind: kind))
            break
          }

          val foundVars = self.typecheckBindingPattern(mutable, pat, innerType)
          for v in foundVars {
            variables.push(v)
          }
        }

        variables
      }
    }
  }

  func typecheckBindingDeclaration(self, token: Token, node: BindingDeclarationNode): Result<TypedAstNode, TypeError> {
    val isMutable = token.kind == TokenKind.Var
    val isPublic = if node.pubToken |pubToken| {
      // If not in a valid export scope, report error and treat it as if not marked `pub`
      if self.ensureValidExportScope(pubToken) |err| {
        self.currentModule.addTypeError(err)
        false
      } else {
        true
      }
    } else {
      false
    }

    val annType = if node.typeAnnotation |typeAnn| {
      val ty = try self.resolveTypeIdentifier(typeAnn) else |err| {
        self.currentModule.addTypeError(err)
        Type(kind: TypeKind.CouldNotDetermine)
      }
      Some(ty)
    } else {
      None
    }

    val (expr, ty) = if node.expr |expr| {
      val typedExpr = try self._typecheckExpression(expr, annType) else |err| {
        self.currentModule.addTypeError(err)
        TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder)
      }
      val ty = if annType |annotatedType| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: annotatedType) {
          self.currentModule.addTypeError(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([annotatedType], typedExpr.ty)))
        }

        annotatedType
      } else {
        typedExpr.ty
      }

      if ty.isInvalidValueType() {
        self.currentModule.addTypeError(TypeError(position: expr.token.position, kind: TypeErrorKind.IllegalValueType(ty: ty, purpose: "assignment")))
      }

      (Some(typedExpr), ty)
    } else if !isMutable {
      val err = match node.bindingPattern {
        BindingPattern.Variable(label) => TypeError(position: label.position, kind: TypeErrorKind.MissingValExpr(Some(label.name)))
        BindingPattern.Tuple(lParenTok, _) => TypeError(position: lParenTok.position, kind: TypeErrorKind.MissingValExpr(None))
      }
      return Err(err)
    } else if annType |ty| {
      (None, ty)
    } else {
      val err = match node.bindingPattern {
        BindingPattern.Variable(label) => TypeError(position: label.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(Some(label.name)))
        BindingPattern.Tuple(lParenTok, _) => TypeError(position: lParenTok.position, kind: TypeErrorKind.MissingVarExprAndTypeAnn(None))
      }
      return Err(err)
    }

    val variables = self.typecheckBindingPattern(isMutable, node.bindingPattern, ty)
    for v in variables {
      if isPublic {
        v.isExported = true
        self.currentModule.exports[v.label.name] = Export.Variable(v)
      }
    }

    val typedNode = TypedBindingDeclarationNode(bindingPattern: node.bindingPattern, variables: variables, expr: expr)
    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.BindingDeclaration(typedNode)))
  }

  func _typecheckAssignment(self, token: Token, expr: AstNode, op: AssignOp, mode: AssignmentMode): Result<TypedAstNode, TypeError> {
    match mode {
      AssignmentMode.Variable(name, varToken) => {
        val pos = varToken.position

        val variable = if self._resolveIdentifier(name) |(v, modExportedFrom)| {
          if modExportedFrom return Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.Import)))

          v
        } else {
          return Err(TypeError(position: pos, kind: TypeErrorKind.UnknownName(name, "variable")))
        }
        match variable.alias {
          VariableAlias.Function => return Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.FunctionAlias)))
          VariableAlias.Struct => return Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.TypeAlias)))
          _ => {
            if !variable.mutable return Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "variable", name: name, reason: IllegalAssignmentReason.ImmutableVariable)))
          }
        }

        val typedExpr = try self._typecheckExpression(expr, Some(variable.ty))
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: variable.ty) {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([variable.ty], typedExpr.ty)))
        }

        val mode = TypedAssignmentMode.Variable(variable)
        return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.Assignment(mode, op, typedExpr)))
      }
      AssignmentMode.Indexing(targetExpr, indexExpr) => {
        val typedLhs = try self.typecheckIndexing(token, targetExpr, IndexingMode.Single(indexExpr), None)
        val typedIndexingNode = match typedLhs.kind {
          TypedAstNodeKind.Indexing(node) => node
          _ => unreachable("typecheckIndexing returned unexpected TypedAstNodeKind")
        }
        val assignmentTy = self._typeIsOption(typedLhs.ty) ?: typedLhs.ty

        val typedExpr = try self._typecheckExpression(expr, Some(assignmentTy))
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: assignmentTy) {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([assignmentTy], typedExpr.ty)))
        }

        val mode = TypedAssignmentMode.Indexing(typedIndexingNode)
        return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.Assignment(mode, op, typedExpr)))
      }
      AssignmentMode.Accessor(accessorNode) => {
        val typedLhs = try self.typecheckAccessor(token, accessorNode, None, isInvocation: false)
        val (mode, fieldLabel, field) = match typedLhs.kind {
          TypedAstNodeKind.Accessor(head, mid, tail) => {
            val t = match tail {
              AccessorPathSegment.EnumVariant(label, _, _, variant) => {
                return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAssignment("enum variant", variant.label.name, IllegalAssignmentReason.EnumVariant)))
              }
              AccessorPathSegment.Method(label, fn, _, _) => {
                val (kind, reason) = match fn.kind {
                  FunctionKind.StaticMethod => ("static method", IllegalAssignmentReason.StaticMethod)
                  _ => ("method", IllegalAssignmentReason.Method)
                }

                return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAssignment(kind, fn.label.name, reason)))
              }
              AccessorPathSegment.Field(label, _, field, _) => {
                val mode = TypedAssignmentMode.Accessor(head, mid, tail)
                (mode, label, field)
              }
            }
            t
          }
          TypedAstNodeKind.Identifier(name, _, _, varImportMod) => {
            val pos = typedLhs.token.position
            if varImportMod return Err(TypeError(position: pos, kind: TypeErrorKind.IllegalAssignment(kind: "member", name: name, reason: IllegalAssignmentReason.Import)))
            unreachable("typecheckAccessor returned unexpected TypedAstNodeKind")
          }
          _ => unreachable("typecheckAccessor returned unexpected TypedAstNodeKind")
        }

        val typedExpr = try self._typecheckExpression(expr, Some(field.ty))
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: field.ty) {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([field.ty], typedExpr.ty)))
        }

        return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.Assignment(mode, op, typedExpr)))
      }
    }
  }

  func _typecheckWhile(self, token: Token, condition: AstNode, conditionBinding: BindingPattern?, block: AstNode[]): Result<TypedAstNode, TypeError> {
    val typedCondition = try self._typecheckExpression(condition, None)
    val condOptInnerTy = self._typeIsOption(typedCondition.ty)
    if !condOptInnerTy && !self._typeSatisfiesRequired(ty: typedCondition.ty, required: Type(kind: TypeKind.PrimitiveBool)) {
      return Err(TypeError(position: typedCondition.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedCondition.ty, purpose: "while")))
    }

    val prevScope = self.beginChildScope("while", ScopeKind.While)

    val conditionBindingPattern = if conditionBinding |pattern| {
      val ty = condOptInnerTy ?: typedCondition.ty

      val vars = self.typecheckBindingPattern(false, pattern, ty)
      Some((pattern, vars))
    } else {
      None
    }

    val typedNodes: TypedAstNode[] = []
    for node in block {
      if self.currentScope.terminator return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = self.typecheckStatement(node, None)
      typedNodes.push(typedNode)
    }
    val terminator = self.currentScope.terminator

    self.currentScope = prevScope
    if terminator == Some(Terminator.Returning) {
      self.currentScope.terminator = terminator
    }

    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: TypedAstNodeKind.While(typedCondition, conditionBindingPattern, typedNodes, terminator)))
  }

  func _typeIsOption(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(instanceKind, generics) => {
        match instanceKind {
          InstanceKind.Enum(enum_) => {
            if enum_ != self.project.preludeOptionEnum return None
            if generics[0] |innerTy| {
              Some(innerTy)
            } else {
              unreachable("Option instance lacks inner type")
            }
          }
          _ => None
        }
      }
      _ => None
    }
  }

  func _typeIsResult(self, ty: Type): (Type, Type)? {
    match ty.kind {
      TypeKind.Instance(instanceKind, generics) => {
        match instanceKind {
          InstanceKind.Enum(enum_) => {
            if enum_ != self.project.preludeResultEnum return None
            if generics[0] |valTy| {
              if generics[1] |errTy| {
                Some((valTy, errTy))
              } else {
                unreachable("Result instance lacks error type")
              }
            } else {
              unreachable("Result instance lacks value type")
            }
          }
          _ => None
        }
      }
      _ => None
    }
  }

  func typeIsIterable(self, ty: Type): Type? {
    match ty.kind {
      TypeKind.Instance(instanceKind, generics) => {
        val instanceMethods = match instanceKind {
          InstanceKind.Struct(struct) => {
            if struct == self.project.preludeArrayStruct return generics[0]
            if struct == self.project.preludeSetStruct return generics[0]
            if struct == self.project.preludeMapStruct {
              val keyTy = generics[0] ?: Type(kind: TypeKind.Hole)
              val valTy = generics[1] ?: Type(kind: TypeKind.Hole)
              return Some(Type(kind: TypeKind.Tuple([keyTy, valTy])))
            }

            struct.instanceMethods
          }
          InstanceKind.Enum(enum_) => enum_.instanceMethods
        }
        for m in instanceMethods {
          if m.label.name == "next" {
            if !m.params.isEmpty() return None
            val iterItemType = m.returnType
            return self._typeIsOption(iterItemType)
          }
        }

        None
      }
      _ => None
    }
  }

  func typeIsCompileTimeKnown(self, ty: Type): Bool {
    match ty.kind {
      TypeKind.PrimitiveInt => true
      TypeKind.PrimitiveFloat => true
      TypeKind.PrimitiveBool => true
      TypeKind.PrimitiveChar => true
      TypeKind.PrimitiveString => true
      else => false // todo: other compile-time known types
    }
  }

  func typecheckFor(self, token: Token, itemPattern: BindingPattern, indexPattern: BindingPattern?, subject: ForIterKind, block: AstNode[]): Result<TypedAstNode, TypeError> {
    val (typedForIterKind, itemType) = match subject {
      ForIterKind.Expr(iterator) => {
        val typedIterator = try self._typecheckExpression(iterator, None)
        val itemType = try self.typeIsIterable(typedIterator.ty) else {
          return Err(TypeError(position: typedIterator.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedIterator.ty, purpose: "for")))
        }
        if itemType.kind == TypeKind.Hole {
          return Err(TypeError(position: typedIterator.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedIterator.ty, purpose: "for")))
        }
        (TypedForIterKind.Expr(typedIterator), itemType)
      }
      ForIterKind.Range(start, end) => {
        val intType = Type(kind: TypeKind.PrimitiveInt)
        val typedStart = try self._typecheckExpression(start, Some(intType))
        if !self._typeSatisfiesRequired(ty: typedStart.ty, required: intType) {
          self.currentModule.addTypeError(TypeError(position: typedStart.token.position, kind: TypeErrorKind.TypeMismatch([intType], typedStart.ty)))
        }
        val typedEnd = try self._typecheckExpression(end, Some(intType))
        if !self._typeSatisfiesRequired(ty: typedEnd.ty, required: intType) {
          self.currentModule.addTypeError(TypeError(position: typedEnd.token.position, kind: TypeErrorKind.TypeMismatch([intType], typedEnd.ty)))
        }

        (TypedForIterKind.Range(startExpr: typedStart, endExpr: typedEnd), intType)
      }
    }

    val prevScope = self.beginChildScope("for", ScopeKind.For)

    val variables = self.typecheckBindingPattern(false, itemPattern, itemType)
    val indexBinding = if indexPattern |pat| {
      val variables = self.typecheckBindingPattern(false, pat, Type(kind: TypeKind.PrimitiveInt))
      variables[0]
    } else {
      None
    }

    val typedNodes: TypedAstNode[] = []
    for node in block {
      if self.currentScope.terminator return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      val typedNode = self.typecheckStatement(node, None)
      typedNodes.push(typedNode)
    }
    val terminator = self.currentScope.terminator

    self.currentScope = prevScope
    if terminator == Some(Terminator.Returning) {
      self.currentScope.terminator = terminator
    }

    val kind = TypedAstNodeKind.For(typedForIterKind, (itemPattern, variables), indexBinding, typedNodes, terminator)
    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveUnit), kind: kind))
  }

  func _typecheckBreak(self, token: Token): Result<TypedAstNode, TypeError> = self._typecheckBreakContinue(token, "break", TypedAstNodeKind.Break)

  func _typecheckContinue(self, token: Token): Result<TypedAstNode, TypeError> = self._typecheckBreakContinue(token, "continue", TypedAstNodeKind.Continue)

  func _typecheckBreakContinue(self, token: Token, terminator: String, kind: TypedAstNodeKind): Result<TypedAstNode, TypeError> {
    var scope = Some(self.currentScope)
    while scope |sc| {
      val isValid = match sc.kind {
        ScopeKind.Root => false
        ScopeKind.Module => false
        ScopeKind.Type => false
        ScopeKind.Func => false
        ScopeKind.If => {
          scope = sc.parent
          continue
        }
        ScopeKind.MatchCase => {
          scope = sc.parent
          continue
        }
        ScopeKind.Try => {
          scope = sc.parent
          continue
        }
        ScopeKind.While => true
        ScopeKind.For => true
      }

      if !isValid return Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTerminatorPosition(terminator)))
      break
    }
    self.currentScope.terminator = Some(Terminator.NonReturning)

    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.Never), kind: kind))
  }

  func _typecheckReturn(self, token: Token, expr: AstNode?): Result<TypedAstNode, TypeError> {
    val fn = try self.currentFunction else return Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTerminatorPosition("return")))

    val typedExpr = if expr |expr| {
      val typedExpr = try self._typecheckExpression(expr, Some(fn.returnType))
      if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: fn.returnType) {
        val fnName = if fn.isLambda None else Some(fn.label.name)
        return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Some(typedExpr.ty))))
      }

      Some(typedExpr)
    } else {
      if fn.returnType.kind != TypeKind.PrimitiveUnit {
        val fnName = if fn.isLambda None else Some(fn.label.name)
        return Err(TypeError(position: token.position, kind: TypeErrorKind.ReturnTypeMismatch(fnName, fn.returnType, Some(Type(kind: TypeKind.PrimitiveUnit)))))
      }

      None
    }

    if fn.isLambda && fn.returnType.kind == TypeKind.Hole {
      fn.returnType = typedExpr?.ty ?: Type(kind: TypeKind.PrimitiveUnit)
    }

    self.currentScope.terminator = Some(Terminator.Returning)

    Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.Never), kind: TypedAstNodeKind.Return(typedExpr)))
  }

  func _typecheckIf(
    self,
    token: Token,
    condition: AstNode,
    conditionBinding: BindingPattern?,
    ifBlock: AstNode[],
    elseBlock: AstNode[]?,
    typeHint: Type?,
  ): Result<TypedAstNode, TypeError> {
    val isStatement = if typeHint |hint| hint.kind == TypeKind.PrimitiveUnit else false

    val typedCondition = try self._typecheckExpression(condition, None)
    val condOptInnerTy = self._typeIsOption(typedCondition.ty)
    if !condOptInnerTy && !self._typeSatisfiesRequired(ty: typedCondition.ty, required: Type(kind: TypeKind.PrimitiveBool)) {
      return Err(TypeError(position: typedCondition.token.position, kind: TypeErrorKind.IllegalControlFlowType(ty: typedCondition.ty, purpose: "if")))
    }

    var prevScope = self.beginChildScope("if_then", ScopeKind.If)

    val conditionBindingPattern = if conditionBinding |pattern| {
      val ty = condOptInnerTy ?: typedCondition.ty

      val vars = self.typecheckBindingPattern(false, pattern, ty)
      Some((pattern, vars))
    } else {
      None
    }

    val typedIfBlock: TypedAstNode[] = []
    for node, idx in ifBlock {
      if self.currentScope.terminator == Some(Terminator.Returning) return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

      if idx == ifBlock.length - 1 && !isStatement {
        val typedNode = try self._typecheckExpressionOrTerminator(node, typeHint)
        typedIfBlock.push(typedNode)
      } else {
        val typedNode = self.typecheckStatement(node, None)
        typedIfBlock.push(typedNode)
      }
    }
    val ifType = typedIfBlock[-1]?.ty
    val ifBlockTerminator = self.currentScope.terminator
    self.currentScope = prevScope

    prevScope = self.beginChildScope("if_else", ScopeKind.If)
    var hasElseBlock = false
    val typedElseBlock: TypedAstNode[] = []
    if elseBlock |elseBlock| {
      hasElseBlock = true
      for node, idx in elseBlock {
        if self.currentScope.terminator == Some(Terminator.Returning) return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

        if idx == elseBlock.length - 1 && !isStatement {
          val hint = if ifType |t| (if t.hasUnfilledHoles() None else ifType) else None
          val typedNode = try self._typecheckExpressionOrTerminator(node, hint)
          typedElseBlock.push(typedNode)
        } else {
          val typedNode = self.typecheckStatement(node, None)
          typedElseBlock.push(typedNode)
        }
      }
    }
    val elseBlockTerminator = self.currentScope.terminator
    self.currentScope = prevScope

    self.currentScope.terminator = Terminator.combine(ifBlockTerminator, elseBlockTerminator)

    val ty = if !isStatement {
      if ifType |ifType| {
        if typedElseBlock[-1] |lastElseNode| {
          val elseType = lastElseNode.ty

          if ifType.hasUnfilledHoles() {
            ifType.tryFillHoles(elseType)
          }
          if elseType.hasUnfilledHoles() {
            elseType.tryFillHoles(ifType)
          }

          if !self._typeSatisfiesRequired(ty: elseType, required: ifType) {
            return Err(TypeError(position: lastElseNode.token.position, kind: TypeErrorKind.TypeMismatch([ifType], elseType)))
          }

          if ifType.kind == TypeKind.Never { elseType } else { ifType }
        } else {
          return Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredBlock(exprKind: "if-else", clause: "else", missing: !hasElseBlock)))
        }
      } else {
        return Err(TypeError(position: token.position, kind: TypeErrorKind.MissingRequiredBlock(exprKind: "if-else", clause: "if", missing: false)))
      }
    } else {
      Type(kind: TypeKind.PrimitiveUnit)
    }

    val kind = TypedAstNodeKind.If(isStatement, typedCondition, conditionBindingPattern, typedIfBlock, ifBlockTerminator, typedElseBlock, elseBlockTerminator)
    Ok(TypedAstNode(token: token, ty: ty, kind: kind))
  }

  func _typecheckMatch(self, token: Token, expr: AstNode, cases: MatchCase[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    val isStatement = if typeHint |hint| hint.kind == TypeKind.PrimitiveUnit else false
    val typedExpr = try self._typecheckExpression(expr, None)

    var subjectTy = typedExpr.ty
    val typedCases: TypedMatchCase[] = []
    var resultTy: Type? = None
    var seenElseCase = false
    var seenNoneCase = false
    var seenLiteralCases: Set<LiteralAstNode> = #{}
    val seenEnumVariants: Map<Enum, Set<Int>> = {}
    val seenTypes: Set<Type> = #{}

    val allCasesHandled: () => Bool = () => {
      if seenElseCase return true

      for (enum_, seenVariantIdxs) in seenEnumVariants {
        val enumVariantIdxs = enum_.variants.map((_, i) => i).asSet()
        if seenVariantIdxs == enumVariantIdxs {
          if self._typeIsOption(typedExpr.ty) {
            if seenNoneCase return true
          } else return true
        }
      }

      if self.project.typesAreEquivalent(ty: Type(kind: TypeKind.PrimitiveBool), other: typedExpr.ty) {
        if seenLiteralCases == #{LiteralAstNode.Bool(true), LiteralAstNode.Bool(false)} return true
      }

      if !seenTypes.isEmpty() {
        if self._typeIsOption(typedExpr.ty) {
          if seenNoneCase return true
        } else return true
      }

      false
    }

    for case in cases {
      if allCasesHandled() {
        return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.AlreadyCovered(exhaustive: true), typedExpr.ty)))
      }

      val typedBody: TypedAstNode[] = []
      var prevScope = self.currentScope

      var caseVar: Variable? = None
      val typedMatchCaseKind = match case.kind {
        MatchCaseKind.Type(path, last, args) => {
          val typeOrEnumVariant = try self._resolveTypeOrEnumVariant(path, last)
          val typedCaseKind = match typeOrEnumVariant {
            Either.Left(caseTy) => {
              if seenTypes.contains(caseTy) return Err(TypeError(position: case.position, kind: TypeErrorKind.DuplicateMatchCase))
              seenTypes.insert(caseTy)

              if args[0] |firstArg| {
                return Err(TypeError(position: firstArg.position, kind: TypeErrorKind.InvalidMatchCaseDestructuring(InvalidMatchCaseDestructuringReason.NonEnum)))
              }

              val subjectTy = self._typeIsOption(subjectTy) ?: subjectTy
              if !self._typeSatisfiesRequired(ty: caseTy, required: subjectTy) {
                return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.NoOverlap(caseTy: Some(caseTy)), typedExpr.ty)))
              }

              self.beginChildScope("matchcase_${caseTy.repr()}", ScopeKind.MatchCase)
              if case.binding |binding| {
                // TODO: generics in ty
                caseVar = Some(Variable(label: binding, scope: self.currentScope, mutable: false, ty: caseTy))
              }

              TypedMatchCaseKind.Type(caseTy)
            }
            Either.Right(_p) => {
              // TODO: destructuring in match cases
              val (enum_, variant, variantIdx) = _p
              if seenEnumVariants[enum_] |seenVariants| {
                if seenVariants.contains(variantIdx) return Err(TypeError(position: case.position, kind: TypeErrorKind.DuplicateMatchCase))
                seenVariants.insert(variantIdx)
              } else {
                seenEnumVariants[enum_] = #{variantIdx}
              }

              val subjectTy = self._typeIsOption(subjectTy) ?: subjectTy
              val template = Type(kind: TypeKind.Instance(InstanceKind.Enum(enum_), enum_.typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
              val extractedGenerics = subjectTy.extractGenerics(template)
              val resolvedGenerics: Map<String, Type> = {}
              for (name, ty) in extractedGenerics {
                resolvedGenerics[name] = ty
              }

              val caseTy = template.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
              if !self._typeSatisfiesRequired(ty: caseTy, required: subjectTy) {
                return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.NoOverlap(caseTy: Some(caseTy)), typedExpr.ty)))
              }

              self.beginChildScope("matchcase_${enum_.label.name}_$variantIdx", ScopeKind.MatchCase)

              val variables: Variable[] = []
              if args[0] |firstArg| {
                match variant.kind {
                  EnumVariantKind.Constant => return Err(TypeError(position: firstArg.position, kind: TypeErrorKind.InvalidMatchCaseDestructuring(InvalidMatchCaseDestructuringReason.NonEnumContainer)))
                  EnumVariantKind.Container(fields) => {
                    if args[fields.length] |invalidArg| {
                      val kind = TypeErrorKind.InvalidMatchCaseDestructuring(InvalidMatchCaseDestructuringReason.InvalidArity(expected: fields.length, given: args.length))
                      return Err(TypeError(position: invalidArg.position, kind: kind))
                    }

                    for field, idx in fields {
                      val arg = try args[idx] else {
                        val kind = TypeErrorKind.InvalidMatchCaseDestructuring(InvalidMatchCaseDestructuringReason.InvalidArity(expected: fields.length, given: args.length))
                        return Err(TypeError(position: case.position, kind: kind))
                      }
                      val variableTy = if field.ty.containsGenerics() {
                        field.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
                      } else {
                        field.ty
                      }
                      val variable = Variable(label: arg, scope: self.currentScope, mutable: false, ty: variableTy)
                      try self.addVariableToScope(variable)
                      variables.push(variable)

                      if self.lspMode {
                        val ident = IdentifierMeta(
                          name: arg.name,
                          kind: IdentifierKindMeta.Variable(mutable: false, typeRepr: variableTy.repr()),
                          definitionPosition: Some((IdentifierMetaModule.Module(self.currentModule.name), arg.position)),
                        )
                        self._addLSPIdent(arg.position, ident)
                      }
                    }
                  }
                }
              }

              if case.binding |binding| {
                caseVar = Some(Variable(label: binding, scope: self.currentScope, mutable: false, ty: caseTy))
              }

              TypedMatchCaseKind.EnumVariant(enum_, variant, variantIdx, variables)
            }
          }

          typedCaseKind
        }
        MatchCaseKind.Literal(value) => {
          if seenLiteralCases.contains(value) return Err(TypeError(position: case.position, kind: TypeErrorKind.DuplicateMatchCase))
          seenLiteralCases.insert(value)

          val literalTy = match value {
            LiteralAstNode.Int => Type(kind: TypeKind.PrimitiveInt)
            LiteralAstNode.Float => Type(kind: TypeKind.PrimitiveFloat)
            LiteralAstNode.Bool => Type(kind: TypeKind.PrimitiveBool)
            LiteralAstNode.Char => Type(kind: TypeKind.PrimitiveChar)
            LiteralAstNode.String => Type(kind: TypeKind.PrimitiveString)
          }

          self.beginChildScope("matchcase_$value", ScopeKind.MatchCase)
          if case.binding |binding| {
            caseVar = Some(Variable(label: binding, scope: self.currentScope, mutable: false, ty: literalTy))
          }

          val subjectTy = self._typeIsOption(subjectTy) ?: subjectTy
          if !self._typeSatisfiesRequired(ty: literalTy, required: subjectTy) {
            return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.NoOverlap(caseTy: Some(literalTy)), typedExpr.ty)))
          }

          if seenTypes.contains(literalTy) return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.AlreadyCovered(exhaustive: false), typedExpr.ty)))

          TypedMatchCaseKind.Literal(value)
        }
        MatchCaseKind.None_ => {
          if seenNoneCase return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.AlreadyCovered(exhaustive: false), typedExpr.ty)))
          seenNoneCase = true

          self.beginChildScope("matchcase_None", ScopeKind.MatchCase)
          if case.binding |binding| {
            caseVar = Some(Variable(label: binding, scope: self.currentScope, mutable: false, ty: subjectTy))
          }

          subjectTy = try self._typeIsOption(subjectTy) else {
            return Err(TypeError(position: case.position, kind: TypeErrorKind.UnreachableMatchCase(UnreachableMatchCaseReason.NoOverlap(caseTy: None), typedExpr.ty)))
          }

          TypedMatchCaseKind.None_
        }
        MatchCaseKind.Else => {
          seenElseCase = true

          self.beginChildScope("matchcase_else", ScopeKind.MatchCase)
          if case.binding |binding| {
            caseVar = Some(Variable(label: binding, scope: self.currentScope, mutable: false, ty: subjectTy))
          }

          TypedMatchCaseKind.Else
        }
      }

      if caseVar |v| {
        try self.addVariableToScope(v)
      }

      for node, idx in case.body {
        if self.currentScope.terminator return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

        if idx == case.body.length - 1 && !isStatement {
          val typedNode = try self._typecheckExpressionOrTerminator(node, typeHint)
          typedBody.push(typedNode)
        } else {
          val typedNode = self.typecheckStatement(node, None)
          typedBody.push(typedNode)
        }
      }

      if !isStatement {
        val lastBodyNode = try typedBody[-1] else return Err(TypeError(position: case.position, kind: TypeErrorKind.EmptyMatchBlock))
        val bodyTy = lastBodyNode.ty

        if resultTy |resTy| {
          if resTy.hasUnfilledHoles() {
            resTy.tryFillHoles(bodyTy)
          } else if bodyTy.hasUnfilledHoles() {
            bodyTy.tryFillHoles(resTy)
          }

          if !self._typeSatisfiesRequired(ty: bodyTy, required: resTy) {
            return Err(TypeError(position: lastBodyNode.token.position, kind: TypeErrorKind.TypeMismatch([resTy], bodyTy)))
          }

          if resTy.kind == TypeKind.Never {
            resultTy = Some(bodyTy)
          }
        } else {
          resultTy = typedBody[-1]?.ty
        }
      }

      val terminator = self.currentScope.terminator
      self.currentScope = prevScope

      typedCases.push(TypedMatchCase(kind: typedMatchCaseKind, binding: caseVar, body: typedBody, terminator: terminator))
    }

    if !isStatement && !allCasesHandled() {
      return Err(TypeError(position: token.position, kind: TypeErrorKind.NonExhaustiveMatch(typedExpr.ty)))
    }

    val ty = try resultTy else {
      if !isStatement unreachable("match expression without result type")
      Type(kind: TypeKind.PrimitiveUnit)
    }

    // If the resulting type is Unit or Never after visiting all the cases' blocks, then treat this as a statement
    val isStmt = isStatement || ty.kind == TypeKind.PrimitiveUnit || ty.kind == TypeKind.Never
    val kind = TypedAstNodeKind.Match(isStmt, typedExpr, typedCases)
    Ok(TypedAstNode(token: token, ty: ty, kind: kind))
  }

  func _typecheckExpression(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val token = node.token
    val typedExpr = match node.kind {
      AstNodeKind.Literal(literal) => {
        val kind = match literal {
          LiteralAstNode.Int => TypeKind.PrimitiveInt
          LiteralAstNode.Float => TypeKind.PrimitiveFloat
          LiteralAstNode.Bool => TypeKind.PrimitiveBool
          LiteralAstNode.Char => TypeKind.PrimitiveChar
          LiteralAstNode.String => TypeKind.PrimitiveString
        }

        TypedAstNode(token: token, ty: Type(kind: kind), kind: TypedAstNodeKind.Literal(literal))
      }
      AstNodeKind.StringInterpolation(exprs) => self.typecheckStringInterpolation(token, exprs)
      AstNodeKind.Unary(node) => try self.typecheckUnary(token, node)
      AstNodeKind.Binary(node) => try self.typecheckBinary(token, node)
      AstNodeKind.Grouped(inner) => {
        val expr = try self._typecheckExpression(inner, None)
        TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Grouped(expr))
      }
      AstNodeKind.Identifier(kind) => try self.typecheckIdentifier(token, kind, typeHint)
      AstNodeKind.Accessor(node) => try self.typecheckAccessor(token, node, typeHint, isInvocation: false)
      AstNodeKind.Invocation(node) => try self.typecheckInvocation(token, node, typeHint)
      AstNodeKind.Array(items) => try self.typecheckArray(token, items, typeHint)
      AstNodeKind.Set(items) => try self.typecheckSet(token, items, typeHint)
      AstNodeKind.Map(items) => try self.typecheckMap(token, items, typeHint)
      AstNodeKind.Tuple(items) => try self.typecheckTuple(token, items, typeHint)
      AstNodeKind.Indexing(expr, index) => try self.typecheckIndexing(token, expr, index, typeHint)
      AstNodeKind.Lambda(value) => try self._typecheckLambda(token, value, typeHint)
      AstNodeKind.If(condition, conditionBinding, ifBlock, elseBlock) => try self._typecheckIf(token, condition, conditionBinding, ifBlock, elseBlock, typeHint)
      AstNodeKind.Match(subject, cases) => try self._typecheckMatch(token, subject, cases, typeHint)
      AstNodeKind.Try(expr, elseClause) => try self.typecheckTry(token, expr, elseClause, typeHint)
      _ => unreachable("all other node types should have already been handled")
    }

    match typedExpr.ty.kind {
      TypeKind.Type => {
        if !self.isStructOrEnumValueAllowed {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalValueType(typedExpr.ty, "value")))
        }
      }
      _ => {}
    }

    Ok(typedExpr)
  }

  func _typecheckExpressionOrTerminator(self, node: AstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    match node.kind {
      AstNodeKind.Break => self._typecheckBreak(node.token)
      AstNodeKind.Continue => self._typecheckContinue(node.token)
      AstNodeKind.Return(expr) => self._typecheckReturn(node.token, expr)
      _ => self._typecheckExpression(node, typeHint)
    }
  }

  func typecheckStringInterpolation(self, token: Token, exprs: AstNode[]): TypedAstNode {
    val typedExprs: TypedAstNode[] = []
    for expr in exprs {
      match self._typecheckExpression(expr, None) {
        Ok(typedExpr) => typedExprs.push(typedExpr)
        Err(err) => self.currentModule.addTypeError(err)
      }
    }

    TypedAstNode(token: token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.StringInterpolation(exprs: typedExprs))
  }

  func typecheckUnary(self, token: Token, node: UnaryAstNode): Result<TypedAstNode, TypeError> {
    val expr = try self._typecheckExpression(node: node.expr, typeHint: None)
    if expr.ty.kind == TypeKind.CouldNotDetermine {
      return Ok(TypedAstNode(token: token, ty: expr.ty, kind: TypedAstNodeKind.Unary(op: node.op, expr: expr)))
    }

    val ty = match node.op {
      UnaryOp.Minus => {
        if !self._typeSatisfiesRequired(ty: expr.ty, required: Type(kind: TypeKind.PrimitiveInt)) &&
          !self._typeSatisfiesRequired(ty: expr.ty, required: Type(kind: TypeKind.PrimitiveFloat)) {
          val expected = [Type(kind: TypeKind.PrimitiveInt), Type(kind: TypeKind.PrimitiveFloat)]
          return Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch(expected, expr.ty)))
        }
        expr.ty
      }
      UnaryOp.Negate => {
        if !self._typeIsOption(expr.ty) && !self._typeSatisfiesRequired(ty: expr.ty, required: Type(kind: TypeKind.PrimitiveBool)) {
          return Err(TypeError(position: expr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveBool)], expr.ty)))
        }
        Type(kind: TypeKind.PrimitiveBool)
      }
    }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Unary(op: node.op, expr: expr)))
  }

  func typecheckBinary(self, token: Token, node: BinaryAstNode): Result<TypedAstNode, TypeError> {
    val handleCases: ((TypeKind, TypeKind, TypeKind)[]) => Result<TypedAstNode, TypeError> = (cases) => {
      val left = try self._typecheckExpression(node.left, None)
      val right = try self._typecheckExpression(node.right, None)
      for (lTy, rTy, outTy) in cases {
        if (lTy == TypeKind.Hole || self._typeSatisfiesRequired(ty: left.ty, required: Type(kind: lTy))) &&
          ((rTy == TypeKind.Hole || self._typeSatisfiesRequired(ty: right.ty, required: Type(kind: rTy)))) {

          val kind = if left.ty.kind == TypeKind.CouldNotDetermine || right.ty.kind == TypeKind.CouldNotDetermine {
            TypeKind.CouldNotDetermine
          } else {
            outTy
          }
          return Ok(TypedAstNode(token: token, ty: Type(kind: kind), kind: TypedAstNodeKind.Binary(left, node.op, right)))
        }
      }

      return Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, right.ty)))
    }

    val handleEquality: () => Result<TypedAstNode, TypeError> = () => {
      val left = try self._typecheckExpression(node.left, None)
      val right = try self._typecheckExpression(node.right, Some(left.ty))

      if !self._typeSatisfiesRequired(ty: right.ty, required: left.ty) {
        return Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([left.ty], right.ty)))
      }

      val kind = if left.ty.kind == TypeKind.CouldNotDetermine || right.ty.kind == TypeKind.CouldNotDetermine {
        TypeKind.CouldNotDetermine
      } else {
        TypeKind.PrimitiveBool
      }
      Ok(TypedAstNode(token: token, ty: Type(kind: kind), kind: TypedAstNodeKind.Binary(left, node.op, right)))
    }

    val standardArithmeticCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
    ]
    val allFloatArithmeticCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
    ]
    val boolOpCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
      (TypeKind.PrimitiveBool, TypeKind.PrimitiveBool, TypeKind.PrimitiveBool),
    ]
    val comparisonCases = [
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveBool),
      (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveBool),
    ]

    // TODO: combine match cases, this can be cleaned up a lot
    match node.op {
      BinaryOp.Add => {
        handleCases([
          (TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt),
          (TypeKind.PrimitiveFloat, TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat),
          (TypeKind.PrimitiveInt, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
          (TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat, TypeKind.PrimitiveFloat),
          (TypeKind.Hole, TypeKind.PrimitiveString, TypeKind.PrimitiveString),
          (TypeKind.PrimitiveString, TypeKind.Hole, TypeKind.PrimitiveString),
        ])
      }
      BinaryOp.Sub => handleCases(standardArithmeticCases)
      BinaryOp.Mul => handleCases(standardArithmeticCases)
      BinaryOp.Div => handleCases(allFloatArithmeticCases)
      BinaryOp.Mod => handleCases(standardArithmeticCases)
      BinaryOp.Pow => handleCases(allFloatArithmeticCases)
      BinaryOp.And => handleCases(boolOpCases)
      BinaryOp.Or => handleCases(boolOpCases)
      BinaryOp.Xor => handleCases(boolOpCases)
      BinaryOp.Coalesce => {
        // If the lhs isn't a nullable type then we can short-circuit and don't even typecheck the rhs
        val left = try self._typecheckExpression(node.left, None)
        val right = if self._typeIsOption(left.ty) |innerTy| {
          val right = try self._typecheckExpression(node.right, Some(innerTy))
          if !self._typeSatisfiesRequired(ty: right.ty, required: innerTy) {
            return Err(TypeError(position: right.token.position, kind: TypeErrorKind.TypeMismatch([innerTy], right.ty)))
          }

          right
        } else {
          // Pass Hole as rhs type because it doesn't matter - there's special logic within NoSuchOperator for `?:` used with non-Option types
          return Err(TypeError(position: token.position, kind: TypeErrorKind.NoSuchOperator(left.ty, node.op, Type(kind: TypeKind.Hole))))
        }

        Ok(TypedAstNode(token: token, ty: right.ty, kind: TypedAstNodeKind.Binary(left, node.op, right)))
      }
      BinaryOp.Eq => handleEquality()
      BinaryOp.Neq => handleEquality()
      BinaryOp.LT => handleCases(comparisonCases)
      BinaryOp.LTE => handleCases(comparisonCases)
      BinaryOp.Shl => handleCases([(TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt)])
      BinaryOp.GT => handleCases(comparisonCases)
      BinaryOp.GTE => handleCases(comparisonCases)
      BinaryOp.Shr => handleCases([(TypeKind.PrimitiveInt, TypeKind.PrimitiveInt, TypeKind.PrimitiveInt)])
    }
  }

  func typecheckIdentifier(self, token: Token, kind: IdentifierKind, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val ((variable, varImportMod), name, fnTypeHint) = match kind {
      IdentifierKind.Named(name) => {
        val resolvedIdentifier = try self._resolveIdentifier(name) else {
          val err = TypeError(position: token.position, kind: TypeErrorKind.UnknownName(name, "variable"))
          if self.paramDefaultValueContext |ctx| {
            ctx.exprContainsVariableRef = true
            // Return error here rather than just recording and recovering because the logic which determines whether to revisit a
            // parameter's failed default value typechecking expects an Error to have been returned. A bit of a weird control flow.
            return Err(err)
          } else {
            self.currentModule.addTypeError(err)
            val bogusVar = Variable.bogus()
            bogusVar.label.name = name
            bogusVar.ty = Type(kind: TypeKind.CouldNotDetermine)
            (bogusVar, None)
          }
        }

        val variable = resolvedIdentifier[0]
        val fnTypeHint = match variable.alias {
          VariableAlias.Function(fn) => {
            if fn.isClosure() {
              if self.currentFunction |currentFn| {
                if !currentFn.capturedClosures.find(f => f.label.name == fn.label.name) {
                  currentFn.capturedClosures.push(fn)
                }
              }
            }

            typeHint
          }
          _ => None
        }

        (resolvedIdentifier, name, fnTypeHint)
      }
      IdentifierKind.Discard => return Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("_", "variable")))
      IdentifierKind.None_ => {
        val replacement = AstNode(
          token: token,
          kind: AstNodeKind.Accessor(AccessorAstNode(
            root: AstNode(token: Token(position: Position.bogus(), kind: TokenKind.Ident("Option")), kind: AstNodeKind.Identifier(IdentifierKind.Named("Option"))),
            path: [(Token(position: token.position, kind: TokenKind.Dot), Label(name: "None", position: token.position))]
          ))
        )

        return self._typecheckExpression(replacement, typeHint)
      }
      IdentifierKind.Self => {
        val resolvedIdentifier = try self._resolveIdentifier("self") else {
          if self.paramDefaultValueContext |ctx| {
            ctx.exprContainsVariableRef = true
          }
          return Err(TypeError(position: token.position, kind: TypeErrorKind.UnknownName("self", "variable")))
        }

        (resolvedIdentifier, "self", None)
      }
    }

    if self.lspMode {
      val kind = match variable.alias {
        None => IdentifierKindMeta.Variable(variable.mutable, variable.ty.repr())
        VariableAlias.Function(fn) => {
          val typeParams: String[] = []
          for (_, label) in fn.typeParams {
            typeParams.push(label.name)
          }

          val params: String[] = []
          for param in fn.params {
            params.push("${if param.isVariadic "..." else ""}${param.label.name}${if param.defaultValue "?" else ""}: ${param.ty.repr()}")
          }

          val returnTypeRepr = fn.returnType.repr()

          IdentifierKindMeta.Function(typeParams, params, returnTypeRepr, methodTy: None)
        }
        VariableAlias.Struct(struct) => IdentifierKindMeta.Type(isEnum: false, typeParams: struct.typeParams)
        VariableAlias.Enum(_enum) => IdentifierKindMeta.Type(isEnum: true, typeParams: _enum.typeParams)
      }

      val defMod = if variable.scope == self.project.preludeModule.rootScope {
        IdentifierMetaModule.Prelude
      } else {
        IdentifierMetaModule.Module(varImportMod?.name ?: self.currentModule.name)
      }

      val ident = IdentifierMeta(
        name: name,
        kind: kind,
        definitionPosition: Some((defMod, variable.label.position)),
      )
      self._addLSPIdent(token.position, ident)
    }

    Ok(TypedAstNode(token: token, ty: variable.ty, kind: TypedAstNodeKind.Identifier(name, variable, fnTypeHint, varImportMod)))
  }

  func resolveAccessorPathSegment(self, ty: Type, label: Label, typeHint: Type?, isInvocation: Bool, optSafe = false): Result<AccessorPathSegment?, TypeError> {
    val foundSegment = match ty.kind {
      TypeKind.CouldNotDetermine => None
      TypeKind.PrimitiveUnit => None
      TypeKind.PrimitiveInt => return self.resolveAccessorPathSegment(Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeIntStruct), [])), label, None, isInvocation, optSafe)
      TypeKind.PrimitiveFloat => return self.resolveAccessorPathSegment(Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeFloatStruct), [])), label, None, isInvocation, optSafe)
      TypeKind.PrimitiveBool => return self.resolveAccessorPathSegment(Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeBoolStruct), [])), label, None, isInvocation, optSafe)
      TypeKind.PrimitiveChar => return self.resolveAccessorPathSegment(Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeCharStruct), [])), label, None, isInvocation, optSafe)
      TypeKind.PrimitiveString => return self.resolveAccessorPathSegment(Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeStringStruct), [])), label, None, isInvocation, optSafe)
      TypeKind.Never => None
      TypeKind.Generic => {
        val scope = self.project.preludeModule.rootScope.makeChild("T", ScopeKind.Type)
        val method = if label.name == "toString" {
          Some(Function.generated(scope, "toString", [], Type(kind: TypeKind.PrimitiveString), FunctionKind.InstanceMethod(None, true)))
        } else if label.name == "hash" {
          Some(Function.generated(scope, "hash", [], Type(kind: TypeKind.PrimitiveInt), FunctionKind.InstanceMethod(None, true)))
        } else if label.name == "eq" {
          Some(Function.generated(scope, "eq", [("other", ty)], Type(kind: TypeKind.PrimitiveBool), FunctionKind.InstanceMethod(None, true)))
        } else {
          None
        }

        if method |method| {
          Some(AccessorPathSegment.Method(label, method, optSafe, typeHint))
        } else {
          None
        }
      }
      TypeKind.Instance(instanceKind, generics) => {
        val (instanceMethods, typeParams, instanceTypeModuleId) = match instanceKind {
          InstanceKind.Struct(struct) => {
            for field in struct.fields {
              if field.name.name == label.name {
                if !field.isPublic && self._isIllegalAccessForMember(struct.moduleId) {
                  return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAccess(name: field.name.name, kind: "field", parentTy: ty)))
                }

                val resolvedGenerics: Map<String, Type> = {}
                for name, idx in struct.typeParams {
                  resolvedGenerics[name] = try generics[idx] else unreachable("typeParams.length != generics.length")
                }
                var ty = field.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
                if optSafe {
                  ty = Type(kind: TypeKind.Instance(InstanceKind.Enum(self.project.preludeOptionEnum), [ty]))
                }
                return Ok(Some(AccessorPathSegment.Field(label, ty, field, optSafe)))
              }
            }

            (struct.instanceMethods, struct.typeParams, struct.moduleId)
          }
          InstanceKind.Enum(enum_) => (enum_.instanceMethods, enum_.typeParams, enum_.moduleId)
        }

        for fn in instanceMethods {
          if fn.label.name == label.name {
            val isPublic = match fn.kind {
              FunctionKind.InstanceMethod(_, isPublic) => isPublic
              else => unreachable("Function '${fn.label.name}' should be an instance method here")
            }
            if !isPublic && self._isIllegalAccessForMember(instanceTypeModuleId) {
              return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAccess(name: fn.label.name, kind: "method", parentTy: ty)))
            }

            val method = if typeParams.isEmpty() || isInvocation {
              fn
            } else {
              val resolvedGenerics: Map<String, Type> = {}
              for name, idx in typeParams {
                resolvedGenerics[name] = try generics[idx] else unreachable("typeParams.length != generics.length")
              }

              fn.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: true, genericsInScope: #{})
            }
            return Ok(Some(AccessorPathSegment.Method(label, method, optSafe, typeHint)))
          }
        }

        None
      }
      TypeKind.Tuple => None
      TypeKind.Func => None
      TypeKind.Type(instanceKind) => {
        // TODO: static fields

        val (staticMethods, typeModuleId) = match instanceKind {
          InstanceKind.Struct(struct) => (struct.staticMethods, struct.moduleId)
          InstanceKind.Enum(enum_) => {
            for variant in enum_.variants {
              if variant.label.name == label.name {
                val typeArgs = enum_.typeParams.map(p => Type(kind: TypeKind.Generic(p)))
                val ty = if typeHint |hint| {
                  val template = Type(kind: TypeKind.Instance(InstanceKind.Enum(enum_), typeArgs))
                  val extractedGenerics = hint.extractGenerics(template)
                  val resolvedGenerics: Map<String, Type> = {}
                  for (name, ty) in extractedGenerics {
                    resolvedGenerics[name] = ty
                  }

                  template.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
                } else {
                  match variant.kind {
                    EnumVariantKind.Container => Type(kind: TypeKind.Instance(InstanceKind.Enum(enum_), typeArgs))
                    EnumVariantKind.Constant => Type(kind: TypeKind.Instance(InstanceKind.Enum(enum_), enum_.typeParams.map(() => Type(kind: TypeKind.Hole))))
                  }
                }

                // TODO: move this above, to bail earlier?
                match variant.kind {
                  EnumVariantKind.Container => {
                    if !self.isEnumContainerValueAllowed return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalNonConstantEnumVariant))
                  }
                  _ => {}
                }

                return Ok(Some(AccessorPathSegment.EnumVariant(label, ty, enum_, variant)))
              }
            }

            (enum_.staticMethods, enum_.moduleId)
          }
        }

        for method in staticMethods {
          if method.label.name == label.name {
            val isPublic = match method.kind {
              FunctionKind.StaticMethod(_, isPublic) => isPublic
              else => unreachable("Function '${method.label.name}' should be a static method here")
            }
            if !isPublic && self._isIllegalAccessForMember(typeModuleId) {
              return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAccess(name: method.label.name, kind: "static method", parentTy: ty)))
            }

            return Ok(Some(AccessorPathSegment.Method(label, method, optSafe, typeHint)))
          }
        }

        None
      }
      TypeKind.Hole => None
    }

    Ok(foundSegment)
  }

  func resolveModuleAliasAccessor(self, root: AstNode, field: (Token, Label)): (TypedAstNode?, Bool) {
    val _mod = match root.kind {
      AstNodeKind.Identifier(identKind) => {
        match identKind {
          IdentifierKind.Named(name) => self.findModuleByAlias(name)
          _ => None
        }
      }
      _ => None
    }

    val identifierNode = if _mod |(mod, aliasLabel)| {
      val (dotTok, label) = field
      if dotTok.kind == TokenKind.QuestionDot {
        self.currentModule.addTypeError(TypeError(position: dotTok.position, kind: TypeErrorKind.UnnecessaryOptSafety))
      }

      val exportVar = match mod.exports[label.name] {
        None => {
          self.currentModule.addTypeError(TypeError(position: label.position, kind: TypeErrorKind.UnknownImportForAlias(label.name, aliasLabel)))
          return (None, true)
        }
        Export.Variable(v) => v
        Export.Function(v) => v
        Export.Type(_, v) => v
      }

      val token = Token(position: label.position, kind: TokenKind.Ident(label.name))
      Some(TypedAstNode(token: token, ty: exportVar.ty, kind: TypedAstNodeKind.Identifier(label.name, exportVar, None, Some(mod))))
    } else {
      None
    }

    (identifierNode, false)
  }

  func typecheckAccessor(self, token: Token, node: AccessorAstNode, typeHint: Type?, isInvocation: Bool): Result<TypedAstNode, TypeError> {
    var accessorPath = node.path

    val firstSeg = try accessorPath[0] else unreachable("path should have at least 1 segment")
    val (maybeModuleAccessor, errorOccurred) = self.resolveModuleAliasAccessor(node.root, firstSeg)
    val typedRoot = if maybeModuleAccessor |n| {
      if accessorPath.length == 1 return Ok(n)

      accessorPath = accessorPath[1:]
      n
    } else if errorOccurred {
      return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder))
    } else {
      self.isStructOrEnumValueAllowed = true
      val typedNode = try self._typecheckExpression(node.root, None)
      self.isStructOrEnumValueAllowed = false
      typedNode
    }

    val path: AccessorPathSegment[] = []
    var ty = typedRoot.ty
    if ty.kind == TypeKind.CouldNotDetermine return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder))

    var seenOptSafeDot = false
    for (token, label), idx in accessorPath {
      val isOptSafe = token.kind == TokenKind.QuestionDot
      seenOptSafeDot ||= isOptSafe
      val optInnerTy = self._typeIsOption(ty)

      val subjTy = if isOptSafe {
        if optInnerTy |innerTy| {
          innerTy
        } else {
          return Err(TypeError(position: token.position, kind: TypeErrorKind.UnnecessaryOptSafety))
        }
      } else {
        ty
      }

      val seg = try self.resolveAccessorPathSegment(subjTy, label, typeHint, isInvocation, isOptSafe)
      if seg |seg| {
        val nextTy = seg.getType()

        match seg {
          AccessorPathSegment.Method(_, fn, _, _) => {
            if fn.isClosure() {
              if self.currentFunction |currentFn| {
                if !currentFn.capturedClosures.find(f => f.label.name == fn.label.name) {
                  currentFn.capturedClosures.push(fn)
                }
              }
            }

            if self.lspMode {
              val typeParams: String[] = []
              for (_, label) in fn.typeParams {
                typeParams.push(label.name)
              }

              val (isInstanceMethod, params) = match fn.kind {
                FunctionKind.InstanceMethod => (true, ["self"])
                _ => (false, [])
              }

              for param in fn.params {
                params.push("${if param.isVariadic "..." else ""}${param.label.name}${if param.defaultValue "?" else ""}: ${param.ty.repr()}")
              }

              val returnTypeRepr = fn.returnType.repr()

              if self._getLSPTypeData(subjTy) |(definitionModule, parentTy)| {
                val parentTypeRepr = parentTy.asInstanceType().repr(shorthand: false)
                val kind = IdentifierKindMeta.Function(typeParams, params, returnTypeRepr, methodTy: Some((isInstanceMethod, parentTypeRepr)))

                val ident = IdentifierMeta(
                  name: label.name,
                  kind: kind,
                  definitionPosition: Some((definitionModule, fn.label.position)),
                )
                self._addLSPIdent(label.position, ident)
              }
            }
          }
          AccessorPathSegment.Field(_, ty, f, _) => {
            if self.lspMode {
              if self._getLSPTypeData(subjTy) |(definitionModule, parentTy)| {
                val parentTypeRepr = parentTy.asInstanceType().repr(shorthand: false)
                val kind = IdentifierKindMeta.Field(fieldTy: ty.repr(), parentTypeRepr: parentTypeRepr)
                val ident = IdentifierMeta(
                  name: label.name,
                  kind: kind,
                  definitionPosition: Some((definitionModule, f.name.position)),
                )
                self._addLSPIdent(label.position, ident)
              }
            }
          }
          AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => {
            if self.lspMode {
              self._addLSPIdentForEnumVariant(label.position, enum_, variant)
            }
          }
        }

        path.push(seg)
        ty = if isOptSafe {
          match seg {
            AccessorPathSegment.Field => nextTy // type is already wrapped in Option in resolveAccessorPathSegment for fields if opt-safe
            _ => Type(kind: TypeKind.Instance(InstanceKind.Enum(self.project.preludeOptionEnum), [nextTy]))
          }
        } else {
          nextTy
        }
      } else {
        val specialCase = if optInnerTy |innerTy| {
          if try self.resolveAccessorPathSegment(innerTy, label, typeHint, isInvocation) {
            Some(UnknownFieldSpecialCase.ExistsButTypeIsNullable(seenOptSafeDot))
          } else {
            None
          }
        } else {
          match ty.kind {
            TypeKind.Instance(instanceKind, _) => {
              if try self.resolveAccessorPathSegment(Type(kind: TypeKind.Type(instanceKind)), label, typeHint, isInvocation) {
                Some(UnknownFieldSpecialCase.StaticFieldReferencedAsInstance)
              } else {
                None
              }
            }
            _ => None
          }
        }

        self.currentModule.addTypeError(TypeError(position: label.position, kind: TypeErrorKind.UnknownField(ty, label.name, specialCase)))
        return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder))
      }
    }

    val finalField = try path.pop() else unreachable("the accessor path should not be empty")

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Accessor(typedRoot, path, finalField)))
  }

  func typecheckInvocation(self, token: Token, node: InvocationAstNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    self.isStructOrEnumValueAllowed = true
    self.isEnumContainerValueAllowed = true
    // If invokee is an accessor, typecheck the accessor by passing a special flag. This flag indicates to _not_ substitute generics into the
    // underlying node (if it's a method); that will be resolved later on in this method. This is necessary because when typechecking a non-invocation
    // accessor, we _do_ want to substitute generics into methods since otherwise that information will be lost from that point onwards.
    val invokee = match node.invokee.kind {
      AstNodeKind.Accessor(value) => try self.typecheckAccessor(node.invokee.token, value, None, isInvocation: true),
      else => try self._typecheckExpression(node.invokee, None)
    }
    if invokee.ty.kind == TypeKind.CouldNotDetermine return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder))
    self.isStructOrEnumValueAllowed = false
    self.isEnumContainerValueAllowed = false

    match invokee.kind {
      TypedAstNodeKind.Identifier(name, variable, _, _) => {
        match variable.alias {
          VariableAlias.Function(fn) => self.typecheckInvocationOfFunction(token, invokee.token.position, fn, node.typeArguments, node.arguments, typeHint)
          VariableAlias.Struct(struct) => {
            val initializerFn = Function.initializer(self.currentScope, struct)
            self.typecheckInvocationOfFunction(token, invokee.token.position, initializerFn, node.typeArguments, node.arguments, typeHint, None, Some(Instantiatable.Struct(struct)))
          }
          VariableAlias.Enum(enum_) => return Err(TypeError(position: invokee.token.position, kind: TypeErrorKind.IllegalCallableType(Type(kind: TypeKind.Type(InstanceKind.Enum(enum_))))))
          None => self._typecheckInvocationOfExpression(token, invokee, invokee.token.position, node)
        }
      }
      TypedAstNodeKind.Accessor(head, mid, tail) => {
        match tail {
          AccessorPathSegment.EnumVariant(label, _, enum_, variant) => {
            val fields = match variant.kind {
              EnumVariantKind.Constant => return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalCallableType(invokee.ty)))
              EnumVariantKind.Container(fields) => fields
            }

            val enumVariantAsFn = Function.forEnumVariant(self.currentScope, enum_, variant.label, fields)

            self.typecheckInvocationOfFunction(token, invokee.token.position, enumVariantAsFn, node.typeArguments, node.arguments, typeHint, None, Some(Instantiatable.EnumContainerVariant(enum_, variant, fields)))
          }
          AccessorPathSegment.Method(l, fn, optSafe, _) => {
            match fn.kind {
              FunctionKind.InstanceMethod => {
                val selfVal = if mid[-1] |newTail| {
                  TypedAstNode(token: token, ty: newTail.getType(), kind: TypedAstNodeKind.Accessor(head, mid[:-1], newTail))
                } else {
                  head
                }

                if optSafe {
                  val typedNode = try self.typecheckInvocationOfFunction(token, invokee.token.position, fn, node.typeArguments, node.arguments, typeHint, Some((selfVal, true)))
                  typedNode.ty = Type(kind: TypeKind.Instance(InstanceKind.Enum(self.project.preludeOptionEnum), [typedNode.ty]))
                  Ok(typedNode)
                } else {
                  self.typecheckInvocationOfFunction(token, invokee.token.position, fn, node.typeArguments, node.arguments, typeHint, Some((selfVal, false)))
                }
              }
              _ => self.typecheckInvocationOfFunction(token, invokee.token.position, fn, node.typeArguments, node.arguments, typeHint)
            }
          }
          AccessorPathSegment.Field(label, _, _, _) => self._typecheckInvocationOfExpression(token, invokee, label.position, node)
        }
      }
      _ => self._typecheckInvocationOfExpression(token, invokee, invokee.token.position, node)
    }
  }

  func _typecheckInvocationOfExpression(self, token: Token, invokeeExpr: TypedAstNode, exprPos: Position, invocationNode: InvocationAstNode): Result<TypedAstNode, TypeError> {
    val (paramTypes, returnType) = match invokeeExpr.ty.kind {
      TypeKind.Func(paramTypes, returnType) => (paramTypes.filter(p => p[1]).map(p => p[0]), returnType)
      _ => return Err(TypeError(position: exprPos, kind: TypeErrorKind.IllegalCallableType(invokeeExpr.ty)))
    }

    if self.paramDefaultValueContext |ctx| {
      ctx.exprContainsFunctionCall = true
      return Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Placeholder))
    }

    val typedArguments: TypedAstNode?[] = []
    for arg, idx in invocationNode.arguments {
      if arg.label |label| {
        return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalParameterLabel))
      }

      var paramType = try paramTypes[idx] else {
        return Err(TypeError(position: arg.position(), kind: TypeErrorKind.WrongInvocationArity(expected: paramTypes.length, given: invocationNode.arguments.length)))
      }

      val typedArg = try self._typecheckExpression(arg.value, Some(paramType))
      if !self._typeSatisfiesRequired(ty: typedArg.ty, required: paramType) {
        return Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(None, paramType, typedArg.ty)))
      }
      typedArguments.push(Some(typedArg))
    }

    if typedArguments.length < paramTypes.length {
      return Err(TypeError(position: token.position, kind: TypeErrorKind.WrongInvocationArity(expected: paramTypes.length, given: typedArguments.length)))
    }

    val typedInvokee = TypedInvokee.Expr(invokeeExpr)
    Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Invocation(typedInvokee, typedArguments, {})))
  }

  func typecheckInvocationOfFunction(
    self,
    token: Token,
    invokeePosition: Position,
    fn: Function,
    typeArguments: TypeIdentifier[],
    arguments: InvocationArgument[],
    typeHint: Type?,
    selfVal: (TypedAstNode, Bool)? = None,
    instantiationOf: Instantiatable? = None
  ): Result<TypedAstNode, TypeError> {
    // Function invocation is position-based for required parameters, with optional parameter labels to express call-site intent (ie. for Bool params), and it's
    // an error if a positional parameter's label is incorrect. Once we reach any optional parameters in the argument list, parameters can either be positional
    // OR labeled, but once a labeled optional parameter is seen, all subsequent arguments in the argument list must also be labeled.
    val paramsByName = fn.params.keyBy(p => p.label.name)
    val typedArgumentsByName: Map<String, TypedAstNode> = {}
    val resolvedGenerics: Map<String, Type> = {}

    if !typeArguments.isEmpty() {
      for (_, typeParamLabel), idx in fn.typeParams {
        val typeArg = try typeArguments[idx] else {
          return Err(TypeError(position: invokeePosition, kind: TypeErrorKind.WrongTypeArgumentArity(expected: fn.typeParams.length, given: typeArguments.length)))
        }
        val typeArgTy = try self.resolveTypeIdentifier(typeArg)
        resolvedGenerics[typeParamLabel.name] = typeArgTy
      }
      if typeArguments.length > fn.typeParams.length {
        return Err(TypeError(position: invokeePosition, kind: TypeErrorKind.WrongTypeArgumentArity(expected: fn.typeParams.length, given: typeArguments.length)))
      }
    }

    if typeHint |hint| {
      if hint.kind != TypeKind.PrimitiveUnit && fn.returnType.containsGenerics() {
        val extractedGenerics = hint.extractGenerics(template: fn.returnType)

        for (name, ty) in extractedGenerics {
          if resolvedGenerics[name] |original| {
            if original != ty {
              val returnType = fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
              return Err(TypeError(position: invokeePosition, kind: TypeErrorKind.TypeMismatch([hint], returnType)))
            }
            continue
          }
          resolvedGenerics[name] = ty
        }
      }
    }

    if selfVal |(selfNode, _)| {
      val instanceKind = match fn.kind {
        FunctionKind.InstanceMethod(instanceKind, _) => instanceKind
        else => unreachable("if selfVal passed, then FunctionKind must be InstanceMethod")
      }

      // When instanceKind is not present on FunctionKind.InstanceMethod, that means that the method's selfVal is a generic.
      // In that case, the template from which to extract generics should just be self's type.
      val template = if instanceKind |instanceKind| {
        val typeParams = match instanceKind { InstanceKind.Struct(s) => s.typeParams, InstanceKind.Enum(e) => e.typeParams }
        Type(kind: TypeKind.Instance(instanceKind, typeParams.map(name => Type(kind: TypeKind.Generic(name)))))
      } else {
        selfNode.ty
      }
      val extractedGenerics = selfNode.ty.extractGenerics(template: template)
      for (name, ty) in extractedGenerics {
        if resolvedGenerics[name] |original| {
          if original != ty unreachable("original != ty") // is this check necessary? i don't think so
          continue
        }
        resolvedGenerics[name] = ty
      }
    }

    if self.paramDefaultValueContext |ctx| {
      ctx.exprContainsFunctionCall = true

      val returnType = if fn.returnType.containsGenerics() {
        fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: #{})
      } else {
        fn.returnType
      }
      return Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Placeholder))
    }

    val genericsInScope = self._genericsInScope()
    var hasBegunOptionalParams = false
    var variadicParam: (TypedFunctionParam, Int)? = None
    val variadicArgs: TypedAstNode[] = []
    var mostRecentLabeledOptionalParam: Label? = None
    val argumentsQueue = arguments.map((arg, idx) => (arg, idx, 0))
    for (arg, argIdx, numAttempts) in argumentsQueue {
      val idx = if variadicParam |(_, idx)| idx else argIdx

      var param = try fn.params[idx] else {
        return Err(TypeError(position: arg.position(), kind: TypeErrorKind.WrongInvocationArity(expected: fn.params.length, given: arguments.length)))
      }
      if (!!param.defaultValue) || param.isVariadic { hasBegunOptionalParams = true }

      var paramTy = param.ty
      if arg.label |label| {
        if label.name != param.label.name {
          if !hasBegunOptionalParams {
            return Err(TypeError(position: label.position, kind: TypeErrorKind.ParameterLabelMismatch(expected: param.label.name, given: label.name)))
          }

          param = try paramsByName[label.name] else return Err(TypeError(position: label.position, kind: TypeErrorKind.UnknownParameterName(label.name)))
          paramTy = param.ty
        }

        if instantiationOf |instantiatable| {
          match instantiatable {
            Instantiatable.Struct(struct) => {
              for f in struct.fields {
                if f.name.name != label.name continue
                if !f.isPublic && self._isIllegalAccessForMember(struct.moduleId) {
                  return Err(TypeError(position: label.position, kind: TypeErrorKind.IllegalAccess(name: f.name.name, kind: "field", parentTy: struct.asInstanceType())))
                }
              }
            }
            _ => {}
          }
        }

        if hasBegunOptionalParams && !mostRecentLabeledOptionalParam {
          mostRecentLabeledOptionalParam = Some(label)
        }
        if param.isVariadic {
          paramTy = Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeArrayStruct), [paramTy]))
        }
      } else if instantiationOf |instantiatable| {
        match instantiatable {
          Instantiatable.EnumContainerVariant => {}
          Instantiatable.Struct(struct) => {
            if !struct.isDecoratorType return Err(TypeError(position: arg.position(), kind: TypeErrorKind.MissingRequiredArgumentLabel))

            val reqFields = struct.fields.filter(f => !f.initializer)
            if reqFields.length > 1 return Err(TypeError(position: arg.position(), kind: TypeErrorKind.MissingRequiredArgumentLabel))
          }
        }
      } else if mostRecentLabeledOptionalParam |label| {
        return Err(TypeError(position: arg.position(), kind: TypeErrorKind.MixedArgumentType(label)))
      } else {
        if param.isVariadic { variadicParam = Some((param, idx)) }
      }

      val (typedArg, paramType) = if param.ty.containsGenerics() {
        if fn.isMacro todo("macro functions with generics")

        var paramType = paramTy.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)

        val typedArg = try self._typecheckExpression(arg.value, Some(paramType))
        if numAttempts < 1 && typedArg.ty.hasUnfilledHoles() {
          argumentsQueue.push((arg, argIdx, numAttempts + 1))
          continue
        }

        val extractedGenerics = typedArg.ty.extractGenerics(template: paramTy)

        for (name, ty) in extractedGenerics {
          if resolvedGenerics[name] |original| {
            match original.kind {
              TypeKind.Generic => {
                resolvedGenerics[name] = ty
                continue
              }
              TypeKind.Hole => {
                resolvedGenerics[name] = ty
                continue
              }
              _ => {}
            }
            if !self.project.typesAreEquivalent(ty: original, other: ty) {
              return Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(Some(param.label.name), original, typedArg.ty)))
            }
            continue
          }
          resolvedGenerics[name] = ty
        }

        paramType = paramTy.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)
        (typedArg, paramType)
      } else {
        val typeHint = if fn.isMacro None else Some(paramTy)
        val typedArg = try self._typecheckExpression(arg.value, typeHint)
        (typedArg, paramTy)
      }

      if fn.isMacro && paramType == Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.metaExprStruct), [])) {
        // allow expressions of any type to be passed to macros, if the argument is of known type `meta.Expr`
      } else {
        if !self._typeSatisfiesRequired(ty: typedArg.ty, required: paramType) {
          return Err(TypeError(position: typedArg.token.position, kind: TypeErrorKind.ParameterTypeMismatch(Some(param.label.name), paramType, typedArg.ty)))
        }
      }

      if variadicParam {
        variadicArgs.push(typedArg)
      } else {
        typedArgumentsByName[param.label.name] = typedArg
      }
    }

    if variadicParam |(param, _)| {
      var innerType = param.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)
      val paramType = Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeArrayStruct), [innerType]))
      typedArgumentsByName[param.label.name] = TypedAstNode(token: token, ty: paramType, kind: TypedAstNodeKind.Array(variadicArgs))
    }

    val typedArguments: TypedAstNode?[] = []
    for param in fn.params {
      if typedArgumentsByName[param.label.name] |argValue| {
        typedArguments.push(Some(argValue))
      } else if param.defaultValue {
        typedArguments.push(None)
      } else if param.isVariadic {
        var innerType = param.ty.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)
        val paramType = Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeArrayStruct), [innerType]))
        typedArguments.push(Some(TypedAstNode(token: token, ty: paramType, kind: TypedAstNodeKind.Array([]))))
      } else {
        val errorKind = if instantiationOf |i| {
          val missing = match i {
            Instantiatable.Struct(struct) => {
              struct.fields
                .filter(f => !f.initializer && !typedArgumentsByName.containsKey(f.name.name))
                .map(f => f.name.name)
            }
            Instantiatable.EnumContainerVariant(_, _, fields) => {
              fields
                .filter(f => !f.initializer && !typedArgumentsByName.containsKey(f.name.name))
                .map(f => f.name.name)
            }
          }
          TypeErrorKind.MissingRequiredFields(missing)
        } else {
          val numRequired = fn.params.filter(p => !p.defaultValue).length
          TypeErrorKind.WrongInvocationArity(expected: numRequired, given: arguments.length)
        }

        return Err(TypeError(position: token.position, kind: errorKind))
      }
    }

    // If the function being invoked is a macro, invoke the function at compile-time and typecheck its returned node as if it were present in the original source
    if fn.isMacro {
      val res = self.typecheckMacroInvocation(token, fn, typedArguments, resolvedGenerics)
      return Ok(res)
    }

    val returnType = if fn.decorators.find(d => d.label.name == "noreturn") {
      self.currentScope.terminator = Some(Terminator.Returning)
      Type(kind: TypeKind.Never)
    } else if fn.returnType.containsGenerics() {
      fn.returnType.withSubstitutedGenerics(resolvedGenerics: resolvedGenerics, retainUnknown: false, genericsInScope: genericsInScope)
    } else {
      fn.returnType
    }

    val typedInvokee = if instantiationOf |i| {
      match i {
        Instantiatable.Struct(struct) => TypedInvokee.Struct(struct)
        Instantiatable.EnumContainerVariant(enum_, variant, _) => TypedInvokee.EnumVariant(enum_, variant)
      }
    } else if selfVal |(selfVal, isOptSafe)| {
      TypedInvokee.Method(fn, selfVal, isOptSafe)
    } else {
      TypedInvokee.Function(fn)
    }

    if fn.isClosure() {
      if self.currentFunction |currentFn| {
        if !currentFn.capturedClosures.find(f => f.label.name == fn.label.name) {
          currentFn.capturedClosures.push(fn)
        }
      }
    }

    Ok(TypedAstNode(token: token, ty: returnType, kind: TypedAstNodeKind.Invocation(typedInvokee, typedArguments, resolvedGenerics)))
  }

  func typecheckMacroInvocation(self, token: Token, fn: Function, typedArguments: TypedAstNode?[], resolvedGenerics: Map<String, Type>): TypedAstNode {
    // If there's any errors in the module in which the macro function is declared, then assume that we cannot accurately invoke the function at compile-time.
    // Note: this is not a great assumption, since the function itself may not have any related errors, and may not depend on anything in the module which
    // has any errors. However, this is difficult to verify at the moment.
    val (_, fnModulePath) = try fn.scope.findParentModule() else unreachable("fn '${fn.label.name} must be defined within a module")
    val fnModule = try self.project.modules[fnModulePath] else unreachable("could not find module '$fnModulePath'")
    if fnModule.hasError() {
      self.currentModule.addTypeError(TypeError(
        position: token.position,
        kind: TypeErrorKind.ErrorWithinMacroFunction(fn)
      ))
      return TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder)
    }

    val injectedCode = try self.comptimeFuncEvaluator(fn, typedArguments, resolvedGenerics) else |e| unreachable("comptimeFuncEvaluator: $e")
    val contents = injectedCode.chunks.join()
    val parsedModule = try tokenizeAndParse(contents) else |e| {
      self.currentModule.addTypeError(TypeError(
        position: token.position,
        kind: TypeErrorKind.ErrorWithinMacroOutput(macroName: fn.label.name, generatedContents: contents, innerError: ErrorWithinMacroOutputKind.LexerOrParseError(e))
      ))
      return TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder)
    }

    for (mod, alias) in injectedCode.imports {
      parsedModule.imports.push(ImportNode(
        token: Token(position: Position(line: -1, col: -1), kind: TokenKind.Import),
        kind: ImportKind.Alias(Label(name: alias, position: Position(line: -1, col: -1))),
        moduleName: Label(name: mod, position: Position(line: -1, col: -1)),
      ))
    }
    val imports = try self.processImports(None, parsedModule) else |position| {
      self.currentModule.addTypeError(TypeError(
        position: token.position,
        kind: TypeErrorKind.ErrorWithinMacroOutput(macroName: fn.label.name, generatedContents: contents, innerError: ErrorWithinMacroOutputKind.TypeError(TypeError(position: position, kind: TypeErrorKind.CircularDependency)))
      ))
      return TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder)
    }

    for (typedImportModule, importNode) in imports {
      val errors = self._typecheckImport(typedImportModule, importNode)
      for err in errors {
        self.currentModule.addTypeError(TypeError(
          position: token.position,
          kind: TypeErrorKind.ErrorWithinMacroOutput(macroName: fn.label.name, generatedContents: contents, innerError: ErrorWithinMacroOutputKind.TypeError(err))
        ))
      }
    }

    val origTypeErrors = self.currentModule.typeErrors
    self.currentModule.typeErrors = []
    var resultNode: TypedAstNode? = None
    for node in parsedModule.nodes {
      resultNode = Some(self.typecheckStatement(node, None))
    }
    val seenTypeErrors = self.currentModule.typeErrors
    self.currentModule.typeErrors = origTypeErrors

    for err in seenTypeErrors {
      self.currentModule.addTypeError(TypeError(
        position: token.position,
        kind: TypeErrorKind.ErrorWithinMacroOutput(macroName: fn.label.name, generatedContents: contents, innerError: ErrorWithinMacroOutputKind.TypeError(err))
      ))
    }

    // todo: somehow allow this
    try resultNode else unreachable("an empty list of nodes was returned")
  }

  func typecheckArray(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerType: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance1(hint, self.project.preludeArrayStruct) |inner| {
        if inner.kind != TypeKind.Hole {
          innerType = Some(inner)
        }
      }
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = try self._typecheckExpression(node: node, typeHint: innerType)
      if innerType |ty| {
        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          return Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
        }
      } else if !typedItem.ty.hasUnfilledHoles() {
        innerType = Some(typedItem.ty)
      }
      typedItems.push(typedItem)
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeArrayStruct), [inner]))
    val innerHasUnfilledHoles = inner.hasUnfilledHoles()

    for item in typedItems {
      if !innerHasUnfilledHoles && item.ty.hasUnfilledHoles() {
        item.ty.tryFillHoles(inner)
        if !self._typeSatisfiesRequired(ty: item.ty, required: inner) {
          return Err(TypeError(position: item.token.position, kind: TypeErrorKind.TypeMismatch([inner], item.ty)))
        }
      }
    }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Array(typedItems)))
  }

  func typecheckSet(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var innerType: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance1(hint, self.project.preludeSetStruct) |inner| {
        if inner.kind != TypeKind.Hole {
          innerType = Some(inner)
        }
      }
    }

    var makeItemsNullable = false
    val typedItems: TypedAstNode[] = []
    for node in items {
      val typedItem = try self._typecheckExpression(node: node, typeHint: innerType)
      if innerType |ty| {
        if !self._typeSatisfiesRequired(ty: typedItem.ty, required: ty) {
          return Err(TypeError(position: typedItem.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedItem.ty)))
        }
      } else if !typedItem.ty.hasUnfilledHoles() {
        innerType = Some(typedItem.ty)
      }
      typedItems.push(typedItem)
    }

    val inner = innerType ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeSetStruct), [inner]))
    val innerHasUnfilledHoles = inner.hasUnfilledHoles()

    for item in typedItems {
      if !innerHasUnfilledHoles && item.ty.hasUnfilledHoles() {
        item.ty.tryFillHoles(inner)
        if !self._typeSatisfiesRequired(ty: item.ty, required: inner) {
          return Err(TypeError(position: item.token.position, kind: TypeErrorKind.TypeMismatch([inner], item.ty)))
        }
      }
    }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Set(typedItems)))
  }

  func typecheckMap(self, token: Token, items: (AstNode, AstNode)[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var keyTy: Type? = None
    var valTy: Type? = None
    if typeHint |hint| {
      if self._typeAsInstance2(hint, self.project.preludeMapStruct) |(keyHintTy, valHintTy)| {
        if keyHintTy.kind != TypeKind.Hole {
          keyTy = Some(keyHintTy)
        }
        if valHintTy.kind != TypeKind.Hole {
          valTy = Some(valHintTy)
        }
      }
    }

    val typedItems: (TypedAstNode, TypedAstNode)[] = []
    for (keyNode, valNode) in items {
      val typedKey = match keyNode.kind {
        AstNodeKind.Identifier(identKind) => match identKind {
          IdentifierKind.Named(name) => TypedAstNode(token: keyNode.token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.Literal(LiteralAstNode.String(name)))
          IdentifierKind.Discard => TypedAstNode(token: keyNode.token, ty: Type(kind: TypeKind.PrimitiveString), kind: TypedAstNodeKind.Literal(LiteralAstNode.String("_")))
          IdentifierKind.Self => try self._typecheckExpression(node: keyNode, typeHint: keyTy)
          IdentifierKind.None_ => try self._typecheckExpression(node: keyNode, typeHint: keyTy)
        }
        _ => try self._typecheckExpression(node: keyNode, typeHint: keyTy)
      }

      if keyTy |ty| {
        if !self._typeSatisfiesRequired(ty: typedKey.ty, required: ty) {
          return Err(TypeError(position: typedKey.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedKey.ty)))
        }
      } else if !typedKey.ty.hasUnfilledHoles() {
        keyTy = Some(typedKey.ty)
      }

      val typedVal = try self._typecheckExpression(node: valNode, typeHint: valTy)
      if valTy |ty| {
        if !self._typeSatisfiesRequired(ty: typedVal.ty, required: ty) {
          return Err(TypeError(position: typedVal.token.position, kind: TypeErrorKind.TypeMismatch([ty], typedVal.ty)))
        }
      } else if !typedVal.ty.hasUnfilledHoles() {
        valTy = Some(typedVal.ty)
      }

      typedItems.push((typedKey, typedVal))
    }

    val kTy = keyTy ?: Type(kind: TypeKind.Hole)
    val vTy = valTy ?: Type(kind: TypeKind.Hole)
    val ty = Type(kind: TypeKind.Instance(InstanceKind.Struct(self.project.preludeMapStruct), [kTy, vTy]))
    val keyTyHasUnfilledHoles = kTy.hasUnfilledHoles()
    val valTyHasUnfilledHoles = vTy.hasUnfilledHoles()

    for (typedKey, typedVal) in typedItems {
      if !keyTyHasUnfilledHoles && typedKey.ty.hasUnfilledHoles() { typedKey.ty.tryFillHoles(kTy) }
      if !valTyHasUnfilledHoles && typedVal.ty.hasUnfilledHoles() { typedVal.ty.tryFillHoles(vTy) }
     }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Map(typedItems)))
  }

  func typecheckTuple(self, token: Token, items: AstNode[], typeHint: Type?): Result<TypedAstNode, TypeError> {
    var typeHints: Type[]? = None
    if typeHint |hint| {
      match hint.kind {
        TypeKind.Tuple(types) => typeHints = Some(types)
        _ => {}
      }
    }

    val typedItems: TypedAstNode[] = []
    for node, idx in items {
      val typeHint = if typeHints |typeHints| typeHints[idx] else None
      val typedExpr = try self._typecheckExpression(node, typeHint)
      if typeHint |hint| {
        if !self._typeSatisfiesRequired(ty: typedExpr.ty, required: hint) {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.TypeMismatch([hint], typedExpr.ty)))
        }
      }
      typedItems.push(typedExpr)
    }
    val ty = Type(kind: TypeKind.Tuple(typedItems.map(item => item.ty)))
    if typeHints |typeHints| {
      val hintTy = Type(kind: TypeKind.Tuple(typeHints))
      if !self._typeSatisfiesRequired(ty: ty, required: hintTy) {
        return Err(TypeError(position: token.position, kind: TypeErrorKind.TypeMismatch([hintTy], ty)))
      }
    }

    Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Tuple(typedItems)))
  }

  func typecheckIndexing(self, token: Token, expr: AstNode, indexMode: IndexingMode<AstNode>, typeHint: Type?): Result<TypedAstNode, TypeError> {
    val typedExpr = try self._typecheckExpression(expr, None)
    if typedExpr.ty.kind == TypeKind.CouldNotDetermine return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder))

    if self._typeIsOption(typedExpr.ty) {
      return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
    }

    match typedExpr.ty.kind {
      TypeKind.PrimitiveString => {
        val resTy = Type(kind: TypeKind.PrimitiveString)
        self._typecheckIndexingArraylike(token: token, typedExpr: typedExpr, indexMode: indexMode, singleModeType: resTy, rangeModeType: resTy)
      }
      TypeKind.Tuple(types) => self._typecheckIndexingTuple(token, types, typedExpr, indexMode)
      TypeKind.Instance(struct, typeArgs) => {
        if self._typeAsInstance1(typedExpr.ty, self.project.preludeArrayStruct) |inner| {
          val innerAsOpt = Type(kind: TypeKind.Instance(InstanceKind.Enum(self.project.preludeOptionEnum), [inner]))
          self._typecheckIndexingArraylike(token: token, typedExpr: typedExpr, indexMode: indexMode, singleModeType: innerAsOpt, rangeModeType: typedExpr.ty)
        } else if self._typeAsInstance2(typedExpr.ty, self.project.preludeMapStruct) |(keyTy, valTy)| {
          match indexMode {
            IndexingMode.Single(idxExpr) => {
              val typedIdxExpr = try self._typecheckExpression(idxExpr, Some(keyTy))
              if !self._typeSatisfiesRequired(ty: typedIdxExpr.ty, required: keyTy) {
                return Err(TypeError(position: typedIdxExpr.token.position, kind: TypeErrorKind.TypeMismatch([keyTy], typedIdxExpr.ty)))
              }

              val ty = Type(kind: TypeKind.Instance(InstanceKind.Enum(self.project.preludeOptionEnum), [Type(kind: valTy.kind, )]))
              Ok(TypedAstNode(token: token, ty: ty, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.Map(typedExpr, typedIdxExpr))))
            }
            IndexingMode.Range => return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: true)))
          }
        } else {
          return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
        }
      }
      _ => return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.IllegalIndexableType(ty: typedExpr.ty, isRange: false)))
    }
  }

  func _typecheckIndexingArraylike(self, token: Token, typedExpr: TypedAstNode, indexMode: IndexingMode<AstNode>, singleModeType: Type, rangeModeType: Type): Result<TypedAstNode, TypeError> {
    match indexMode {
      IndexingMode.Single(idxExpr) => {
        val typedIdxExpr = try self._typecheckExpression(idxExpr, None)
        val idxTy = typedIdxExpr.ty
        if idxTy.kind != TypeKind.PrimitiveInt || !!self._typeIsOption(idxTy) {
          return Err(TypeError(position: typedIdxExpr.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], idxTy)))
        }

        val typedIndexMode = IndexingMode.Single(typedIdxExpr)
        return Ok(TypedAstNode(token: token, ty: singleModeType, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.ArrayLike(typedExpr, typedIndexMode))))
      }
      IndexingMode.Range(startExpr, endExpr) => {
        val typedStartExpr = if startExpr |expr| {
          val e = try self._typecheckExpression(expr, None)
          if e.ty.kind != TypeKind.PrimitiveInt || !!self._typeIsOption(e.ty) {
            return Err(TypeError(position: e.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], e.ty)))
          }
          Some(e)
        } else None
        val typedEndExpr = if endExpr |expr| {
          val e = try self._typecheckExpression(expr, None)
          if e.ty.kind != TypeKind.PrimitiveInt || !!self._typeIsOption(e.ty) {
            return Err(TypeError(position: e.token.position, kind: TypeErrorKind.TypeMismatch([Type(kind: TypeKind.PrimitiveInt)], e.ty)))
          }
          Some(e)
        } else None
        val typedIndexMode = IndexingMode.Range(typedStartExpr, typedEndExpr)
        return Ok(TypedAstNode(token: token, ty: rangeModeType, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.ArrayLike(typedExpr, typedIndexMode))))
      }
    }
  }

  func _typecheckIndexingTuple(self, token: Token, tupleItemTypes: Type[], tupleExpr: TypedAstNode, indexMode: IndexingMode<AstNode>): Result<TypedAstNode, TypeError> {
    match indexMode {
      IndexingMode.Single(idxExpr) => {
        match idxExpr.kind {
          AstNodeKind.Literal(lit) => {
            match lit {
              LiteralAstNode.Int(i) => {
                val itemTy = if i < 0
                  return Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.IndexNegative)))
                else if tupleItemTypes[i] |ty|
                  ty
                else
                  return Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.IndexOutOfBounds)))

                Ok(TypedAstNode(token: token, ty: itemTy, kind: TypedAstNodeKind.Indexing(TypedIndexingNode.Tuple(tupleExpr, i))))
              }
              _ => Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.NotIntLiteral)))
            }
          }
          _ => Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalTupleIndexing(tupleExpr.ty, IllegalTupleIndexingReason.NotLiteralNode)))
        }
      }
      // TODO: should tuples be indexable as a range? it could just create a sub-tuple copy? is that useful at all? seems silly to forbid it
      IndexingMode.Range => Err(TypeError(position: token.position, kind: TypeErrorKind.IllegalIndexableType(ty: tupleExpr.ty, isRange: true)))
    }
  }

  func _typecheckLambda(self, token: Token, node: LambdaNode, typeHint: Type?): Result<TypedAstNode, TypeError> {
    var paramHints: Type[] = []
    var retHint: Type? = None
    if typeHint |hint| {
      match hint.kind {
        TypeKind.Func(paramTypes, retType) => {
          for (ty, isRequired) in paramTypes {
            if !isRequired unreachable("unexpected non-required param in lambda param type hint")

            paramHints.push(ty)
          }
          retHint = Some(retType)
        }
        _ => {}
      }
    }

    val lambdaName = self._nextLambdaName()
    val prevScope = self.beginChildScope(lambdaName, ScopeKind.Func)
    val prevFn = self.currentFunction

    var returnType = retHint ?: Type(kind: TypeKind.Hole)
    if returnType.containsGenerics() {
      // If the return type of a lambda contains generics that have not yet been resolved by the time we get here, then
      // they must be "out" generics rather than "in" generics - this means that they should be treated as Holes which will
      // be filled once the return type is discovered, during typecheckFunctionPass3.
      returnType = returnType.withSubstitutedGenerics(resolvedGenerics: {}, retainUnknown: false, genericsInScope: #{})
    }
    val fn = Function(
      label: Label(name: lambdaName, position: token.position),
      scope: self.currentScope,
      kind: FunctionKind.Standalone,
      returnType: returnType,
      isLambda: true,
    )

    self.currentFunction = Some(fn)
    val paramsNeedingRevisit = try self.typecheckFunctionPass2(fn: fn, allowSelf: false, params: node.params, paramHints: paramHints)
    try self.typecheckFunctionPass3(fn: fn, allowSelf: false, params: node.params, body: node.body, paramsNeedingRevisit: paramsNeedingRevisit)
    self.currentFunction = prevFn

    if fn.isClosure() {
      if self.currentFunction |currentFn| {
        for capturedVar in fn.captures {
          if !currentFn.captures.find(v => v.label.name == capturedVar.label.name) {
            if !currentFn.scope.contains(capturedVar.scope) {
              currentFn.captures.push(capturedVar)
            }
          }
        }
        for capturedClosure in fn.capturedClosures {
          if !currentFn.capturedClosures.find(fn => fn.label.name == capturedClosure.label.name) {
            currentFn.capturedClosures.push(capturedClosure)
          }
        }
      }
    }

    val lambdaTy = fn.getType()
    self.currentScope = prevScope

    Ok(TypedAstNode(token: token, ty: lambdaTy, kind: TypedAstNodeKind.Lambda(fn, typeHint)))
  }

  func typecheckTry(self, token: Token, expr: AstNode, elseClause: (Token, BindingPattern?, AstNode[])?, typeHint: Type?): Result<TypedAstNode, TypeError> {
    // TODO: support top-level try (the error case would just exit the program)
    val currentFn = try self.currentFunction else return Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTryLocation(InvalidTryLocationReason.NotWithinFunction)))

    val (typedExpr, returnTypeResultErr) = if self._typeIsResult(currentFn.returnType) |(_, retErrType)| {
      val hint = if typeHint |typeHint| { Some(Type(kind: TypeKind.Instance(InstanceKind.Enum(self.project.preludeResultEnum), [typeHint, retErrType]))) } else None
      val typedExpr = try self._typecheckExpression(expr, hint)

      (typedExpr, Some(retErrType))
    } else if self._typeIsOption(currentFn.returnType) |inner| {
      val hint = if typeHint |typeHint| { Some(Type(kind: TypeKind.Instance(InstanceKind.Enum(self.project.preludeOptionEnum), [typeHint]))) } else None
      val typedExpr = try self._typecheckExpression(expr, hint)

      (typedExpr, None)
    } else if elseClause {
      val typedExpr = try self._typecheckExpression(expr, None)
      (typedExpr, None)
    } else if currentFn.returnType.kind == TypeKind.CouldNotDetermine {
      return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder))
    } else {
      val typedExpr = try self._typecheckExpression(expr, None)

      if typedExpr.ty.kind == TypeKind.CouldNotDetermine return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder))

      val kind = if self._typeIsResult(typedExpr.ty) InvalidFunctionReturnTypeKind.IsResult else InvalidFunctionReturnTypeKind.IsOption
      return Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTryLocation(InvalidTryLocationReason.InvalidFunctionReturnType(fnLabel: currentFn.label, tryType: typedExpr.ty, returnType: currentFn.returnType, kind: kind))))
    }

    if typedExpr.ty.kind == TypeKind.CouldNotDetermine return Ok(TypedAstNode(token: token, ty: Type(kind: TypeKind.CouldNotDetermine), kind: TypedAstNodeKind.Placeholder))

    val (tryValType, typedElseClause) = if elseClause |(elseToken, bindingPattern, elseBlock)| {
      val isStatement = if typeHint |hint| hint.kind == TypeKind.PrimitiveUnit else false

      val (tryValType, tryErrType) = if self._typeIsResult(typedExpr.ty) |t| {
        t
      } else if self._typeIsOption(typedExpr.ty) |inner| {
        (inner, typedExpr.ty)
      } else {
        return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.InvalidTryTarget(typedExpr.ty)))
      }

      val prevScope = self.beginChildScope("try_else", ScopeKind.Try)

      val elseBindingPattern = if bindingPattern |pat| {
        // TODO: Emit warning if expression is an Option type, since the binding would always equal `None`
        val variables = self.typecheckBindingPattern(false, pat, tryErrType)
        Some((pat, variables))
      } else {
        None
      }

      val typedNodes: TypedAstNode[] = []
      for node, idx in elseBlock {
        if self.currentScope.terminator return Err(TypeError(position: node.token.position, kind: TypeErrorKind.UnreachableCode))

        val typedNode = if idx == elseBlock.length - 1 && !isStatement {
          try self._typecheckExpressionOrTerminator(node, typeHint)
        } else {
          self.typecheckStatement(node, None)
        }
        typedNodes.push(typedNode)
      }
      val terminator = self.currentScope.terminator

      if typedNodes[-1] |lastElseNode| {
        val elseType = lastElseNode.ty

        if tryValType.hasUnfilledHoles() {
          tryValType.tryFillHoles(elseType)
        }
        if elseType.hasUnfilledHoles() {
          elseType.tryFillHoles(tryValType)
        }

        if !self._typeSatisfiesRequired(ty: elseType, required: tryValType) {
          return Err(TypeError(position: lastElseNode.token.position, kind: TypeErrorKind.TypeMismatch([tryValType], elseType)))
        }
      } else {
        return Err(TypeError(position: elseToken.position, kind: TypeErrorKind.MissingRequiredBlock(exprKind: "try-else", clause: "else", missing: false)))
      }

      self.currentScope = prevScope

      val elseClause = TypedTryElseClause(pattern: elseBindingPattern, errorType: tryErrType, block: typedNodes, terminator: terminator)
      (tryValType, Some(elseClause))
    } else {
      val tryValType = if self._typeIsResult(typedExpr.ty) |(exprOkType, exprErrType)| {
        if returnTypeResultErr |retErrType| {
          if !self._typeSatisfiesRequired(ty: retErrType, required: exprErrType) {
            return Err(TypeError(position: token.position, kind: TypeErrorKind.TryReturnTypeMismatch(fnLabel: currentFn.label, tryType: typedExpr.ty, tryErrType: exprErrType, retErrType: retErrType)))
          } else {
            exprOkType
          }
        } else {
          return Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTryLocation(InvalidTryLocationReason.InvalidFunctionReturnType(fnLabel: currentFn.label, tryType: typedExpr.ty, returnType: currentFn.returnType, kind: InvalidFunctionReturnTypeKind.IsResult))))
        }
      } else if self._typeIsOption(typedExpr.ty) |inner| {
        if returnTypeResultErr {
          return Err(TypeError(position: token.position, kind: TypeErrorKind.InvalidTryLocation(InvalidTryLocationReason.InvalidFunctionReturnType(fnLabel: currentFn.label, tryType: typedExpr.ty, returnType: currentFn.returnType, kind: InvalidFunctionReturnTypeKind.IsOption))))
        } else {
          inner
        }
      } else {
        return Err(TypeError(position: typedExpr.token.position, kind: TypeErrorKind.InvalidTryTarget(typedExpr.ty)))
      }

      (tryValType, None)
    }

    Ok(TypedAstNode(token: token, ty: tryValType, kind: TypedAstNodeKind.Try(typedExpr, typedElseClause)))
  }
}
