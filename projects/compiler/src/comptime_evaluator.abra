import Pointer, Byte from "_intrinsics"
import Lexer, LexerError, Token, TokenKind, Position from "./lexer"
import Parser, ParseError, ParsedModule, AstNode, LiteralAstNode, ImportNode, ImportKind, Label, IndexingMode from "./parser"
import Project, Function, Struct, Type, TypedAstNode, TypedAstNodeKind, InstanceKind, TypedInvokee, AccessorPathSegment, TypedIndexingNode, FunctionKind from "./typechecker"
import Generator from "./ir"
import VM, VmValue, Instance, VmFunction, unmarshallString from "./ir_vm"
import InjectedCode from "meta"

pub type ComptimeFunctionEvaluator {
  project: Project
  gen: Generator

  pub func init(project: Project): ComptimeFunctionEvaluator {
    val gen = Generator.init(project, foldConstants: true)
    ComptimeFunctionEvaluator(project: project, gen: gen)
  }

  pub func eval(self, fn: Function, arguments: TypedAstNode?[], resolvedGenerics: Map<String, Type>): Result<InjectedCode, String> {
    self.gen.generate()

    val irFn = self.gen.genTcFunction(fn, resolvedGenerics)
    // process function queue to generate IR for any functions discovered above
    for f in self.gen.fnQueue { self.gen.genFunction(f) }

    val ir = self.gen.getIR()
    val vm = VM(ir: ir)

    val marshalledArgs: VmValue[] = []
    for argument, idx in arguments {
      val arg = try argument else todo("macros: optional arguments")
      val param = try fn.params[idx] else unreachable("")
      val marshalledArg = if param.isVariadic {
        val items = match arg.kind { TypedAstNodeKind.Array(items) => items, else => unreachable("variadic arguments are pre-wrapped in Array") }
        marshallArrayNodeToArray(items)
      } else {
        marshallTypedAstNodeToExpr(arg)
      }
      marshalledArgs.push(marshalledArg)
    }
    val res = vm.evalFunctionCall(irFn, marshalledArgs)

    unmarshallInjectedCode(res)
  }
}

func stringifyTypedNode(node: TypedAstNode): String {
  match node.kind {
    TypedAstNodeKind.Literal(lit) => match lit {
      LiteralAstNode.Int(i) => "$i"
      LiteralAstNode.Float(f) => "$f"
      LiteralAstNode.Bool(b) => "$b"
      LiteralAstNode.String(s) => "\"$s\""
      else => todo("stringify: other literal kinds")
    }
    TypedAstNodeKind.StringInterpolation(chunks) => {
      val chunkStrs = ["\""]
      for chunk in chunks {
        match chunk.kind {
          TypedAstNodeKind.Literal(lit) => match lit {
            LiteralAstNode.String(s) => {
              chunkStrs.push(s)
              continue
            }
          }
        }
        chunkStrs.push("\${")
        chunkStrs.push(stringifyTypedNode(chunk))
        chunkStrs.push("}")
      }
      chunkStrs.push("\"")
      chunkStrs.join()
    }
    TypedAstNodeKind.Unary(op, expr) => {
      "${op.repr()}${stringifyTypedNode(expr)}"
    }
    TypedAstNodeKind.Binary(left, op, right) => {
      val chunks: String[] = []

      chunks.push(stringifyTypedNode(left))
      chunks.push(" ${op.repr()} ")
      chunks.push(stringifyTypedNode(right))

      chunks.join()
    }
    TypedAstNodeKind.Grouped(inner) => {
      val str = stringifyTypedNode(inner)
      "($str)"
    }
    TypedAstNodeKind.Identifier(name, _, _, _) => name
    TypedAstNodeKind.Accessor(head, middle, tail) => {
      val chunks: String[] = []

      chunks.push(stringifyTypedNode(head))
      for seg in middle {
        match seg {
          AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => todo("stringifyTypedNode: Accessor: EnumVariant")
          AccessorPathSegment.Method(label, fn, optSafe, typeHint) => todo("stringifyTypedNode: Accessor: Method")
          AccessorPathSegment.Field(label, _, _, optSafe) => {
            val dot = if optSafe "?." else "."
            chunks.push(dot)
            chunks.push(label.name)
          }
        }
      }

      match tail {
        AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => todo("stringifyTypedNode: Accessor: EnumVariant")
        AccessorPathSegment.Method(label, fn, optSafe, typeHint) => todo("stringifyTypedNode: Accessor: Method")
        AccessorPathSegment.Field(label, _, _, optSafe) => {
          val dot = if optSafe "?." else "."
          chunks.push(dot)
          chunks.push(label.name)
        }
      }

      chunks.join()
    }
    TypedAstNodeKind.Invocation(invokee, arguments, _) => {
      val chunks: String[] = []
      match invokee {
        TypedInvokee.Method(fn, selfVal, isOptSafe) => {
          chunks.push(stringifyTypedNode(selfVal))
          val dot = if isOptSafe "?." else "."
          chunks.push(dot)
          chunks.push(fn.label.name)
        }
        TypedInvokee.Function(fn) => {
          match fn.kind {
            FunctionKind.StaticMethod(instanceKind, _) => {
              // todo: this doesn't cover every case (eg. mod.Type.fn())
              match instanceKind {
                InstanceKind.Struct(struct) => chunks.push(struct.label.name)
                InstanceKind.Enum(enum_) => chunks.push(enum_.label.name)
              }
              chunks.push(".")
            }
          }
          chunks.push(fn.label.name)
        }
        TypedInvokee.Struct(struct) => todo("stringifyTypedNode: Invocation:Struct")
        TypedInvokee.Expr(expr) => todo("stringifyTypedNode: Invocation:Expr")
        TypedInvokee.EnumVariant(enum_, variant) => todo("stringifyTypedNode: Invocation:EnumVariant")
      }

      chunks.push("(")
      for _arg, idx in arguments {
        val arg = try _arg else continue
        val stringifiedArg = stringifyTypedNode(arg)
        chunks.push(stringifiedArg)
        if idx != arguments.length - 1 {
          chunks.push(", ")
        }
      }
      chunks.push(")")

      chunks.join()
    }
    TypedAstNodeKind.Array(items) => {
      val chunks = ["["]

      for item, idx in items {
        chunks.push(stringifyTypedNode(item))
        if idx != items.length - 1 {
          chunks.push(", ")
        }
      }

      chunks.push("]")
      chunks.join()
    }
    TypedAstNodeKind.Set(items) => {
      val chunks = ["#{"]

      for item, idx in items {
        chunks.push(stringifyTypedNode(item))
        if idx != items.length - 1 {
          chunks.push(", ")
        }
      }

      chunks.push("}")
      chunks.join()
    }
    TypedAstNodeKind.Map => todo("stringifyTypedNode: Map")
    TypedAstNodeKind.Tuple => todo("stringifyTypedNode: Tuple")
    TypedAstNodeKind.Indexing(node) => {
      match node {
        TypedIndexingNode.ArrayLike(expr, indexingMode) => {
          val exprStr = stringifyTypedNode(expr)
          val idxStr = match indexingMode {
            IndexingMode.Single(expr) => stringifyTypedNode(expr)
            IndexingMode.Range(start, end) => {
              val startStr = if start |s| stringifyTypedNode(s) else ""
              val endStr = if end |e| stringifyTypedNode(e) else ""
              "$startStr:$endStr"
            }
          }

          "$exprStr[$idxStr]"
        }
        TypedIndexingNode.Map(expr, idx) => todo("stringifyTypedNode: Indexing: Map")
        TypedIndexingNode.Tuple(tupleExpr, idx) => todo("stringifyTypedNode: Indexing: Tuple")
      }
    }
    TypedAstNodeKind.Lambda(fn, _) => {
      val chunks = ["("]
      for param, idx in fn.params {
        chunks.push(param.label.name)
        if param.defaultValue |v| {
          chunks.push(" = ")
          chunks.push(stringifyTypedNode(v))
        }

        if idx != fn.params.length - 1 {
          chunks.push(", ")
        }
      }
      chunks.push(") => ")

      val bodyIsSingleExpr = fn.body.length != 1
      if bodyIsSingleExpr chunks.push("{")
      for node, idx in fn.body {
        if bodyIsSingleExpr chunks.push("  ")
        chunks.push(stringifyTypedNode(node))
        if bodyIsSingleExpr chunks.push("\n")
      }
      if bodyIsSingleExpr chunks.push("}")

      chunks.join()
    }
    TypedAstNodeKind.Assignment => todo("stringifyTypedNode: Assignment")
    TypedAstNodeKind.If => todo("stringifyTypedNode: If")
    TypedAstNodeKind.Match => todo("stringifyTypedNode: Match")
    TypedAstNodeKind.Try => todo("stringifyTypedNode: Try")
    TypedAstNodeKind.While => todo("stringifyTypedNode: While")
    TypedAstNodeKind.For => todo("stringifyTypedNode: For")
    TypedAstNodeKind.BindingDeclaration => todo("stringifyTypedNode: BindingDeclaration")
    TypedAstNodeKind.FunctionDeclaration => todo("stringifyTypedNode: FunctionDeclaration")
    TypedAstNodeKind.TypeDeclaration => todo("stringifyTypedNode: TypeDeclaration")
    TypedAstNodeKind.EnumDeclaration => todo("stringifyTypedNode: EnumDeclaration")
    TypedAstNodeKind.Break => todo("stringifyTypedNode: Break")
    TypedAstNodeKind.Continue => todo("stringifyTypedNode: Continue")
    TypedAstNodeKind.Return => todo("stringifyTypedNode: Return")
    TypedAstNodeKind.Placeholder => unreachable("stringifyTypedNode: Placeholder")
  }
}

func marshallTypedAstNodeToExpr(node: TypedAstNode): VmValue {
  VmValue.Instance(Instance(
    name: "Expr",
    fields: [
      /* stringifyFn */ VmValue.Function(VmFunction.HostSupplied(() => VmValue.ConstString(stringifyTypedNode(node))))
    ]
  ))
}

func marshallArrayNodeToArray(items: TypedAstNode[]): VmValue {
  val bufPtr = Pointer.malloc<VmValue>(items.length)
  for item, idx in items {
    val marshalledExpr = marshallTypedAstNodeToExpr(item)
    bufPtr.storeAt(marshalledExpr, idx)
  }

  VmValue.Instance(Instance(
    name: "Array",
    fields: [
      /* length */ VmValue.Int(items.length),
      /* _buffer */ VmValue.Pointer(Pointer.reinterpret(bufPtr)),
      /* _capacity */ VmValue.Int(items.length)
    ]
  ))
}

func unmarshallInjectedCode(value: VmValue): Result<InjectedCode, String> {
  val instance = value.expectInstance("value should be an instance")
  if !instance.name.endsWith("InjectedCode") return Err("cannot unmarshall instance of type '${instance.name}' as InjectedCode")

  val chunksValue = instance.expectField(0).expectInstance("InjectedCode chunks is String[]")
  val chunksLength = chunksValue.expectField(0).expectInt("Array field 0 is length")
  val chunksItems = chunksValue.expectField(1).expectPointer("Array field 1 is buffer")
  val chunks: String[] = []
  for i in 0:chunksLength {
    val chunkValue = Pointer.reinterpret<Byte, VmValue>(chunksItems).loadAt(i)
    val chunk = try unmarshallString(chunkValue)
    chunks.push(chunk)
  }

  val imports: Map<String, String> = {}
  val importsValue = instance.expectField(1).expectInstance("InjectedCode imports is Map<String, String>")
  val importsSize = importsValue.expectField(0).expectInt("Map field 0 is size")
  if importsSize != 0 {
    val importsEntries = importsValue.expectField(1).expectInstance("Map field 1 is _entries (MapEntry<String, String>[])")
    val importsEntriesLength = importsEntries.expectField(0).expectInt("Array field 0 is length")
    val importsEntriesItems = importsEntries.expectField(1).expectPointer("Array field 1 is buffer")
    for i in 0:importsEntriesLength {
      var next = Pointer.reinterpret<Byte, VmValue>(importsEntriesItems).loadAt(i)

      while next != VmValue.OptionNone {
        val entry = next.expectInstance("MapEntry is instance")
        val entryIsEmpty = entry.expectField(3).expectBool("MapEntry field 3 is _empty")
        if entryIsEmpty break

        val entryKey = try unmarshallString(entry.expectField(0))
        val entryValue = try unmarshallString(entry.expectField(1))
        imports[entryKey] = entryValue

        next = entry.expectField(2)
      }
    }
  }

  Ok(InjectedCode(chunks: chunks, imports: imports))
}
