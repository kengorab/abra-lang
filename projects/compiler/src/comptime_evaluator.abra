import Pointer, Byte from "_intrinsics"
import Lexer, LexerError, Token, TokenKind, Position from "./lexer"
import Parser, ParseError, ParsedModule, AstNode, LiteralAstNode, ImportNode, ImportKind, Label from "./parser"
import Project, Function, Struct, Type, TypedAstNode, TypedAstNodeKind, InstanceKind, TypedInvokee from "./typechecker"
import Generator from "./ir"
import VM, VmValue, Instance, VmFunction, unmarshallString from "./ir_vm"
import InjectedCode from "meta"

pub type ComptimeFunctionEvaluator {
  project: Project
  gen: Generator

  pub func init(project: Project): ComptimeFunctionEvaluator {
    val gen = Generator.init(project, foldConstants: true)
    ComptimeFunctionEvaluator(project: project, gen: gen)
  }

  pub func eval(self, fn: Function, arguments: TypedAstNode?[], resolvedGenerics: Map<String, Type>): Result<InjectedCode, String> {
    self.gen.generate()

    val irFn = self.gen.genTcFunction(fn, resolvedGenerics)
    // process function queue to generate IR for any functions discovered above
    for f in self.gen.fnQueue { self.gen.genFunction(f) }

    val ir = self.gen.getIR()
    val vm = VM(ir: ir)

    val marshalledArgs: VmValue[] = []
    for argument, idx in arguments {
      val arg = try argument else todo("macros: optional arguments")
      val param = try fn.params[idx] else unreachable("")
      val marshalledArg = if param.isVariadic {
        val items = match arg.kind { TypedAstNodeKind.Array(items) => items, else => unreachable("variadic arguments are pre-wrapped in Array") }
        marshallArrayNodeToArray(items)
      } else {
        marshallTypedAstNodeToExpr(arg)
      }
      marshalledArgs.push(marshalledArg)
    }
    val res = vm.evalFunctionCall(irFn, marshalledArgs)

    unmarshallInjectedCode(res)
  }
}

func stringifyTypedNode(node: TypedAstNode): String {
  match node.kind {
    TypedAstNodeKind.Literal(lit) => match lit {
      LiteralAstNode.Int(i) => "$i"
      LiteralAstNode.Float(f) => "$f"
      LiteralAstNode.Bool(b) => "$b"
      LiteralAstNode.String(s) => "\"$s\""
      else => todo("stringify: other literal kinds")
    }
    TypedAstNodeKind.StringInterpolation(chunks) => {
      val chunkStrs = ["\""]
      for chunk in chunks {
        match chunk.kind {
          TypedAstNodeKind.Literal(lit) => match lit {
            LiteralAstNode.String(s) => {
              chunkStrs.push(s)
              continue
            }
          }
        }
        chunkStrs.push("\${")
        chunkStrs.push(stringifyTypedNode(chunk))
        chunkStrs.push("}")
      }
      chunkStrs.push("\"")
      chunkStrs.join()
    }
    TypedAstNodeKind.Unary => todo("stringifyTypedNode: Unary")
    TypedAstNodeKind.Binary => todo("stringifyTypedNode: Binary")
    TypedAstNodeKind.Grouped => todo("stringifyTypedNode: Grouped")
    TypedAstNodeKind.Identifier(name, _, _, _) => name
    TypedAstNodeKind.Accessor => todo("stringifyTypedNode: Accessor")
    TypedAstNodeKind.Invocation(invokee, arguments, _) => {
      val chunks: String[] = []
      match invokee {
        TypedInvokee.Method(fn, selfVal, isOptSafe) => todo("stringifyTypedNode: Invocation:Method")
        TypedInvokee.Function(fn) => {
          chunks.push(fn.label.name)
        }
        TypedInvokee.Struct(struct) => todo("stringifyTypedNode: Invocation:Struct")
        TypedInvokee.Expr(expr) => todo("stringifyTypedNode: Invocation:Expr")
        TypedInvokee.EnumVariant(enum_, variant) => todo("stringifyTypedNode: Invocation:EnumVariant")
      }

      chunks.push("(")
      for _arg in arguments {
        val arg = try _arg else continue
        val stringifiedArg = stringifyTypedNode(arg)
        chunks.push(stringifiedArg)
        chunks.push(", ")
      }
      chunks.push(")")

      chunks.join()
    }
    TypedAstNodeKind.Array => todo("stringifyTypedNode: Array")
    TypedAstNodeKind.Set => todo("stringifyTypedNode: Set")
    TypedAstNodeKind.Map => todo("stringifyTypedNode: Map")
    TypedAstNodeKind.Tuple => todo("stringifyTypedNode: Tuple")
    TypedAstNodeKind.Indexing => todo("stringifyTypedNode: Indexing")
    TypedAstNodeKind.Lambda => todo("stringifyTypedNode: Lambda")
    TypedAstNodeKind.Assignment => todo("stringifyTypedNode: Assignment")
    TypedAstNodeKind.If => todo("stringifyTypedNode: If")
    TypedAstNodeKind.Match => todo("stringifyTypedNode: Match")
    TypedAstNodeKind.Try => todo("stringifyTypedNode: Try")
    TypedAstNodeKind.While => todo("stringifyTypedNode: While")
    TypedAstNodeKind.For => todo("stringifyTypedNode: For")
    TypedAstNodeKind.BindingDeclaration => todo("stringifyTypedNode: BindingDeclaration")
    TypedAstNodeKind.FunctionDeclaration => todo("stringifyTypedNode: FunctionDeclaration")
    TypedAstNodeKind.TypeDeclaration => todo("stringifyTypedNode: TypeDeclaration")
    TypedAstNodeKind.EnumDeclaration => todo("stringifyTypedNode: EnumDeclaration")
    TypedAstNodeKind.Break => todo("stringifyTypedNode: Break")
    TypedAstNodeKind.Continue => todo("stringifyTypedNode: Continue")
    TypedAstNodeKind.Return => todo("stringifyTypedNode: Return")
    TypedAstNodeKind.Placeholder => unreachable("stringifyTypedNode: Placeholder")
  }
}

func marshallTypedAstNodeToExpr(node: TypedAstNode): VmValue {
  VmValue.Instance(Instance(
    name: "Expr",
    fields: [
      /* stringifyFn */ VmValue.Function(VmFunction.HostSupplied(() => VmValue.ConstString(stringifyTypedNode(node))))
    ]
  ))
}

func marshallArrayNodeToArray(items: TypedAstNode[]): VmValue {
  val bufPtr = Pointer.malloc<VmValue>(items.length)
  for item, idx in items {
    val marshalledExpr = marshallTypedAstNodeToExpr(item)
    bufPtr.storeAt(marshalledExpr, idx)
  }

  VmValue.Instance(Instance(
    name: "Array",
    fields: [
      /* length */ VmValue.Int(items.length),
      /* _buffer */ VmValue.Pointer(Pointer.reinterpret(bufPtr)),
      /* _capacity */ VmValue.Int(items.length)
    ]
  ))
}

func unmarshallInjectedCode(value: VmValue): Result<InjectedCode, String> {
  val instance = value.expectInstance("value should be an instance")
  if !instance.name.endsWith("InjectedCode") return Err("cannot unmarshall instance of type '${instance.name}' as InjectedCode")

  val chunksValue = instance.expectField(0).expectInstance("InjectedCode chunks is String[]")
  val chunksLength = chunksValue.expectField(0).expectInt("Array field 0 is length")
  val chunksItems = chunksValue.expectField(1).expectPointer("Array field 1 is buffer")
  val chunks: String[] = []
  for i in 0:chunksLength {
    val chunkValue = Pointer.reinterpret<Byte, VmValue>(chunksItems).loadAt(i)
    val chunk = try unmarshallString(chunkValue)
    chunks.push(chunk)
  }

  val imports: Map<String, String> = {}
  val importsValue = instance.expectField(1).expectInstance("InjectedCode imports is Map<String, String>")
  val importsSize = importsValue.expectField(0).expectInt("Map field 0 is size")
  if importsSize != 0 {
    val importsEntries = importsValue.expectField(1).expectInstance("Map field 1 is _entries (MapEntry<String, String>[])")
    val importsEntriesLength = importsEntries.expectField(0).expectInt("Array field 0 is length")
    val importsEntriesItems = importsEntries.expectField(1).expectPointer("Array field 1 is buffer")
    for i in 0:importsEntriesLength {
      var next = Pointer.reinterpret<Byte, VmValue>(importsEntriesItems).loadAt(i)

      while next != VmValue.OptionNone {
        val entry = next.expectInstance("MapEntry is instance")
        val entryIsEmpty = entry.expectField(3).expectBool("MapEntry field 3 is _empty")
        if entryIsEmpty break

        val entryKey = try unmarshallString(entry.expectField(0))
        val entryValue = try unmarshallString(entry.expectField(1))
        imports[entryKey] = entryValue

        next = entry.expectField(2)
      }
    }
  }

  Ok(InjectedCode(chunks: chunks, imports: imports))
}
