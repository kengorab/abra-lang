import Position from "./lexer"
import LiteralAstNode, AssignOp, BinaryOp, BindingPattern from "./parser"
// match arms don't support import-based namespacing for enums yet, so enums used in matches are imported by name
import TypedAstNodeKind, TypedInvokee, FunctionKind, TypeKind, ScopeKind, InstanceKind, VariableAlias, AccessorPathSegment, TypedAssignmentMode from "./typechecker"
import "./typechecker" as tc

// TODO: move to stdlib
pub type StringBuilder {
  chunks: String[] = []

  pub func write(self, str: String): StringBuilder {
    if !str.isEmpty() self.chunks.push(str)
    self
  }

  pub func writeln(self, str: String = ""): StringBuilder = self.write(str).write("\n")

  pub func build(self): String = self.chunks.join("")
}

pub type Knowns {
  strTy: CompositeType? = None
  strInit: IrFunction? = None

  pub func stringType(self): CompositeType = try self.strTy else unreachable("String type expected to be initialized")
  pub func stringInitializerFn(self): IrFunction = try self.strInit else unreachable("String initializer fn expected to be initialized")
}

pub type IR {
  pub mainFunction: IrFunction
  pub functions: IrFunction[]
  pub types: CompositeType[]
  pub globals: GlobalVariable[]
  pub knowns: Knowns = Knowns()

  pub func render(self, sb: StringBuilder) {
    for t in self.types {
      t.render(sb)
      sb.writeln()
    }

    for g in self.globals {
      g.render(sb)
      sb.writeln()
    }

    sb.writeln()
    self.mainFunction.render(sb)

    for f in self.functions {
      sb.writeln()
      f.render(sb)
    }
  }
}

pub type IrFunction {
  pub extern: String? = None
  pub name: String
  pub params: Ident[]
  pub ret: IrType
  pub block: (String, Instruction[]) = ("start", [])

  pub func render(self, sb: StringBuilder) {
    if self.extern |name| sb.writeln("@extern($name)")

    sb.write("function ")
    sb.write(self.name)

    sb.write("(")
    for p, idx in self.params {
      p.render(sb)
      if idx != self.params.length - 1 {
        sb.write(", ")
      }
    }
    sb.write(") ")

    self.ret.render(sb)
    sb.writeln()

    val (label, block) = self.block
    sb.writeln("$label:")
    for inst in block {
      sb.write("  ")
      inst.render(sb)
      sb.writeln()
    }
  }
}

pub type Instruction {
  pub assignee: Ident? = None
  pub op: Operation

  pub func render(self, sb: StringBuilder) {
    if self.assignee |a| {
      a.render(sb)
      sb.write(" = ")
    }

    self.op.render(sb)
  }
}

pub enum IdentKind {
  Anon(idx: Int)
  Named(name: String)
}

pub type Ident {
  pub ty: IrType
  pub kind: IdentKind

  pub func render(self, sb: StringBuilder) {
    self.ty.render(sb)
    sb.write(" %")
    match self.kind {
      IdentKind.Anon(idx) => sb.write("_" + idx)
      IdentKind.Named(name) => sb.write(name)
    }
  }
}

pub enum Value {
  Unit
  ConstInt(value: Int)
  // ConstFloat(value: Float)
  ConstBool(value: Bool)
  ConstChar(value: Int) // 64-bit repr of char
  ConstString(value: String)
  Ident(ident: Ident)
  Global(global: GlobalVariable)

  pub func render(self, sb: StringBuilder) {
    match self {
      Value.Unit => {}
      Value.ConstInt(v) => {
        IrType.I64.render(sb)
        sb.write(" ").write(v.toString())
      }
      Value.ConstBool(b) => {
        IrType.Bool.render(sb)
        sb.write(" $b")
      }
      Value.ConstChar(intVal) => {
        IrType.I64.render(sb)
        sb.write(" ${Char.fromInt(intVal)}")
      }
      Value.ConstString(s) => {
        sb.write("\"")
          .write(s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"").replaceAll("\n", "\\n").replaceAll("\r", "\\r"))
          .write("\"")
      }
      Value.Ident(i) => i.render(sb)
      Value.Global(g) => {
        g.ty.render(sb)
        sb.write(" $").write(g.name)
      }
    }
  }
}

pub enum Builtin {
  Malloc(count: Value, itemTy: IrType? = None)
  Realloc(ptr: Value, count: Value, itemTy: IrType? = None)
  Store(ptr: Value, value: Value, offset: Value, itemTy: IrType)
  Load(ptr: Value, offset: Value, itemTy: IrType)
  CopyFrom(dst: Value, dstOffset: Value, src: Value, srcOffset: Value, size: Value, itemTy: IrType)
  I64ToString(intVal: Value)
}

pub type Block {
  pub name: String
  pub body: Instruction[]
  pub result: Value?
  pub terminates: Bool
}

pub type CompoundValue {
  pub body: Instruction[]
  pub result: Value
}

pub enum Operation {
  NewLocal(ty: IrType, initialValue: Value? = None)
  ConstInt(int: Int)

  Add(left: Value, right: Value)
  Sub(left: Value, right: Value)
  Mul(left: Value, right: Value)
  Eq(primitive: Bool, negate: Bool, left: Value, right: Value)
  Lt(left: Value, right: Value)

  Load(ty: IrType, mem: Value)
  LoadField(ty: IrType, mem: Value, name: String, offset: Int)
  Store(ty: IrType, value: Value, mem: Value)
  StoreField(ty: IrType, value: Value, mem: Value, name: String, offset: Int)

  If(ty: IrType, cond: Value, thenBlock: Block, elseBlock: Block)
  While(ty: IrType, cond: CompoundValue, body: Block)

  Call(ret: IrType, fnName: String, args: Value[])

  Return(value: Value? = None)

  Builtin(ret: IrType, builtin: Builtin)

  pub func render(self, sb: StringBuilder) {
    match self {
      Operation.NewLocal(ty, initialValue) => {
        sb.write("local(")
        ty.render(sb)
        if initialValue |v| {
          sb.write(", ")
          v.render(sb)
        }
        sb.write(")")
      }
      Operation.ConstInt(int) => {
        IrType.I64.render(sb)
        sb.write(" $int")
      }
      Operation.Add(l, r) => {
        sb.write("add(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Mul(l, r) => {
        sb.write("mul(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Eq(_, negate, left, right) => {
        if negate sb.write("neq(") else sb.write("eq(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Lt(left, right) => {
        sb.write("lt(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Load(ty, mem) => {
        sb.write("load(")
        ty.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(")")
      }
      Operation.LoadField(ty, mem, name, offset) => {
        sb.write("load(")
        ty.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(", $name ($offset))")
      }
      Operation.Store(ty, value, mem) => {
        sb.write("store(")
        ty.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(")")
      }
      Operation.StoreField(ty, value, mem, name, offset) => {
        sb.write("store(")
        ty.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(", $name ($offset))")
      }
      Operation.If(ty, cond, thenBlock, elseBlock) => {
        sb.write("if(")
        cond.render(sb)
        sb.write(", .${thenBlock.name}")
        if thenBlock.result |v| {
          sb.write(" (")
          v.render(sb)
          sb.write(")")
        }
        if !elseBlock.body.isEmpty() {
          sb.write(", .${elseBlock.name}")
          if elseBlock.result |v| {
            sb.write(" (")
            v.render(sb)
            sb.write(")")
          }
        }
        sb.writeln(")")

        sb.writeln(".${thenBlock.name}:")
        for instr in thenBlock.body {
          sb.write("  ")
          instr.render(sb)
          sb.writeln()
        }
        if !elseBlock.body.isEmpty() {
          sb.writeln(".${elseBlock.name}:")
          for instr in elseBlock.body {
            sb.write("  ")
            instr.render(sb)
            sb.writeln()
          }
        }
        sb.write("# endif")
      }
      Operation.While(ty, cond, body) => {
        for instr in cond.body {
          instr.render(sb)
          sb.writeln()
        }
        sb.write("while(")
        cond.result.render(sb)
        sb.writeln(", .${body.name})")

        sb.writeln(".${body.name}:")
        for instr in body.body {
          sb.write("  ")
          instr.render(sb)
          sb.writeln()
        }
        sb.write("# endwhile")
      }
      Operation.Call(ret, fnName, args) => {
        sb.write("call(")
        ret.render(sb)
        sb.write(", ").write(fnName)
        for arg, idx in args {
          sb.write(", ")
          arg.render(sb)
        }
        sb.write(")")
      }
      Operation.Return(v) => {
        sb.write("return(")
        if v |v| v.render(sb)
        sb.write(")")
      }
      Operation.Builtin(ret, builtin) => {
        sb.write("builtin(")
        ret.render(sb)
        sb.write(", ")
        match builtin {
          Builtin.Malloc(size, itemTy) => {
            sb.write("malloc, ")
            size.render(sb)
            if itemTy |ty| {
              sb.write(", ")
              ty.render(sb)
            }
          }
          Builtin.Realloc(ptr, count, itemTy) => {
            sb.write("realloc, ")
            ptr.render(sb)
            sb.write(", ")
            count.render(sb)
            if itemTy |ty| {
              sb.write(", ")
              ty.render(sb)
            }
          }
          Builtin.Store(ptr, value, offset, itemTy) => {
            sb.write("ptr_store, ")
            ptr.render(sb)
            sb.write(", ")
            value.render(sb)
            sb.write(", ")
            offset.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.Load(ptr, offset, itemTy) => {
            sb.write("ptr_load, ")
            ptr.render(sb)
            sb.write(", ")
            offset.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.CopyFrom(dst, dstOffset, src, srcOffset, size, itemTy) => {
            sb.write("copy_from, ")
            dst.render(sb)
            sb.write(", ")
            dstOffset.render(sb)
            sb.write(", ")
            src.render(sb)
            sb.write(", ")
            srcOffset.render(sb)
            sb.write(", ")
            size.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.I64ToString(int) => {
            sb.write("i64_to_string, ")
            int.render(sb)
          }
        }
        sb.write(")")
      }
    }
  }
}

pub enum IrType {
  Unit
  I64
  Bool
  Byte
  Composite(name: String)
  Ptr

  pub func render(self, sb: StringBuilder) {
    match self {
      IrType.Unit => sb.write("unit")
      IrType.I64 => sb.write("i64")
      IrType.Bool => sb.write("bool")
      IrType.Byte => sb.write("byte")
      IrType.Composite(name) => sb.write(name)
      IrType.Ptr => sb.write("ptr")
    }
  }
}

pub type CompositeType {
  pub name: String
  pub fields: (String, IrType)[]

  pub func render(self, sb: StringBuilder) {
    sb.write("type ")
      .write(self.name)
      .write(" = struct {")
    if !self.fields.isEmpty() sb.writeln()

    for (name, ty) in self.fields {
      sb.write("\n")
        .write("  ")
        .write(name)
        .write(": ")
      ty.render(sb)
    }
    sb.writeln("}")
  }
}

pub type GlobalVariable {
  pub name: String
  pub ty: IrType
  pub mutable: Bool
  pub initialValue: Value? = None
  pub referenced: Bool = false

  pub func render(self, sb: StringBuilder) {
    sb.write("global ")

    if self.mutable {
      sb.write("mutable ")
    } else {
      sb.write("const ")
    }

    self.ty.render(sb)
    sb.write(" ${self.name}")

    if self.initialValue |v| {
      sb.write(" = ")
      v.render(sb)
    }

    if !self.referenced {
      sb.write(" # not referenced")
    }
  }
}

type Context {
  fn: IrFunction
  block: (String, Instruction[])
  locals: Ident[]
  anonLocalIdx: Int = 0
}

enum CallableToCompile {
  Function(fn: tc.Function)
  Initializer(concreteType: ConcreteType)
}

type FunctionToCompile {
  callable: CallableToCompile
  fnName: String
  paramsNeedingDefaultValue: Bool[]
  concreteGenerics: Map<String, ConcreteType>
  methodInstanceType: ConcreteType? = None
}

type ConcreteType {
  instanceKind: InstanceKind
  typeArgs: ConcreteType[] = []

  func toString(self): String {
    val base = match self.instanceKind {
      InstanceKind.Struct(s) => s.label.name
      InstanceKind.Enum(e) => e.label.name
    }

    val typeArgs = self.typeArgs.map(t => t.toString())
    if typeArgs.isEmpty() {
      "ConcreteType($base)"
    } else {
      "ConcreteType($base<${typeArgs.join(", ")}>)"
    }
  }
}

pub type Generator {
  project: tc.Project
  functions: IrFunction[]
  functionsByName: Map<String, IrFunction>
  curCtx: Context
  fnQueue: FunctionToCompile[] = []
  types: Map<String, CompositeType> = {}
  globals: Map<String, GlobalVariable> = {}
  knowns: Knowns = Knowns()

  pub func generateIR(project: tc.Project): IR {
    val allModules = project.modules.values().sortBy(m => m.id)

    val mainFn = IrFunction(name: "main", params: [], ret: IrType.I64)
    val curCtx = Context(fn: mainFn, block: mainFn.block, locals: [])
    val generator = Generator(project: project, functions: [], functionsByName: {}, curCtx: curCtx)

    for mod in allModules {
      if generator.genModule(mod) |modFn| {
        mainFn.block[1].push(Instruction(op: Operation.Call(ret: modFn.ret, fnName: modFn.name, args: [])))
      }
    }

    mainFn.block[1].push(Instruction(op: Operation.Return(value: Some(Value.ConstInt(0)))))

    IR(
      mainFunction: mainFn,
      functions: generator.functions,
      types: generator.types.values(),
      globals: generator.globals.values(),
      knowns: generator.knowns
    )
  }

  func genModule(self, mod: tc.TypedModule): IrFunction? {
    val modFnName = "__mod_${mod.id}"
    val modFn = IrFunction(name: modFnName, params: [], ret: IrType.Unit)
    val prevCtx = self.curCtx
    self.curCtx = Context(fn: modFn, block: modFn.block, locals: [])

    for node in mod.code {
      self.genStatement(node, {})
    }
    if self.curCtx.fn.block[1].isEmpty() return None

    self.functions.push(modFn)
    self.emit(Instruction(op: Operation.Return()))

    self.curCtx = prevCtx

    for nextFn in self.fnQueue {
      self.genFunction(nextFn)
    }

    Some(modFn)
  }

  func genFunction(self, ctx: FunctionToCompile) {
    if self.functionsByName[ctx.fnName] return

    val fn = match ctx.callable {
      CallableToCompile.Function(fn) => fn
      CallableToCompile.Initializer(concreteType) => {
        self.getOrGenStructInitializer(concreteType, ctx.concreteGenerics, ctx.paramsNeedingDefaultValue)
        return
      }
    }

    val retTy = match fn.returnType.kind {
      TypeKind.PrimitiveUnit => IrType.Unit
      TypeKind.Generic(name) => {
        val concreteGeneric = try ctx.concreteGenerics[name] else unreachable("genFunction, no generic")
        self.getIrTypeForConcreteType(concreteGeneric)
      }
      else ty => {
        val retConcreteType = self.getConcreteTypeFromType(fn.returnType, ctx.concreteGenerics)
        self.getIrTypeForConcreteType(retConcreteType)
      }
    }

    val externName = self.getExternDecName(fn)
    val irFunc = IrFunction(extern: externName, name: ctx.fnName, params: [], ret: retTy)
    self.addFunction(ctx.fnName, irFunc)
    val prevCtx = self.enterFunction(irFunc)

    match fn.kind {
      FunctionKind.InstanceMethod => {
        val selfConcreteType = try ctx.methodInstanceType else unreachable("Instance method without instance type")
        val selfTy = self.getIrTypeForConcreteType(selfConcreteType)
        val selfParamIdent = Ident(ty: selfTy, kind: IdentKind.Named("self"))
        irFunc.params.push(selfParamIdent)

        if fn.label.name == "toString" && fn.isGenerated {
          self.genToStringMethodBody(Value.Ident(selfParamIdent), selfConcreteType)
          self.curCtx = prevCtx
          return
        }
      }
    }

    var anyParamNeedsDefault = false
    for param, idx in fn.params {
      val paramConcreteType = self.getConcreteTypeFromType(param.ty, ctx.concreteGenerics)
      val paramTy = self.getIrTypeForConcreteType(paramConcreteType)
      val paramIdent = Ident(ty: paramTy, kind: IdentKind.Named(param.label.name))

      if param.defaultValue {
        val paramNeedsDefault = ctx.paramsNeedingDefaultValue[idx] ?: false
        if paramNeedsDefault {
          anyParamNeedsDefault = true
          todo("params with default values")
        } else {
          irFunc.params.push(paramIdent)
        }
      } else {
        irFunc.params.push(paramIdent)
      }
    }

    if anyParamNeedsDefault {
      todo()
    } else {
      for node, idx in fn.body {
        if idx == fn.body.length - 1 {
          if retTy != IrType.Unit {
            val retVal = self.genExpression(node, ctx.concreteGenerics)
            self.emit(Instruction(op: Operation.Return(Some(retVal))))
          } else {
            self.genStatement(node, ctx.concreteGenerics)
            self.emit(Instruction(op: Operation.Return()))
          }
        } else {
          self.genStatement(node, ctx.concreteGenerics)
        }
      }
    }

    self.curCtx = prevCtx
  }

  func getOrGenStructInitializer(self, concreteType: ConcreteType, concreteGenerics: Map<String, ConcreteType>, fieldsNeedingDefaultValue: Bool[] = []): IrFunction {
    val struct = match concreteType.instanceKind { InstanceKind.Struct(s) => s, else => unreachable("getOrGenStructInitializer called with non-struct") }

    val fnName = self.structInitFnName(concreteType)
    if self.functionsByName[fnName] |f| return f

    val retTy = self.getIrTypeForConcreteType(concreteType)

    var size = 0
    var anyFieldNeedsDefault = false
    val params: Ident[] = []
    val argsForUnderlying: (Value, IrType, String, Int)[] = []
    for field, idx in struct.fields {
      val fieldConcreteType = self.getConcreteTypeFromType(field.ty, concreteGenerics)
      val fieldTy = self.getIrTypeForConcreteType(fieldConcreteType)
      size += 8 // TODO: don't assume 8 byte alignment for all fields

      val fieldVal = if field.initializer |initializerNode| {
        val fieldNeedsDefault = fieldsNeedingDefaultValue[idx] ?: false
        if fieldNeedsDefault {
          anyFieldNeedsDefault = true
          todo("fields with default values")
        } else {
          val ident = Ident(ty: fieldTy, kind: IdentKind.Named(field.name.name))
          params.push(ident)
          Value.Ident(ident)
        }
      } else {
        val ident = Ident(ty: fieldTy, kind: IdentKind.Named(field.name.name))
        params.push(ident)
        Value.Ident(ident)
      }

      // TODO: don't assume 8 byte alignment for all fields
      argsForUnderlying.push((fieldVal, fieldTy, field.name.name, idx * 8))
    }

    val irFunc = IrFunction(name: fnName, params: params, ret: retTy)
    self.addFunction(fnName, irFunc)
    val prevCtx = self.enterFunction(irFunc)

    val ident = Ident(ty: IrType.Ptr, kind: IdentKind.Anon(self.nextAnonLocal()))
    self.emit(Instruction(assignee: Some(ident), op: Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.Malloc(Value.ConstInt(size)))))
    val mem = Value.Ident(ident: ident)

    for (fieldVal, fieldTy, fieldName, fieldOffset), idx in argsForUnderlying {
      self.emit(Instruction(op: Operation.StoreField(ty: fieldTy, value: fieldVal, mem: mem, name: fieldName, offset: fieldOffset)))
    }

    self.emit(Instruction(op: Operation.Return(Some(mem))))

    self.curCtx = prevCtx
    irFunc
  }

  func genToStringMethodBody(self, selfVal: Value, concreteType: ConcreteType) {
    match concreteType.instanceKind {
      InstanceKind.Struct(s) => {
        if s == self.project.preludeIntStruct {
          val strTy = self.getIrTypeForConcreteType(ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeStringStruct), typeArgs: []))
          val ident = Ident(ty: IrType.I64, kind: IdentKind.Anon(self.nextAnonLocal()))
          self.emit(Instruction(assignee: Some(ident), op: Operation.Builtin(ret: strTy, builtin: Builtin.I64ToString(selfVal))))
          self.emit(Instruction(op: Operation.Return(Some(Value.Ident(ident)))))
        }
      }
      InstanceKind.Enum(e) => todo()
    }
  }

  func genStatement(self, node: tc.TypedAstNode, concreteGenerics: Map<String, ConcreteType>) {
    match node.kind {
      TypedAstNodeKind.If(isStatement, condNode, condBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if !isStatement {
          self.genExpression(node, concreteGenerics)
          return
        }

        val cond = self.genExpression(condNode, concreteGenerics)
        if self.project.typeIsOption(condNode.ty) todo("optional if-conditions")
        if condBinding todo("if-expr condition binding")

        if self.valueAsCompileTime(cond) |cond| {
          val condVal = match cond { Value.ConstBool(b) => b, else => todo("non-boolean if-conditions") }
          val block = if condVal ifBlock else elseBlock
          for node, idx in block {
            self.genStatement(node, concreteGenerics)
          }

          return
        }

        val ifBody = self.withinBlock("then", !!ifBlockTerminator, () => {
          for node, idx in ifBlock {
            self.genStatement(node, concreteGenerics)
          }

          None
        })
        val elseBody = self.withinBlock("else", !!elseBlockTerminator, () => {
          for node, idx in elseBlock {
            self.genStatement(node, concreteGenerics)
          }

          None
        })

        self.emit(Instruction(op: Operation.If(IrType.Unit, cond, ifBody, elseBody)))
      }
      TypedAstNodeKind.Match => todo("TypedAstNodeKind.Match (${node.token.position})")
      TypedAstNodeKind.While(condNode, condBinding, block, terminator) => {
        // A single expression node could result in many instructions. All of the condition's instructions will need
        // to be rerun for each iteration of the loop in order to determine whether the loop should continue, so it's
        // necessary to keep track of those in a manner separate from the rest of the instructions in the current
        // function (in order to properly set up jump labels if necessary when compiling the IR to its target).
        val cond = self.genCompoundValue(() => self.genExpression(condNode, concreteGenerics))

        if self.project.typeIsOption(condNode.ty) todo("optional while-conditions")
        if condBinding todo("while-expr condition binding")

        if self.valueAsCompileTime(cond.result) |cond| {
          val condVal = match cond { Value.ConstBool(b) => b, else => todo("non-boolean while-conditions") }
          if !condVal return
        }

        val body = self.withinBlock("while_loop", !!terminator, () => {
          for node, idx in block {
            self.genStatement(node, concreteGenerics)
          }

          None
        })

        self.emit(Instruction(op: Operation.While(IrType.Unit, cond, body)))
      }
      TypedAstNodeKind.For => todo("TypedAstNodeKind.For (${node.token.position})")
      TypedAstNodeKind.BindingDeclaration(node) => self.genBindingDeclaration(node, concreteGenerics)
      TypedAstNodeKind.FunctionDeclaration => { /* todo: TypedAstNodeKind.FunctionDeclaration */ }
      TypedAstNodeKind.TypeDeclaration => { /* todo: TypedAstNodeKind.TypeDeclaration */ }
      TypedAstNodeKind.EnumDeclaration => { /* todo: TypedAstNodeKind.EnumDeclaration */ }
      TypedAstNodeKind.Break => todo("TypedAstNodeKind.Break (${node.token.position})")
      TypedAstNodeKind.Continue => todo("TypedAstNodeKind.Continue (${node.token.position})")
      TypedAstNodeKind.Return(retValExpr) => {
        val retVal = if retValExpr |expr| {
          Some(self.genExpression(expr, concreteGenerics))
        } else {
          None
        }

        self.emit(Instruction(op: Operation.Return(retVal)))
      }
      TypedAstNodeKind.Placeholder => unreachable("Placeholder nodes should not be emitted from the typechecker")
      TypedAstNodeKind.Assignment(mode, op, expr) => self.genAssignment(concreteGenerics, mode, op, expr)
      else => self.genExpression(node, concreteGenerics)
    }
  }

  func genBindingDeclaration(self, node: tc.TypedBindingDeclarationNode, concreteGenerics: Map<String, ConcreteType>) {
    val variables = node.variables.keyBy(v => v.label.name)
    self.genBindingPattern(node.bindingPattern, variables, node.expr, concreteGenerics)
  }

  func genBindingPattern(self, pattern: BindingPattern, variables: Map<String, tc.Variable>, valueNode: tc.TypedAstNode?, concreteGenerics: Map<String, ConcreteType>) {
    val name = match pattern {
      BindingPattern.Variable(label) => label.name
      BindingPattern.Tuple => todo("genBindingPattern: BindingPattern.Tuple")
    }
    val variable = try variables[name] else unreachable("expected binding '$name', but missing from variables")

    if self.variableIsGlobal(variable) |modId| {
      val global = self.addGlobal(variable, modId, concreteGenerics)
      if valueNode |node| {
        val value = self.genExpression(node, concreteGenerics)
        if self.valueAsCompileTime(value) |v| {
          global.initialValue = Some(v)
        } else {
          self.emit(Instruction(op: Operation.Store(ty: global.ty, value: value, mem: Value.Global(global))))
        }
      }

      return
    }

    val varName = if variable.scope.idxInFn |idx| "_${name}_${idx}" else name
    val varTy = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varIrTy = self.getIrTypeForConcreteType(varTy)
    val ident = Ident(ty: varIrTy, kind: IdentKind.Named(varName))
    if valueNode |node| {
      if variable.mutable {
        val value = self.genExpression(node, concreteGenerics, None)
        self.emit(Instruction(assignee: Some(ident), op: Operation.NewLocal(ty: varIrTy, initialValue: Some(value))))
      } else {
        self.genExpression(node, concreteGenerics, Some(varName))
      }
    } else {
      self.emit(Instruction(assignee: Some(ident), op: Operation.NewLocal(ty: varIrTy, initialValue: None)))
    }
  }

  func genAssignment(self, concreteGenerics: Map<String, ConcreteType>, mode: TypedAssignmentMode, op: AssignOp, expr: tc.TypedAstNode) {
    val res = self.genExpression(expr, concreteGenerics)

    match mode {
      TypedAssignmentMode.Variable(v) => {
        val varName = if v.scope.idxInFn |idx| "_${v.label.name}_${idx}" else v.label.name
        val varTy = self.getConcreteTypeFromType(v.ty, concreteGenerics)
        val varIrTy = self.getIrTypeForConcreteType(varTy)
        val ident = Ident(ty: varIrTy, kind: IdentKind.Named(varName))
        self.emit(Instruction(op: Operation.Store(ty: varIrTy, value: res, mem: Value.Ident(ident))))
      }
      TypedAssignmentMode.Indexing => todo("genAssignment: Indexing")
      TypedAssignmentMode.Accessor(head, middle, tail) => {
        val (ty, mem, fieldName, offset) = self.followAccessorPath(head, middle, tail, concreteGenerics)
        self.emit(Instruction(op: Operation.StoreField(ty: ty, value: res, mem: mem, name: fieldName, offset: offset)))
      }
    }
  }

  func genExpression(self, node: tc.TypedAstNode, concreteGenerics: Map<String, ConcreteType>, dst: String? = None): Value {
    val pos = node.token.position

    match node.kind {
      TypedAstNodeKind.Literal(lit) => self.genLiteral(pos, lit)
      TypedAstNodeKind.StringInterpolation => todo("genExpression: StringInterpolation (${node.token})")
      TypedAstNodeKind.Unary => todo("genExpression: Unary (${node.token})")
      TypedAstNodeKind.Binary(left, op, right) => self.genBinary(pos, concreteGenerics, dst, left, op, right)
      TypedAstNodeKind.Grouped(inner) => self.genExpression(inner, {}, dst)
      TypedAstNodeKind.Identifier(name, variable, fnAliasTypeHint, varImportModule) => self.genIdentifier(pos, concreteGenerics, name, variable, fnAliasTypeHint, varImportModule)
      TypedAstNodeKind.Accessor(head, middle, tail) => self.genAccessor(head, middle, tail, concreteGenerics, dst)
      TypedAstNodeKind.Invocation(invokee, args, resolvedGenerics) => {
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        for (name, ty) in resolvedGenerics.entries() {
          val concreteType = self.getConcreteTypeFromType(ty, concreteGenerics)
          newConcreteGenerics[name] = concreteType
        }
        self.genCall(pos, newConcreteGenerics, dst, node.ty, invokee, args)
      }
      TypedAstNodeKind.Array(items) => self.genArray(pos, concreteGenerics, dst, node.ty, items)
      TypedAstNodeKind.Set => todo("genExpression: Set (${node.token})")
      TypedAstNodeKind.Map => todo("genExpression: Map (${node.token})")
      TypedAstNodeKind.Tuple => todo("genExpression: Tuple (${node.token})")
      TypedAstNodeKind.Indexing => todo("genExpression: Indexing (${node.token})")
      TypedAstNodeKind.Lambda => todo("genExpression: Lambda (${node.token})")
      TypedAstNodeKind.If(isStatement, condNode, condBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if isStatement unreachable("unexpected if statement")

        val cond = self.genExpression(condNode, concreteGenerics)
        if self.project.typeIsOption(condNode.ty) todo("optional if-conditions")
        if condBinding todo("if-expr condition binding")

        if self.valueAsCompileTime(cond) |cond| {
          val condVal = match cond { Value.ConstBool(b) => b, else => todo("non-boolean if-conditions") }
          val block = if condVal ifBlock else elseBlock
          for node, idx in block {
            if idx == block.length - 1 && !ifBlockTerminator {
              return self.genExpression(node, concreteGenerics, dst)
            } else {
              self.genStatement(node, concreteGenerics)
            }
          }
          unreachable("should have returned above")
        }

        val ifBody = self.withinBlock("then", !!ifBlockTerminator, () => {
          for node, idx in ifBlock {
            if idx == ifBlock.length - 1 && !ifBlockTerminator {
              return Some(self.genExpression(node, concreteGenerics))
            } else {
              self.genStatement(node, concreteGenerics)
            }
          }

          None
        })
        val elseBody = self.withinBlock("else", !!elseBlockTerminator, () => {
          for node, idx in elseBlock {
            if idx == elseBlock.length - 1 && !elseBlockTerminator {
              return Some(self.genExpression(node, concreteGenerics))
            } else {
              self.genStatement(node, concreteGenerics)
            }
          }

          None
        })

        val resConcreteType = self.getConcreteTypeFromType(node.ty, concreteGenerics)
        val resIrTy = self.getIrTypeForConcreteType(resConcreteType)
        val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
        val res = Ident(ty: resIrTy, kind: identKind)
        self.emit(Instruction(assignee: Some(res), op: Operation.If(resIrTy, cond, ifBody, elseBody)))
        Value.Ident(res)
      }
      else => todo("Other expressions (${node.token})")
    }
  }

  func genLiteral(self, pos: Position, lit: LiteralAstNode): Value {
    match lit {
      LiteralAstNode.Int(i) => Value.ConstInt(i)
      LiteralAstNode.Float => todo("genLiteral: LiteralAstNode.Float")
      LiteralAstNode.Bool(b) => Value.ConstBool(b)
      LiteralAstNode.Char(c) => Value.ConstChar(c)
      LiteralAstNode.String(s) => {
        val strConcreteTy = ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeStringStruct))
        // Ensure the composite type and struct initializer functions are known, even though they're not used when constructing a string literal
        self.knowns.strTy = Some(self.getOrAddCompositeType(strConcreteTy))
        self.knowns.strInit = Some(self.getOrGenStructInitializer(strConcreteTy, {}))

        Value.ConstString(s)
      }
    }
  }

  func genBinary(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, left: tc.TypedAstNode, op: BinaryOp, right: tc.TypedAstNode): Value {
    match op {
      BinaryOp.Add => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valueAsCompileTime(lval) |lval| {
          if self.valueAsCompileTime(rval) |rval| {
            val l = match lval { Value.ConstInt(l) => l, else => todo("genBinary: constant-folding other value types (add)") }
            val r = match rval { Value.ConstInt(r) => r, else => todo("genBinary: constant-folding other value types (add)") }

            return Value.ConstInt(l + r)
          }
        }

        val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
        val ident = Ident(ty: IrType.I64, kind: identKind)
        self.emit(Instruction(assignee: Some(ident), op: Operation.Add(lval, rval)))

        Value.Ident(ident: ident)
      }
      BinaryOp.Sub => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valueAsCompileTime(lval) |lval| {
          if self.valueAsCompileTime(rval) |rval| {
            val l = match lval { Value.ConstInt(l) => l, else => todo("genBinary: constant-folding other value types (sub)") }
            val r = match rval { Value.ConstInt(r) => r, else => todo("genBinary: constant-folding other value types (sub)") }

            return Value.ConstInt(l - r)
          }
        }

        val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
        val ident = Ident(ty: IrType.I64, kind: identKind)
        self.emit(Instruction(assignee: Some(ident), op: Operation.Sub(lval, rval)))

        Value.Ident(ident: ident)
      }
      BinaryOp.Mul => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valueAsCompileTime(lval) |lval| {
          if self.valueAsCompileTime(rval) |rval| {
            val l = match lval { Value.ConstInt(l) => l, else => todo("genBinary: constant-folding other value types (mul)") }
            val r = match rval { Value.ConstInt(r) => r, else => todo("genBinary: constant-folding other value types (mul)") }

            return Value.ConstInt(l * r)
          }
        }

        val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
        val ident = Ident(ty: IrType.I64, kind: identKind)
        self.emit(Instruction(assignee: Some(ident), op: Operation.Mul(lval, rval)))

        Value.Ident(ident: ident)
      }
      BinaryOp.Div => todo("genBinary: BinaryOp.Div")
      BinaryOp.Mod => todo("genBinary: BinaryOp.Mod")
      BinaryOp.Pow => todo("genBinary: BinaryOp.Pow")
      BinaryOp.And => todo("genBinary: BinaryOp.And ($pos)")
      BinaryOp.Or => todo("genBinary: BinaryOp.Or")
      BinaryOp.Xor => todo("genBinary: BinaryOp.Xor")
      BinaryOp.Coalesce => todo("genBinary: BinaryOp.Coalesce")
      BinaryOp.Eq => self.genEq(concreteGenerics, left, right, false, dst)
      BinaryOp.Neq => self.genEq(concreteGenerics, left, right, true, dst)
      BinaryOp.LT => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valueAsCompileTime(lval) |lval| {
          if self.valueAsCompileTime(rval) |rval| {
            val l = match lval { Value.ConstInt(l) => l, else => todo("genBinary: constant-folding other value types (lt)") }
            val r = match rval { Value.ConstInt(r) => r, else => todo("genBinary: constant-folding other value types (lt)") }

            return Value.ConstBool(l < r)
          }
        }

        val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
        val ident = Ident(ty: IrType.I64, kind: identKind)
        self.emit(Instruction(assignee: Some(ident), op: Operation.Lt(lval, rval)))

        Value.Ident(ident: ident)
      }
      BinaryOp.LTE => todo("genBinary: BinaryOp.LTE")
      BinaryOp.Shl => todo("genBinary: BinaryOp.Shl")
      BinaryOp.GT => todo("genBinary: BinaryOp.GT")
      BinaryOp.GTE => todo("genBinary: BinaryOp.GTE")
      BinaryOp.Shr => todo("genBinary: BinaryOp.Shr")
    }
  }

  func genEq(self, concreteGenerics: Map<String, ConcreteType>, left: tc.TypedAstNode, right: tc.TypedAstNode, negate: Bool, dst: String?): Value {
    val leftConcreteType = self.getConcreteTypeFromType(left.ty, concreteGenerics)
    val leftIrTy = self.getIrTypeForConcreteType(leftConcreteType)
    val rightConcreteType = self.getConcreteTypeFromType(right.ty, concreteGenerics)
    val rightIrTy = self.getIrTypeForConcreteType(rightConcreteType)
    if leftIrTy != rightIrTy unreachable("equality operators require matching types")

    val lval = self.genExpression(left, concreteGenerics)
    val rval = self.genExpression(right, concreteGenerics)

    if self.valueAsCompileTime(lval) |lval| {
      if self.valueAsCompileTime(rval) |rval| {
        val l = match lval { Value.ConstInt(l) => l, else => todo("genBinary: constant-folding other value types (n/eq)") }
        val r = match rval { Value.ConstInt(r) => r, else => todo("genBinary: constant-folding other value types (n/eq)") }

        return Value.ConstBool(l == r && !negate)
      }
    }

    val op = match leftIrTy {
      IrType.I64 => Operation.Eq(primitive: true, negate: negate, lval, rval)
      else => todo("n/eq logic for non-i64")
    }

    val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
    val ident = Ident(ty: IrType.Bool, kind: identKind)
    self.emit(Instruction(assignee: Some(ident), op: op))

    Value.Ident(ident: ident)
  }

  func intrinsicArgs1(self, name: String, arguments: tc.TypedAstNode?[]): tc.TypedAstNode {
    val arg0 = try arguments[0] else unreachable("'$name' has 1 required argument")
    try arg0 else unreachable("'$name' has 1 required argument")
  }

  func intrinsicArgs2(self, name: String, arguments: tc.TypedAstNode?[]): (tc.TypedAstNode, tc.TypedAstNode) {
    val _arg0 = try arguments[0] else unreachable("'$name' has 2 required arguments")
    val arg0 = try _arg0 else unreachable("'$name' has 2 required arguments")

    val _arg1 = try arguments[1] else unreachable("'$name' has 2 required arguments")
    val arg1 = try _arg1 else unreachable("'$name' has 2 required arguments")

    (arg0, arg1)
  }

  func intrinsicArgs4(self, name: String, arguments: tc.TypedAstNode?[]): (tc.TypedAstNode, tc.TypedAstNode, tc.TypedAstNode, tc.TypedAstNode) {
    val _arg0 = try arguments[0] else unreachable("'$name' has 4 required arguments")
    val arg0 = try _arg0 else unreachable("'$name' has 4 required arguments")

    val _arg1 = try arguments[1] else unreachable("'$name' has 4 required arguments")
    val arg1 = try _arg1 else unreachable("'$name' has 4 required arguments")

    val _arg2 = try arguments[2] else unreachable("'$name' has 4 required arguments")
    val arg2 = try _arg2 else unreachable("'$name' has 4 required arguments")

    val _arg3 = try arguments[3] else unreachable("'$name' has 4 required arguments")
    val arg3 = try _arg3 else unreachable("'$name' has 4 required arguments")

    (arg0, arg1, arg2, arg3)
  }

  func genCall(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, returnType: tc.Type, invokee: tc.TypedInvokee, args: tc.TypedAstNode?[]): Value {
    val argValues: Value[] = []

    val fnName = match invokee {
      TypedInvokee.Function(fn) => {
        if self.getExternDecName(fn) |fnName| {
          self.enqueueFunction(fn, fnName, [], None, {})
          fnName
        } else if self.getIntrinsicDecName(fn) |intrinsicName| {
          return match intrinsicName {
            "pointer_malloc" => {
              val count = self.genExpression(self.intrinsicArgs1("pointer_malloc", args), concreteGenerics)
              val itemTy = self.getIrTypeForConcreteType(try concreteGenerics["T"] else unreachable("(pointer_malloc) could not resolve T for Pointer<T>"))

              val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
              val ident = Ident(ty: IrType.Ptr, kind: identKind)
              val builtin = Builtin.Malloc(count: count, itemTy: Some(itemTy))
              self.emit(Instruction(assignee: Some(ident), op: Operation.Builtin(ret: IrType.Ptr, builtin: builtin)))
              Value.Ident(ident: ident)
            }
            "byte_from_int" => {
              val arg = self.intrinsicArgs1("byte_from_int", args)
              self.genExpression(arg, concreteGenerics)
            }
            "char_as_int" => {
              val arg = self.intrinsicArgs1("char_as_int", args)
              self.genExpression(arg, concreteGenerics)
            }
            else => todo("Unimplemented static/standalone intrinsic '$intrinsicName'")
          }
        } else {
          // todo: check for closure

          val paramsNeedingDefaultValue = args.map((arg, idx) => {
            // todo: simplify expression to just `!!fn.params[idx]?.defaultValue && !arg` ?
            if fn.params[idx] |param| {
              !!param.defaultValue && !arg
            } else {
              false
            }
          })

          // TODO: does `concreteGenerics` contain both T and U for `Array<T>#map<U>`??
          val fnName = self.fnName(None, fn, concreteGenerics, paramsNeedingDefaultValue)
          self.enqueueFunction(fn, fnName, paramsNeedingDefaultValue, None, concreteGenerics)

          fnName
        }
      }
      TypedInvokee.Method(fn, selfVal, isOptSafe) => {
        if self.getExternDecName(fn) |fnName| {
          todo("Unimplemented external method '$fnName'")
        } else if self.getIntrinsicDecName(fn) |intrinsicName| {
          return match intrinsicName {
            "pointer_realloc" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val count = self.intrinsicArgs1("pointer_realloc", args)

              val itemTy = self.getIrTypeForConcreteType(try concreteGenerics["T"] else unreachable("(pointer_realloc) could not resolve T for Pointer<T>"))
              val countVal = self.genExpression(count, concreteGenerics)

              val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
              val ident = Ident(ty: IrType.Ptr, kind: identKind)
              val builtin = Builtin.Realloc(ptr: ptrVal, count: countVal, itemTy: Some(itemTy))
              self.emit(Instruction(assignee: Some(ident), op: Operation.Builtin(ret: IrType.Ptr, builtin: builtin)))
              Value.Ident(ident: ident)
            }
            "pointer_store_at" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val (value, offset) = self.intrinsicArgs2("pointer_store_at", args)

              val itemTy = self.getIrTypeForConcreteType(try concreteGenerics["T"] else unreachable("(pointer_store) could not resolve T for Pointer<T>"))
              val valueVal = self.genExpression(value, concreteGenerics)
              val offsetVal = self.genExpression(offset, concreteGenerics)

              self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: Builtin.Store(ptr: ptrVal, value: valueVal, offset: offsetVal, itemTy: itemTy))))
              Value.Unit
            }
            "pointer_load_at" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val offset = self.intrinsicArgs1("pointer_load_at", args)

              val itemTy = self.getIrTypeForConcreteType(try concreteGenerics["T"] else unreachable("(pointer_load) could not resolve T for Pointer<T>"))
              val offsetVal = self.genExpression(offset, concreteGenerics)

              val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
              val ident = Ident(ty: itemTy, kind: identKind)
              self.emit(Instruction(assignee: Some(ident), op: Operation.Builtin(ret: itemTy, builtin: Builtin.Load(ptr: ptrVal, offset: offsetVal, itemTy: itemTy))))
              Value.Ident(ident: ident)
            }
            "pointer_copy_from" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val (dstOffset, src, srcOffset, size) = self.intrinsicArgs4("pointer_copy_from", args)

              val dstOffsetVal = self.genExpression(dstOffset, concreteGenerics)
              val srcVal = self.genExpression(src, concreteGenerics)
              val srcOffsetVal = self.genExpression(srcOffset, concreteGenerics)
              val sizeVal = self.genExpression(size, concreteGenerics)

              val itemTy = self.getIrTypeForConcreteType(try concreteGenerics["T"] else unreachable("(pointer_copy_from) could not resolve T for Pointer<T>"))

              val builtin = Builtin.CopyFrom(dst: ptrVal, dstOffset: dstOffsetVal, src: srcVal, srcOffset: srcOffsetVal, size: sizeVal, itemTy: itemTy)
              self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: builtin)))
              Value.Unit
            }
            else => todo("Unimplemented method intrinsic '$intrinsicName'")
          }
        } else {
          // todo: check for closure

          val paramsNeedingDefaultValue = args.map((arg, idx) => {
            // todo: simplify expression to just `!!fn.params[idx]?.defaultValue && !arg` ?
            if fn.params[idx] |param| {
              !!param.defaultValue && !arg
            } else {
              false
            }
          })

          val selfConcreteType = self.getConcreteTypeFromType(selfVal.ty, concreteGenerics)
          val fnName = self.fnName(Some(selfConcreteType), fn, concreteGenerics, paramsNeedingDefaultValue)
          self.enqueueFunction(fn, fnName, paramsNeedingDefaultValue, Some(selfConcreteType), concreteGenerics)

          argValues.push(self.genExpression(selfVal, concreteGenerics))

          fnName
        }
      }
      TypedInvokee.Struct(s) => {
        val typeArgs: ConcreteType[] = []
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        for tp in s.typeParams {
          val concreteGeneric = try concreteGenerics[tp] else unreachable("Could not resolve generic '$tp' for struct initializer '${s.label.name}'")
          typeArgs.push(concreteGeneric)
          newConcreteGenerics[tp] = concreteGeneric
        }
        val concreteType = ConcreteType(instanceKind: InstanceKind.Struct(s), typeArgs: typeArgs)

        val paramsNeedingDefaultValue = args.map((arg, idx) => {
          // todo: simplify expression to just `!!fn.params[idx]?.defaultValue && !arg` ?
          if s.fields[idx] |field| {
            !!field.initializer && !arg
          } else {
            false
          }
        })

        val fnName = self.structInitFnName(concreteType)
        self.enqueueInitializer(concreteType, fnName, paramsNeedingDefaultValue, None, newConcreteGenerics)

        fnName
      }
      else => todo("other TypedInvokee types")
    }

    for arg in args {
      if arg |arg| {
        argValues.push(self.genExpression(arg, concreteGenerics))
      }
    }

    if returnType.kind == tc.TypeKind.PrimitiveUnit {
      val op = Operation.Call(ret: IrType.Unit, fnName: fnName, args: argValues)
      self.emit(Instruction(op: op))

      Value.Unit
    } else {
      val retConcreteType = self.getConcreteTypeFromType(returnType, concreteGenerics)
      val retTy = self.getIrTypeForConcreteType(retConcreteType)

      val op = Operation.Call(ret: retTy, fnName: fnName, args: argValues)
      val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
      val ident = Ident(ty: retTy, kind: identKind)
      self.emit(Instruction(assignee: Some(ident), op: op))

      Value.Ident(ident: ident)
    }
  }

  func genIdentifier(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, name: String, variable: tc.Variable, fnAliasTypeHint: tc.Type?, varImportModule: tc.TypedModule?): Value {
    val varConcreteType = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varTy = self.getIrTypeForConcreteType(varConcreteType)

    if variable.isParameter {
      // todo: handle whether variable is captured

      return Value.Ident(ident: Ident(ty: varTy, kind: IdentKind.Named(name)))
    }

    match variable.alias {
      VariableAlias.Function => todo("genIdentifier VariableAlias.Function")
      else => {
        if varImportModule |mod| {
          val globalName = self.globalName(mod.id, variable.label.name)
          val global = try self.globals[globalName] else unreachable("no such global '$globalName'")
          global.referenced = true

          Value.Global(global)
        } else if self.variableIsGlobal(variable) |modId| {
          val globalName = self.globalName(modId, variable.label.name)
          val global = try self.globals[globalName] else unreachable("no such global '$globalName'")
          global.referenced = true

          Value.Global(global)
        } else if variable.isCaptured {
          // Note: captured top-level variables are "global" and are handled above; variables handled here are not top-level
          todo("genIdentifier captured variable")
        } else if variable.mutable {
          val varName = if variable.scope.idxInFn |idx| "_${name}_${idx}" else name
          val slot = Value.Ident(ident: Ident(ty: varTy, kind: IdentKind.Named(varName)))
          val ident = Ident(ty: varTy, kind: IdentKind.Anon(self.nextAnonLocal()))
          val op = Operation.Load(ty: varTy, mem: slot)
          self.emit(Instruction(assignee: Some(ident), op: op))

          Value.Ident(ident)
        } else {
          val varName = if variable.scope.idxInFn |idx| "_${name}_${idx}" else name
          Value.Ident(ident: Ident(ty: varTy, kind: IdentKind.Named(varName)))
        }
      }
    }
  }

  func followAccessorPath(self, head: tc.TypedAstNode, middle: tc.AccessorPathSegment[], tail: tc.AccessorPathSegment, concreteGenerics: Map<String, ConcreteType>): (IrType, Value, String, Int) {
    val segs = middle.concat([tail])

    var (workingVal, concreteType) = match segs[0] {
      AccessorPathSegment.EnumVariant => todo()
      else => {
        val concreteType = self.getConcreteTypeFromType(head.ty, concreteGenerics)
        val headVal = self.genExpression(head, concreteGenerics)

        (headVal, concreteType)
      }
    }

    for seg, idx in segs {
      match seg {
        AccessorPathSegment.EnumVariant => todo()
        AccessorPathSegment.Method => todo()
        AccessorPathSegment.Field(label, ty, field, isOptSafe) => {
          if isOptSafe todo()

          match concreteType.instanceKind {
            InstanceKind.Struct(struct) => {
              val (f, fieldIdx) = try struct.fields.findIndex(f => f.name.name == field.name.name) else unreachable("no such field '${field.name.name}'")
              val offset = fieldIdx * 8 // TODO: don't assume 8 byte alignment for all fields
              val fieldConcreteType = self.getConcreteTypeFromType(f.ty, concreteGenerics)
              val fieldTy = self.getIrTypeForConcreteType(fieldConcreteType)

              if idx == segs.length - 1 return (fieldTy, workingVal, f.name.name, offset)

              val ident = Ident(ty: fieldTy, kind: IdentKind.Anon(self.nextAnonLocal()))
              val op = Operation.LoadField(ty: fieldTy, mem: workingVal, name: f.name.name, offset: offset)
              self.emit(Instruction(assignee: Some(ident), op: op))

              workingVal = Value.Ident(ident: ident)
              concreteType = self.getConcreteTypeFromType(ty, concreteGenerics)
            }
            InstanceKind.Enum => todo("enum field accessor")
          }
        }
      }
    }

    unreachable("followAccessorPath end (${segs.length})")
  }

  func genAccessor(self, head: tc.TypedAstNode, middle: tc.AccessorPathSegment[], tail: tc.AccessorPathSegment, concreteGenerics: Map<String, ConcreteType>, dst: String?): Value {
    val (ty, mem, fieldName, offset) = self.followAccessorPath(head, middle, tail, concreteGenerics)

    val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
    val ident = Ident(ty: ty, kind: identKind)
    val op = Operation.LoadField(ty: ty, mem: mem, name: fieldName, offset: offset)
    self.emit(Instruction(assignee: Some(ident), op: op))

    Value.Ident(ident: ident)
  }

  func genArray(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, arrayTy: tc.Type, items: tc.TypedAstNode[]): Value {
    val arrayConcreteType = self.getConcreteTypeFromType(arrayTy, concreteGenerics)

    val arrConcreteGenerics = {"T": ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeIntStruct))}
    val arrayWithCapacityFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "withCapacity", staticMethod: true)
    val arrayWithCapacityFnName = self.fnName(None, arrayWithCapacityFn, arrConcreteGenerics, [])
    self.enqueueFunction(arrayWithCapacityFn, arrayWithCapacityFnName, [], None, arrConcreteGenerics)

    val sizeVal = Value.ConstInt(items.length.nextPowerOf2())
    val arrayIrTy = self.getIrTypeForConcreteType(arrayConcreteType)
    val op = Operation.Call(ret: arrayIrTy, fnName: arrayWithCapacityFnName, args: [sizeVal])
    val identKind = if dst |dst| IdentKind.Named(dst) else IdentKind.Anon(self.nextAnonLocal())
    val ident = Ident(ty: arrayIrTy, kind: identKind)
    self.emit(Instruction(assignee: Some(ident), op: op))
    val arrVal = Value.Ident(ident: ident)

    val arrayPushFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "push", staticMethod: false)
    val arrayPushFnName = self.fnName(Some(arrayConcreteType), arrayPushFn, arrConcreteGenerics, [])
    self.enqueueFunction(arrayPushFn, arrayPushFnName, [], Some(arrayConcreteType), arrConcreteGenerics)

    for item in items {
      val itemVal = self.genExpression(item, arrConcreteGenerics)
      self.emit(Instruction(op: Operation.Call(ret: IrType.Unit, fnName: arrayPushFnName, args: [arrVal, itemVal])))
    }

    arrVal
  }

  // helpers

  func enterFunction(self, fn: IrFunction): Context {
    val prevCtx = self.curCtx
    val params = fn.params.map(p => Ident(ty: IrType.I64, kind: p.kind))
    self.curCtx = Context(fn: fn, block: fn.block, locals: params)

    prevCtx
  }

  func withinBlock(self, name: String, terminates: Bool, fn: () => Value?): Block {
    val prevBlock = self.curCtx.block

    val instrs: Instruction[] = []
    self.curCtx.block = (name, instrs)
    val finalVal = fn()
    self.curCtx.block = prevBlock

    Block(name: name, body: instrs, result: finalVal, terminates: terminates)
  }

  func genCompoundValue(self, fn: () => Value): CompoundValue {
    val prevBlock = self.curCtx.block

    val instrs: Instruction[] = []
    self.curCtx.block = ("_compoundvalue", instrs)
    val finalVal = fn()
    self.curCtx.block = prevBlock

    CompoundValue(body: instrs, result: finalVal)
  }

  func enqueueFunction(self, fn: tc.Function, fnName: String, paramsNeedingDefaultValue: Bool[], methodInstanceType: ConcreteType?, concreteGenerics: Map<String, ConcreteType>) {
    self.fnQueue.push(FunctionToCompile(callable: CallableToCompile.Function(fn), fnName: fnName, paramsNeedingDefaultValue: paramsNeedingDefaultValue, concreteGenerics: concreteGenerics, methodInstanceType: methodInstanceType))
  }

  func enqueueInitializer(self, ty: ConcreteType, fnName: String, paramsNeedingDefaultValue: Bool[], methodInstanceType: ConcreteType?, concreteGenerics: Map<String, ConcreteType>) {
    self.fnQueue.push(FunctionToCompile(callable: CallableToCompile.Initializer(ty), fnName: fnName, paramsNeedingDefaultValue: paramsNeedingDefaultValue, concreteGenerics: concreteGenerics, methodInstanceType: methodInstanceType))
  }

  func addFunction(self, fnName: String, fn: IrFunction) {
    self.functions.push(fn)
    self.functionsByName[fnName] = fn
  }

  func addGlobal(self, variable: tc.Variable, modId: Int, concreteGenerics: Map<String, ConcreteType>): GlobalVariable {
    val varConcreteType = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varTy = self.getIrTypeForConcreteType(varConcreteType)

    val globalName = self.globalName(modId, variable.label.name)
    val v = GlobalVariable(name: globalName, ty: varTy, mutable: variable.mutable)
    self.globals[globalName] = v

    v
  }

  func globalName(self, modId: Int, name: String): String = "_${modId}_$name"

  func typeName(self, ty: ConcreteType, withTypeArgs = true): String {
    val (id, baseName) = match ty.instanceKind {
      InstanceKind.Struct(s) => {
        val (id, _) = try s.scope.findParentModule() else unreachable("could not find parent module for struct '${s.label.name}'")

        (id, s.label.name)
      }
      InstanceKind.Enum(e) => {
        val (id, _) = try e.scope.findParentModule() else unreachable("could not find parent module for enum '${e.label.name}'")

        (id, e.label.name)
      }
    }

    val parts = [id.toString(), baseName]
    if withTypeArgs {
      for typeArg in ty.typeArgs {
        parts.push(self.typeName(typeArg))
      }
    }

    parts.join("_")
  }

  func getConcreteTypeFromType(self, ty: tc.Type, concreteGenerics: Map<String, ConcreteType>): ConcreteType {
    match ty.kind {
      TypeKind.CouldNotDetermine => unreachable("Encountered CouldNotDetermine type")
      TypeKind.PrimitiveUnit => unreachable("getConcreteTypeFromType: Unit")
      TypeKind.PrimitiveInt => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeIntStruct), typeArgs: [])
      TypeKind.PrimitiveFloat => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeFloatStruct), typeArgs: [])
      TypeKind.PrimitiveBool => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeBoolStruct), typeArgs: [])
      TypeKind.PrimitiveChar => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeCharStruct), typeArgs: [])
      TypeKind.PrimitiveString => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeStringStruct), typeArgs: [])
      TypeKind.Never => unreachable("Encountered Never type")
      TypeKind.Generic(name) => try concreteGenerics[name] else unreachable("getConcreteTypeFromType: generic '$name'")
      TypeKind.Instance(instanceKind, typeArgs) => {
        val concreteTypeArgs = typeArgs.map(t => self.getConcreteTypeFromType(t, concreteGenerics))
        ConcreteType(instanceKind: instanceKind, typeArgs: concreteTypeArgs)
      }
      TypeKind.Func(paramTypes, returnType) => todo("TypeKind.Func")
      TypeKind.Type(type_) => todo("TypeKind.Type")
      TypeKind.Tuple(types) => todo("TypeKind.Tuple")
      TypeKind.Hole => todo("TypeKind.Hole")
    }
  }

  func fnName(self, methodInstTy: ConcreteType?, fn: tc.Function, concreteGenerics: Map<String, ConcreteType>, paramsNeedingDefaultValue: Bool[] = []): String {
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    val prefix = match fn.kind {
      FunctionKind.Standalone => {
        val (defModId, _) = try fn.scope.findParentModule() else unreachable("could not find parent module for function '${fn.label.name}'")

        val base = "_${defModId}_${fn.label.name}"
        if !fn.typeParams.isEmpty() todo("generic functions")

        base
      }
      FunctionKind.InstanceMethod => {
        val instTy = try methodInstTy else unreachable("InstanceMethod without methodInstTy")
        val typeName = self.typeName(instTy)

        val base = "_${typeName}_${fn.label.name}"
        if !fn.typeParams.isEmpty() todo("[3] generic instance methods")

        base
      }
      FunctionKind.StaticMethod(instanceKind, _) => {
        val typeName = self.typeName(ConcreteType(instanceKind: instanceKind), withTypeArgs: false)

        val base = ["_${typeName}__${fn.label.name}"]
        for (_, label) in fn.typeParams {
          val concreteGeneric = try concreteGenerics[label.name] else unreachable("Could not resolve generic '${label.name}' for function '${fn.label.name}'")
          base.push(self.typeName(concreteGeneric))
        }

        base.join("_")
      }
    }

    if defaultValuesFlag == 0 {
      prefix
    } else {
      "${prefix}_$defaultValuesFlag"
    }
  }

  func structInitFnName(self, ty: ConcreteType): String {
    val typeName = self.typeName(ty)
    "_${typeName}__init__"
  }

  func getIrTypeForConcreteType(self, ty: ConcreteType): IrType {
    match ty.instanceKind {
      InstanceKind.Struct(s) => {
        if s == self.project.preludeIntStruct return IrType.I64

        if s.builtin == Some(tc.BuiltinModule.Intrinsics) {
          if s.label.name == "Byte" return IrType.Byte
        }

        val t = self.getOrAddCompositeType(ty)
        IrType.Composite(name: t.name)
      }
      InstanceKind.Enum => todo("getIrTypeForConcreteType enums")
    }
  }

  func getOrAddCompositeType(self, ty: ConcreteType): CompositeType {
    val typeName = self.typeName(ty)

    if self.types[typeName] |t| return t

    // TODO
    // val fields = match instanceKind {
    //   InstanceKind.Struct(s) => {
    //     s.fields.map(f => (f.name.name, self.getIrTypeForTcType(f.ty)))
    //   }
    //   InstanceKind.Enum => todo("getOrAddCompositeType for enums")
    // }

    val t = CompositeType(name: typeName, fields: [])
    self.types[typeName] = t

    t
  }

  func emit(self, inst: Instruction) = self.curCtx.block[1].push(inst)

  func getMethodByName(self, parent: InstanceKind, name: String, staticMethod = false): tc.Function {
    val (parentName, methods) = match parent {
      InstanceKind.Struct(s) => (s.label.name, if staticMethod s.staticMethods else s.instanceMethods)
      InstanceKind.Enum(e) => (e.label.name, if staticMethod e.staticMethods else e.instanceMethods)
    }

    try methods.find(m => m.label.name == name) else {
      val sep = if staticMethod "." else "#"
      unreachable("$parentName$sep$name must exist")
    }
  }

  func variableIsGlobal(self, variable: tc.Variable): Int? {
    // Top-level variables in a module are only globals if they're captured; otherwise they're treated as locals within the module wrapper function.
    // Exported variables (which _should_ also be top-level) are necessarily hoisted to global scope.
    val modId = variable.isGlobal()
    if variable.isExported {
      if !modId unreachable("a variable should only be able to be exported if it's at the top-level")
      return modId
    }

    if !variable.isCaptured return None

    modId
  }

  func valueAsCompileTime(self, value: Value): Value? {
    // A value is said to be known at compile time if it's a constant (int, float, bool, or string), or if it's an immutable global.
    match value {
      Value.Unit => None // should be unreachable, but it's ok to return None here
      Value.ConstInt => Some(value)
      Value.ConstBool => Some(value)
      Value.ConstChar => Some(value)
      Value.ConstString => Some(value)
      Value.Ident => None
      Value.Global(global) => if global.mutable None else global.initialValue
    }
  }

  func nextAnonLocal(self): Int {
    val idx = self.curCtx.anonLocalIdx
    self.curCtx.anonLocalIdx += 1
    idx
  }

  func getExternDecName(self, fn: tc.Function): String? {
    if fn.decorators.find(dec => dec.label.name == "external") |dec| {
      match dec.arguments[0] {
        LiteralAstNode.String(value) => Some(value)
        _ => unreachable("@external decorator requires 1 string argument for the name")
      }
    } else {
      None
    }
  }

  func getIntrinsicDecName(self, fn: tc.Function): String? {
    if fn.decorators.find(dec => dec.label.name == "intrinsic") |dec| {
      match dec.arguments[0] {
        LiteralAstNode.String(value) => Some(value)
        _ => unreachable("@external decorator requires 1 string argument for the name")
      }
    } else {
      None
    }
  }
}
