import "process" as process
import Position from "./lexer"
import Label, LiteralAstNode, AssignOp, UnaryOp, BinaryOp, BindingPattern, IndexingMode from "./parser"
// match arms don't support import-based namespacing for enums yet, so enums used in matches are imported by name
import TypedAstNodeKind, TypedInvokee, FunctionKind, TypeKind, ScopeKind, InstanceKind, EnumVariantKind, VariableAlias, AccessorPathSegment, TypedAssignmentMode, TypedIndexingNode from "./typechecker"
import "./typechecker" as tc

// TODO: move to stdlib
pub type StringBuilder {
  chunks: String[] = []

  pub func write(self, str: String): StringBuilder {
    if !str.isEmpty() self.chunks.push(str)
    self
  }

  pub func writeln(self, str: String = ""): StringBuilder = self.write(str).write("\n")

  pub func build(self): String = self.chunks.join("")
}

pub type Knowns {
  strTy: CompositeType? = None
  strInit: IrFunction? = None

  pub func stringType(self): CompositeType = try self.strTy else unreachable("String type expected to be initialized")
  pub func stringInitializerFn(self): IrFunction = try self.strInit else unreachable("String initializer fn expected to be initialized")
}

pub type IR {
  pub mainFunction: IrFunction
  pub functions: IrFunction[]
  pub types: CompositeType[]
  pub globals: GlobalVariable[]
  pub knowns: Knowns = Knowns()

  pub func render(self, sb: StringBuilder) {
    for t in self.types {
      t.render(sb)
      sb.writeln()
    }

    for g in self.globals {
      g.render(sb)
      sb.writeln()
    }

    sb.writeln()
    self.mainFunction.render(sb)

    for f in self.functions {
      sb.writeln()
      f.render(sb)
    }
  }
}

pub type IrFunction {
  pub extern: String? = None
  pub name: String
  pub params: Ident[]
  pub ret: IrType
  pub block: (String, Instruction[]) = ("start", [])

  pub func render(self, sb: StringBuilder) {
    if self.extern |name| sb.writeln("@extern($name)")

    sb.write("function ")
    sb.write(self.name)

    sb.write("(")
    for p, idx in self.params {
      p.render(sb)
      if idx != self.params.length - 1 {
        sb.write(", ")
      }
    }
    sb.write(") ")

    self.ret.render(sb)
    sb.writeln()

    val (label, block) = self.block
    sb.writeln("$label:")
    for inst in block {
      sb.write("  ")
      inst.render(sb)
      sb.writeln()
    }
  }
}

pub type Instruction {
  pub assignee: Ident? = None
  pub op: Operation

  pub func render(self, sb: StringBuilder) {
    if self.assignee |a| {
      a.render(sb)
      sb.write(" = ")
    }

    self.op.render(sb)
  }
}

pub enum IdentKind {
  Anon(idx: Int)
  Named(name: String)

  pub func name(self): String = match self {
    IdentKind.Anon(idx) => "_$idx"
    IdentKind.Named(name) => name
  }
}

pub type Ident {
  pub ty: IrType
  pub kind: IdentKind
  compileTimeValue: Const? = None

  pub func render(self, sb: StringBuilder) {
    self.ty.render(sb)
    sb.write(" %")
    sb.write(self.kind.name())
  }
}

pub enum Const {
  Int(value: Int)
  Float(value: Float)
  Bool(value: Bool)
  Char(value: Int) // 64-bit repr of char
  String(value: String)

  pub func render(self, sb: StringBuilder) {
    match self {
      Const.Int(v) => {
        IrType.I64.render(sb)
        sb.write(" ").write(v.toString())
      }
      Const.Float(v) => {
        IrType.F64.render(sb)
        sb.write(" ").write(v.toString())
      }
      Const.Bool(b) => {
        IrType.Bool.render(sb)
        sb.write(" $b")
      }
      Const.Char(intVal) => {
        IrType.I64.render(sb)
        sb.write(" ${Char.fromInt(intVal)}")
      }
      Const.String(s) => {
        sb.write("\"")
          .write(s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"").replaceAll("\n", "\\n").replaceAll("\r", "\\r"))
          .write("\"")
      }
    }
  }
}

pub enum Value {
  Unit
  Const(value: Const)
  Ident(ident: Ident)
  Global(global: GlobalVariable)

  pub func render(self, sb: StringBuilder) {
    match self {
      Value.Unit => {}
      Value.Const(const) => const.render(sb)
      Value.Ident(i) => i.render(sb)
      Value.Global(g) => {
        g.ty.render(sb)
        sb.write(" $").write(g.name)
      }
    }
  }
}

pub enum Builtin {
  Malloc(count: Value, itemTy: IrType? = None)
  Realloc(ptr: Value, count: Value, itemTy: IrType? = None)
  Store(ptr: Value, value: Value, offset: Value, itemTy: IrType)
  Load(ptr: Value, offset: Value, itemTy: IrType)
  CopyFrom(dst: Value, dstOffset: Value, src: Value, srcOffset: Value, size: Value, itemTy: IrType)
  I64ToString(intVal: Value)
  U64ToString(intVal: Value)
  F64ToString(floatVal: Value)
  BoolToString(boolVal: Value)
  IntAsFloat(intVal: Value)
  FloatAsInt(floatVal: Value)
  FloatCeil(floatVal: Value)
  FloatFloor(floatVal: Value)
  FloatRound(floatVal: Value)
  Uninitialized
}

pub type Block {
  pub name: String
  pub body: Instruction[]
  pub result: Value?
  pub terminates: Bool
}

pub type CompoundValue {
  pub body: Instruction[]
  pub result: Value
}

pub enum Operation {
  NewLocal(ty: IrType, initialValue: Value? = None)
  ConstInt(int: Int)
  ConstFloat(float: Float)
  ConstBool(b: Bool)
  ConstChar(value: Int) // 64-bit repr of char
  ConstString(str: String)

  Minus(value: Value)
  Negate(value: Value)

  Add(left: Value, right: Value)
  Sub(left: Value, right: Value)
  Mul(left: Value, right: Value)
  Div(left: Value, right: Value)
  Mod(left: Value, right: Value)
  Pow(left: Value, right: Value)
  BitAnd(left: Value, right: Value)
  BoolAnd(left: Value, right: CompoundValue)
  BitOr(left: Value, right: Value)
  BoolOr(left: Value, right: CompoundValue)
  Xor(bitwise: Bool, left: Value, right: Value)
  Eq(negate: Bool, left: Value, right: Value)
  Lt(left: Value, right: Value)
  Lte(left: Value, right: Value)
  Shl(left: Value, right: Value)
  Gt(left: Value, right: Value)
  Gte(left: Value, right: Value)
  Shr(left: Value, right: Value)

  Load(ty: IrType, mem: Value)
  LoadField(ty: IrType, mem: Value, name: String, offset: Int)
  Store(ty: IrType, value: Value, mem: Value)
  StoreField(ty: IrType, value: Value, mem: Value, name: String, offset: Int)

  If(ty: IrType, cond: Value, thenBlock: Block, elseBlock: Block)
  WhileLoopStart(name: String)
  While(cond: Value, body: Block)

  Call(ret: IrType, fnName: String, args: Value[])

  Break
  Continue
  Return(value: Value? = None)

  OptionNone(innerTy: IrType)
  OptionSome(innerTy: IrType, value: Value)
  OptionIsNone(value: Value)
  OptionUnwrap(innerTy: IrType, value: Value)
  StructuredToString(prefix: String, lenVal: Value, fields: (IrType, String, Value)[])
  Builtin(ret: IrType, builtin: Builtin)

  pub func render(self, sb: StringBuilder) {
    match self {
      Operation.NewLocal(ty, initialValue) => {
        sb.write("local(")
        ty.render(sb)
        if initialValue |v| {
          sb.write(", ")
          v.render(sb)
        }
        sb.write(")")
      }
      Operation.ConstInt(int) => {
        IrType.I64.render(sb)
        sb.write(" $int")
      }
      Operation.ConstFloat(float) => {
        IrType.F64.render(sb)
        sb.write(" $float")
      }
      Operation.ConstString(str) => {
        sb.write("string \"$str\"")
      }
      Operation.ConstBool(b) => {
        IrType.Bool.render(sb)
        sb.write(" $b")
      }
      Operation.ConstChar(c) => {
        IrType.I64.render(sb)
        sb.write(" '$c'")
      }
      Operation.Minus(v) => {
        sb.write("minus(")
        v.render(sb)
        sb.write(")")
      }
      Operation.Negate(v) => {
        sb.write("negate(")
        v.render(sb)
        sb.write(")")
      }
      Operation.Add(l, r) => {
        sb.write("add(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Mul(l, r) => {
        sb.write("mul(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Div(l, r) => {
        sb.write("div(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Mod(l, r) => {
        sb.write("mod(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Pow(l, r) => {
        sb.write("pow(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.BitAnd(l, r) => {
        sb.write("bitand(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.BoolAnd(l, r) => {
        for instr in r.body {
          instr.render(sb)
          sb.writeln()
        }
        sb.write("and(")
        l.render(sb)
        sb.write(", ")
        r.result.render(sb)
        sb.write(")")
      }
      Operation.BitOr(l, r) => {
        sb.write("bitor(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.BoolOr(l, r) => {
        for instr in r.body {
          instr.render(sb)
          sb.writeln()
        }
        sb.write("or(")
        l.render(sb)
        sb.write(", ")
        r.result.render(sb)
        sb.write(")")
      }
      Operation.Xor(_, l, r) => {
        sb.write("xor(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Eq(negate, left, right) => {
        if negate sb.write("neq(") else sb.write("eq(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Lt(left, right) => {
        sb.write("lt(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Lte(left, right) => {
        sb.write("lte(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Shl(left, right) => {
        sb.write("shl(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Gt(left, right) => {
        sb.write("gt(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Gte(left, right) => {
        sb.write("gte(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Shr(left, right) => {
        sb.write("shr(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Load(ty, mem) => {
        sb.write("load(")
        ty.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(")")
      }
      Operation.LoadField(ty, mem, name, offset) => {
        sb.write("load(")
        ty.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(", $name ($offset))")
      }
      Operation.Store(ty, value, mem) => {
        sb.write("store(")
        ty.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(")")
      }
      Operation.StoreField(ty, value, mem, name, offset) => {
        sb.write("store(")
        ty.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(", $name ($offset))")
      }
      Operation.If(ty, cond, thenBlock, elseBlock) => {
        sb.write("if(")
        cond.render(sb)
        sb.write(", .${thenBlock.name}")
        if thenBlock.result |v| {
          sb.write(" (")
          v.render(sb)
          sb.write(")")
        }
        if !elseBlock.body.isEmpty() {
          sb.write(", .${elseBlock.name}")
          if elseBlock.result |v| {
            sb.write(" (")
            v.render(sb)
            sb.write(")")
          }
        }
        sb.writeln(")")

        sb.writeln(".${thenBlock.name}:")
        for instr in thenBlock.body {
          sb.write("  ")
          instr.render(sb)
          sb.writeln()
        }
        if !elseBlock.body.isEmpty() {
          sb.writeln(".${elseBlock.name}:")
          for instr in elseBlock.body {
            sb.write("  ")
            instr.render(sb)
            sb.writeln()
          }
        }
        sb.write("# endif")
      }
      Operation.WhileLoopStart(name) => sb.write("while_loop_start(.$name)")
      Operation.While(cond, body) => {
        sb.write("while(")
        cond.render(sb)
        sb.writeln(", .${body.name})")

        sb.writeln(".${body.name}:")
        for instr in body.body {
          sb.write("  ")
          instr.render(sb)
          sb.writeln()
        }
        sb.write("# endwhile")
      }
      Operation.Call(ret, fnName, args) => {
        sb.write("call(")
        ret.render(sb)
        sb.write(", ").write(fnName)
        for arg, idx in args {
          sb.write(", ")
          arg.render(sb)
        }
        sb.write(")")
      }
      Operation.Break => sb.write("break")
      Operation.Continue => sb.write("continue")
      Operation.Return(v) => {
        sb.write("return(")
        if v |v| v.render(sb)
        sb.write(")")
      }
      Operation.OptionNone(innerTy) => {
        sb.write("option_none(")
        innerTy.render(sb)
        sb.write(")")
      }
      Operation.OptionSome(innerTy, value) => {
        sb.write("option_some(")
        innerTy.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(")")
      }
      Operation.OptionIsNone(value) => {
        sb.write("option_is_none(")
        value.render(sb)
        sb.write(")")
      }
      Operation.OptionUnwrap(innerTy, value) => {
        sb.write("option_unwrap(")
        innerTy.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(")")
      }
      Operation.StructuredToString(prefix, lenVal, fields) => {
        sb.write("structured_to_string($prefix, ")
        lenVal.render(sb)

        for (fieldIrTy, fieldName, fieldToStringVal) in fields {
          sb.write(", ")
          fieldIrTy.render(sb)
          sb.write(" $fieldName ")
          fieldToStringVal.render(sb)
        }
        sb.write(")")
      }
      Operation.Builtin(ret, builtin) => {
        sb.write("builtin(")
        ret.render(sb)
        sb.write(", ")
        match builtin {
          Builtin.Malloc(size, itemTy) => {
            sb.write("malloc, ")
            size.render(sb)
            if itemTy |ty| {
              sb.write(", ")
              ty.render(sb)
            }
          }
          Builtin.Realloc(ptr, count, itemTy) => {
            sb.write("realloc, ")
            ptr.render(sb)
            sb.write(", ")
            count.render(sb)
            if itemTy |ty| {
              sb.write(", ")
              ty.render(sb)
            }
          }
          Builtin.Store(ptr, value, offset, itemTy) => {
            sb.write("ptr_store, ")
            ptr.render(sb)
            sb.write(", ")
            value.render(sb)
            sb.write(", ")
            offset.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.Load(ptr, offset, itemTy) => {
            sb.write("ptr_load, ")
            ptr.render(sb)
            sb.write(", ")
            offset.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.CopyFrom(dst, dstOffset, src, srcOffset, size, itemTy) => {
            sb.write("copy_from, ")
            dst.render(sb)
            sb.write(", ")
            dstOffset.render(sb)
            sb.write(", ")
            src.render(sb)
            sb.write(", ")
            srcOffset.render(sb)
            sb.write(", ")
            size.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.I64ToString(int) => {
            sb.write("i64_to_string, ")
            int.render(sb)
          }
          Builtin.U64ToString(int) => {
            sb.write("u64_to_string, ")
            int.render(sb)
          }
          Builtin.F64ToString(int) => {
            sb.write("f64_to_string, ")
            int.render(sb)
          }
          Builtin.BoolToString(int) => {
            sb.write("bool_to_string, ")
            int.render(sb)
          }
          Builtin.IntAsFloat(float) => {
            sb.write("int_as_float, ")
            float.render(sb)
          }
          Builtin.FloatAsInt(float) => {
            sb.write("float_as_int, ")
            float.render(sb)
          }
          Builtin.FloatCeil(float) => {
            sb.write("float_ceil, ")
            float.render(sb)
          }
          Builtin.FloatFloor(float) => {
            sb.write("float_floor, ")
            float.render(sb)
          }
          Builtin.FloatRound(float) => {
            sb.write("float_round, ")
            float.render(sb)
          }
          Builtin.Uninitialized => {
            sb.write("uninitialized")
          }
        }
        sb.write(")")
      }
    }
  }
}

pub enum IrType {
  Unit
  I64
  F64
  Bool
  Byte
  Composite(name: String)
  Ptr

  pub func render(self, sb: StringBuilder) {
    match self {
      IrType.Unit => sb.write("unit")
      IrType.I64 => sb.write("i64")
      IrType.F64 => sb.write("f64")
      IrType.Bool => sb.write("bool")
      IrType.Byte => sb.write("byte")
      IrType.Composite(name) => sb.write(name)
      IrType.Ptr => sb.write("ptr")
    }
  }
}

pub type CompositeType {
  pub name: String
  pub fields: (String, IrType)[]

  pub func render(self, sb: StringBuilder) {
    sb.write("type ")
      .write(self.name)
      .write(" = struct {")
    if !self.fields.isEmpty() sb.writeln()

    for (name, ty) in self.fields {
      sb.write("\n")
        .write("  ")
        .write(name)
        .write(": ")
      ty.render(sb)
    }
    sb.writeln("}")
  }
}

pub type GlobalVariable {
  pub name: String
  pub ty: IrType
  pub mutable: Bool
  pub initialValue: Const? = None
  pub referenced: Bool = false

  pub func render(self, sb: StringBuilder) {
    sb.write("global ")

    if self.mutable {
      sb.write("mutable ")
    } else {
      sb.write("const ")
    }

    self.ty.render(sb)
    sb.write(" ${self.name}")

    if self.initialValue |v| {
      sb.write(" = ")
      v.render(sb)
    }

    if !self.referenced {
      sb.write(" # not referenced")
    }
  }
}

type Context {
  fn: IrFunction
  block: (String, Instruction[])
  locals: Map<String, Value> = {}
  anonLocalIdx: Int = 0

  func getLocal(self, name: String, pos: Position): Value {
    try self.locals[name] else unreachable("failed to find variable '$name' ($pos)")
  }
}

enum CallableToCompile {
  Function(fn: tc.Function)
  Initializer(concreteType: ConcreteType)
  EnumVariant(concreteType: ConcreteType, variant: tc.TypedEnumVariant)
}

type FunctionToCompile {
  callable: CallableToCompile
  fnName: String
  paramsNeedingDefaultValue: Bool[]
  concreteGenerics: Map<String, ConcreteType>
  methodInstanceType: ConcreteType? = None
}

type ConcreteType {
  instanceKind: InstanceKind
  typeArgs: ConcreteType[] = []

  func toString(self): String {
    val base = match self.instanceKind {
      InstanceKind.Struct(s) => s.label.name
      InstanceKind.Enum(e) => e.label.name
    }

    val typeArgs = self.typeArgs.map(t => t.toString())
    if typeArgs.isEmpty() {
      "ConcreteType($base)"
    } else {
      "ConcreteType($base<${typeArgs.join(", ")}>)"
    }
  }
}

pub type Generator {
  project: tc.Project
  functions: IrFunction[]
  functionsByName: Map<String, IrFunction>
  curCtx: Context
  foldConstants: Bool
  fnQueue: FunctionToCompile[] = []
  types: Map<String, (CompositeType, ConcreteType)> = {}
  globals: Map<String, GlobalVariable> = {}
  knowns: Knowns = Knowns()
  tupleStructs: Map<String, tc.Struct> = {}

  pub func generateIR(project: tc.Project, foldConstants: Bool = true): IR {
    val allModules = project.modules.values().sortBy(m => m.id)

    val mainFn = IrFunction(name: "main", params: [], ret: IrType.I64)
    val curCtx = Context(fn: mainFn, block: mainFn.block)
    val generator = Generator(project: project, functions: [], functionsByName: {}, curCtx: curCtx, foldConstants: foldConstants)

    val strConcreteTy = ConcreteType(instanceKind: InstanceKind.Struct(project.preludeStringStruct))
    generator.knowns.strTy = Some(generator.getOrAddCompositeType(strConcreteTy))
    generator.knowns.strInit = Some(generator.getOrGenInitializerFn(strConcreteTy, None, {}))

    for mod in allModules {
      if generator.genModule(mod) |modFn| {
        mainFn.block[1].push(Instruction(op: Operation.Call(ret: modFn.ret, fnName: modFn.name, args: [])))
      }
    }

    mainFn.block[1].push(Instruction(op: Operation.Return(value: Some(Value.Const(Const.Int(0))))))

    IR(
      mainFunction: mainFn,
      functions: generator.functions,
      types: generator.types.values().map(t => t[0]),
      globals: generator.globals.values(),
      knowns: generator.knowns
    )
  }

  func genModule(self, mod: tc.TypedModule): IrFunction? {
    val modFnName = "__mod_${mod.id}"
    val modFn = IrFunction(name: modFnName, params: [], ret: IrType.Unit)
    val prevCtx = self.curCtx
    self.curCtx = Context(fn: modFn, block: modFn.block)

    for node in mod.code {
      self.genStatement(node, {})
    }
    if self.curCtx.fn.block[1].isEmpty() return None

    self.functions.push(modFn)
    self.emit(Instruction(op: Operation.Return()))

    self.curCtx = prevCtx

    for nextFn in self.fnQueue {
      self.genFunction(nextFn)
    }

    Some(modFn)
  }

  func genFunction(self, ctx: FunctionToCompile) {
    if self.functionsByName[ctx.fnName] return

    val fn = match ctx.callable {
      CallableToCompile.Function(fn) => fn
      CallableToCompile.Initializer(concreteType) => {
        self.getOrGenInitializerFn(concreteType, None, ctx.concreteGenerics, ctx.paramsNeedingDefaultValue)
        return
      }
      CallableToCompile.EnumVariant(concreteType, variant) => {
        self.getOrGenInitializerFn(concreteType, Some(variant), ctx.concreteGenerics, ctx.paramsNeedingDefaultValue)
        return
      }
    }

    val retTy = match fn.returnType.kind {
      TypeKind.PrimitiveUnit => IrType.Unit
      TypeKind.Generic(name) => {
        val concreteGeneric = try ctx.concreteGenerics[name] else unreachable("genFunction, no generic")
        self.getIrTypeForConcreteType(concreteGeneric)
      }
      else ty => {
        val retConcreteType = self.getConcreteTypeFromType(fn.returnType, ctx.concreteGenerics)
        self.getIrTypeForConcreteType(retConcreteType)
      }
    }

    val externName = self.getExternDecName(fn)
    val irFunc = IrFunction(extern: externName, name: ctx.fnName, params: [], ret: retTy)
    self.addFunction(ctx.fnName, irFunc)
    val prevCtx = self.enterFunction(irFunc)

    var selfParam: Value? = None
    match fn.kind {
      FunctionKind.InstanceMethod => {
        val selfConcreteType = try ctx.methodInstanceType else unreachable("Instance method without instance type")
        val selfTy = self.getIrTypeForConcreteType(selfConcreteType)
        val selfParamIdent = Ident(ty: selfTy, kind: IdentKind.Named("self"))
        irFunc.params.push(selfParamIdent)
        selfParam = Some(Value.Ident(selfParamIdent))
      }
    }

    var anyParamNeedsDefault = false
    val argsForUnderlying = if selfParam |selfParam| [selfParam] else []
    for param, idx in fn.params {
      val paramConcreteType = self.getConcreteTypeFromType(param.ty, ctx.concreteGenerics)
      val paramTy = self.getIrTypeForConcreteType(paramConcreteType)
      val paramIdent = Ident(ty: paramTy, kind: IdentKind.Named(param.label.name))

      val argVal = if param.defaultValue |defaultValue| {
        val paramNeedsDefault = ctx.paramsNeedingDefaultValue[idx] ?: false
        if paramNeedsDefault {
          anyParamNeedsDefault = true
          self.genExpression(defaultValue, ctx.concreteGenerics, Some(param.label.name))
        } else {
          irFunc.params.push(paramIdent)
          Value.Ident(paramIdent)
        }
      } else {
        irFunc.params.push(paramIdent)
        Value.Ident(paramIdent)
      }
      argsForUnderlying.push(argVal)
    }

    match fn.kind {
      FunctionKind.InstanceMethod => {
        val selfConcreteType = try ctx.methodInstanceType else unreachable("Instance method without instance type")
        val selfParam = try argsForUnderlying[0] else unreachable()

        if fn.label.name == "toString" && fn.isGenerated {
          self.genToStringMethodBody(selfParam, selfConcreteType)
          self.curCtx = prevCtx
          return
        }

        if fn.label.name == "eq" && fn.isGenerated {
          val otherParam = try argsForUnderlying[1] else unreachable()
          self.genEqMethodBody(selfParam, otherParam, selfConcreteType)
          self.curCtx = prevCtx
          return
        }
      }
    }

    if anyParamNeedsDefault {
      val baseFnName = self.fnName(ctx.methodInstanceType, fn, ctx.concreteGenerics, [])
      self.enqueueFunction(fn, baseFnName, [], ctx.methodInstanceType, ctx.concreteGenerics)

      if retTy == IrType.Unit {
        self.emit(Instruction(op: Operation.Call(ret: IrType.Unit, fnName: baseFnName, args: argsForUnderlying)))
        self.emit(Instruction(op: Operation.Return()))
      } else {
        val ident = self.ssaValue(retTy, Operation.Call(ret: retTy, fnName: baseFnName, args: argsForUnderlying), None)
        self.emit(Instruction(op: Operation.Return(Some(ident))))
      }
    } else {
      for node, idx in fn.body {
        if idx == fn.body.length - 1 && fn.scope.terminator != Some(tc.Terminator.Returning) {
          if retTy != IrType.Unit {
            val retVal = self.genExpression(node, ctx.concreteGenerics)
            self.emit(Instruction(op: Operation.Return(Some(retVal))))
          } else {
            self.genStatement(node, ctx.concreteGenerics)
            self.emit(Instruction(op: Operation.Return()))
          }
        } else {
          self.genStatement(node, ctx.concreteGenerics)
        }
      }
    }

    self.curCtx = prevCtx
  }

  func getOrGenInitializerFn(self, concreteType: ConcreteType, enumVariant: tc.TypedEnumVariant?, concreteGenerics: Map<String, ConcreteType>, fieldsNeedingDefaultValue: Bool[] = []): IrFunction {
    val (fnName, fields, initialSize, enumVariantIdx) = match concreteType.instanceKind {
      InstanceKind.Struct(s) => {
        val fnName = self.structInitFnName(concreteType, fieldsNeedingDefaultValue)

        (fnName, s.fields, 0, None)
      }
      InstanceKind.Enum(e) => {
        val variant = try enumVariant else unreachable()
        val fields = match variant.kind {
          EnumVariantKind.Constant => unreachable()
          EnumVariantKind.Container(fields) => fields
        }
        val fnName = self.enumVariantInitFnName(concreteType, variant, fieldsNeedingDefaultValue)
        val (_, variantIdx) = try e.variants.findIndex(v => v.label.name == variant.label.name) else unreachable("${e.label.name}.${variant.label.name} must exist")

        (fnName, fields, 8, Some(variantIdx))
      }
    }

    if self.functionsByName[fnName] |f| return f

    val retTy = self.getIrTypeForConcreteType(concreteType)
    val irFunc = IrFunction(name: fnName, params: [], ret: retTy)
    self.addFunction(fnName, irFunc)
    val prevCtx = self.enterFunction(irFunc)

    var size = initialSize
    var anyFieldNeedsDefault = false
    val argsForUnderlying: (Value, IrType, String, Int)[] = []
    for field, idx in fields {
      val fieldConcreteType = self.getConcreteTypeFromType(field.ty, concreteGenerics)
      val fieldTy = self.getIrTypeForConcreteType(fieldConcreteType)
      size += 8 // TODO: don't assume 8 byte alignment for all fields

      val fieldVal = if field.initializer |initializerNode| {
        val fieldNeedsDefault = fieldsNeedingDefaultValue[idx] ?: false
        if fieldNeedsDefault {
          anyFieldNeedsDefault = true
          self.genExpression(initializerNode, concreteGenerics, Some(field.name.name))
        } else {
          val ident = Ident(ty: fieldTy, kind: IdentKind.Named(field.name.name))
          irFunc.params.push(ident)
          Value.Ident(ident)
        }
      } else {
        val ident = Ident(ty: fieldTy, kind: IdentKind.Named(field.name.name))
        irFunc.params.push(ident)
        Value.Ident(ident)
      }

      // TODO: don't assume 8 byte alignment for all fields
      argsForUnderlying.push((fieldVal, fieldTy, field.name.name, idx * 8))
    }

    val retVal = if anyFieldNeedsDefault {
      val baseFnName = if enumVariant |variant| {
        val baseFnName = self.enumVariantInitFnName(concreteType, variant, [])
        self.enqueueInitializer(concreteType, Some(variant), baseFnName, [], None, concreteGenerics)
        baseFnName
      } else {
        val baseFnName = self.structInitFnName(concreteType, [])
        self.enqueueInitializer(concreteType, None, baseFnName, [], None, concreteGenerics)
        baseFnName
      }

      self.ssaValue(retTy, Operation.Call(ret: retTy, fnName: baseFnName, args: argsForUnderlying.map(a => a[0])), None)
    } else {
      val mem = self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.Malloc(Value.Const(Const.Int(size)))), None)

      if enumVariantIdx |enumVariantIdx| {
        self.emit(Instruction(op: Operation.StoreField(ty: IrType.I64, value: Value.Const(Const.Int(enumVariantIdx)), mem: mem, name: "\$idx", offset: 0)))
      }

      for (fieldVal, fieldTy, fieldName, fieldOffset), idx in argsForUnderlying {
        self.emit(Instruction(op: Operation.StoreField(ty: fieldTy, value: fieldVal, mem: mem, name: fieldName, offset: fieldOffset)))
      }

      mem
    }
    self.emit(Instruction(op: Operation.Return(Some(retVal))))

    self.curCtx = prevCtx

    irFunc
  }

  func genToStringMethodBody(self, selfVal: Value, concreteType: ConcreteType) {
    val strTy = IrType.Composite(self.knowns.stringType().name)

    val newConcreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
    match concreteType.instanceKind {
      InstanceKind.Struct(s) => {
        if s == self.project.preludeStringStruct {
          self.emit(Instruction(op: Operation.Return(Some(selfVal))))
          return
        }

        if s == self.project.preludeIntStruct || s == self.project.preludeFloatStruct || s == self.project.preludeBoolStruct {
          val builtin = if s == self.project.preludeIntStruct {
            Builtin.I64ToString(selfVal)
          } else if s == self.project.preludeFloatStruct {
            Builtin.F64ToString(selfVal)
          } else if s == self.project.preludeBoolStruct {
            Builtin.BoolToString(selfVal)
          } else unreachable()

          val ident = self.ssaValue(strTy, Operation.Builtin(ret: strTy, builtin: builtin), None)
          self.emit(Instruction(op: Operation.Return(Some(ident))))
          return
        }

        val isTupleStruct = self.isTupleStruct(s)
        val fields = s.fields.map((f, idx) => {
          val fieldConcreteType = self.getConcreteTypeFromType(f.ty, newConcreteGenerics)
          val fieldIrType = self.getIrTypeForConcreteType(fieldConcreteType)

          val itemVal = self.ssaValue(fieldIrType, Operation.LoadField(ty: fieldIrType, mem: selfVal, name: f.name.name, offset: idx * 8), None)
          val itemLabel = if isTupleStruct "" else f.name.name
          (itemLabel, fieldConcreteType, itemVal)
        })
        val prefix = if isTupleStruct "" else s.label.name

        val res = self.genToStringLogicForStructuredData(prefix, fields)
        self.emit(Instruction(op: Operation.Return(Some(res))))
      }
      InstanceKind.Enum(e) => {
        if e == self.project.preludeOptionEnum {
          val typeArg = try concreteType.typeArgs[0] else unreachable()
          val typeArgIrType = self.getIrTypeForConcreteType(typeArg)

          val isNoneBlock = self.withinBlock("is_none", false, () => {
            val none = self.ssaValue(strTy, Operation.ConstString("Option.None"), None)
            Some(none)
          })
          val isSomeBlock = self.withinBlock("is_some", false, () => {
            val some = self.ssaValue(typeArgIrType, Operation.OptionUnwrap(typeArgIrType, selfVal), None)
            val res = self.genToStringLogicForStructuredData("Option.Some", [("value", typeArg, some)])

            Some(res)
          })

          val cond = self.ssaValue(IrType.Bool, Operation.OptionIsNone(selfVal), None)
          val ident = self.ssaValue(strTy, Operation.If(strTy, cond, isNoneBlock, isSomeBlock), None)
          self.emit(Instruction(op: Operation.Return(Some(ident))))
        } else {
          todo("genToStringMethodBody: enum")
        }
      }
    }
  }

  func genEqMethodBody(self, selfVal: Value, otherVal: Value, concreteType: ConcreteType) {
    val newConcreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
    match concreteType.instanceKind {
      InstanceKind.Struct(s) => {
        if s == self.project.preludeIntStruct || s == self.project.preludeFloatStruct || s == self.project.preludeBoolStruct {
          val ident = self.ssaValue(IrType.Bool, Operation.Eq(negate: false, left: selfVal, right: otherVal), None)
          self.emit(Instruction(op: Operation.Return(Some(ident))))
          return
        }

        val fields = s.fields.map((f, idx) => {
          val fieldConcreteType = self.getConcreteTypeFromType(f.ty, newConcreteGenerics)
          val fieldIrType = self.getIrTypeForConcreteType(fieldConcreteType)

          val selfItemVal = self.ssaValue(fieldIrType, Operation.LoadField(ty: fieldIrType, mem: selfVal, name: f.name.name, offset: idx * 8), None)
          val otherItemVal = self.ssaValue(fieldIrType, Operation.LoadField(ty: fieldIrType, mem: otherVal, name: f.name.name, offset: idx * 8), None)
          (fieldConcreteType, selfItemVal, otherItemVal)
        })

        val res = self.genEqLogicForStructuredData(fields)
        self.emit(Instruction(op: Operation.Return(Some(res))))
      }
      InstanceKind.Enum => todo("genEqMethodBody: enum")
    }
  }

  func genStatement(self, node: tc.TypedAstNode, concreteGenerics: Map<String, ConcreteType>) {
    val pos = node.token.position

    match node.kind {
      TypedAstNodeKind.If(isStatement, condNode, condBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if !isStatement {
          self.genExpression(node, concreteGenerics)
          return
        }

        val optInnerTy = self.project.typeIsOption(condNode.ty)
        val condBindingVal = self.genExpression(condNode, concreteGenerics)
        val condVal = if optInnerTy |innerTy| {
          val optIsNone = self.ssaValue(IrType.Bool, Operation.OptionIsNone(condBindingVal), None)
          self.ssaValue(IrType.Bool, Operation.Negate(optIsNone), None)
        } else {
          condBindingVal
        }

        if self.valueAsCompileTime(condVal) |cond| {
          val condVal = match cond { Const.Bool(b) => b, else => todo("non-boolean if-conditions") }
          val block = if condVal ifBlock else elseBlock
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)
          for node, idx in block {
            self.genStatement(node, concreteGenerics)
          }

          return
        }

        val ifBody = self.withinBlock("then", !!ifBlockTerminator, () => {
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)

          for node, idx in ifBlock {
            self.genStatement(node, concreteGenerics)
          }

          None
        })
        val elseBody = self.withinBlock("else", !!elseBlockTerminator, () => {
          for node, idx in elseBlock {
            self.genStatement(node, concreteGenerics)
          }

          None
        })

        self.emit(Instruction(op: Operation.If(IrType.Unit, condVal, ifBody, elseBody)))
      }
      TypedAstNodeKind.Match => todo("TypedAstNodeKind.Match (${node.token.position})")
      TypedAstNodeKind.While(condNode, condBinding, block, terminator) => {
        val optInnerTy = self.project.typeIsOption(condNode.ty)

        val loopName = "while_loop"
        self.emit(Instruction(op: Operation.WhileLoopStart(loopName)))

        val condBindingVal = self.genExpression(condNode, concreteGenerics)
        val cond = if optInnerTy |innerTy| {
          val optIsNone = self.ssaValue(IrType.Bool, Operation.OptionIsNone(condBindingVal), None)
          self.ssaValue(IrType.Bool, Operation.Negate(optIsNone), None)
        } else {
          condBindingVal
        }

        val body = self.withinBlock(loopName, !!terminator, () => {
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)

          for node, idx in block {
            self.genStatement(node, concreteGenerics)
          }

          None
        })

        self.emit(Instruction(op: Operation.While(cond: cond, body: body)))
      }
      TypedAstNodeKind.For => todo("TypedAstNodeKind.For (${node.token.position})")
      TypedAstNodeKind.BindingDeclaration(node) => self.genBindingDeclaration(node, concreteGenerics)
      TypedAstNodeKind.FunctionDeclaration => { /* todo: TypedAstNodeKind.FunctionDeclaration */ }
      TypedAstNodeKind.TypeDeclaration => { /* todo: TypedAstNodeKind.TypeDeclaration */ }
      TypedAstNodeKind.EnumDeclaration => { /* todo: TypedAstNodeKind.EnumDeclaration */ }
      TypedAstNodeKind.Break => self.emit(Instruction(op: Operation.Break))
      TypedAstNodeKind.Continue => self.emit(Instruction(op: Operation.Continue))
      TypedAstNodeKind.Return(retValExpr) => {
        val retVal = if retValExpr |expr| {
          Some(self.genExpression(expr, concreteGenerics))
        } else {
          None
        }

        self.emit(Instruction(op: Operation.Return(retVal)))
      }
      TypedAstNodeKind.Placeholder => unreachable("Placeholder nodes should not be emitted from the typechecker")
      TypedAstNodeKind.Assignment(mode, op, expr) => self.genAssignment(pos, concreteGenerics, mode, op, expr)
      else => self.genExpression(node, concreteGenerics)
    }
  }

  func genBindingDeclaration(self, node: tc.TypedBindingDeclarationNode, concreteGenerics: Map<String, ConcreteType>) {
    val variables = node.variables.keyBy(v => v.label.name)
    val exprVal = if node.expr |expr| {
      val exprVal = self.genExpression(expr, concreteGenerics)
      val exprTy = self.getConcreteTypeFromType(expr.ty, concreteGenerics)
      Some((exprVal, exprTy))
    } else {
      None
    }
    self.genBindingPattern(node.bindingPattern, variables, exprVal, concreteGenerics)
  }

  func genBindingPattern(self, pattern: BindingPattern, variables: Map<String, tc.Variable>, value: (Value, ConcreteType)?, concreteGenerics: Map<String, ConcreteType>) {
    val name = match pattern {
      BindingPattern.Variable(label) => label.name
      BindingPattern.Tuple(tok, pats) => {
        val (value, valueTy) = try value else return
        for pat, idx in pats {
          val itemTy = try valueTy.typeArgs[idx] else unreachable()
          val itemIrTy = self.getIrTypeForConcreteType(itemTy)
          val itemVal = self.ssaValue(itemIrTy, Operation.LoadField(ty: itemIrTy, mem: value, name: "__$idx", offset: idx * 8), None)

          self.genBindingPattern(pat, variables, Some((itemVal, itemTy)), concreteGenerics)
        }

        return
      }
    }
    val variable = try variables[name] else unreachable("expected binding '$name', but missing from variables")

    if self.variableIsGlobal(variable) |modId| {
      val global = self.addGlobal(variable, modId, concreteGenerics)
      if value |(value, _)| {
        if self.valueAsCompileTime(value) |v| {
          global.initialValue = Some(v)
        } else {
          self.emit(Instruction(op: Operation.Store(ty: global.ty, value: value, mem: Value.Global(global))))
        }
      }

      return
    }

    val varName = if variable.scope.idxInFn |idx| "_${name}_${idx}" else name
    val varTy = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varIrTy = self.getIrTypeForConcreteType(varTy)
    val ident = if value |(value, _)| {
      if variable.mutable {
        self.ssaValue(varIrTy, Operation.NewLocal(ty: varIrTy, initialValue: Some(value)), Some(varName))
      } else {
        value
      }
    } else {
      self.ssaValue(varIrTy, Operation.NewLocal(ty: varIrTy, initialValue: None), Some(varName))
    }

    self.curCtx.locals[varName] = ident
  }

  func genConditionBinding(self, concreteGenerics: Map<String, ConcreteType>, innerOptType: tc.Type?, condValue: Value, condBinding: (BindingPattern, tc.Variable[])) {
    val (pattern, vars) = condBinding
    val variables = vars.keyBy(v => v.label.name)
    match pattern {
      BindingPattern.Variable(label) => {
        if innerOptType |innerTy| {
          val innerConcreteType = self.getConcreteTypeFromType(innerTy, concreteGenerics)
          val innerIrType = self.getIrTypeForConcreteType(innerConcreteType)
          val optVal = self.ssaValue(innerIrType, Operation.OptionUnwrap(innerTy: innerIrType, value: condValue), None)
          self.genBindingPattern(pattern, variables, Some((optVal, innerConcreteType)), concreteGenerics)
        }
      }
      BindingPattern.Tuple(_, pats) => {
        val innerTy = try innerOptType else unreachable("cannot destructure a Bool")
        val innerConcreteType = self.getConcreteTypeFromType(innerTy, concreteGenerics)
        val innerIrType = self.getIrTypeForConcreteType(innerConcreteType)

        val optVal = self.ssaValue(innerIrType, Operation.OptionUnwrap(innerTy: innerIrType, value: condValue), None)
        self.genBindingPattern(pattern, variables, Some((optVal, innerConcreteType)), concreteGenerics)
      }
    }
  }

  func genAssignment(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, mode: TypedAssignmentMode, op: AssignOp, expr: tc.TypedAstNode) {
    val res = self.genExpression(expr, concreteGenerics)

    match mode {
      TypedAssignmentMode.Variable(v) => {
        val varTy = self.getConcreteTypeFromType(v.ty, concreteGenerics)
        val varIrTy = self.getIrTypeForConcreteType(varTy)

        if self.variableIsGlobal(v) |modId| {
          val globalName = self.globalName(modId, v.label.name)
          val global = self.getGlobal(globalName, pos)
          self.emit(Instruction(op: Operation.Store(ty: varIrTy, value: res, mem: Value.Global(global))))
        } else {
          val varName = if v.scope.idxInFn |idx| "_${v.label.name}_${idx}" else v.label.name
          val ident = self.curCtx.getLocal(varName, pos)
          self.emit(Instruction(op: Operation.Store(ty: varIrTy, value: res, mem: ident)))
        }
      }
      TypedAssignmentMode.Indexing(mode) => {
        match mode {
          TypedIndexingNode.ArrayLike(arrExpr, mode) => {
            val idxExpr = match mode { IndexingMode.Single(idxExpr) => idxExpr, IndexingMode.Range => unreachable("cannot use range index in index-assignment") }
            val idxVal = self.genExpression(idxExpr, concreteGenerics)

            val arrVal = self.genExpression(arrExpr, concreteGenerics)
            val exprConcreteType = self.getConcreteTypeFromType(arrExpr.ty, concreteGenerics)
            val arrIrTy = self.getIrTypeForConcreteType(exprConcreteType)

            val arrItemConcreteType = try exprConcreteType.typeArgs[0] else unreachable("ConcreteType for array must have 1 type argument")
            val arrConcreteGenerics = { "T": arrItemConcreteType } // `T` is the known generic of `Array#set`

            val arraySetFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "set", staticMethod: false)
            val arraySetFnName = self.fnName(Some(exprConcreteType), arraySetFn, arrConcreteGenerics, [])
            self.enqueueFunction(arraySetFn, arraySetFnName, [], Some(exprConcreteType), arrConcreteGenerics)

            val optWrapperConcreteType = ConcreteType(instanceKind: InstanceKind.Enum(self.project.preludeOptionEnum), typeArgs: [arrItemConcreteType])
            val optWrapperIrTy = self.getIrTypeForConcreteType(optWrapperConcreteType)

            self.emit(Instruction(op: Operation.Call(ret: optWrapperIrTy, fnName: arraySetFnName, args: [arrVal, idxVal, res])))
          }
          TypedIndexingNode.Map(mapExpr, idxExpr) => {
            val idxVal = self.genExpression(idxExpr, concreteGenerics)

            val mapVal = self.genExpression(mapExpr, concreteGenerics)
            val mapConcreteType = self.getConcreteTypeFromType(mapExpr.ty, concreteGenerics)
            val mapIrTy = self.getIrTypeForConcreteType(mapConcreteType)

            val mapKeyConcreteType = try mapConcreteType.typeArgs[0] else unreachable("ConcreteType for map must have 2 type arguments")
            val mapValConcreteType = try mapConcreteType.typeArgs[1] else unreachable("ConcreteType for map must have 2 type arguments")
            val mapKeyIrTy = self.getIrTypeForConcreteType(mapKeyConcreteType)
            val mapValIrTy = self.getIrTypeForConcreteType(mapValConcreteType)

            val mapConcreteGenerics = { "K": mapKeyConcreteType, "V": mapValConcreteType } // `K`, and `V` are the known generics of `Map.insert`
            val mapInsertFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeMapStruct), "insert", staticMethod: false)
            val mapInsertFnName = self.fnName(Some(mapConcreteType), mapInsertFn, mapConcreteGenerics, [])
            self.enqueueFunction(mapInsertFn, mapInsertFnName, [], Some(mapConcreteType), mapConcreteGenerics)

            val optWrapperConcreteType = ConcreteType(instanceKind: InstanceKind.Enum(self.project.preludeOptionEnum), typeArgs: [mapValConcreteType])
            val optWrapperIrTy = self.getIrTypeForConcreteType(optWrapperConcreteType)

            self.emit(Instruction(op: Operation.Call(ret: optWrapperIrTy, fnName: mapInsertFnName, args: [mapVal, idxVal, res])))
          }
          TypedIndexingNode.Tuple => unreachable("cannot assign to tuple via indexing")
        }
      }
      TypedAssignmentMode.Accessor(head, middle, tail) => self.followAccessorPath(head, middle, tail, concreteGenerics, None, Some(res))
    }
  }

  func genExpression(self, node: tc.TypedAstNode, concreteGenerics: Map<String, ConcreteType>, dst: String? = None): Value {
    val pos = node.token.position

    match node.kind {
      TypedAstNodeKind.Literal(lit) => self.genLiteral(pos, lit, dst)
      TypedAstNodeKind.StringInterpolation(exprs) => self.genStringInterpolation(pos, concreteGenerics, exprs, dst)
      TypedAstNodeKind.Unary(op, expr) => self.genUnary(pos, concreteGenerics, dst, expr, op)
      TypedAstNodeKind.Binary(left, op, right) => self.genBinary(pos, concreteGenerics, dst, left, op, right)
      TypedAstNodeKind.Grouped(inner) => self.genExpression(inner, concreteGenerics, dst)
      TypedAstNodeKind.Identifier(name, variable, fnAliasTypeHint, varImportModule) => self.genIdentifier(pos, concreteGenerics, dst, name, variable, fnAliasTypeHint, varImportModule)
      TypedAstNodeKind.Accessor(head, middle, tail) => self.followAccessorPath(head, middle, tail, concreteGenerics, dst)
      TypedAstNodeKind.Invocation(invokee, args, resolvedGenerics) => {
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        for (name, ty) in resolvedGenerics.entries() {
          val concreteType = self.getConcreteTypeFromType(ty, concreteGenerics)
          newConcreteGenerics[name] = concreteType
        }
        self.genCall(pos, concreteGenerics, newConcreteGenerics, dst, invokee, args)
      }
      TypedAstNodeKind.Array(items) => self.genArray(pos, concreteGenerics, dst, node.ty, items)
      TypedAstNodeKind.Set => todo("genExpression: Set (${node.token})")
      TypedAstNodeKind.Map(items) => self.genMap(pos, concreteGenerics, dst, node.ty, items)
      TypedAstNodeKind.Tuple(items) => {
        val tupleStruct = self.tupleStruct(items.length)
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        val args: tc.TypedAstNode?[] = []
        for item, idx in items {
          args.push(Some(item))
          val itemConcreteType = self.getConcreteTypeFromType(item.ty, concreteGenerics)
          val tupleTypeParam = try tupleStruct.typeParams[idx] else unreachable("expected tuple type param at idx $idx")
          newConcreteGenerics[tupleTypeParam] = itemConcreteType
        }
        val invokee = tc.TypedInvokee.Struct(tupleStruct)

        self.genCall(pos, concreteGenerics, newConcreteGenerics, dst, invokee, args)
      }
      TypedAstNodeKind.Indexing(node) => self.genIndexing(pos, concreteGenerics, dst, node)
      TypedAstNodeKind.Lambda => todo("genExpression: Lambda (${node.token})")
      TypedAstNodeKind.If(isStatement, condNode, condBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if isStatement unreachable("unexpected if statement")

        val optInnerTy = self.project.typeIsOption(condNode.ty)
        val condBindingVal = self.genExpression(condNode, concreteGenerics)
        val condVal = if optInnerTy |innerTy| {
          val optIsNone = self.ssaValue(IrType.Bool, Operation.OptionIsNone(condBindingVal), None)
          self.ssaValue(IrType.Bool, Operation.Negate(optIsNone), None)
        } else {
          condBindingVal
        }

        if self.valueAsCompileTime(condVal) |cond| {
          val condVal = match cond { Const.Bool(b) => b, else => todo("non-boolean if-conditions") }
          val block = if condVal ifBlock else elseBlock
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)
          for node, idx in block {
            if idx == block.length - 1 && !ifBlockTerminator {
              return self.genExpression(node, concreteGenerics, dst)
            } else {
              self.genStatement(node, concreteGenerics)
            }
          }
          unreachable("should have returned above")
        }

        val ifBody = self.withinBlock("then", !!ifBlockTerminator, () => {
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)
          for node, idx in ifBlock {
            if idx == ifBlock.length - 1 && !ifBlockTerminator {
              return Some(self.genExpression(node, concreteGenerics))
            } else {
              self.genStatement(node, concreteGenerics)
            }
          }

          None
        })
        val elseBody = self.withinBlock("else", !!elseBlockTerminator, () => {
          for node, idx in elseBlock {
            if idx == elseBlock.length - 1 && !elseBlockTerminator {
              return Some(self.genExpression(node, concreteGenerics))
            } else {
              self.genStatement(node, concreteGenerics)
            }
          }

          None
        })

        val resConcreteType = self.getConcreteTypeFromType(node.ty, concreteGenerics)
        val resIrTy = self.getIrTypeForConcreteType(resConcreteType)
        self.ssaValue(resIrTy, Operation.If(resIrTy, condVal, ifBody, elseBody), dst)
      }
      else => todo("Other expressions (${node.token})")
    }
  }

  func genLiteral(self, pos: Position, lit: LiteralAstNode, dst: String?): Value {
    match lit {
      LiteralAstNode.Int(i) => self.ssaValueComptime(Const.Int(i), dst)
      LiteralAstNode.Float(f) => self.ssaValueComptime(Const.Float(f), dst)
      LiteralAstNode.Bool(b) => self.ssaValueComptime(Const.Bool(b), dst)
      LiteralAstNode.Char(c) => self.ssaValueComptime(Const.Char(c), dst)
      LiteralAstNode.String(s) => self.ssaValueComptime(Const.String(s), dst)
    }
  }

  func genStringInterpolation(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, exprs: tc.TypedAstNode[], dst: String?): Value {
    val strIrTy = IrType.Composite(self.knowns.stringType().name)

    var allComptime = true
    val comptimeStrings: String[] = []
    val exprVals: Value[] = []
    for expr in exprs {
      val exprVal = self.genExpression(expr, concreteGenerics)
      if allComptime {
        if self.valueAsCompileTime(exprVal) |exprVal| {
          val str = match exprVal {
            Const.Int(i) => i.toString()
            Const.Float(f) => f.toString()
            Const.Bool(b) => b.toString()
            Const.Char(c) => Char.fromInt(c).toString()
            Const.String(s) => s
          }
          comptimeStrings.push(str)
        } else {
          allComptime = false
        }
      }
      exprVals.push(exprVal)
    }

    if allComptime return Value.Const(Const.String(comptimeStrings.join()))

    val toStringVals: (Value, Value)[] = []
    var totalLenVal = Value.Const(Const.Int(0))
    for exprVal in exprVals {
      val toStringVal = if self.getValueTy(exprVal) == strIrTy { exprVal } else self.genCallToStringMethod(exprVal)

      if exprVals.length == 1 return toStringVal

      val strLenVal = self.ssaValue(IrType.I64, Operation.LoadField(ty: IrType.I64, mem: toStringVal, name: "length", offset: 0), None)
      val strBufVal = self.ssaValue(IrType.Ptr, Operation.LoadField(ty: IrType.Ptr, mem: toStringVal, name: "_buffer", offset: 8), None)
      toStringVals.push((strLenVal, strBufVal))

      totalLenVal = self.ssaValue(IrType.I64, Operation.Add(totalLenVal, strLenVal), None)
    }

    val lenPlusOneVal = self.ssaValue(IrType.I64, Operation.Add(Value.Const(Const.Int(1)), totalLenVal), None) // account for NULL
    val totalBufVal = self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.Malloc(count: lenPlusOneVal, itemTy: Some(IrType.Byte))), None)
    var cursor = Value.Const(Const.Int(0))
    for (strLenVal, strBufVal) in toStringVals {
      val builtin = Builtin.CopyFrom(dst: totalBufVal, dstOffset: cursor, src: strBufVal, srcOffset: Value.Const(Const.Int(0)), size: strLenVal, itemTy: IrType.Byte)
      self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: builtin)))

      cursor = self.ssaValue(IrType.I64, Operation.Add(cursor, strLenVal), None)
    }

    val strInitFn = self.knowns.stringInitializerFn()

    self.ssaValue(strIrTy, Operation.Call(ret: strIrTy, fnName: strInitFn.name, args: [totalLenVal, totalBufVal]), dst)
  }

  func genUnary(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, expr: tc.TypedAstNode, op: UnaryOp): Value {
    val exprVal = self.genExpression(expr, concreteGenerics)

    match op {
      UnaryOp.Minus => {
        if self.valueAsCompileTime(exprVal) |exprVal| {
          return match exprVal {
            Const.Int(v) => self.ssaValueComptime(Const.Int(-v), dst)
            Const.Float(v) => self.ssaValueComptime(Const.Float(-v), dst)
            else => unreachable("[genUnary minus]: unexpected const value ($exprVal)")
          }
        }

        self.ssaValue(self.getValueTy(exprVal), Operation.Minus(exprVal), dst)
      }
      UnaryOp.Negate => {
        if self.valueAsCompileTime(exprVal) |exprVal| {
          return match exprVal {
            Const.Bool(v) => self.ssaValueComptime(Const.Bool(!v), dst)
            else => unreachable("[genUnary negate]: unexpected const value ($exprVal)")
          }
        }

        self.ssaValue(IrType.Bool, Operation.Negate(exprVal), dst)
      }
    }
  }

  func genBinary(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, left: tc.TypedAstNode, op: BinaryOp, right: tc.TypedAstNode): Value {
    match op {
      BinaryOp.Add => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        val strTy = IrType.Composite(self.knowns.stringType().name)
        val lvalTy = self.getValueTy(lval)
        val rvalTy = self.getValueTy(rval)
        if lvalTy == strTy || rvalTy == strTy {
          if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
            val constStr = match lval {
              Const.Int(l) => match rval { Const.String(r) => l + r, else => unreachable() }
              Const.Float(l) => match rval { Const.String(r) => l + r, else => unreachable() }
              Const.Bool(l) => match rval { Const.String(r) => l + r, else => unreachable() }
              Const.Char(l) => match rval { Const.String(r) => l + r, else => unreachable() }
              Const.String(l) => match rval {
                Const.Int(r) => l + r
                Const.Float(r) => l + r
                Const.Bool(r) => l + r
                Const.Char(r) => l + r
                Const.String(r) => l + r
              }
            }

            return self.ssaValueComptime(Const.String(constStr), dst)
          }

          val lStrVal = if lvalTy == strTy { lval } else self.genCallToStringMethod(lval, dst)
          val rStrVal = if rvalTy == strTy { rval } else self.genCallToStringMethod(rval, dst)

          val strConcreteTy = ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeStringStruct))
          val concatFn = self.getMethodByName(strConcreteTy.instanceKind, "concat", staticMethod: false)
          val concatFnName = self.fnName(Some(strConcreteTy), concatFn, {}, [])
          self.enqueueFunction(concatFn, concatFnName, [], Some(strConcreteTy), {})

          return self.ssaValue(strTy, Operation.Call(ret: strTy, fnName: concatFnName, args: [lStrVal, rStrVal]), dst)
        }

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Int(l + r)
              Const.Float(r) => Const.Float(l + r)
              else => unreachable("[genBinary add]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Float(l + r)
              Const.Float(r) => Const.Float(l + r)
              else => unreachable("[genBinary add]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary add]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        val resTy = if lvalTy == IrType.F64 || rvalTy == IrType.F64 { IrType.F64 } else { IrType.I64 }
        self.ssaValue(resTy, Operation.Add(lval, rval), dst)
      }
      BinaryOp.Sub => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Int(l - r)
              Const.Float(r) => Const.Float(l - r)
              else => unreachable("[genBinary sub]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Float(l - r)
              Const.Float(r) => Const.Float(l - r)
              else => unreachable("[genBinary sub]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary sub]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        val resTy = if self.getValueTy(lval) == IrType.F64 || self.getValueTy(rval) == IrType.F64 { IrType.F64 } else { IrType.I64 }
        self.ssaValue(resTy, Operation.Sub(lval, rval), dst)
      }
      BinaryOp.Mul => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Int(l * r)
              Const.Float(r) => Const.Float(l * r)
              else => unreachable("[genBinary mul]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Float(l * r)
              Const.Float(r) => Const.Float(l * r)
              else => unreachable("[genBinary mul]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary mul]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        val resTy = if self.getValueTy(lval) == IrType.F64 || self.getValueTy(rval) == IrType.F64 { IrType.F64 } else { IrType.I64 }
        self.ssaValue(resTy, Operation.Mul(lval, rval), dst)
      }
      BinaryOp.Div => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val float = match lval {
            Const.Int(l) => match rval { Const.Int(r) => l / r, Const.Float(r) => l / r, else => unreachable("[genBinary div]: unexpected const value ($rval)") }
            Const.Float(l) => match rval { Const.Int(r) => l / r, Const.Float(r) => l / r, else => unreachable("[genBinary div]: unexpected const value ($rval)") }
            else => unreachable("[genBinary div]: unexpected const value ($lval)")
          }
          val const = Const.Float(float)

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.F64, Operation.Div(lval, rval), dst)
      }
      BinaryOp.Mod => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Int(l % r)
              Const.Float(r) => Const.Float(l % r)
              else => unreachable("[genBinary mod]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Float(l % r)
              Const.Float(r) => Const.Float(l % r)
              else => unreachable("[genBinary mod]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary mod]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        val resTy = if self.getValueTy(lval) == IrType.I64 && self.getValueTy(rval) == IrType.I64 { IrType.I64 } else { IrType.F64 }
        self.ssaValue(resTy, Operation.Mod(lval, rval), dst)
      }
      BinaryOp.Pow => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val float = match lval {
            Const.Int(l) => match rval { Const.Int(r) => l ** r, Const.Float(r) => l ** r, else => unreachable("[genBinary pow]: unexpected const value ($rval)") }
            Const.Float(l) => match rval { Const.Int(r) => l ** r, Const.Float(r) => l ** r, else => unreachable("[genBinary pow]: unexpected const value ($rval)") }
            else => unreachable("[genBinary pow]: unexpected const value ($lval)")
          }
          val const = Const.Float(float)

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.F64, Operation.Pow(lval, rval), dst)
      }
      BinaryOp.And => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genCompoundValue(() => self.genExpression(right, concreteGenerics))
        val lvalTy = self.getValueTy(lval)
        val rvalTy = self.getValueTy(rval.result)

        if self.valuesAsCompileTime(lval, rval.result) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval { Const.Int(r) => Const.Int(l && r), else => unreachable("[genBinary bit-and]: unexpected const value ($rval)") }
            Const.Bool(l) => match rval { Const.Bool(r) => Const.Bool(l && r), else => unreachable("[genBinary bool-and]: unexpected const value ($rval)") }
            else => unreachable("[genBinary and]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        if lvalTy == IrType.I64 && rvalTy == IrType.I64 {
          for inst in rval.body {
            self.emit(inst)
          }
          self.ssaValue(IrType.I64, Operation.BitAnd(lval, rval.result), dst)
        } else {
          self.ssaValue(IrType.Bool, Operation.BoolAnd(lval, rval), dst)
        }
      }
      BinaryOp.Or => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genCompoundValue(() => self.genExpression(right, concreteGenerics))
        val lvalTy = self.getValueTy(lval)
        val rvalTy = self.getValueTy(rval.result)

        if self.valuesAsCompileTime(lval, rval.result) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval { Const.Int(r) => Const.Int(l || r), else => unreachable("[genBinary bit-or]: unexpected const value ($rval)") }
            Const.Bool(l) => match rval { Const.Bool(r) => Const.Bool(l || r), else => unreachable("[genBinary bool-or]: unexpected const value ($rval)") }
            else => unreachable("[genBinary or]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        if lvalTy == IrType.I64 && rvalTy == IrType.I64 {
          for inst in rval.body {
            self.emit(inst)
          }
          self.ssaValue(IrType.I64, Operation.BitOr(lval, rval.result), dst)
        } else {
          self.ssaValue(IrType.Bool, Operation.BoolOr(lval, rval), dst)
        }
      }
      BinaryOp.Xor => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)
        val lvalTy = self.getValueTy(lval)
        val rvalTy = self.getValueTy(rval)

        val bitwise = lvalTy == IrType.I64 && rvalTy == IrType.I64
        val retTy = if bitwise { IrType.I64 } else { IrType.Bool }
        self.ssaValue(retTy, Operation.Xor(bitwise, lval, rval), dst)
      }
      BinaryOp.Coalesce => todo("genBinary: BinaryOp.Coalesce")
      BinaryOp.Eq => self.genEq(concreteGenerics, left, right, false, dst)
      BinaryOp.Neq => self.genEq(concreteGenerics, left, right, true, dst)
      BinaryOp.LT => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Bool(l < r)
              Const.Float(r) => Const.Bool(l < r)
              else => unreachable("[genBinary lt]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Bool(l < r)
              Const.Float(r) => Const.Bool(l < r)
              else => unreachable("[genBinary lt]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary lt]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Lt(lval, rval), dst)
      }
      BinaryOp.LTE => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Bool(l <= r)
              Const.Float(r) => Const.Bool(l <= r)
              else => unreachable("[genBinary lte]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Bool(l <= r)
              Const.Float(r) => Const.Bool(l <= r)
              else => unreachable("[genBinary lte]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary lte]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Lte(lval, rval), dst)
      }
      BinaryOp.Shl => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval { Const.Int(r) => Const.Int(l << r), else => unreachable("[genBinary shl]: unexpected const value ($rval)") }
            else => unreachable("[genBinary shl]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Shl(lval, rval), dst)
      }
      BinaryOp.GT => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Bool(l > r)
              Const.Float(r) => Const.Bool(l > r)
              else => unreachable("[genBinary gt]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Bool(l > r)
              Const.Float(r) => Const.Bool(l > r)
              else => unreachable("[genBinary gt]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary gt]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Gt(lval, rval), dst)
      }
      BinaryOp.GTE => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Bool(l >= r)
              Const.Float(r) => Const.Bool(l >= r)
              else => unreachable("[genBinary gte]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Bool(l >= r)
              Const.Float(r) => Const.Bool(l >= r)
              else => unreachable("[genBinary gte]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary gte]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Gte(lval, rval), dst)
      }
      BinaryOp.Shr => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval { Const.Int(r) => Const.Int(l >> r), else => unreachable("[genBinary shr]: unexpected const value ($rval)") }
            else => unreachable("[genBinary shr]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Shr(lval, rval), dst)
      }
    }
  }

  func genEq(self, concreteGenerics: Map<String, ConcreteType>, left: tc.TypedAstNode, right: tc.TypedAstNode, negate: Bool, dst: String?): Value {
    val leftConcreteType = self.getConcreteTypeFromType(left.ty, concreteGenerics)
    val leftIrTy = self.getIrTypeForConcreteType(leftConcreteType)
    val rightConcreteType = self.getConcreteTypeFromType(right.ty, concreteGenerics)
    val rightIrTy = self.getIrTypeForConcreteType(rightConcreteType)
    if leftIrTy != rightIrTy unreachable("equality operators require matching types")

    val lval = self.genExpression(left, concreteGenerics)
    val rval = self.genExpression(right, concreteGenerics)

    self.genEqLogic(leftConcreteType, lval, rval, negate, dst)
  }

  func genEqLogic(self, concreteType: ConcreteType, left: Value, right: Value, negate: Bool, dst: String?): Value {
    if self.valuesAsCompileTime(left, right) |(lval, rval)| {
      val const = match lval {
        Const.Int(l) => match rval { Const.Int(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
        Const.Float(l) => match rval { Const.Float(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
        Const.Bool(l) => match rval { Const.Bool(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
        Const.Char(l) => match rval { Const.Char(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
        Const.String(l) => match rval { Const.String(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
      }

      return self.ssaValueComptime(const, dst)
    }

    val irTy = self.getIrTypeForConcreteType(concreteType)
    val op = if irTy == IrType.I64 || irTy == IrType.F64 || irTy == IrType.Bool || irTy == IrType.Byte {
      Operation.Eq(negate: negate, left, right)
    } else {
      val newConcreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
      val eqFn = self.getMethodByName(concreteType.instanceKind, "eq", staticMethod: false)
      val eqFnName = self.fnName(Some(concreteType), eqFn, newConcreteGenerics, [])
      self.enqueueFunction(eqFn, eqFnName, [], Some(concreteType), newConcreteGenerics)

      val op = Operation.Call(ret: IrType.Bool, fnName: eqFnName, args: [left, right])

      if negate {
        Operation.Negate(self.ssaValue(IrType.Bool, op, None))
      } else {
        op
      }
    }

    self.ssaValue(IrType.Bool, op, dst)
  }

  func intrinsicArgs1(self, name: String, arguments: tc.TypedAstNode?[]): tc.TypedAstNode {
    val arg0 = try arguments[0] else unreachable("'$name' has 1 required argument")
    try arg0 else unreachable("'$name' has 1 required argument")
  }

  func intrinsicArgs2(self, name: String, arguments: tc.TypedAstNode?[]): (tc.TypedAstNode, tc.TypedAstNode) {
    val _arg0 = try arguments[0] else unreachable("'$name' has 2 required arguments")
    val arg0 = try _arg0 else unreachable("'$name' has 2 required arguments")

    val _arg1 = try arguments[1] else unreachable("'$name' has 2 required arguments")
    val arg1 = try _arg1 else unreachable("'$name' has 2 required arguments")

    (arg0, arg1)
  }

  func intrinsicArgs4(self, name: String, arguments: tc.TypedAstNode?[]): (tc.TypedAstNode, tc.TypedAstNode, tc.TypedAstNode, tc.TypedAstNode) {
    val _arg0 = try arguments[0] else unreachable("'$name' has 4 required arguments")
    val arg0 = try _arg0 else unreachable("'$name' has 4 required arguments")

    val _arg1 = try arguments[1] else unreachable("'$name' has 4 required arguments")
    val arg1 = try _arg1 else unreachable("'$name' has 4 required arguments")

    val _arg2 = try arguments[2] else unreachable("'$name' has 4 required arguments")
    val arg2 = try _arg2 else unreachable("'$name' has 4 required arguments")

    val _arg3 = try arguments[3] else unreachable("'$name' has 4 required arguments")
    val arg3 = try _arg3 else unreachable("'$name' has 4 required arguments")

    (arg0, arg1, arg2, arg3)
  }

  func genCall(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, innerConcreteGenerics: Map<String, ConcreteType>, dst: String?, invokee: tc.TypedInvokee, args: tc.TypedAstNode?[]): Value {
    val argValues: Value[] = []

    val (fnName, returnType) = match invokee {
      TypedInvokee.Function(fn) => {
        if self.getExternDecName(fn) |fnName| {
          self.enqueueFunction(fn, fnName, [], None, {})
          val concreteReturnType = if fn.returnType.kind == tc.TypeKind.PrimitiveUnit {
            None
          } else {
            Some(self.getConcreteTypeFromType(fn.returnType, innerConcreteGenerics))
          }
          (fnName, concreteReturnType)
        } else if self.getIntrinsicDecName(fn) |intrinsicName| {
          return match intrinsicName {
            "pointer_malloc" => {
              val count = self.genExpression(self.intrinsicArgs1("pointer_malloc", args), innerConcreteGenerics)
              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_malloc) could not resolve T for Pointer<T>"))

              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.Malloc(count: count, itemTy: Some(itemTy))), dst)
            }
            "byte_from_int" => {
              val arg = self.intrinsicArgs1("byte_from_int", args)
              self.genExpression(arg, innerConcreteGenerics, dst)
            }
            "char_as_int" => {
              val arg = self.intrinsicArgs1("char_as_int", args)
              self.genExpression(arg, innerConcreteGenerics, dst)
            }
            "int_as_float" => {
              val arg = self.intrinsicArgs1("int_as_float", args)
              val intVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.F64, builtin: Builtin.IntAsFloat(intVal)), dst)
            }
            "float_as_int" => {
              val arg = self.intrinsicArgs1("float_as_int", args)
              val floatVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.I64, builtin: Builtin.FloatAsInt(floatVal)), dst)
            }
            "float_ceil" => {
              val arg = self.intrinsicArgs1("float_ceil", args)
              val floatVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.I64, builtin: Builtin.FloatCeil(floatVal)), dst)
            }
            "float_floor" => {
              val arg = self.intrinsicArgs1("float_floor", args)
              val floatVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.I64, builtin: Builtin.FloatFloor(floatVal)), dst)
            }
            "float_round" => {
              val arg = self.intrinsicArgs1("float_round", args)
              val floatVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.I64, builtin: Builtin.FloatRound(floatVal)), dst)
            }
            "u64_to_string" => {
              val arg = self.intrinsicArgs1("u64_to_string", args)
              val u64Val = self.genExpression(arg, innerConcreteGenerics, dst)

              val strTy = IrType.Composite(self.knowns.stringType().name)
              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: strTy, builtin: Builtin.U64ToString(u64Val)), dst)
            }
            "uninitialized" => {
              val innerTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_malloc) could not resolve T for Pointer<T>"))
              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: innerTy, builtin: Builtin.Uninitialized), dst)
            }
            else => todo("Unimplemented static/standalone intrinsic '$intrinsicName'")
          }
        } else {
          // todo: check for closure

          val paramsNeedingDefaultValue = args.map((arg, idx) => !!fn.params[idx]?.defaultValue && !arg)
          val fnName = self.fnName(None, fn, innerConcreteGenerics, paramsNeedingDefaultValue)
          self.enqueueFunction(fn, fnName, paramsNeedingDefaultValue, None, innerConcreteGenerics)

          val concreteReturnType = if fn.returnType.kind == tc.TypeKind.PrimitiveUnit {
            None
          } else {
            Some(self.getConcreteTypeFromType(fn.returnType, innerConcreteGenerics))
          }
          (fnName, concreteReturnType)
        }
      }
      TypedInvokee.Method(fn, selfVal, isOptSafe) => {
        if self.getExternDecName(fn) |fnName| {
          todo("Unimplemented external method '$fnName'")
        } else if self.getIntrinsicDecName(fn) |intrinsicName| {
          return match intrinsicName {
            "pointer_realloc" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val count = self.intrinsicArgs1("pointer_realloc", args)

              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_realloc) could not resolve T for Pointer<T>"))
              val countVal = self.genExpression(count, innerConcreteGenerics)

              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.Realloc(ptr: ptrVal, count: countVal, itemTy: Some(itemTy))), dst)
            }
            "pointer_store_at" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val (value, offset) = self.intrinsicArgs2("pointer_store_at", args)

              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_store) could not resolve T for Pointer<T>"))
              val valueVal = self.genExpression(value, innerConcreteGenerics)
              val offsetVal = self.genExpression(offset, innerConcreteGenerics)

              self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: Builtin.Store(ptr: ptrVal, value: valueVal, offset: offsetVal, itemTy: itemTy))))
              Value.Unit
            }
            "pointer_load_at" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val offset = self.intrinsicArgs1("pointer_load_at", args)

              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_load) could not resolve T for Pointer<T>"))
              val offsetVal = self.genExpression(offset, innerConcreteGenerics)

              self.ssaValue(itemTy, Operation.Builtin(ret: itemTy, builtin: Builtin.Load(ptr: ptrVal, offset: offsetVal, itemTy: itemTy)), dst)
            }
            "pointer_copy_from" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val (dstOffset, src, srcOffset, size) = self.intrinsicArgs4("pointer_copy_from", args)

              val dstOffsetVal = self.genExpression(dstOffset, innerConcreteGenerics)
              val srcVal = self.genExpression(src, innerConcreteGenerics)
              val srcOffsetVal = self.genExpression(srcOffset, innerConcreteGenerics)
              val sizeVal = self.genExpression(size, innerConcreteGenerics)

              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_copy_from) could not resolve T for Pointer<T>"))

              val builtin = Builtin.CopyFrom(dst: ptrVal, dstOffset: dstOffsetVal, src: srcVal, srcOffset: srcOffsetVal, size: sizeVal, itemTy: itemTy)
              self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: builtin)))
              Value.Unit
            }
            "byte_as_int" => {
              self.genExpression(selfVal, concreteGenerics)
            }
            else => todo("Unimplemented method intrinsic '$intrinsicName'")
          }
        } else {
          // todo: check for closure

          val paramsNeedingDefaultValue = args.map((arg, idx) => !!fn.params[idx]?.defaultValue && !arg)
          val selfConcreteType = self.getConcreteTypeFromType(selfVal.ty, concreteGenerics)
          val method = match selfVal.ty.kind {
            TypeKind.Generic => {
              if fn.label.name == "toString" || fn.label.name == "eq" || fn.label.name == "hash" {
                self.getMethodByName(selfConcreteType.instanceKind, fn.label.name, staticMethod: false)
              } else {
                unreachable("no other methods can exist on a value of generic type")
              }
            }
            else => fn
          }
          val fnName = self.fnName(Some(selfConcreteType), method, innerConcreteGenerics, paramsNeedingDefaultValue)
          self.enqueueFunction(method, fnName, paramsNeedingDefaultValue, Some(selfConcreteType), innerConcreteGenerics)

          argValues.push(self.genExpression(selfVal, concreteGenerics))

          val concreteReturnType = if method.returnType.kind == tc.TypeKind.PrimitiveUnit {
            None
          } else {
            Some(self.getConcreteTypeFromType(method.returnType, innerConcreteGenerics))
          }
          (fnName, concreteReturnType)
        }
      }
      TypedInvokee.Struct(s) => {
        val typeArgs: ConcreteType[] = []
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        for tp in s.typeParams {
          val concreteGeneric = try innerConcreteGenerics[tp] else unreachable("Could not resolve generic '$tp' for struct initializer '${s.label.name}'")
          typeArgs.push(concreteGeneric)
          newConcreteGenerics[tp] = concreteGeneric
        }
        val concreteType = ConcreteType(instanceKind: InstanceKind.Struct(s), typeArgs: typeArgs)

        val fieldsNeedingDefaultValue = args.map((arg, idx) => !!s.fields[idx]?.initializer && !arg)
        val fnName = self.structInitFnName(concreteType, fieldsNeedingDefaultValue)
        self.enqueueInitializer(concreteType, None, fnName, fieldsNeedingDefaultValue, None, newConcreteGenerics)

        (fnName, Some(concreteType))
      }
      TypedInvokee.EnumVariant(enum_, variant) => {
        val typeArgs: ConcreteType[] = []
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        for tp in enum_.typeParams {
          val concreteGeneric = try innerConcreteGenerics[tp] else unreachable("Could not resolve generic '$tp' for struct initializer '${enum_.label.name}'")
          typeArgs.push(concreteGeneric)
          newConcreteGenerics[tp] = concreteGeneric
        }
        val concreteType = ConcreteType(instanceKind: InstanceKind.Enum(enum_), typeArgs: typeArgs)

        if enum_ == self.project.preludeOptionEnum {
          if variant.label.name != "Some" unreachable()

          val arg = try try args[0] else unreachable() else unreachable() // ew lol
          val argVal = self.genExpression(arg, concreteGenerics)

          val irType = self.getIrTypeForConcreteType(concreteType)
          val typeArg = try concreteType.typeArgs[0] else unreachable()
          val typeArgIrType = self.getIrTypeForConcreteType(typeArg)
          return self.ssaValue(irType, Operation.OptionSome(typeArgIrType, argVal), dst)
        }

        val fields = match variant.kind {
          EnumVariantKind.Constant => unreachable("cannot invoke constant enum variant")
          EnumVariantKind.Container(fields) => fields
        }

        val fieldsNeedingDefaultValue = args.map((arg, idx) => !!fields[idx]?.initializer && !arg)
        val fnName = self.enumVariantInitFnName(concreteType, variant, fieldsNeedingDefaultValue)
        self.enqueueInitializer(concreteType, Some(variant), fnName, fieldsNeedingDefaultValue, None, newConcreteGenerics)

        (fnName, Some(concreteType))
      }
      else => todo("other TypedInvokee types")
    }

    for arg in args {
      if arg |arg| {
        argValues.push(self.genExpression(arg, concreteGenerics))
      }
    }

    if returnType |concreteReturnType| {
      val retTy = self.getIrTypeForConcreteType(concreteReturnType)

      self.ssaValue(retTy, Operation.Call(ret: retTy, fnName: fnName, args: argValues), dst)
    } else {
      val op = Operation.Call(ret: IrType.Unit, fnName: fnName, args: argValues)
      self.emit(Instruction(op: op))

      Value.Unit
    }
  }

  func genIdentifier(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, name: String, variable: tc.Variable, fnAliasTypeHint: tc.Type?, varImportModule: tc.TypedModule?): Value {
    val varConcreteType = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varTy = self.getIrTypeForConcreteType(varConcreteType)

    if variable.isParameter {
      // todo: handle whether variable is captured

      return Value.Ident(ident: Ident(ty: varTy, kind: IdentKind.Named(name)))
    }

    match variable.alias {
      VariableAlias.Function => todo("genIdentifier VariableAlias.Function")
      else => {
        if varImportModule |mod| {
          val globalName = self.globalName(mod.id, variable.label.name)
          val global = self.getGlobal(globalName, pos)
          if global.initialValue |v| {
            Value.Const(v)
          } else {
            global.referenced = true
            Value.Global(global)
          }
        } else if self.variableIsGlobal(variable) |modId| {
          val globalName = self.globalName(modId, variable.label.name)
          val global = self.getGlobal(globalName, pos)
          if global.initialValue |v| {
            Value.Const(v)
          } else {
            global.referenced = true
            Value.Global(global)
          }
        } else if variable.isCaptured {
          // Note: captured top-level variables are "global" and are handled above; variables handled here are not top-level
          todo("genIdentifier captured variable")
        } else if variable.mutable {
          val varName = if variable.scope.idxInFn |idx| "_${name}_${idx}" else name
          val slot = self.curCtx.getLocal(varName, pos)
          // val slot = Value.Ident(ident)
          self.ssaValue(varTy, Operation.Load(ty: varTy, mem: slot), dst)
        } else {
          val varName = if variable.scope.idxInFn |idx| "_${name}_${idx}" else name
          self.curCtx.getLocal(varName, pos)
          // Value.Ident(ident)
        }
      }
    }
  }

  func followAccessorPath(self, head: tc.TypedAstNode, middle: tc.AccessorPathSegment[], tail: tc.AccessorPathSegment, concreteGenerics: Map<String, ConcreteType>, dst: String?, storeVal: Value? = None): Value {
    val segs = middle.concat([tail])

    var (workingVal, concreteType) = match segs[0] {
      AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => {
        match variant.kind {
          EnumVariantKind.Container => unreachable("non-constant enum variant missing instantation")
          _ => {}
        }

        val concreteType = self.getConcreteTypeFromType(ty, concreteGenerics)
        val (_, variantIdx) = try enum_.variants.findIndex(v => v.label.name == variant.label.name) else unreachable("${enum_.label.name}.${variant.label.name} must exist")
        val variantVal = if enum_ == self.project.preludeOptionEnum {
          if variant.label.name != "None" unreachable()

          val irType = self.getIrTypeForConcreteType(concreteType)
          val typeArg = try concreteType.typeArgs[0] else unreachable()
          val typeArgIrType = self.getIrTypeForConcreteType(typeArg)
          self.ssaValue(irType, Operation.OptionNone(typeArgIrType), dst)
        } else {
          val global = self.getOrAddConstEnumVariant(concreteType, variant, variantIdx)
          global.initialValue = Some(Const.Int(variantIdx))
          global.referenced = true
          Value.Global(global)
        }

        (variantVal, concreteType)
      }
      else => {
        val concreteType = self.getConcreteTypeFromType(head.ty, concreteGenerics)
        val headVal = self.genExpression(head, concreteGenerics)

        (headVal, concreteType)
      }
    }

    var resVal = Value.Unit

    for seg, idx in segs {
      match seg {
        AccessorPathSegment.EnumVariant => {
          if idx != segs.length - 1 unreachable("enum variant must be in first position")
          if storeVal |res| unreachable("cannot store into enum variant")

          resVal = workingVal
          break
        }
        AccessorPathSegment.Method => todo("followAccessorPath: methods")
        AccessorPathSegment.Field(label, ty, field, isOptSafe) => {
          if isOptSafe todo()

          match concreteType.instanceKind {
            InstanceKind.Struct(struct) => {
              val (f, fieldIdx) = try struct.fields.findIndex(f => f.name.name == field.name.name) else unreachable("no such field '${field.name.name}'")
              val offset = fieldIdx * 8 // TODO: don't assume 8 byte alignment for all fields
              val fieldConcreteType = self.getConcreteTypeFromType(f.ty, concreteGenerics)
              val fieldTy = self.getIrTypeForConcreteType(fieldConcreteType)

              if idx == segs.length - 1 {
                resVal = if storeVal |res| {
                  self.emit(Instruction(op: Operation.StoreField(ty: fieldTy, value: res, mem: workingVal, name: f.name.name, offset: offset)))
                  Value.Unit
                } else {
                  self.ssaValue(fieldTy, Operation.LoadField(ty: fieldTy, mem: workingVal, name: f.name.name, offset: offset), dst)
                }
                break
              }

              workingVal = self.ssaValue(fieldTy, Operation.LoadField(ty: fieldTy, mem: workingVal, name: f.name.name, offset: offset), None)
              concreteType = self.getConcreteTypeFromType(ty, concreteGenerics)
            }
            InstanceKind.Enum => todo("enum field accessor")
          }
        }
      }
    }

    resVal
  }

  func genArray(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, arrayTy: tc.Type, items: tc.TypedAstNode[]): Value {
    val arrayConcreteType = self.getConcreteTypeFromType(arrayTy, concreteGenerics)
    val arrayItemConcreteType = try arrayConcreteType.typeArgs[0] else unreachable("ConcreteType for array must have 1 type argument")

    val arrayItemIrTy = self.getIrTypeForConcreteType(arrayItemConcreteType)
    val values = items.map(item => self.genExpression(item, concreteGenerics))

    self.generateArrayWithItems(pos, arrayItemConcreteType, dst, values)
  }

  func genMap(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, mapTy: tc.Type, items: (tc.TypedAstNode, tc.TypedAstNode)[]): Value {
    val mapConcreteType = self.getConcreteTypeFromType(mapTy, concreteGenerics)
    val mapIrTy = self.getIrTypeForConcreteType(mapConcreteType)
    val mapKeyConcreteType = try mapConcreteType.typeArgs[0] else unreachable("ConcreteType for map must have 2 type arguments")
    val mapValConcreteType = try mapConcreteType.typeArgs[1] else unreachable("ConcreteType for map must have 2 type arguments")
    val mapKeyIrTy = self.getIrTypeForConcreteType(mapKeyConcreteType)
    val mapValIrTy = self.getIrTypeForConcreteType(mapValConcreteType)

    val mapConcreteGenerics = { "K": mapKeyConcreteType, "V": mapValConcreteType } // `K`, and `V` are the known generics of `Map.new`
    val mapNewFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeMapStruct), "new", staticMethod: true)
    val mapNewFnName = self.fnName(None, mapNewFn, mapConcreteGenerics, [true])
    self.enqueueFunction(mapNewFn, mapNewFnName, [true], None, mapConcreteGenerics)

    val mapVal = self.ssaValue(mapIrTy, Operation.Call(ret: mapIrTy, fnName: mapNewFnName, args: []), None)

    if !items.isEmpty() {
      val mapInsertFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeMapStruct), "insert", staticMethod: false)
      val mapInsertFnName = self.fnName(Some(mapConcreteType), mapInsertFn, mapConcreteGenerics, [])
      self.enqueueFunction(mapInsertFn, mapInsertFnName, [], Some(mapConcreteType), mapConcreteGenerics)

      for (k, v) in items {
        val keyVal = self.genExpression(k, mapConcreteGenerics)
        val valVal = self.genExpression(v, mapConcreteGenerics)
        self.emit(Instruction(op: Operation.Call(ret: IrType.Unit, fnName: mapInsertFnName, args: [mapVal, keyVal, valVal])))
      }
    }

    mapVal
  }

  func genIndexing(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, node: tc.TypedIndexingNode): Value {
    match node {
      TypedIndexingNode.ArrayLike(expr, mode) => {
        val exprVal = self.genExpression(expr, concreteGenerics)
        val exprConcreteType = self.getConcreteTypeFromType(expr.ty, concreteGenerics)
        val exprIrTy = self.getIrTypeForConcreteType(exprConcreteType)

        match mode {
          IndexingMode.Single(idxExpr) => {
            val idxVal = self.genExpression(idxExpr, concreteGenerics)

            if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeArrayStruct) {
              val arrItemConcreteType = try exprConcreteType.typeArgs[0] else unreachable("ConcreteType for array must have 1 type argument")
              val arrConcreteGenerics = { "T": arrItemConcreteType } // `T` is the known generic of `Array#get`

              val arrayGetFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "get", staticMethod: false)
              val arrayGetFnName = self.fnName(Some(exprConcreteType), arrayGetFn, arrConcreteGenerics, [])
              self.enqueueFunction(arrayGetFn, arrayGetFnName, [], Some(exprConcreteType), arrConcreteGenerics)

              val optWrapperConcreteType = ConcreteType(instanceKind: InstanceKind.Enum(self.project.preludeOptionEnum), typeArgs: [arrItemConcreteType])
              val optWrapperIrTy = self.getIrTypeForConcreteType(optWrapperConcreteType)

              self.ssaValue(optWrapperIrTy, Operation.Call(ret: optWrapperIrTy, fnName: arrayGetFnName, args: [exprVal, idxVal]), dst)
            } else if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeStringStruct) {
              val stringGetFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeStringStruct), "get", staticMethod: false)
              val stringGetFnName = self.fnName(Some(exprConcreteType), stringGetFn, {}, [])
              self.enqueueFunction(stringGetFn, stringGetFnName, [], Some(exprConcreteType), {})

              self.ssaValue(exprIrTy, Operation.Call(ret: exprIrTy, fnName: stringGetFnName, args: [exprVal, idxVal]), dst)
            } else {
              unreachable("unsupported type for indexing operator")
            }
          }
          IndexingMode.Range(startExpr, endExpr) => {
            val startVal = if startExpr |startExpr| Some(self.genExpression(startExpr, concreteGenerics)) else None
            val endVal = if endExpr |endExpr| Some(self.genExpression(endExpr, concreteGenerics)) else None

            val paramsNeedingDefaultValue = [!startVal, !endVal]
            val fnName = if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeArrayStruct) {
              val arrItemConcreteType = try exprConcreteType.typeArgs[0] else unreachable("ConcreteType for array must have 1 type argument")
              val arrConcreteGenerics = { "T": arrItemConcreteType } // `T` is the known generic of `Array#getRange`

              val arrayGetRangeFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "getRange", staticMethod: false)
              val arrayGetRangeFnName = self.fnName(Some(exprConcreteType), arrayGetRangeFn, arrConcreteGenerics, paramsNeedingDefaultValue)
              self.enqueueFunction(arrayGetRangeFn, arrayGetRangeFnName, paramsNeedingDefaultValue, Some(exprConcreteType), arrConcreteGenerics)

              arrayGetRangeFnName
            } else if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeArrayStruct) {
              val stringGetRangeFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeStringStruct), "getRange", staticMethod: false)
              val stringGetRangeFnName = self.fnName(Some(exprConcreteType), stringGetRangeFn, {}, paramsNeedingDefaultValue)
              self.enqueueFunction(stringGetRangeFn, stringGetRangeFnName, paramsNeedingDefaultValue, Some(exprConcreteType), {})

              stringGetRangeFnName
            } else {
              unreachable("unsupported type for range indexing operator")
            }

            val args = if startVal |startVal| {
              if endVal |endVal| {
                [exprVal, startVal, endVal]
              } else {
                [exprVal, startVal]
              }
            } else if endVal |endVal| {
              [exprVal, endVal]
            } else {
              [exprVal]
            }

            self.ssaValue(exprIrTy, Operation.Call(ret: exprIrTy, fnName: fnName, args: args), dst)
          }
        }
      }
      TypedIndexingNode.Map(mapExpr, idxExpr) => {
        val idxVal = self.genExpression(idxExpr, concreteGenerics)

        val mapVal = self.genExpression(mapExpr, concreteGenerics)
        val mapConcreteType = self.getConcreteTypeFromType(mapExpr.ty, concreteGenerics)
        val mapIrTy = self.getIrTypeForConcreteType(mapConcreteType)

        val mapKeyConcreteType = try mapConcreteType.typeArgs[0] else unreachable("ConcreteType for map must have 2 type arguments")
        val mapValConcreteType = try mapConcreteType.typeArgs[1] else unreachable("ConcreteType for map must have 2 type arguments")
        val mapKeyIrTy = self.getIrTypeForConcreteType(mapKeyConcreteType)
        val mapValIrTy = self.getIrTypeForConcreteType(mapValConcreteType)

        val mapConcreteGenerics = { "K": mapKeyConcreteType, "V": mapValConcreteType } // `K`, and `V` are the known generics of `Map.get`
        val mapGetFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeMapStruct), "get", staticMethod: false)
        val mapGetFnName = self.fnName(Some(mapConcreteType), mapGetFn, mapConcreteGenerics, [])
        self.enqueueFunction(mapGetFn, mapGetFnName, [], Some(mapConcreteType), mapConcreteGenerics)

        val optWrapperConcreteType = ConcreteType(instanceKind: InstanceKind.Enum(self.project.preludeOptionEnum), typeArgs: [mapValConcreteType])
        val optWrapperIrTy = self.getIrTypeForConcreteType(optWrapperConcreteType)

        self.ssaValue(optWrapperIrTy, Operation.Call(ret: optWrapperIrTy, fnName: mapGetFnName, args: [mapVal, idxVal]), dst)
      }
      TypedIndexingNode.Tuple(tupleExpr, idx) => {
        val tupleVal = self.genExpression(tupleExpr, concreteGenerics)
        val tupleConcreteType = self.getConcreteTypeFromType(tupleExpr.ty, concreteGenerics)

        val fieldConcreteType = try tupleConcreteType.typeArgs[idx] else unreachable("Tuple of size ${tupleConcreteType.typeArgs.length} must have an index $idx")
        val fieldIrType = self.getIrTypeForConcreteType(fieldConcreteType)

        self.ssaValue(fieldIrType, Operation.LoadField(ty: fieldIrType, mem: tupleVal, name: "__$idx", offset: idx * 8), dst)
      }
    }
  }

  // codegen helpers

  func generateArrayWithItems(self, pos: Position, arrayItemConcreteType: ConcreteType, dst: String?, values: Value[]): Value {
    val arrayConcreteType = ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeArrayStruct), typeArgs: [arrayItemConcreteType])
    val arrConcreteGenerics = { "T": arrayItemConcreteType } // `T` is the known generic of `Array.withCapacity`
    val arrayWithCapacityFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "withCapacity", staticMethod: true)
    val arrayWithCapacityFnName = self.fnName(None, arrayWithCapacityFn, arrConcreteGenerics, [])
    self.enqueueFunction(arrayWithCapacityFn, arrayWithCapacityFnName, [], None, arrConcreteGenerics)

    val sizeVal = Value.Const(Const.Int(values.length.nextPowerOf2()))
    val arrayIrTy = self.getIrTypeForConcreteType(arrayConcreteType)
    val op = Operation.Call(ret: arrayIrTy, fnName: arrayWithCapacityFnName, args: [sizeVal])
    val arrVal = self.ssaValue(arrayIrTy, op, dst)

    val (_, lengthFieldIdx) = try self.project.preludeArrayStruct.fields.findIndex(f => f.name.name == "length") else unreachable("no such field 'length'")
    self.emit(Instruction(op: Operation.StoreField(ty: IrType.I64, value: Value.Const(Const.Int(values.length)), mem: arrVal, name: "length", offset: lengthFieldIdx * 8)))

    val (_, bufferFieldIdx) = try self.project.preludeArrayStruct.fields.findIndex(f => f.name.name == "_buffer") else unreachable("no such field '_buffer'")
    val bufferVal = self.ssaValue(IrType.Ptr, Operation.LoadField(ty: IrType.Ptr, mem: arrVal, name: "_buffer", offset: bufferFieldIdx * 8), None)

    val arrayItemIrTy = self.getIrTypeForConcreteType(arrayItemConcreteType)
    for value, idx in values {
      val builtin = Builtin.Store(ptr: bufferVal, value: value, offset: Value.Const(Const.Int(idx)), itemTy: arrayItemIrTy)
      self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: builtin)))
    }

    arrVal
  }

  func genToStringLogicForStructuredData(self, prefix: String, data: (String, ConcreteType, Value)[]): Value {
    val strTy = self.knowns.stringType()
    val strIrType = IrType.Composite(strTy.name)

    val prefixStr = Value.Const(Const.String(prefix))
    var knownConstLen = prefix.length + 2 + (data.length - 1) * 2 // account for '(' and ')', as well as ',' and ' ' between items. NB: does not include NULL
    var lenVal = Value.Const(Const.Int(0))

    val reprVals: (IrType, String, Value)[] = []
    for (itemName, itemConcreteType, itemVal), idx in data {
      val itemIrTy = self.getIrTypeForConcreteType(itemConcreteType)
      val itemConcreteGenerics = self.extractConcreteGenericsFromConcreteType(itemConcreteType)

      // If the item label is meant to be output, account for the label as well as ':' and ' ' between the label and the value
      if !itemName.isEmpty() { knownConstLen += (itemName.length + 2) }

      val toStringFn = self.getMethodByName(itemConcreteType.instanceKind, "toString", staticMethod: false)
      val toStringFnName = self.fnName(Some(itemConcreteType), toStringFn, itemConcreteGenerics, [])
      self.enqueueFunction(toStringFn, toStringFnName, [], Some(itemConcreteType), itemConcreteGenerics)

      val toStringVal = self.ssaValue(strIrType, Operation.Call(ret: strIrType, fnName: toStringFnName, args: [itemVal]), None)
      val toStringValLen = self.ssaValue(IrType.I64, Operation.LoadField(ty: IrType.I64, mem: toStringVal, name: "length", offset: 0), None)
      lenVal = self.ssaValue(IrType.I64, Operation.Add(lenVal, toStringValLen), None)

      if itemIrTy == strIrType {
        // account for opening and closing " chars
        lenVal = self.ssaValue(IrType.I64, Operation.Add(lenVal, Value.Const(Const.Int(2))), None)
      }

      reprVals.push((itemIrTy, itemName, toStringVal))
    }

    val totalLenVal = self.ssaValue(IrType.I64, Operation.Add(lenVal, Value.Const(Const.Int(knownConstLen))), None)
    self.ssaValue(strIrType, Operation.StructuredToString(prefix: prefix, lenVal: totalLenVal, fields: reprVals), None)
  }

  func genEqLogicForStructuredData(self, data: (ConcreteType, Value, Value)[]): Value {
    var acc = Value.Const(Const.Bool(true))
    for (itemConcreteType, selfVal, otherVal), idx in data {
      val eq = self.genCompoundValue(() => self.genEqLogic(itemConcreteType, selfVal, otherVal, negate: false, dst: None))
      acc = self.ssaValue(IrType.Bool, Operation.BoolAnd(acc, eq), None)
    }

    acc
  }

  func ssaValueComptime(self, const: Const, name: String?): Value {
    if name |name| {
      val (op, ty) = match const {
        Const.Int(value) => (Operation.ConstInt(value), IrType.I64)
        Const.Float(value) => (Operation.ConstFloat(value), IrType.F64)
        Const.Bool(value) => (Operation.ConstBool(value), IrType.Bool)
        Const.Char(value) => (Operation.ConstChar(value), IrType.I64)
        Const.String(value) => {
          val strTy = IrType.Composite(self.knowns.stringType().name)
          (Operation.ConstString(value), strTy)
        }
      }
      val ident = Ident(ty: ty, kind: IdentKind.Named(name), compileTimeValue: Some(const))
      self.emit(Instruction(assignee: Some(ident), op: op))

      Value.Ident(ident: ident)
    } else {
      Value.Const(const)
    }
  }

  func ssaValue(self, ty: IrType, op: Operation, name: String?): Value {
    val identKind = if name |name| IdentKind.Named(name) else IdentKind.Anon(self.nextAnonLocal())
    val ident = Ident(ty: ty, kind: identKind)
    self.emit(Instruction(assignee: Some(ident), op: op))

    Value.Ident(ident: ident)
  }

  func genCallToStringMethod(self, value: Value, dst: String? = None): Value {
    val strTy = IrType.Composite(self.knowns.stringType().name)
    val valTy = self.getValueTy(value)
    val concreteType = match valTy {
      IrType.Unit => unreachable("values cannot be of type unit")
      IrType.I64 => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeIntStruct))
      IrType.F64 => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeFloatStruct))
      IrType.Bool => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeBoolStruct))
      IrType.Byte => todo("Byte#toString()")
      IrType.Composite(name) => {
        val (_, concreteTy) = try self.types[name] else unreachable("type '$name' missing from known types")
        concreteTy
      }
      IrType.Ptr => todo("Pointer#toString()")
    }

    val concreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
    val toStringFn = self.getMethodByName(concreteType.instanceKind, "toString", staticMethod: false)
    val toStringFnName = self.fnName(Some(concreteType), toStringFn, concreteGenerics, [])
    self.enqueueFunction(toStringFn, toStringFnName, [], Some(concreteType), concreteGenerics)

    self.ssaValue(strTy, Operation.Call(ret: strTy, fnName: toStringFnName, args: [value]), dst)
  }

  // helpers

  func enterFunction(self, fn: IrFunction): Context {
    val prevCtx = self.curCtx
    val params = fn.params.map(p => Ident(ty: IrType.I64, kind: p.kind))
    val locals = Map.fromPairs(fn.params.map(p => (p.kind.name(), Value.Ident(p))))
    self.curCtx = Context(fn: fn, block: fn.block, locals: locals)

    prevCtx
  }

  func withinBlock(self, name: String, terminates: Bool, fn: () => Value?): Block {
    val prevBlock = self.curCtx.block

    val instrs: Instruction[] = []
    self.curCtx.block = (name, instrs)
    val finalVal = fn()
    self.curCtx.block = prevBlock

    Block(name: name, body: instrs, result: finalVal, terminates: terminates)
  }

  func genCompoundValue(self, fn: () => Value): CompoundValue {
    val prevBlock = self.curCtx.block

    val instrs: Instruction[] = []
    self.curCtx.block = ("_compoundvalue", instrs)
    val finalVal = fn()
    self.curCtx.block = prevBlock

    CompoundValue(body: instrs, result: finalVal)
  }

  func enqueueFunction(self, fn: tc.Function, fnName: String, paramsNeedingDefaultValue: Bool[], methodInstanceType: ConcreteType?, concreteGenerics: Map<String, ConcreteType>) {
    self.fnQueue.push(FunctionToCompile(callable: CallableToCompile.Function(fn), fnName: fnName, paramsNeedingDefaultValue: paramsNeedingDefaultValue, concreteGenerics: concreteGenerics, methodInstanceType: methodInstanceType))
  }

  func enqueueInitializer(self, ty: ConcreteType, enumVariant: tc.TypedEnumVariant?, fnName: String, paramsNeedingDefaultValue: Bool[], methodInstanceType: ConcreteType?, concreteGenerics: Map<String, ConcreteType>) {
    if enumVariant |variant| {
      self.fnQueue.push(FunctionToCompile(callable: CallableToCompile.EnumVariant(ty, variant), fnName: fnName, paramsNeedingDefaultValue: paramsNeedingDefaultValue, concreteGenerics: concreteGenerics, methodInstanceType: methodInstanceType))
    } else {
      self.fnQueue.push(FunctionToCompile(callable: CallableToCompile.Initializer(ty), fnName: fnName, paramsNeedingDefaultValue: paramsNeedingDefaultValue, concreteGenerics: concreteGenerics, methodInstanceType: methodInstanceType))
    }
  }

  func addFunction(self, fnName: String, fn: IrFunction) {
    self.functions.push(fn)
    self.functionsByName[fnName] = fn
  }

  func getOrAddConstEnumVariant(self, concreteType: ConcreteType, variant: tc.TypedEnumVariant, variantIdx: Int): GlobalVariable {
    val typeName = self.typeName(concreteType, withTypeArgs: true)
    val globalName = "${typeName}_${variant.label.name}"
    if self.globals[globalName] |g| return g

    val ty = self.getIrTypeForConcreteType(concreteType)

    val v = GlobalVariable(name: globalName, ty: ty, mutable: false)
    self.globals[globalName] = v

    v
  }

  func addGlobal(self, variable: tc.Variable, modId: Int, concreteGenerics: Map<String, ConcreteType>): GlobalVariable {
    val globalName = self.globalName(modId, variable.label.name)
    if self.globals[globalName] |g| return g

    val varConcreteType = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varTy = self.getIrTypeForConcreteType(varConcreteType)

    val v = GlobalVariable(name: globalName, ty: varTy, mutable: variable.mutable)
    self.globals[globalName] = v

    v
  }

  func getGlobal(self, name: String, pos: Position): GlobalVariable {
    try self.globals[name] else unreachable("no such global '$name' ($pos)")
  }

  func globalName(self, modId: Int, name: String): String = "_${modId}_$name"

  func typeName(self, ty: ConcreteType, withTypeArgs = true): String {
    val (id, baseName) = match ty.instanceKind {
      InstanceKind.Struct(s) => (s.moduleId, s.label.name)
      InstanceKind.Enum(e) => (e.moduleId, e.label.name)
    }

    val parts = [id.toString(), baseName]
    if withTypeArgs {
      for typeArg in ty.typeArgs {
        parts.push(self.typeName(typeArg))
      }
    }

    parts.join("_")
  }

  func tupleStruct(self, arity: Int): tc.Struct {
    val name = "Tuple$arity"

    self.tupleStructs.getOrInsert(name, () => {
      val dummyModuleId = 0
      val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      val typeParams = alphabet[:arity].split("")
      val fields = typeParams.map((p, idx) => ("__$idx", tc.Type(kind: TypeKind.Generic(name: p))))
      tc.Struct.makeDummy(moduleId: dummyModuleId, name: name, typeParams: typeParams, fields: fields)
    })
  }

  func isTupleStruct(self, struct: tc.Struct): Bool = if self.tupleStructs[struct.label.name] |s| s == struct else false

  func getConcreteTypeFromType(self, ty: tc.Type, concreteGenerics: Map<String, ConcreteType>): ConcreteType {
    match ty.kind {
      TypeKind.CouldNotDetermine => unreachable("Encountered CouldNotDetermine type")
      TypeKind.PrimitiveUnit => unreachable("getConcreteTypeFromType: Unit")
      TypeKind.PrimitiveInt => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeIntStruct), typeArgs: [])
      TypeKind.PrimitiveFloat => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeFloatStruct), typeArgs: [])
      TypeKind.PrimitiveBool => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeBoolStruct), typeArgs: [])
      TypeKind.PrimitiveChar => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeCharStruct), typeArgs: [])
      TypeKind.PrimitiveString => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeStringStruct), typeArgs: [])
      TypeKind.Never => unreachable("Encountered Never type")
      TypeKind.Generic(name) => try concreteGenerics[name] else {
        stdoutWriteln(process.getStackTrace())
        unreachable("getConcreteTypeFromType: generic '$name'")
      }
      TypeKind.Instance(instanceKind, typeArgs) => {
        val concreteTypeArgs = typeArgs.map(t => self.getConcreteTypeFromType(t, concreteGenerics))
        ConcreteType(instanceKind: instanceKind, typeArgs: concreteTypeArgs)
      }
      TypeKind.Func(paramTypes, returnType) => todo("TypeKind.Func")
      TypeKind.Type(type_) => todo("TypeKind.Type")
      TypeKind.Tuple(types) => {
        val struct = self.tupleStruct(types.length)
        val concreteTypeArgs = types.map(t => self.getConcreteTypeFromType(t, concreteGenerics))

        ConcreteType(instanceKind: InstanceKind.Struct(struct), typeArgs: concreteTypeArgs)
      }
      TypeKind.Hole => todo("TypeKind.Hole")
    }
  }

  func extractConcreteGenericsFromConcreteType(self, concreteType: ConcreteType): Map<String, ConcreteType> {
    val typeParams = match concreteType.instanceKind {
      InstanceKind.Struct(s) => s.typeParams
      InstanceKind.Enum(e) => e.typeParams
    }

    val concreteGenerics: Map<String, ConcreteType> = {}
    for typeParam, idx in typeParams {
      val concreteGeneric = try concreteType.typeArgs[idx] else unreachable()
      concreteGenerics[typeParam] = concreteGeneric
    }

    concreteGenerics
  }

  func fnName(self, methodInstTy: ConcreteType?, fn: tc.Function, concreteGenerics: Map<String, ConcreteType>, paramsNeedingDefaultValue: Bool[] = []): String {
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    val prefix = match fn.kind {
      FunctionKind.Standalone => {
        val (defModId, _) = try fn.scope.findParentModule() else unreachable("could not find parent module for function '${fn.label.name}'")

        val base = "_${defModId}_${fn.label.name}"
        if !fn.typeParams.isEmpty() todo("generic functions")

        base
      }
      FunctionKind.InstanceMethod => {
        val instTy = try methodInstTy else unreachable("InstanceMethod without methodInstTy")
        val typeName = self.typeName(instTy)

        val base = ["_${typeName}_${fn.label.name}"]
        for (_, label) in fn.typeParams {
          val concreteGeneric = try concreteGenerics[label.name] else unreachable("Could not resolve generic '${label.name}' for function '${fn.label.name}'")
          base.push(self.typeName(concreteGeneric))
        }

        base.join("_")
      }
      FunctionKind.StaticMethod(instanceKind, _) => {
        val typeName = self.typeName(ConcreteType(instanceKind: instanceKind), withTypeArgs: false)

        val base = ["_${typeName}__${fn.label.name}"]
        for (_, label) in fn.typeParams {
          val concreteGeneric = try concreteGenerics[label.name] else unreachable("Could not resolve generic '${label.name}' for function '${fn.label.name}'")
          base.push(self.typeName(concreteGeneric))
        }

        base.join("_")
      }
    }

    if defaultValuesFlag == 0 {
      prefix
    } else {
      "${prefix}_$defaultValuesFlag"
    }
  }

  func structInitFnName(self, ty: ConcreteType, paramsNeedingDefaultValue: Bool[] = []): String {
    val typeName = self.typeName(ty)
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))

    val prefix = "_${typeName}__init__"
    if defaultValuesFlag == 0 {
      prefix
    } else {
      "${prefix}_$defaultValuesFlag"
    }
  }

  func enumVariantInitFnName(self, ty: ConcreteType, variant: tc.TypedEnumVariant, paramsNeedingDefaultValue: Bool[] = []): String {
    val typeName = self.typeName(ty)
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))

    val prefix = "_${typeName}__${variant.label.name}"
    if defaultValuesFlag == 0 {
      prefix
    } else {
      "${prefix}_$defaultValuesFlag"
    }
  }

  func getIrTypeForConcreteType(self, ty: ConcreteType): IrType {
    match ty.instanceKind {
      InstanceKind.Struct(s) => {
        if s == self.project.preludeIntStruct return IrType.I64
        if s == self.project.preludeFloatStruct return IrType.F64
        if s == self.project.preludeBoolStruct return IrType.Bool

        if s.builtin == Some(tc.BuiltinModule.Intrinsics) {
          if s.label.name == "Byte" return IrType.Byte
        }

        val t = self.getOrAddCompositeType(ty)
        IrType.Composite(name: t.name)
      }
      InstanceKind.Enum => {
        val t = self.getOrAddCompositeType(ty)
        IrType.Composite(name: t.name)
      }
    }
  }

  func getOrAddCompositeType(self, ty: ConcreteType): CompositeType {
    val typeName = self.typeName(ty)

    if self.types[typeName] |(t, _)| return t

    // TODO
    // val fields = match instanceKind {
    //   InstanceKind.Struct(s) => {
    //     s.fields.map(f => (f.name.name, self.getIrTypeForTcType(f.ty)))
    //   }
    //   InstanceKind.Enum => todo("getOrAddCompositeType for enums")
    // }

    val t = CompositeType(name: typeName, fields: [])
    self.types[typeName] = (t, ty)

    t
  }

  func emit(self, inst: Instruction) = self.curCtx.block[1].push(inst)

  func getMethodByName(self, parent: InstanceKind, name: String, staticMethod = false): tc.Function {
    val (parentName, methods) = match parent {
      InstanceKind.Struct(s) => (s.label.name, if staticMethod s.staticMethods else s.instanceMethods)
      InstanceKind.Enum(e) => (e.label.name, if staticMethod e.staticMethods else e.instanceMethods)
    }

    try methods.find(m => m.label.name == name) else {
      val sep = if staticMethod "." else "#"
      unreachable("$parentName$sep$name must exist")
    }
  }

  func variableIsGlobal(self, variable: tc.Variable): Int? {
    // Top-level variables in a module are only globals if they're captured; otherwise they're treated as locals within the module wrapper function.
    // Exported variables (which _should_ also be top-level) are necessarily hoisted to global scope.
    val modId = variable.isGlobal()
    if variable.isExported {
      if !modId unreachable("a variable should only be able to be exported if it's at the top-level")
      return modId
    }

    if !variable.isCaptured return None

    modId
  }

  func valueAsCompileTime(self, value: Value): Const? {
    if !self.foldConstants return None

    // A value is said to be known at compile time if it's a constant (int, float, bool, char, or string), or if it's an immutable global.
    match value {
      Value.Unit => None // should be unreachable, but it's ok to return None here
      Value.Const(const) => Some(const)
      Value.Ident(ident) => ident.compileTimeValue
      Value.Global(global) => if global.mutable None else global.initialValue
    }
  }

  func valuesAsCompileTime(self, value1: Value, value2: Value): (Const, Const)? {
    if self.valueAsCompileTime(value1) |v1| {
      if self.valueAsCompileTime(value2) |v2| {
        return Some((v1, v2))
      }
    }

    None
  }

  func getValueTy(self, value: Value): IrType {
    match value {
      Value.Unit => IrType.Unit
      Value.Const(const) => match const {
        Const.Int => IrType.I64
        Const.Float => IrType.F64
        Const.Bool => IrType.Bool
        Const.Char => IrType.I64
        Const.String => IrType.Composite(name: self.knowns.stringType().name)
      }
      Value.Ident(ident) => ident.ty
      Value.Global(global) => global.ty
    }
  }

  func nextAnonLocal(self): Int {
    val idx = self.curCtx.anonLocalIdx
    self.curCtx.anonLocalIdx += 1
    idx
  }

  func getExternDecName(self, fn: tc.Function): String? {
    if fn.decorators.find(dec => dec.label.name == "external") |dec| {
      match dec.arguments[0] {
        LiteralAstNode.String(value) => Some(value)
        _ => unreachable("@external decorator requires 1 string argument for the name")
      }
    } else {
      None
    }
  }

  func getIntrinsicDecName(self, fn: tc.Function): String? {
    if fn.decorators.find(dec => dec.label.name == "intrinsic") |dec| {
      match dec.arguments[0] {
        LiteralAstNode.String(value) => Some(value)
        _ => unreachable("@external decorator requires 1 string argument for the name")
      }
    } else {
      None
    }
  }
}
