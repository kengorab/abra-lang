import "process" as process
import Position from "./lexer"
import Label, LiteralAstNode, AssignOp, UnaryOp, BinaryOp, BindingPattern, IndexingMode from "./parser"
// match arms don't support import-based namespacing for enums yet, so enums used in matches are imported by name
import TypedAstNodeKind, TypedInvokee, FunctionKind, TypeKind, ScopeKind, InstanceKind, EnumVariantKind, VariableAlias, AccessorPathSegment, TypedAssignmentMode, TypedIndexingNode, TypedForIterKind from "./typechecker"
import "./typechecker" as tc

// TODO: move to stdlib
pub type StringBuilder {
  chunks: String[] = []

  pub func write(self, str: String): StringBuilder {
    if !str.isEmpty() self.chunks.push(str)
    self
  }

  pub func writeln(self, str: String = ""): StringBuilder = self.write(str).write("\n")

  pub func build(self): String = self.chunks.join("")
}

pub type Knowns {
  strTy: CompositeType? = None
  strInit: IrFunction? = None

  pub func stringType(self): CompositeType = try self.strTy else unreachable("String type expected to be initialized")
  pub func stringInitializerFn(self): IrFunction = try self.strInit else unreachable("String initializer fn expected to be initialized")
}

pub type IR {
  pub mainFunction: IrFunction
  pub functions: IrFunction[]
  pub types: CompositeType[]
  pub globals: GlobalVariable[]
  pub knowns: Knowns = Knowns()

  pub func render(self, sb: StringBuilder) {
    for t in self.types {
      t.render(sb)
      sb.writeln()
    }

    for g in self.globals {
      g.render(sb)
      sb.writeln()
    }

    sb.writeln()
    self.mainFunction.render(sb)

    for f in self.functions {
      sb.writeln()
      f.render(sb)
    }
  }
}

pub type IrFunction {
  pub extern: String? = None
  pub name: String
  pub params: Ident[]
  pub ret: IrType
  pub block: (String, Instruction[]) = ("start", [])
  pub isClosure: Bool
  pub numLocals: Int

  pub func render(self, sb: StringBuilder) {
    if self.extern |name| sb.writeln("@extern($name)")

    sb.write("function ")
    sb.write(self.name)

    sb.write("(")
    for p, idx in self.params {
      p.render(sb)
      if idx != self.params.length - 1 {
        sb.write(", ")
      }
    }
    sb.write(") ")

    self.ret.render(sb)
    sb.writeln()

    val (label, block) = self.block
    sb.writeln("$label:")
    for inst in block {
      sb.write("  ")
      inst.render(sb)
      sb.writeln()
    }
  }
}

pub type Instruction {
  pub assignee: Ident? = None
  pub op: Operation

  pub func render(self, sb: StringBuilder) {
    if self.assignee |a| {
      a.render(sb)
      sb.write(" = ")
    }

    self.op.render(sb)
  }
}

pub enum IdentKind {
  Anon(idx: Int)
  Named(name: String, idx: Int)

  pub func name(self): String = match self {
    IdentKind.Anon(idx) => "_$idx"
    IdentKind.Named(name, _) => name
  }
}

pub type Ident {
  pub ty: IrType
  pub kind: IdentKind
  compileTimeValue: Const? = None

  pub func render(self, sb: StringBuilder) {
    self.ty.render(sb)
    sb.write(" %")
    sb.write(self.kind.name())
  }
}

pub enum Const {
  Int(value: Int)
  Float(value: Float)
  Bool(value: Bool)
  Char(value: Int) // 64-bit repr of char
  String(value: String)

  pub func render(self, sb: StringBuilder) {
    match self {
      Const.Int(v) => {
        IrType.I64.render(sb)
        sb.write(" ").write(v.toString())
      }
      Const.Float(v) => {
        IrType.F64.render(sb)
        sb.write(" ").write(v.toString())
      }
      Const.Bool(b) => {
        IrType.Bool.render(sb)
        sb.write(" $b")
      }
      Const.Char(intVal) => {
        IrType.I64.render(sb)
        sb.write(" ${Char.fromInt(intVal)}")
      }
      Const.String(s) => {
        sb.write("\"")
          .write(s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"").replaceAll("\n", "\\n").replaceAll("\r", "\\r"))
          .write("\"")
      }
    }
  }
}

pub enum Value {
  Unit
  Const(value: Const)
  Ident(ident: Ident)
  Global(global: GlobalVariable)

  pub func render(self, sb: StringBuilder) {
    match self {
      Value.Unit => {}
      Value.Const(const) => const.render(sb)
      Value.Ident(i) => i.render(sb)
      Value.Global(g) => {
        g.ty.render(sb)
        sb.write(" $").write(g.name)
      }
    }
  }
}

pub enum Builtin {
  Malloc(count: Value, itemTy: IrType)
  Realloc(ptr: Value, count: Value, itemTy: IrType? = None)
  Store(ptr: Value, value: Value, offset: Value, itemTy: IrType)
  Load(ptr: Value, offset: Value, itemTy: IrType)
  CopyFrom(dst: Value, dstOffset: Value, src: Value, srcOffset: Value, size: Value, itemTy: IrType)
  I64ToString(intVal: Value)
  U64ToString(intVal: Value)
  F64ToString(floatVal: Value)
  BoolToString(boolVal: Value)
  IntAsFloat(intVal: Value)
  FloatAsInt(floatVal: Value)
  FloatCeil(floatVal: Value)
  FloatFloor(floatVal: Value)
  FloatRound(floatVal: Value)
  FloatBitsToInt(floatVal: Value)
  Uninitialized
  Callstack
  CallstackPtr
  ModuleNames
  FunctionNames
}

pub type Block {
  pub name: String
  pub body: Instruction[]
  pub result: Value?
  pub terminates: Bool
}

pub type CompoundValue {
  pub body: Instruction[]
  pub result: Value
}

pub enum ClosureEnvLocation {
  Passthrough
}

pub enum CaptureSource {
  WithinCapturingFn(idx: Int, name: String, mutable: Bool)
  OutsideFn(ident: Ident)
}

pub enum Operation {
  NewLocal(ty: IrType, captured: Bool, initialValue: Value? = None)
  ConstInt(int: Int)
  ConstFloat(float: Float)
  ConstBool(b: Bool)
  ConstChar(value: Int) // 64-bit repr of char
  ConstString(str: String)

  Minus(value: Value)
  Negate(value: Value)

  Add(left: Value, right: Value)
  Sub(left: Value, right: Value)
  Mul(left: Value, right: Value)
  Div(left: Value, right: Value)
  Mod(left: Value, right: Value)
  Pow(left: Value, right: Value)
  BitAnd(left: Value, right: Value)
  BoolAnd(left: Value, right: CompoundValue)
  BitOr(left: Value, right: Value)
  BoolOr(left: Value, right: CompoundValue)
  Xor(bitwise: Bool, left: Value, right: Value)
  Eq(negate: Bool, left: Value, right: Value)
  Lt(left: Value, right: Value)
  Lte(left: Value, right: Value)
  Shl(left: Value, right: Value)
  Gt(left: Value, right: Value)
  Gte(left: Value, right: Value)
  Shr(left: Value, right: Value)

  LoadVar(ty: IrType, ident: Ident)
  LoadCapturedVar(ty: IrType, src: CaptureSource, deref: Bool)
  LoadField(ty: IrType, mem: Value, name: String, offset: Int)
  StoreVar(ty: IrType, value: Value, ident: Ident)
  StoreCapturedVar(ty: IrType, value: Value, src: CaptureSource)
  StoreGlobal(ty: IrType, value: Value, global: GlobalVariable)
  StoreField(ty: IrType, value: Value, mem: Value, name: String, offset: Int)

  If(ty: IrType, cond: Value, thenBlock: Block, elseBlock: Block)
  WhileLoopStart(name: String)
  While(cond: Value, body: Block)
  ForRanged(start: Value, end: CompoundValue, iteratee: Ident, idx: Ident?, body: Block)

  FunctionPointer(fnName: String)
  CreateClosure(fnName: String, captures: Value[])
  Call(ret: IrType, fnName: String, args: Value[], envLocation: ClosureEnvLocation? = None)
  CallValue(ret: IrType, fnVal: Value, args: Value[])

  Break
  Continue
  Return(value: Value? = None)

  OptionNone(innerTy: IrType)
  OptionSome(innerTy: IrType, value: Value)
  OptionIsNone(innerTy: IrType, value: Value)
  OptionUnwrap(innerTy: IrType, value: Value)
  StructuredToString(prefix: String, lenVal: Value, fields: (IrType, String, Value)[])
  Builtin(ret: IrType, builtin: Builtin)

  pub func render(self, sb: StringBuilder) {
    match self {
      Operation.NewLocal(ty, captured, initialValue) => {
        sb.write("local(")
        ty.render(sb)
        if captured {
          sb.write(" (captured)")
        }
        if initialValue |v| {
          sb.write(", ")
          v.render(sb)
        }
        sb.write(")")
      }
      Operation.ConstInt(int) => {
        IrType.I64.render(sb)
        sb.write(" $int")
      }
      Operation.ConstFloat(float) => {
        IrType.F64.render(sb)
        sb.write(" $float")
      }
      Operation.ConstString(str) => {
        sb.write("string \"$str\"")
      }
      Operation.ConstBool(b) => {
        IrType.Bool.render(sb)
        sb.write(" $b")
      }
      Operation.ConstChar(c) => {
        IrType.I64.render(sb)
        sb.write(" '$c'")
      }
      Operation.Minus(v) => {
        sb.write("minus(")
        v.render(sb)
        sb.write(")")
      }
      Operation.Negate(v) => {
        sb.write("negate(")
        v.render(sb)
        sb.write(")")
      }
      Operation.Add(l, r) => {
        sb.write("add(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Mul(l, r) => {
        sb.write("mul(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Div(l, r) => {
        sb.write("div(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Mod(l, r) => {
        sb.write("mod(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Pow(l, r) => {
        sb.write("pow(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.BitAnd(l, r) => {
        sb.write("bitand(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.BoolAnd(l, r) => {
        for instr in r.body {
          instr.render(sb)
          sb.writeln()
        }
        sb.write("and(")
        l.render(sb)
        sb.write(", ")
        r.result.render(sb)
        sb.write(")")
      }
      Operation.BitOr(l, r) => {
        sb.write("bitor(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.BoolOr(l, r) => {
        for instr in r.body {
          instr.render(sb)
          sb.writeln()
        }
        sb.write("or(")
        l.render(sb)
        sb.write(", ")
        r.result.render(sb)
        sb.write(")")
      }
      Operation.Xor(_, l, r) => {
        sb.write("xor(")
        l.render(sb)
        sb.write(", ")
        r.render(sb)
        sb.write(")")
      }
      Operation.Eq(negate, left, right) => {
        if negate sb.write("neq(") else sb.write("eq(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Lt(left, right) => {
        sb.write("lt(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Lte(left, right) => {
        sb.write("lte(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Shl(left, right) => {
        sb.write("shl(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Gt(left, right) => {
        sb.write("gt(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Gte(left, right) => {
        sb.write("gte(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.Shr(left, right) => {
        sb.write("shr(")
        left.render(sb)
        sb.write(", ")
        right.render(sb)
        sb.write(")")
      }
      Operation.LoadVar(ty, mem) => {
        sb.write("load_var(")
        ty.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(")")
      }
      Operation.LoadCapturedVar(ty, src, deref) => {
        sb.write("load_captured_var(")
        ty.render(sb)
        sb.write(", ")
        match src {
          CaptureSource.WithinCapturingFn(idx, name, mutable) => {
            sb.write("$idx ($name")
            if mutable {
              sb.write(" (mutable)")
            }
            sb.write(")")
          }
          CaptureSource.OutsideFn(ident) => {
            ident.render(sb)
          }
        }
        if deref {
          sb.write(", deref")
        }
        sb.write(")")
      }
      Operation.LoadField(ty, mem, name, offset) => {
        sb.write("load(")
        ty.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(", $name ($offset))")
      }
      Operation.StoreVar(ty, value, ident) => {
        sb.write("store_var(")
        ty.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(", ")
        ident.render(sb)
        sb.write(")")
      }
      Operation.StoreCapturedVar(ty, value, src) => {
        sb.write("store_captured_var(")
        ty.render(sb)
        sb.write(", ")
        value.render(sb)
        match src {
          CaptureSource.WithinCapturingFn(idx, name, _) => {
            sb.write("$idx ($name)")
          }
          CaptureSource.OutsideFn(ident) => {
            ident.render(sb)
          }
        }
        sb.write(")")
      }
      Operation.StoreGlobal(ty, value, global) => {
        sb.write("store_global(")
        ty.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(", ")
        global.render(sb)
        sb.write(")")
      }
      Operation.StoreField(ty, value, mem, name, offset) => {
        sb.write("store(")
        ty.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(", ")
        mem.render(sb)
        sb.write(", $name ($offset))")
      }
      Operation.If(ty, cond, thenBlock, elseBlock) => {
        sb.write("if(")
        cond.render(sb)
        sb.write(", .${thenBlock.name}")
        if thenBlock.result |v| {
          sb.write(" (")
          v.render(sb)
          sb.write(")")
        }
        if !elseBlock.body.isEmpty() {
          sb.write(", .${elseBlock.name}")
          if elseBlock.result |v| {
            sb.write(" (")
            v.render(sb)
            sb.write(")")
          }
        }
        sb.writeln(")")

        sb.writeln(".${thenBlock.name}:")
        for instr in thenBlock.body {
          sb.write("  ")
          instr.render(sb)
          sb.writeln()
        }
        if !elseBlock.body.isEmpty() {
          sb.writeln(".${elseBlock.name}:")
          for instr in elseBlock.body {
            sb.write("  ")
            instr.render(sb)
            sb.writeln()
          }
        }
        sb.write("# endif")
      }
      Operation.WhileLoopStart(name) => sb.write("while_loop_start(.$name)")
      Operation.While(cond, body) => {
        sb.write("while(")
        cond.render(sb)
        sb.writeln(", .${body.name})")

        sb.writeln(".${body.name}:")
        for instr in body.body {
          sb.write("  ")
          instr.render(sb)
          sb.writeln()
        }
        sb.write("# endwhile")
      }
      Operation.ForRanged(start, end, iteratee, idx, body) => {
        sb.writeln("# forstart")
        for inst in end.body {
          inst.render(sb)
          sb.writeln()
        }
        sb.write("  for(" )
        iteratee.render(sb)
        sb.write(" = ")
        start.render(sb)
        if idx |idx| {
          sb.write("; (")
          idx.render(sb)
          sb.write(")")
        }
        sb.write(", ${iteratee.kind.name()} < ")
        end.result.render(sb)
        sb.writeln(", .${body.name})")
        sb.writeln(".${body.name}:")
        for instr in body.body {
          sb.write("  ")
          instr.render(sb)
          sb.writeln()
        }
        sb.write("# endfor")
      }
      Operation.FunctionPointer(fnName) => {
        sb.write("fn_ptr($fnName)")
      }
      Operation.CreateClosure(fnName, captures) => {
        sb.write("create_closure($fnName, [")
        for c, idx in captures {
          c.render(sb)
          if idx != captures.length - 1 { sb.write(", ") }
        }
        sb.write(")")
      }
      Operation.Call(ret, fnName, args, _) => {
        sb.write("call(")
        ret.render(sb)
        sb.write(", ").write(fnName)
        for arg, idx in args {
          sb.write(", ")
          arg.render(sb)
        }
        sb.write(")")
      }
      Operation.CallValue(ret, fnVal, args) => {
        sb.write("call(")
        ret.render(sb)
        sb.write(", ")
        fnVal.render(sb)
        for arg, idx in args {
          sb.write(", ")
          arg.render(sb)
        }
        sb.write(")")
      }
      Operation.Break => sb.write("break")
      Operation.Continue => sb.write("continue")
      Operation.Return(v) => {
        sb.write("return(")
        if v |v| v.render(sb)
        sb.write(")")
      }
      Operation.OptionNone(innerTy) => {
        sb.write("option_none(")
        innerTy.render(sb)
        sb.write(")")
      }
      Operation.OptionSome(innerTy, value) => {
        sb.write("option_some(")
        innerTy.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(")")
      }
      Operation.OptionIsNone(innerTy, value) => {
        sb.write("option_is_none(")
        innerTy.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(")")
      }
      Operation.OptionUnwrap(innerTy, value) => {
        sb.write("option_unwrap(")
        innerTy.render(sb)
        sb.write(", ")
        value.render(sb)
        sb.write(")")
      }
      Operation.StructuredToString(prefix, lenVal, fields) => {
        sb.write("structured_to_string($prefix, ")
        lenVal.render(sb)

        for (fieldIrTy, fieldName, fieldToStringVal) in fields {
          sb.write(", ")
          fieldIrTy.render(sb)
          sb.write(" $fieldName ")
          fieldToStringVal.render(sb)
        }
        sb.write(")")
      }
      Operation.Builtin(ret, builtin) => {
        sb.write("builtin(")
        ret.render(sb)
        sb.write(", ")
        match builtin {
          Builtin.Malloc(size, itemTy) => {
            sb.write("malloc, ")
            size.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.Realloc(ptr, count, itemTy) => {
            sb.write("realloc, ")
            ptr.render(sb)
            sb.write(", ")
            count.render(sb)
            if itemTy |ty| {
              sb.write(", ")
              ty.render(sb)
            }
          }
          Builtin.Store(ptr, value, offset, itemTy) => {
            sb.write("ptr_store, ")
            ptr.render(sb)
            sb.write(", ")
            value.render(sb)
            sb.write(", ")
            offset.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.Load(ptr, offset, itemTy) => {
            sb.write("ptr_load, ")
            ptr.render(sb)
            sb.write(", ")
            offset.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.CopyFrom(dst, dstOffset, src, srcOffset, size, itemTy) => {
            sb.write("copy_from, ")
            dst.render(sb)
            sb.write(", ")
            dstOffset.render(sb)
            sb.write(", ")
            src.render(sb)
            sb.write(", ")
            srcOffset.render(sb)
            sb.write(", ")
            size.render(sb)
            sb.write(", ")
            itemTy.render(sb)
          }
          Builtin.I64ToString(int) => {
            sb.write("i64_to_string, ")
            int.render(sb)
          }
          Builtin.U64ToString(int) => {
            sb.write("u64_to_string, ")
            int.render(sb)
          }
          Builtin.F64ToString(int) => {
            sb.write("f64_to_string, ")
            int.render(sb)
          }
          Builtin.BoolToString(int) => {
            sb.write("bool_to_string, ")
            int.render(sb)
          }
          Builtin.IntAsFloat(float) => {
            sb.write("int_as_float, ")
            float.render(sb)
          }
          Builtin.FloatAsInt(float) => {
            sb.write("float_as_int, ")
            float.render(sb)
          }
          Builtin.FloatCeil(float) => {
            sb.write("float_ceil, ")
            float.render(sb)
          }
          Builtin.FloatFloor(float) => {
            sb.write("float_floor, ")
            float.render(sb)
          }
          Builtin.FloatRound(float) => {
            sb.write("float_round, ")
            float.render(sb)
          }
          Builtin.FloatBitsToInt(float) => {
            sb.write("float_bits_to_int, ")
            float.render(sb)
          }
          Builtin.Uninitialized => {
            sb.write("uninitialized")
          }
        }
        sb.write(")")
      }
    }
  }
}

pub enum IrType {
  Unit
  I64
  F64
  Bool
  Byte
  Composite(name: String)
  Ptr

  pub func render(self, sb: StringBuilder) {
    match self {
      IrType.Unit => sb.write("unit")
      IrType.I64 => sb.write("i64")
      IrType.F64 => sb.write("f64")
      IrType.Bool => sb.write("bool")
      IrType.Byte => sb.write("byte")
      IrType.Composite(name) => sb.write(name)
      IrType.Ptr => sb.write("ptr")
    }
  }
}

pub type CompositeType {
  pub name: String
  pub fields: (String, IrType)[]

  pub func render(self, sb: StringBuilder) {
    sb.write("type ")
      .write(self.name)
      .write(" = struct {")
    if !self.fields.isEmpty() sb.writeln()

    for (name, ty) in self.fields {
      sb.write("\n")
        .write("  ")
        .write(name)
        .write(": ")
      ty.render(sb)
    }
    sb.writeln("}")
  }
}

pub type GlobalVariable {
  pub name: String
  pub ty: IrType
  pub mutable: Bool
  pub initialValue: Const? = None
  pub referenced: Bool = false

  pub func render(self, sb: StringBuilder) {
    sb.write("global ")

    if self.mutable {
      sb.write("mutable ")
    } else {
      sb.write("const ")
    }

    self.ty.render(sb)
    sb.write(" ${self.name}")

    if self.initialValue |v| {
      sb.write(" = ")
      v.render(sb)
    }

    if !self.referenced {
      sb.write(" # not referenced")
    }
  }
}

type Context {
  fn: IrFunction
  typedFn: tc.Function?
  block: (String, Instruction[])
  locals: Map<String, Value> = {}
  numLocals: Int = 0

  func getLocal(self, name: String, pos: Position): Value {
    try self.locals[name] else unreachable("failed to find variable '$name' ($pos)")
  }

  func addLocal(self, ty: IrType, name: String?): Ident {
    if name |name| {
      if self.locals[name] |v| {
        match v { Value.Ident(i) => i, else v => unreachable("addLocal: expected '$name' to be an ident, but was $v") }
      } else {
        val idx = self.numLocals
        self.numLocals += 1
        val ident = Ident(ty: ty, kind: IdentKind.Named(name, idx))
        self.locals[name] = Value.Ident(ident)
        ident
      }
    } else {
      val idx = self.numLocals
      self.numLocals += 1
      Ident(ty: ty, kind: IdentKind.Anon(idx))
    }
  }
}

pub enum CallableToCompile {
  Function(fn: tc.Function)
  Initializer(concreteType: ConcreteType)
  EnumVariant(concreteType: ConcreteType, variant: tc.TypedEnumVariant)
}

pub type FunctionToCompile {
  pub callable: CallableToCompile
  pub fnName: String
  pub paramsNeedingDefaultValue: Bool[]
  pub concreteGenerics: Map<String, ConcreteType>
  pub methodInstanceType: ConcreteType? = None
  pub paramsToDiscard: ConcreteType[] = []
}

pub type ConcreteType {
  pub instanceKind: InstanceKind
  pub typeArgs: ConcreteType[] = []

  func toString(self): String {
    val base = match self.instanceKind {
      InstanceKind.Struct(s) => s.label.name
      InstanceKind.Enum(e) => e.label.name
    }

    val typeArgs = self.typeArgs.map(t => t.toString())
    if typeArgs.isEmpty() {
      "ConcreteType($base)"
    } else {
      "ConcreteType($base<${typeArgs.join(", ")}>)"
    }
  }
}

// All values placed into heap-allocated memory must be aligned on 8-byte boundaries, in order to satisfy bdwgc
val ALIGNMENT = 8

pub type Generator {
  project: tc.Project
  mainFn: IrFunction
  functions: IrFunction[]
  functionsByName: Map<String, IrFunction>
  curCtx: Context
  foldConstants: Bool
  pub fnQueue: FunctionToCompile[] = []
  types: Map<String, (CompositeType, ConcreteType)> = {}
  globals: Map<String, GlobalVariable> = {}
  knowns: Knowns = Knowns()
  tupleStructs: Map<String, tc.Struct> = {}
  functionStructs: Map<String, tc.Struct> = {}

  pub func init(project: tc.Project, foldConstants = true): Generator {
    val mainFn = IrFunction(name: "main", params: [], ret: IrType.I64, isClosure: false, numLocals: 0)
    val curCtx = Context(fn: mainFn, typedFn: None, block: mainFn.block)
    Generator(project: project, mainFn: mainFn, functions: [], functionsByName: {}, curCtx: curCtx, foldConstants: foldConstants)
  }

  pub func generate(self) {
    val strConcreteTy = ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeStringStruct))
    self.knowns.strTy = Some(self.getOrAddCompositeType(strConcreteTy))
    self.knowns.strInit = Some(self.getOrGenInitializerFn(strConcreteTy, None, {}))

    // Sort by id since there's no obvious entrypoint available. I wonder how long this will work before I start to see issues
    val sortedModules = self.project.modules.values().sortBy(m => m.id)
    for mod in sortedModules {
      if self.genModule(mod) |modFn| {
        self.mainFn.block[1].push(Instruction(op: Operation.Call(ret: IrType.Unit, fnName: modFn.name, args: [])))
      }
    }

    self.mainFn.block[1].push(Instruction(op: Operation.Return(value: Some(Value.Const(Const.Int(0))))))
  }

  pub func getIR(self): IR {
    IR(
      mainFunction: self.mainFn,
      functions: self.functions,
      types: self.types.values().map(t => t[0]),
      globals: self.globals.values(),
      knowns: self.knowns
    )
  }

  pub func generateIR(project: tc.Project, foldConstants: Bool = true): IR {
    val generator = Generator.init(project, foldConstants)
    generator.generate()
    generator.getIR()
  }

  func genModule(self, mod: tc.TypedModule): IrFunction? {
    val modFnName = "__mod_${mod.id}"
    val modFn = IrFunction(name: modFnName, params: [], ret: IrType.Unit, isClosure: false, numLocals: 0)
    val prevCtx = self.curCtx
    self.curCtx = Context(fn: modFn, typedFn: None, block: modFn.block)

    for node in mod.code {
      self.genStatement(node, {})
    }
    if self.curCtx.fn.block[1].isEmpty() return None

    self.functions.push(modFn)
    self.emit(Instruction(op: Operation.Return()))

    modFn.numLocals = self.curCtx.numLocals
    self.curCtx = prevCtx

    for nextFn in self.fnQueue {
      self.genFunction(nextFn)
    }

    Some(modFn)
  }

  pub func genTcFunction(self, fn: tc.Function, resolvedGenerics: Map<String, tc.Type>): IrFunction {
    val concreteGenerics: Map<String, ConcreteType> = {}
    for (name, ty) in resolvedGenerics.entries() {
      val concreteType = self.getConcreteTypeFromType(ty, {})
      concreteGenerics[name] = concreteType
    }

    val fnName = self.fnName(None, fn, concreteGenerics)
    self.genFunction(FunctionToCompile(
      callable: CallableToCompile.Function(fn),
      fnName: fnName,
      paramsNeedingDefaultValue: [],
      concreteGenerics: concreteGenerics,
    ))
  }

  pub func genFunction(self, ctx: FunctionToCompile): IrFunction {
    if self.functionsByName[ctx.fnName] |f| return f

    val fn = match ctx.callable {
      CallableToCompile.Function(fn) => fn
      CallableToCompile.Initializer(concreteType) => {
        return self.getOrGenInitializerFn(concreteType, None, ctx.concreteGenerics, ctx.paramsNeedingDefaultValue)
      }
      CallableToCompile.EnumVariant(concreteType, variant) => {
        return self.getOrGenInitializerFn(concreteType, Some(variant), ctx.concreteGenerics, ctx.paramsNeedingDefaultValue)
      }
    }

    val retTy = match fn.returnType.kind {
      TypeKind.PrimitiveUnit => IrType.Unit
      TypeKind.Generic(name) => {
        val concreteGeneric = try ctx.concreteGenerics[name] else unreachable("genFunction, no generic")
        self.getIrTypeForConcreteType(concreteGeneric)
      }
      else ty => {
        val retConcreteType = self.getConcreteTypeFromType(fn.returnType, ctx.concreteGenerics)
        self.getIrTypeForConcreteType(retConcreteType)
      }
    }

    val externName = self.getExternDecName(fn)
    val isClosure = fn.isClosure()
    val irFunc = IrFunction(extern: externName, name: ctx.fnName, params: [], ret: retTy, isClosure: isClosure, numLocals: 0)
    self.addFunction(ctx.fnName, irFunc)
    val prevCtx = self.enterFunction(irFunc, Some(fn))

    val selfParam = match fn.kind {
      FunctionKind.InstanceMethod => {
        val selfConcreteType = try ctx.methodInstanceType else unreachable("Instance method without instance type")
        val selfTy = self.getIrTypeForConcreteType(selfConcreteType)
        val selfParamIdent = self.curCtx.addLocal(selfTy, Some("self"))
        irFunc.params.push(selfParamIdent)
        Some(Value.Ident(selfParamIdent))
      }
      else => None
    }

    var anyParamNeedsDefault = false
    val argsForUnderlying = if selfParam |selfParam| [selfParam] else []
    for param, idx in fn.params {
      val paramConcreteType = if param.isVariadic {
        val inner = self.getConcreteTypeFromType(param.ty, ctx.concreteGenerics)
        ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeArrayStruct), typeArgs: [inner])
      } else {
        self.getConcreteTypeFromType(param.ty, ctx.concreteGenerics)
      }
      val paramTy = self.getIrTypeForConcreteType(paramConcreteType)
      val paramIdent = self.curCtx.addLocal(paramTy, Some(param.label.name))

      val argVal = if param.defaultValue |defaultValue| {
        val paramNeedsDefault = ctx.paramsNeedingDefaultValue[idx] ?: false
        if paramNeedsDefault {
          anyParamNeedsDefault = true
          self.genExpression(defaultValue, ctx.concreteGenerics, Some(param.label.name))
        } else {
          irFunc.params.push(paramIdent)
          Value.Ident(paramIdent)
        }
      } else {
        irFunc.params.push(paramIdent)
        Value.Ident(paramIdent)
      }
      argsForUnderlying.push(argVal)
    }

    for paramConcreteType, idx in ctx.paramsToDiscard {
      val paramTy = self.getIrTypeForConcreteType(paramConcreteType)
      val paramIdent = self.curCtx.addLocal(paramTy, Some("_discard_${idx}_"))
      irFunc.params.push(paramIdent)
    }

    match fn.kind {
      FunctionKind.InstanceMethod => {
        val selfConcreteType = try ctx.methodInstanceType else unreachable("Instance method without instance type")
        val selfParam = try argsForUnderlying[0] else unreachable()

        if fn.label.name == "toString" && fn.isGenerated {
          self.genToStringMethodBody(selfParam, selfConcreteType)
          irFunc.numLocals = self.curCtx.numLocals
          self.curCtx = prevCtx
          return irFunc
        }

        if fn.label.name == "eq" && fn.isGenerated {
          val otherParam = try argsForUnderlying[1] else unreachable()
          self.genEqMethodBody(selfParam, otherParam, selfConcreteType)
          irFunc.numLocals = self.curCtx.numLocals
          self.curCtx = prevCtx
          return irFunc
        }

        if fn.label.name == "hash" && fn.isGenerated {
          self.genHashMethodBody(selfParam, selfConcreteType)
          irFunc.numLocals = self.curCtx.numLocals
          self.curCtx = prevCtx
          return irFunc
        }
      }
    }

    if anyParamNeedsDefault || !ctx.paramsToDiscard.isEmpty() {
      val baseFnName = self.fnName(ctx.methodInstanceType, fn, ctx.concreteGenerics, [])
      self.enqueueFunction(fn, baseFnName, [], ctx.methodInstanceType, ctx.concreteGenerics)

      val closureEnvLoc = if isClosure {
        Some(ClosureEnvLocation.Passthrough)
      } else {
        None
      }

      if retTy == IrType.Unit {
        self.emit(Instruction(op: Operation.Call(ret: IrType.Unit, fnName: baseFnName, args: argsForUnderlying, envLocation: closureEnvLoc)))
        self.emit(Instruction(op: Operation.Return()))
      } else {
        val ident = self.ssaValue(retTy, Operation.Call(ret: retTy, fnName: baseFnName, args: argsForUnderlying, envLocation: closureEnvLoc), None)
        self.emit(Instruction(op: Operation.Return(Some(ident))))
      }
    } else {
      for node, idx in fn.body {
        if idx == fn.body.length - 1 && fn.scope.terminator != Some(tc.Terminator.Returning) {
          if retTy != IrType.Unit {
            val retVal = self.genExpression(node, ctx.concreteGenerics)
            self.emit(Instruction(op: Operation.Return(Some(retVal))))
          } else {
            self.genStatement(node, ctx.concreteGenerics)
            self.emit(Instruction(op: Operation.Return()))
          }
        } else {
          self.genStatement(node, ctx.concreteGenerics)
        }
      }
    }

    irFunc.numLocals = self.curCtx.numLocals
    self.curCtx = prevCtx

    irFunc
  }

  func getOrGenInitializerFn(self, concreteType: ConcreteType, enumVariant: tc.TypedEnumVariant?, concreteGenerics: Map<String, ConcreteType>, fieldsNeedingDefaultValue: Bool[] = []): IrFunction {
    val (fnName, fields, initialSize, enumVariantIdx) = match concreteType.instanceKind {
      InstanceKind.Struct(s) => {
        val fnName = self.structInitFnName(concreteType, fieldsNeedingDefaultValue)

        (fnName, s.fields, 0, None)
      }
      InstanceKind.Enum(e) => {
        val variant = try enumVariant else unreachable()
        val fields = match variant.kind {
          EnumVariantKind.Constant => unreachable()
          EnumVariantKind.Container(fields) => fields
        }
        val fnName = self.enumVariantInitFnName(concreteType, variant, fieldsNeedingDefaultValue)
        val (_, variantIdx) = try e.variants.findIndex(v => v.label.name == variant.label.name) else unreachable("${e.label.name}.${variant.label.name} must exist")

        (fnName, fields, 8, Some(variantIdx))
      }
    }

    if self.functionsByName[fnName] |f| return f

    val initializedTy = self.getIrTypeForConcreteType(concreteType)
    val irFunc = IrFunction(name: fnName, params: [], ret: initializedTy, isClosure: false, numLocals: 0)
    self.addFunction(fnName, irFunc)
    val prevCtx = self.enterFunction(irFunc, None)

    var size = initialSize
    var anyFieldNeedsDefault = false
    val argsForUnderlying: (Value, IrType, String, Int)[] = []
    for field, idx in fields {
      val fieldConcreteType = self.getConcreteTypeFromType(field.ty, concreteGenerics)
      val fieldTy = self.getIrTypeForConcreteType(fieldConcreteType)
      size += ALIGNMENT

      val fieldVal = if field.initializer |initializerNode| {
        val fieldNeedsDefault = fieldsNeedingDefaultValue[idx] ?: false
        if fieldNeedsDefault {
          anyFieldNeedsDefault = true
          self.genExpression(initializerNode, concreteGenerics, Some(field.name.name))
        } else {
          val ident = self.curCtx.addLocal(fieldTy, Some(field.name.name))
          irFunc.params.push(ident)
          Value.Ident(ident)
        }
      } else {
        val ident = self.curCtx.addLocal(fieldTy, Some(field.name.name))
        irFunc.params.push(ident)
        Value.Ident(ident)
      }

      argsForUnderlying.push((fieldVal, fieldTy, field.name.name, idx * ALIGNMENT))
    }

    val retVal = if anyFieldNeedsDefault {
      val baseFnName = if enumVariant |variant| {
        val baseFnName = self.enumVariantInitFnName(concreteType, variant, [])
        self.enqueueInitializer(concreteType, Some(variant), baseFnName, [], None, concreteGenerics)
        baseFnName
      } else {
        val baseFnName = self.structInitFnName(concreteType, [])
        self.enqueueInitializer(concreteType, None, baseFnName, [], None, concreteGenerics)
        baseFnName
      }

      self.ssaValue(initializedTy, Operation.Call(ret: initializedTy, fnName: baseFnName, args: argsForUnderlying.map(a => a[0])), None)
    } else {
      val mem = self.ssaValue(initializedTy, Operation.Builtin(ret: initializedTy, builtin: Builtin.Malloc(count: Value.Const(Const.Int(size)), itemTy: IrType.Byte)), None)

      if enumVariantIdx |enumVariantIdx| {
        self.emit(Instruction(op: Operation.StoreField(ty: IrType.I64, value: Value.Const(Const.Int(enumVariantIdx)), mem: mem, name: "\$idx", offset: 0)))
      }

      for (fieldVal, fieldTy, fieldName, fieldOffset), idx in argsForUnderlying {
        self.emit(Instruction(op: Operation.StoreField(ty: fieldTy, value: fieldVal, mem: mem, name: fieldName, offset: fieldOffset))) // todo: shouldn't this start at offset 1 (since offset 0 above is $idx)?
      }

      mem
    }
    self.emit(Instruction(op: Operation.Return(Some(retVal))))

    irFunc.numLocals = self.curCtx.numLocals
    self.curCtx = prevCtx

    irFunc
  }

  func genToStringMethodBody(self, selfVal: Value, concreteType: ConcreteType) {
    val strTy = IrType.Composite(self.knowns.stringType().name)

    val newConcreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
    match concreteType.instanceKind {
      InstanceKind.Struct(s) => {
        if s == self.project.preludeStringStruct {
          self.emit(Instruction(op: Operation.Return(Some(selfVal))))
          return
        }

        if s == self.project.preludeIntStruct || s == self.project.preludeFloatStruct || s == self.project.preludeBoolStruct {
          val builtin = if s == self.project.preludeIntStruct {
            Builtin.I64ToString(selfVal)
          } else if s == self.project.preludeFloatStruct {
            Builtin.F64ToString(selfVal)
          } else if s == self.project.preludeBoolStruct {
            Builtin.BoolToString(selfVal)
          } else unreachable()

          val ident = self.ssaValue(strTy, Operation.Builtin(ret: strTy, builtin: builtin), None)
          self.emit(Instruction(op: Operation.Return(Some(ident))))
          return
        }

        val isTupleStruct = self.isTupleStruct(s)
        val fields = s.fields.map((f, idx) => {
          val fieldConcreteType = self.getConcreteTypeFromType(f.ty, newConcreteGenerics)
          val fieldIrType = self.getIrTypeForConcreteType(fieldConcreteType)

          val itemVal = self.ssaValue(fieldIrType, Operation.LoadField(ty: fieldIrType, mem: selfVal, name: f.name.name, offset: idx * ALIGNMENT), None)
          val itemLabel = if isTupleStruct "" else f.name.name
          (itemLabel, fieldConcreteType, itemVal)
        })
        val prefix = if isTupleStruct "" else s.label.name

        val res = self.genToStringLogicForStructuredData(prefix, fields)
        self.emit(Instruction(op: Operation.Return(Some(res))))
      }
      InstanceKind.Enum(e) => {
        if e == self.project.preludeOptionEnum {
          val typeArg = try concreteType.typeArgs[0] else unreachable()
          val typeArgIrType = self.getIrTypeForConcreteType(typeArg)

          val isNoneBlock = self.withinBlock("is_none", false, () => {
            val none = self.ssaValue(strTy, Operation.ConstString("Option.None"), None)
            Some(none)
          })
          val isSomeBlock = self.withinBlock("is_some", false, () => {
            val some = self.ssaValue(typeArgIrType, Operation.OptionUnwrap(typeArgIrType, selfVal), None)
            val res = self.genToStringLogicForStructuredData("Option.Some", [("value", typeArg, some)])

            Some(res)
          })

          val selfIrType = self.getIrTypeForConcreteType(concreteType)
          val cond = self.ssaValue(IrType.Bool, Operation.OptionIsNone(typeArgIrType, selfVal), None)
          val ident = self.ssaValue(strTy, Operation.If(strTy, cond, isNoneBlock, isSomeBlock), None)
          self.emit(Instruction(op: Operation.Return(Some(ident))))
        } else {
          todo("genToStringMethodBody: enum")
        }
      }
    }
  }

  func genEqMethodBody(self, selfVal: Value, otherVal: Value, concreteType: ConcreteType) {
    val newConcreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
    match concreteType.instanceKind {
      InstanceKind.Struct(s) => {
        if s == self.project.preludeIntStruct || s == self.project.preludeFloatStruct || s == self.project.preludeBoolStruct {
          val ident = self.ssaValue(IrType.Bool, Operation.Eq(negate: false, left: selfVal, right: otherVal), None)
          self.emit(Instruction(op: Operation.Return(Some(ident))))
          return
        }

        val fields = s.fields.map((f, idx) => {
          val fieldConcreteType = self.getConcreteTypeFromType(f.ty, newConcreteGenerics)
          val fieldIrType = self.getIrTypeForConcreteType(fieldConcreteType)

          val selfItemVal = self.ssaValue(fieldIrType, Operation.LoadField(ty: fieldIrType, mem: selfVal, name: f.name.name, offset: idx * ALIGNMENT), None)
          val otherItemVal = self.ssaValue(fieldIrType, Operation.LoadField(ty: fieldIrType, mem: otherVal, name: f.name.name, offset: idx * ALIGNMENT), None)
          (fieldConcreteType, selfItemVal, otherItemVal)
        })

        val res = self.genEqLogicForStructuredData(fields)
        self.emit(Instruction(op: Operation.Return(Some(res))))
      }
      InstanceKind.Enum => todo("genEqMethodBody: enum")
    }
  }

  func genHashMethodBody(self, selfVal: Value, concreteType: ConcreteType) {
    val newConcreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
    match concreteType.instanceKind {
      InstanceKind.Struct(s) => {
        if s == self.project.preludeIntStruct || s == self.project.preludeBoolStruct || s == self.project.preludeCharStruct {
          self.emit(Instruction(op: Operation.Return(Some(selfVal))))
          return
        }
        if s == self.project.preludeFloatStruct {
          val ident = self.ssaValue(IrType.I64, Operation.Builtin(IrType.I64, Builtin.FloatBitsToInt(selfVal)), None)
          self.emit(Instruction(op: Operation.Return(Some(ident))))
          return
        }

        val fields = s.fields.map((f, idx) => {
          val fieldConcreteType = self.getConcreteTypeFromType(f.ty, newConcreteGenerics)
          val fieldIrType = self.getIrTypeForConcreteType(fieldConcreteType)

          val selfItemVal = self.ssaValue(fieldIrType, Operation.LoadField(ty: fieldIrType, mem: selfVal, name: f.name.name, offset: idx * ALIGNMENT), None)
          (fieldConcreteType, selfItemVal)
        })

        val res = self.genHashLogicForStructuredData(fields)
        self.emit(Instruction(op: Operation.Return(Some(res))))
      }
      InstanceKind.Enum => todo("genHashMethodBody: enum")
    }
  }

  func genStatement(self, node: tc.TypedAstNode, concreteGenerics: Map<String, ConcreteType>) {
    val pos = node.token.position

    match node.kind {
      TypedAstNodeKind.If(isStatement, condNode, condBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if !isStatement {
          self.genExpression(node, concreteGenerics)
          return
        }

        val optInnerTy = self.project.typeIsOption(condNode.ty)
        val condBindingVal = self.genExpression(condNode, concreteGenerics)
        val condVal = if optInnerTy |innerType| {
          val innerConcreteType = self.getConcreteTypeFromType(innerType, concreteGenerics)
          val innerTy = self.getIrTypeForConcreteType(innerConcreteType)
          val optIsNone = self.ssaValue(IrType.Bool, Operation.OptionIsNone(innerTy, condBindingVal), None)
          self.ssaValue(IrType.Bool, Operation.Negate(optIsNone), None)
        } else {
          condBindingVal
        }

        if self.valueAsCompileTime(condVal) |cond| {
          val condVal = match cond { Const.Bool(b) => b, else => todo("non-boolean if-conditions") }
          val block = if condVal ifBlock else elseBlock
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)
          for node, idx in block {
            self.genStatement(node, concreteGenerics)
          }

          return
        }

        val ifBody = self.withinBlock("then", !!ifBlockTerminator, () => {
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)

          for node, idx in ifBlock {
            self.genStatement(node, concreteGenerics)
          }

          None
        })
        val elseBody = self.withinBlock("else", !!elseBlockTerminator, () => {
          for node, idx in elseBlock {
            self.genStatement(node, concreteGenerics)
          }

          None
        })

        self.emit(Instruction(op: Operation.If(IrType.Unit, condVal, ifBody, elseBody)))
      }
      TypedAstNodeKind.Match => todo("TypedAstNodeKind.Match (${node.token.position})")
      TypedAstNodeKind.While(condNode, condBinding, block, terminator) => {
        val optInnerTy = self.project.typeIsOption(condNode.ty)

        val loopName = "while_loop"
        self.emit(Instruction(op: Operation.WhileLoopStart(loopName)))

        val condBindingVal = self.genExpression(condNode, concreteGenerics)
        val cond = if optInnerTy |innerType| {
          val innerConcreteType = self.getConcreteTypeFromType(innerType, concreteGenerics)
          val innerTy = self.getIrTypeForConcreteType(innerConcreteType)
          val optIsNone = self.ssaValue(IrType.Bool, Operation.OptionIsNone(innerTy, condBindingVal), None)
          self.ssaValue(IrType.Bool, Operation.Negate(optIsNone), None)
        } else {
          condBindingVal
        }

        val body = self.withinBlock(loopName, !!terminator, () => {
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)

          for node, idx in block {
            self.genStatement(node, concreteGenerics)
          }

          None
        })

        self.emit(Instruction(op: Operation.While(cond: cond, body: body)))
      }
      TypedAstNodeKind.For(typedForIterKind, itemBinding, indexBinding, block, terminator) => self.genForLoop(pos, concreteGenerics, typedForIterKind, itemBinding, indexBinding, block, terminator)
      TypedAstNodeKind.BindingDeclaration(node) => self.genBindingDeclaration(node, concreteGenerics)
      TypedAstNodeKind.FunctionDeclaration => { /* todo: TypedAstNodeKind.FunctionDeclaration */ }
      TypedAstNodeKind.TypeDeclaration => { /* todo: TypedAstNodeKind.TypeDeclaration */ }
      TypedAstNodeKind.EnumDeclaration => { /* todo: TypedAstNodeKind.EnumDeclaration */ }
      TypedAstNodeKind.Break => self.emit(Instruction(op: Operation.Break))
      TypedAstNodeKind.Continue => self.emit(Instruction(op: Operation.Continue))
      TypedAstNodeKind.Return(retValExpr) => {
        val retVal = if retValExpr |expr| {
          Some(self.genExpression(expr, concreteGenerics))
        } else {
          None
        }

        self.emit(Instruction(op: Operation.Return(retVal)))
      }
      TypedAstNodeKind.Placeholder => unreachable("Placeholder nodes should not be emitted from the typechecker")
      TypedAstNodeKind.Assignment(mode, op, expr) => self.genAssignment(pos, concreteGenerics, mode, op, expr)
      else => self.genExpression(node, concreteGenerics)
    }
  }

  func genForLoop(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, typedForIterKind: tc.TypedForIterKind, itemBinding: (BindingPattern, tc.Variable[]), indexBinding: tc.Variable?, block: tc.TypedAstNode[], terminator: tc.Terminator?) {
    match typedForIterKind {
      TypedForIterKind.Expr(expr) => {
        val exprVal = self.genExpression(expr, concreteGenerics)
        val exprConcreteType = self.getConcreteTypeFromType(expr.ty, concreteGenerics)
        var isMap = false

        val (iterVal, iterConcreteType) = if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeArrayStruct) {
          val arrItemConcreteType = try exprConcreteType.typeArgs[0] else unreachable("ConcreteType for array must have 1 type argument")
          val arrConcreteGenerics = { "T": arrItemConcreteType } // `T` is the known generic of `Array#iterator`

          val arrayIteratorFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "iterator", staticMethod: false)
          val arrayIteratorFnName = self.fnName(Some(exprConcreteType), arrayIteratorFn, arrConcreteGenerics, [])
          self.enqueueFunction(arrayIteratorFn, arrayIteratorFnName, [], Some(exprConcreteType), arrConcreteGenerics)

          val iterConcreteType = self.getConcreteTypeFromType(arrayIteratorFn.returnType, arrConcreteGenerics)
          val iterIrType = self.getIrTypeForConcreteType(iterConcreteType)
          val iterVal = self.ssaValue(iterIrType, Operation.Call(ret: iterIrType, fnName: arrayIteratorFnName, args: [exprVal]), None)

          (iterVal, iterConcreteType)
        } else if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeSetStruct) {
          val setItemConcreteType = try exprConcreteType.typeArgs[0] else unreachable("ConcreteType for set must have 1 type argument")
          val setConcreteGenerics = { "T": setItemConcreteType } // `T` is the known generic of `Set#iterator`

          val setIteratorFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeSetStruct), "iterator", staticMethod: false)
          val setIteratorFnName = self.fnName(Some(exprConcreteType), setIteratorFn, setConcreteGenerics, [])
          self.enqueueFunction(setIteratorFn, setIteratorFnName, [], Some(exprConcreteType), setConcreteGenerics)

          val iterConcreteType = self.getConcreteTypeFromType(setIteratorFn.returnType, setConcreteGenerics)
          val iterIrType = self.getIrTypeForConcreteType(iterConcreteType)
          val iterVal = self.ssaValue(iterIrType, Operation.Call(ret: iterIrType, fnName: setIteratorFnName, args: [exprVal]), None)

          (iterVal, iterConcreteType)
        } else if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeMapStruct) {
          isMap = true
          val mapKeyConcreteType = try exprConcreteType.typeArgs[0] else unreachable("ConcreteType for map must have 2 type arguments")
          val mapValConcreteType = try exprConcreteType.typeArgs[1] else unreachable("ConcreteType for map must have 2 type arguments")
          val mapConcreteGenerics = { "K": mapKeyConcreteType, "V": mapValConcreteType } // `K` and `V` are the known generics of `Map#iterator`

          val mapIteratorFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeMapStruct), "iterator", staticMethod: false)
          val mapIteratorFnName = self.fnName(Some(exprConcreteType), mapIteratorFn, mapConcreteGenerics, [])
          self.enqueueFunction(mapIteratorFn, mapIteratorFnName, [], Some(exprConcreteType), mapConcreteGenerics)

          val iterConcreteType = self.getConcreteTypeFromType(mapIteratorFn.returnType, mapConcreteGenerics)
          val iterIrType = self.getIrTypeForConcreteType(iterConcreteType)
          val iterVal = self.ssaValue(iterIrType, Operation.Call(ret: iterIrType, fnName: mapIteratorFnName, args: [exprVal]), None)

          (iterVal, iterConcreteType)
        } else {
          (exprVal, exprConcreteType)
        }

        val iterConcreteGenerics = self.extractConcreteGenericsFromConcreteType(iterConcreteType)

        val nextFn = self.getMethodByName(iterConcreteType.instanceKind, "next", staticMethod: false)
        val nextFnName = self.fnName(Some(iterConcreteType), nextFn, iterConcreteGenerics, [])
        self.enqueueFunction(nextFn, nextFnName, [], Some(iterConcreteType), iterConcreteGenerics)

        val nextFnRetConcreteTy = self.getConcreteTypeFromType(nextFn.returnType, iterConcreteGenerics)
        val nextFnRetIrTy = self.getIrTypeForConcreteType(nextFnRetConcreteTy)
        val nextFnRetInnerTy = try self.project.typeIsOption(nextFn.returnType) else unreachable("next() must return T?")
        val nextFnRetInnerConcreteTy = self.getConcreteTypeFromType(nextFnRetInnerTy, iterConcreteGenerics)
        val nextFnRetInnerIrTy = self.getIrTypeForConcreteType(nextFnRetInnerConcreteTy)

        val idxSlot = if indexBinding |idxVariable| {
          idxVariable.mutable = true  // TODO: this is kinda gross, should probably be fixed in the typechecker
          val varName = self.varName(idxVariable)
          val idxSlot = self.ssaValue(IrType.I64, Operation.NewLocal(ty: IrType.I64, captured: false, initialValue: Some(Value.Const(Const.Int(-1)))), Some(varName))
          self.curCtx.locals[varName] = idxSlot
          match idxSlot { Value.Ident(i) => Some(i), else => unreachable("ssaValue returns Ident") }
        } else {
          None
        }

        val loopName = "for_loop"
        self.emit(Instruction(op: Operation.WhileLoopStart(loopName)))

        val condBindingVal = self.ssaValue(nextFnRetIrTy, Operation.Call(ret: nextFnRetIrTy, fnName: nextFnName, args: [iterVal]), None)
        val optIsNone = self.ssaValue(IrType.Bool, Operation.OptionIsNone(nextFnRetInnerIrTy, condBindingVal), None)
        val cond = self.ssaValue(IrType.Bool, Operation.Negate(optIsNone), None)

        val body = self.withinBlock(loopName, !!terminator, () => {
          val (pattern, vars) = itemBinding
          val variables = vars.keyBy(v => v.label.name)

          val nextVal = self.ssaValue(nextFnRetInnerIrTy, Operation.OptionUnwrap(nextFnRetInnerIrTy, condBindingVal), None)

          val names = variables.values().map(v => (v.label.name, v.ty.repr()))
          val bindingConcreteGenerics = self.deriveConcreteGenericsOfForLoopBindingPattern(pattern, variables, nextFnRetInnerConcreteTy)
          self.genBindingPattern(pattern, variables, Some((nextVal, nextFnRetInnerConcreteTy)), bindingConcreteGenerics)

          if idxSlot |idxSlot| {
            val idxValue = self.ssaValue(IrType.I64, Operation.LoadVar(ty: IrType.I64, ident: idxSlot), None)
            val idxInc = self.ssaValue(IrType.I64, Operation.Add(Value.Const(Const.Int(1)), idxValue), None)
            self.emit(Instruction(op: Operation.StoreVar(ty: IrType.I64, value: idxInc, ident: idxSlot)))
          }

          val loopBodyConcreteGenerics: Map<String, ConcreteType> = {}
          for (name, ty) in concreteGenerics {
            loopBodyConcreteGenerics[name] = ty
          }
          for (name, ty) in bindingConcreteGenerics {
            if loopBodyConcreteGenerics[name] |prev| {
              if prev != ty unreachable("would insert conflicting type for generic '$name' (was previously '$prev', but want to insert '$ty')")
            } else {
              loopBodyConcreteGenerics[name] = ty
            }
          }

          for node, idx in block {
            self.genStatement(node, loopBodyConcreteGenerics)
          }

          None
        })

        self.emit(Instruction(op: Operation.While(cond: cond, body: body)))
      }
      TypedForIterKind.Range(start, end) => {
        val (iterateePattern, iterateeBindingVars) = itemBinding
        val iterateeVar = try iterateeBindingVars[0] else unreachable("There should always be an iteratee binding variable")
        iterateeVar.mutable = true // TODO: this is kinda gross, should probably be fixed in the typechecker
        val itVarName = self.varName(iterateeVar)

        val startValue = self.genExpression(start, concreteGenerics)
        val itVar = self.curCtx.addLocal(IrType.I64, Some(itVarName))

        val idxVar = if indexBinding |idxBindingVar| {
          idxBindingVar.mutable = true  // TODO: this is kinda gross, should probably be fixed in the typechecker
          val varName = self.varName(idxBindingVar)
          val idxVal = self.curCtx.addLocal(IrType.I64, Some(varName))
          Some(idxVal)
        } else {
          None
        }

        val endValue = self.genCompoundValue(() => self.genExpression(end, concreteGenerics))

        val body = self.withinBlock("for_loop", !!terminator, () => {
          for node, idx in block {
            self.genStatement(node, concreteGenerics)
          }

          None
        })

        self.emit(Instruction(op: Operation.ForRanged(start: startValue, end: endValue, iteratee: itVar, idx: idxVar, body: body)))
      }
    }
  }

  func deriveConcreteGenericsOfForLoopBindingPattern(self, pattern: BindingPattern, variables: Map<String, tc.Variable>, workingConcreteTy: ConcreteType, result: Map<String, ConcreteType> = {}): Map<String, ConcreteType> {
    match pattern {
      BindingPattern.Variable(varName) => {
        val variable = try variables[varName.name] else unreachable("expected variable '${varName.name}'")
        self._deriveConcreteGenericsOfForLoopVariableBindingPattern(variable.ty, workingConcreteTy, result)
      }
      BindingPattern.Tuple(_, patterns) => {
        val isInvalid = match workingConcreteTy.instanceKind { InstanceKind.Struct(s) => !self.isTupleStruct(s), else => true }
        if isInvalid unreachable("expected tuple concrete type but got $workingConcreteTy")

        for pat, idx in patterns {
          val tupleTy = try workingConcreteTy.typeArgs[idx] else unreachable("invalid tuple arity (expected ${patterns.length}, but was ${workingConcreteTy.typeArgs.length})")
          self.deriveConcreteGenericsOfForLoopBindingPattern(pat, variables, tupleTy, result)
        }
      }
    }

    result
  }

  func _deriveConcreteGenericsOfForLoopVariableBindingPattern(self, bindingType: tc.Type, workingConcreteTy: ConcreteType, result: Map<String, ConcreteType> = {}) {
    match bindingType.kind {
      TypeKind.Generic(name) => {
        result[name] = workingConcreteTy
      }
      TypeKind.Tuple(types) => {
        val isInvalid = match workingConcreteTy.instanceKind { InstanceKind.Struct(s) => !self.isTupleStruct(s), else => true }
        if isInvalid unreachable("expected tuple concrete type but got $workingConcreteTy")

        for ty, idx in types {
          val tupleTy = try workingConcreteTy.typeArgs[idx] else unreachable("invalid tuple arity (expected ${types.length}, but was ${workingConcreteTy.typeArgs.length})")
          self._deriveConcreteGenericsOfForLoopVariableBindingPattern(ty, tupleTy, result)
        }
      }
    }
  }

  func genBindingDeclaration(self, node: tc.TypedBindingDeclarationNode, concreteGenerics: Map<String, ConcreteType>) {
    val variables = node.variables.keyBy(v => v.label.name)
    val exprVal = if node.expr |expr| {
      val exprVal = self.genExpression(expr, concreteGenerics)
      val exprTy = self.getConcreteTypeFromType(expr.ty, concreteGenerics)
      Some((exprVal, exprTy))
    } else {
      None
    }
    self.genBindingPattern(node.bindingPattern, variables, exprVal, concreteGenerics)
  }

  func genBindingPattern(self, pattern: BindingPattern, variables: Map<String, tc.Variable>, value: (Value, ConcreteType)?, concreteGenerics: Map<String, ConcreteType>) {
    val name = match pattern {
      BindingPattern.Variable(label) => label.name
      BindingPattern.Tuple(tok, pats) => {
        val (value, valueTy) = try value else return
        for pat, idx in pats {
          val itemTy = try valueTy.typeArgs[idx] else unreachable()
          val itemIrTy = self.getIrTypeForConcreteType(itemTy)
          val itemVal = self.ssaValue(itemIrTy, Operation.LoadField(ty: itemIrTy, mem: value, name: "__$idx", offset: idx * ALIGNMENT), None)

          self.genBindingPattern(pat, variables, Some((itemVal, itemTy)), concreteGenerics)
        }

        return
      }
    }
    val variable = try variables[name] else unreachable("expected binding '$name', but missing from variables")

    if self.variableIsGlobal(variable) |modId| {
      val global = self.addGlobal(variable, modId, concreteGenerics)
      if value |(value, _)| {
        if self.valueAsCompileTime(value) |v| {
          global.initialValue = Some(v)
        } else {
          global.referenced = true
          self.emit(Instruction(op: Operation.StoreGlobal(ty: global.ty, value: value, global: global)))
        }
      }

      return
    }

    val varName = self.varName(variable)
    val varTy = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varIrTy = self.getIrTypeForConcreteType(varTy)
    val ident = if value |(value, _)| {
      if variable.mutable {
        self.ssaValue(varIrTy, Operation.NewLocal(ty: varIrTy, captured: variable.isCaptured, initialValue: Some(value)), Some(varName))
      } else {
        value
      }
    } else {
      self.ssaValue(varIrTy, Operation.NewLocal(ty: varIrTy, captured: variable.isCaptured, initialValue: None), Some(varName))
    }

    self.curCtx.locals[varName] = ident
  }

  func genConditionBinding(self, concreteGenerics: Map<String, ConcreteType>, innerOptType: tc.Type?, condValue: Value, condBinding: (BindingPattern, tc.Variable[])) {
    val (pattern, vars) = condBinding
    val variables = vars.keyBy(v => v.label.name)
    match pattern {
      BindingPattern.Variable(label) => {
        if innerOptType |innerTy| {
          val innerConcreteType = self.getConcreteTypeFromType(innerTy, concreteGenerics)
          val innerIrType = self.getIrTypeForConcreteType(innerConcreteType)
          val optVal = self.ssaValue(innerIrType, Operation.OptionUnwrap(innerTy: innerIrType, value: condValue), None)
          self.genBindingPattern(pattern, variables, Some((optVal, innerConcreteType)), concreteGenerics)
        }
      }
      BindingPattern.Tuple(_, pats) => {
        val innerTy = try innerOptType else unreachable("cannot destructure a Bool")
        val innerConcreteType = self.getConcreteTypeFromType(innerTy, concreteGenerics)
        val innerIrType = self.getIrTypeForConcreteType(innerConcreteType)

        val optVal = self.ssaValue(innerIrType, Operation.OptionUnwrap(innerTy: innerIrType, value: condValue), None)
        self.genBindingPattern(pattern, variables, Some((optVal, innerConcreteType)), concreteGenerics)
      }
    }
  }

  func genAssignment(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, mode: TypedAssignmentMode, op: AssignOp, expr: tc.TypedAstNode) {
    val res = self.genExpression(expr, concreteGenerics)

    match mode {
      TypedAssignmentMode.Variable(v) => {
        val varTy = self.getConcreteTypeFromType(v.ty, concreteGenerics)
        val varIrTy = self.getIrTypeForConcreteType(varTy)

        if self.variableIsGlobal(v) |modId| {
          val globalName = self.globalName(modId, v.label.name)
          val global = self.getGlobal(globalName, pos)
          global.referenced = true
          self.emit(Instruction(op: Operation.StoreGlobal(ty: varIrTy, value: res, global: global)))
        } else if v.isCaptured {
          self.genStoreCapturedVar(pos, concreteGenerics, v, res)
        } else {
          val varName = self.varName(v)
          val local = self.curCtx.getLocal(varName, pos)
          val ident = match local { Value.Ident(i) => i, else => unreachable("expected ident for local '$varName'") }
          self.emit(Instruction(op: Operation.StoreVar(ty: varIrTy, value: res, ident: ident)))
        }
      }
      TypedAssignmentMode.Indexing(mode) => {
        match mode {
          TypedIndexingNode.ArrayLike(arrExpr, mode) => {
            val idxExpr = match mode { IndexingMode.Single(idxExpr) => idxExpr, IndexingMode.Range => unreachable("cannot use range index in index-assignment") }
            val idxVal = self.genExpression(idxExpr, concreteGenerics)

            val arrVal = self.genExpression(arrExpr, concreteGenerics)
            val exprConcreteType = self.getConcreteTypeFromType(arrExpr.ty, concreteGenerics)
            val arrIrTy = self.getIrTypeForConcreteType(exprConcreteType)

            val arrItemConcreteType = try exprConcreteType.typeArgs[0] else unreachable("ConcreteType for array must have 1 type argument")
            val arrConcreteGenerics = { "T": arrItemConcreteType } // `T` is the known generic of `Array#set`

            val arraySetFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "set", staticMethod: false)
            val arraySetFnName = self.fnName(Some(exprConcreteType), arraySetFn, arrConcreteGenerics, [])
            self.enqueueFunction(arraySetFn, arraySetFnName, [], Some(exprConcreteType), arrConcreteGenerics)

            val optWrapperConcreteType = ConcreteType(instanceKind: InstanceKind.Enum(self.project.preludeOptionEnum), typeArgs: [arrItemConcreteType])
            val optWrapperIrTy = self.getIrTypeForConcreteType(optWrapperConcreteType)

            self.ssaValue(IrType.Unit, Operation.Call(ret: optWrapperIrTy, fnName: arraySetFnName, args: [arrVal, idxVal, res]), None)
          }
          TypedIndexingNode.Map(mapExpr, idxExpr) => {
            val idxVal = self.genExpression(idxExpr, concreteGenerics)

            val mapVal = self.genExpression(mapExpr, concreteGenerics)
            val mapConcreteType = self.getConcreteTypeFromType(mapExpr.ty, concreteGenerics)
            val mapIrTy = self.getIrTypeForConcreteType(mapConcreteType)

            val mapKeyConcreteType = try mapConcreteType.typeArgs[0] else unreachable("ConcreteType for map must have 2 type arguments")
            val mapValConcreteType = try mapConcreteType.typeArgs[1] else unreachable("ConcreteType for map must have 2 type arguments")
            val mapKeyIrTy = self.getIrTypeForConcreteType(mapKeyConcreteType)
            val mapValIrTy = self.getIrTypeForConcreteType(mapValConcreteType)

            val mapConcreteGenerics = { "K": mapKeyConcreteType, "V": mapValConcreteType } // `K`, and `V` are the known generics of `Map.insert`
            val mapInsertFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeMapStruct), "insert", staticMethod: false)
            val mapInsertFnName = self.fnName(Some(mapConcreteType), mapInsertFn, mapConcreteGenerics, [])
            self.enqueueFunction(mapInsertFn, mapInsertFnName, [], Some(mapConcreteType), mapConcreteGenerics)

            val optWrapperConcreteType = ConcreteType(instanceKind: InstanceKind.Enum(self.project.preludeOptionEnum), typeArgs: [mapValConcreteType])
            val optWrapperIrTy = self.getIrTypeForConcreteType(optWrapperConcreteType)

            self.ssaValue(IrType.Unit, Operation.Call(ret: optWrapperIrTy, fnName: mapInsertFnName, args: [mapVal, idxVal, res]), None)
          }
          TypedIndexingNode.Tuple => unreachable("cannot assign to tuple via indexing")
        }
      }
      TypedAssignmentMode.Accessor(head, middle, tail) => self.followAccessorPath(head, middle, tail, concreteGenerics, None, Some(res))
    }
  }

  func genExpression(self, node: tc.TypedAstNode, concreteGenerics: Map<String, ConcreteType>, dst: String? = None): Value {
    val pos = node.token.position

    match node.kind {
      TypedAstNodeKind.Literal(lit) => self.genLiteral(pos, lit, dst)
      TypedAstNodeKind.StringInterpolation(exprs) => self.genStringInterpolation(pos, concreteGenerics, exprs, dst)
      TypedAstNodeKind.Unary(op, expr) => self.genUnary(pos, concreteGenerics, dst, expr, op)
      TypedAstNodeKind.Binary(left, op, right) => self.genBinary(pos, concreteGenerics, dst, left, op, right)
      TypedAstNodeKind.Grouped(inner) => self.genExpression(inner, concreteGenerics, dst)
      TypedAstNodeKind.Identifier(name, variable, fnAliasTypeHint, varImportModule) => self.genIdentifier(pos, concreteGenerics, dst, name, variable, fnAliasTypeHint, varImportModule)
      TypedAstNodeKind.Accessor(head, middle, tail) => self.followAccessorPath(head, middle, tail, concreteGenerics, dst)
      TypedAstNodeKind.Invocation(invokee, args, resolvedGenerics) => {
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        for (name, ty) in resolvedGenerics.entries() {
          val concreteType = self.getConcreteTypeFromType(ty, concreteGenerics)
          newConcreteGenerics[name] = concreteType
        }
        self.genCall(pos, concreteGenerics, newConcreteGenerics, dst, invokee, args)
      }
      TypedAstNodeKind.Array(items) => self.genArray(pos, concreteGenerics, dst, node.ty, items)
      TypedAstNodeKind.Set(items) => self.genSet(pos, concreteGenerics, dst, node.ty, items)
      TypedAstNodeKind.Map(items) => self.genMap(pos, concreteGenerics, dst, node.ty, items)
      TypedAstNodeKind.Tuple(items) => {
        val tupleStruct = self.tupleStruct(items.length)
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        val args: tc.TypedAstNode?[] = []
        for item, idx in items {
          args.push(Some(item))
          val itemConcreteType = self.getConcreteTypeFromType(item.ty, concreteGenerics)
          val tupleTypeParam = try tupleStruct.typeParams[idx] else unreachable("expected tuple type param at idx $idx")
          newConcreteGenerics[tupleTypeParam] = itemConcreteType
        }
        val invokee = tc.TypedInvokee.Struct(tupleStruct)

        self.genCall(pos, concreteGenerics, newConcreteGenerics, dst, invokee, args)
      }
      TypedAstNodeKind.Indexing(node) => self.genIndexing(pos, concreteGenerics, dst, node)
      TypedAstNodeKind.Lambda(fn, typeHint) => self.genLambda(concreteGenerics, fn, typeHint, dst)
      TypedAstNodeKind.If(isStatement, condNode, condBinding, ifBlock, ifBlockTerminator, elseBlock, elseBlockTerminator) => {
        if isStatement unreachable("unexpected if statement")

        val optInnerTy = self.project.typeIsOption(condNode.ty)
        val condBindingVal = self.genExpression(condNode, concreteGenerics)
        val condVal = if optInnerTy |innerType| {
          val innerConcreteType = self.getConcreteTypeFromType(innerType, concreteGenerics)
          val innerTy = self.getIrTypeForConcreteType(innerConcreteType)
          val optIsNone = self.ssaValue(IrType.Bool, Operation.OptionIsNone(innerTy, condBindingVal), None)
          self.ssaValue(IrType.Bool, Operation.Negate(optIsNone), None)
        } else {
          condBindingVal
        }

        if self.valueAsCompileTime(condVal) |cond| {
          val condVal = match cond { Const.Bool(b) => b, else => todo("non-boolean if-conditions") }
          val block = if condVal ifBlock else elseBlock
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)
          for node, idx in block {
            if idx == block.length - 1 && !ifBlockTerminator {
              return self.genExpression(node, concreteGenerics, dst)
            } else {
              self.genStatement(node, concreteGenerics)
            }
          }
          unreachable("should have returned above")
        }

        val ifBody = self.withinBlock("then", !!ifBlockTerminator, () => {
          if condBinding |binding| self.genConditionBinding(concreteGenerics, optInnerTy, condBindingVal, binding)
          for node, idx in ifBlock {
            if idx == ifBlock.length - 1 && !ifBlockTerminator {
              return Some(self.genExpression(node, concreteGenerics))
            } else {
              self.genStatement(node, concreteGenerics)
            }
          }

          None
        })
        val elseBody = self.withinBlock("else", !!elseBlockTerminator, () => {
          for node, idx in elseBlock {
            if idx == elseBlock.length - 1 && !elseBlockTerminator {
              return Some(self.genExpression(node, concreteGenerics))
            } else {
              self.genStatement(node, concreteGenerics)
            }
          }

          None
        })

        if !!ifBlockTerminator && !!elseBlockTerminator {
          self.emit(Instruction(op: Operation.If(IrType.Unit, condVal, ifBody, elseBody)))
          return Value.Unit
        }

        val resConcreteType = self.getConcreteTypeFromType(node.ty, concreteGenerics)
        val resIrTy = self.getIrTypeForConcreteType(resConcreteType)
        self.ssaValue(resIrTy, Operation.If(resIrTy, condVal, ifBody, elseBody), dst)
      }
      TypedAstNodeKind.Try(expr, elseClause) => self.genTry(concreteGenerics, expr, elseClause, dst)
      else => todo("Other expressions (${node.token})")
    }
  }

  func genLiteral(self, pos: Position, lit: LiteralAstNode, dst: String?): Value {
    match lit {
      LiteralAstNode.Int(i) => self.ssaValueComptime(Const.Int(i), dst)
      LiteralAstNode.Float(f) => self.ssaValueComptime(Const.Float(f), dst)
      LiteralAstNode.Bool(b) => self.ssaValueComptime(Const.Bool(b), dst)
      LiteralAstNode.Char(c) => self.ssaValueComptime(Const.Char(c), dst)
      LiteralAstNode.String(s) => self.ssaValueComptime(Const.String(s), dst)
    }
  }

  func genStringInterpolation(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, exprs: tc.TypedAstNode[], dst: String?): Value {
    val strIrTy = IrType.Composite(self.knowns.stringType().name)

    var allComptime = true
    val comptimeStrings: String[] = []
    val exprVals: (Value, ConcreteType)[] = []
    for expr in exprs {
      val exprVal = self.genExpression(expr, concreteGenerics)
      val concreteType = self.getConcreteTypeFromType(expr.ty, concreteGenerics)

      if allComptime {
        if self.valueAsCompileTime(exprVal) |exprVal| {
          val str = match exprVal {
            Const.Int(i) => i.toString()
            Const.Float(f) => f.toString()
            Const.Bool(b) => b.toString()
            Const.Char(c) => Char.fromInt(c).toString()
            Const.String(s) => s
          }
          comptimeStrings.push(str)
        } else {
          allComptime = false
        }
      }

      exprVals.push((exprVal, concreteType))
    }

    if allComptime return Value.Const(Const.String(comptimeStrings.join()))

    val toStringVals: (Value, Value)[] = []
    var totalLenVal = Value.Const(Const.Int(0))
    for (exprVal, concreteType) in exprVals {
      val toStringVal = if self.getValueTy(exprVal) == strIrTy {
        exprVal
      } else {
        self.genCallToStringMethod(exprVal, concreteType)
      }

      if exprVals.length == 1 return toStringVal

      val strLenVal = self.ssaValue(IrType.I64, Operation.LoadField(ty: IrType.I64, mem: toStringVal, name: "length", offset: 0 * ALIGNMENT), None)
      val strBufVal = self.ssaValue(IrType.Ptr, Operation.LoadField(ty: IrType.Ptr, mem: toStringVal, name: "_buffer", offset: 1 * ALIGNMENT), None)
      toStringVals.push((strLenVal, strBufVal))

      totalLenVal = self.ssaValue(IrType.I64, Operation.Add(totalLenVal, strLenVal), None)
    }

    val lenPlusOneVal = self.ssaValue(IrType.I64, Operation.Add(Value.Const(Const.Int(1)), totalLenVal), None) // account for NULL
    val totalBufVal = self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.Malloc(count: lenPlusOneVal, itemTy: IrType.Byte)), None)
    var cursor = Value.Const(Const.Int(0))
    for (strLenVal, strBufVal) in toStringVals {
      val builtin = Builtin.CopyFrom(dst: totalBufVal, dstOffset: cursor, src: strBufVal, srcOffset: Value.Const(Const.Int(0)), size: strLenVal, itemTy: IrType.Byte)
      self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: builtin)))

      cursor = self.ssaValue(IrType.I64, Operation.Add(cursor, strLenVal), None)
    }

    val strInitFn = self.knowns.stringInitializerFn()

    self.ssaValue(strIrTy, Operation.Call(ret: strIrTy, fnName: strInitFn.name, args: [totalLenVal, totalBufVal]), dst)
  }

  func genUnary(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, expr: tc.TypedAstNode, op: UnaryOp): Value {
    val exprVal = self.genExpression(expr, concreteGenerics)

    match op {
      UnaryOp.Minus => {
        if self.valueAsCompileTime(exprVal) |exprVal| {
          return match exprVal {
            Const.Int(v) => self.ssaValueComptime(Const.Int(-v), dst)
            Const.Float(v) => self.ssaValueComptime(Const.Float(-v), dst)
            else => unreachable("[genUnary minus]: unexpected const value ($exprVal)")
          }
        }

        self.ssaValue(self.getValueTy(exprVal), Operation.Minus(exprVal), dst)
      }
      UnaryOp.Negate => {
        if self.valueAsCompileTime(exprVal) |exprVal| {
          return match exprVal {
            Const.Bool(v) => self.ssaValueComptime(Const.Bool(!v), dst)
            else => unreachable("[genUnary negate]: unexpected const value ($exprVal)")
          }
        }

        if self.project.typeIsOption(expr.ty) |innerType| {
          val innerConcreteType = self.getConcreteTypeFromType(innerType, concreteGenerics)
          val innerTy = self.getIrTypeForConcreteType(innerConcreteType)
          self.ssaValue(IrType.Bool, Operation.OptionIsNone(innerTy, exprVal), dst)
        } else {
          self.ssaValue(IrType.Bool, Operation.Negate(exprVal), dst)
        }
      }
    }
  }

  func genBinary(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, left: tc.TypedAstNode, op: BinaryOp, right: tc.TypedAstNode): Value {
    match op {
      BinaryOp.Add => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        val strTy = IrType.Composite(self.knowns.stringType().name)
        val lvalTy = self.getValueTy(lval)
        val rvalTy = self.getValueTy(rval)
        if lvalTy == strTy || rvalTy == strTy {
          if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
            val constStr = match lval {
              Const.Int(l) => match rval { Const.String(r) => l + r, else => unreachable() }
              Const.Float(l) => match rval { Const.String(r) => l + r, else => unreachable() }
              Const.Bool(l) => match rval { Const.String(r) => l + r, else => unreachable() }
              Const.Char(l) => match rval { Const.String(r) => l + r, else => unreachable() }
              Const.String(l) => match rval {
                Const.Int(r) => l + r
                Const.Float(r) => l + r
                Const.Bool(r) => l + r
                Const.Char(r) => l + r
                Const.String(r) => l + r
              }
            }

            return self.ssaValueComptime(Const.String(constStr), dst)
          }

          val lStrVal = if lvalTy == strTy {
            lval
          } else {
            val leftConcreteType = self.getConcreteTypeFromType(left.ty, concreteGenerics)
            self.genCallToStringMethod(lval, leftConcreteType, dst)
          }
          val rStrVal = if rvalTy == strTy {
            rval
          } else {
            val rightConcreteType = self.getConcreteTypeFromType(right.ty, concreteGenerics)
            self.genCallToStringMethod(rval, rightConcreteType, dst)
          }

          val strConcreteTy = ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeStringStruct))
          val concatFn = self.getMethodByName(strConcreteTy.instanceKind, "concat", staticMethod: false)
          val concatFnName = self.fnName(Some(strConcreteTy), concatFn, {}, [])
          self.enqueueFunction(concatFn, concatFnName, [], Some(strConcreteTy), {})

          return self.ssaValue(strTy, Operation.Call(ret: strTy, fnName: concatFnName, args: [lStrVal, rStrVal]), dst)
        }

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Int(l + r)
              Const.Float(r) => Const.Float(l + r)
              else => unreachable("[genBinary add]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Float(l + r)
              Const.Float(r) => Const.Float(l + r)
              else => unreachable("[genBinary add]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary add]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        val resTy = if lvalTy == IrType.F64 || rvalTy == IrType.F64 { IrType.F64 } else { IrType.I64 }
        self.ssaValue(resTy, Operation.Add(lval, rval), dst)
      }
      BinaryOp.Sub => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Int(l - r)
              Const.Float(r) => Const.Float(l - r)
              else => unreachable("[genBinary sub]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Float(l - r)
              Const.Float(r) => Const.Float(l - r)
              else => unreachable("[genBinary sub]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary sub]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        val resTy = if self.getValueTy(lval) == IrType.F64 || self.getValueTy(rval) == IrType.F64 { IrType.F64 } else { IrType.I64 }
        self.ssaValue(resTy, Operation.Sub(lval, rval), dst)
      }
      BinaryOp.Mul => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Int(l * r)
              Const.Float(r) => Const.Float(l * r)
              else => unreachable("[genBinary mul]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Float(l * r)
              Const.Float(r) => Const.Float(l * r)
              else => unreachable("[genBinary mul]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary mul]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        val resTy = if self.getValueTy(lval) == IrType.F64 || self.getValueTy(rval) == IrType.F64 { IrType.F64 } else { IrType.I64 }
        self.ssaValue(resTy, Operation.Mul(lval, rval), dst)
      }
      BinaryOp.Div => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val float = match lval {
            Const.Int(l) => match rval { Const.Int(r) => l / r, Const.Float(r) => l / r, else => unreachable("[genBinary div]: unexpected const value ($rval)") }
            Const.Float(l) => match rval { Const.Int(r) => l / r, Const.Float(r) => l / r, else => unreachable("[genBinary div]: unexpected const value ($rval)") }
            else => unreachable("[genBinary div]: unexpected const value ($lval)")
          }
          val const = Const.Float(float)

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.F64, Operation.Div(lval, rval), dst)
      }
      BinaryOp.Mod => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Int(l % r)
              Const.Float(r) => Const.Float(l % r)
              else => unreachable("[genBinary mod]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Float(l % r)
              Const.Float(r) => Const.Float(l % r)
              else => unreachable("[genBinary mod]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary mod]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        val resTy = if self.getValueTy(lval) == IrType.I64 && self.getValueTy(rval) == IrType.I64 { IrType.I64 } else { IrType.F64 }
        self.ssaValue(resTy, Operation.Mod(lval, rval), dst)
      }
      BinaryOp.Pow => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val float = match lval {
            Const.Int(l) => match rval { Const.Int(r) => l ** r, Const.Float(r) => l ** r, else => unreachable("[genBinary pow]: unexpected const value ($rval)") }
            Const.Float(l) => match rval { Const.Int(r) => l ** r, Const.Float(r) => l ** r, else => unreachable("[genBinary pow]: unexpected const value ($rval)") }
            else => unreachable("[genBinary pow]: unexpected const value ($lval)")
          }
          val const = Const.Float(float)

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.F64, Operation.Pow(lval, rval), dst)
      }
      BinaryOp.And => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genCompoundValue(() => self.genExpression(right, concreteGenerics))
        val lvalTy = self.getValueTy(lval)
        val rvalTy = self.getValueTy(rval.result)

        if self.valuesAsCompileTime(lval, rval.result) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval { Const.Int(r) => Const.Int(l && r), else => unreachable("[genBinary bit-and]: unexpected const value ($rval)") }
            Const.Bool(l) => match rval { Const.Bool(r) => Const.Bool(l && r), else => unreachable("[genBinary bool-and]: unexpected const value ($rval)") }
            else => unreachable("[genBinary and]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        if (lvalTy == IrType.I64 || lvalTy == IrType.Byte) && (rvalTy == IrType.I64 || rvalTy == IrType.Byte) {
          for inst in rval.body self.emit(inst)
          self.ssaValue(IrType.I64, Operation.BitAnd(lval, rval.result), dst)
        } else {
          self.ssaValue(IrType.Bool, Operation.BoolAnd(lval, rval), dst)
        }
      }
      BinaryOp.Or => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genCompoundValue(() => self.genExpression(right, concreteGenerics))
        val lvalTy = self.getValueTy(lval)
        val rvalTy = self.getValueTy(rval.result)

        if self.valuesAsCompileTime(lval, rval.result) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval { Const.Int(r) => Const.Int(l || r), else => unreachable("[genBinary bit-or]: unexpected const value ($rval)") }
            Const.Bool(l) => match rval { Const.Bool(r) => Const.Bool(l || r), else => unreachable("[genBinary bool-or]: unexpected const value ($rval)") }
            else => unreachable("[genBinary or]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        if (lvalTy == IrType.I64 || lvalTy == IrType.Byte) && (rvalTy == IrType.I64 || rvalTy == IrType.Byte) {
          for inst in rval.body self.emit(inst)
          self.ssaValue(IrType.I64, Operation.BitOr(lval, rval.result), dst)
        } else {
          self.ssaValue(IrType.Bool, Operation.BoolOr(lval, rval), dst)
        }
      }
      BinaryOp.Xor => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)
        val lvalTy = self.getValueTy(lval)
        val rvalTy = self.getValueTy(rval)

        val bitwise = lvalTy == IrType.I64 && rvalTy == IrType.I64
        val retTy = if bitwise { IrType.I64 } else { IrType.Bool }
        self.ssaValue(retTy, Operation.Xor(bitwise, lval, rval), dst)
      }
      BinaryOp.Coalesce => {
        val innerType = try self.project.typeIsOption(left.ty) else unreachable("type of coalesce operator must be Optional")
        val innerConcreteType = self.getConcreteTypeFromType(innerType, concreteGenerics)
        val innerTy = self.getIrTypeForConcreteType(innerConcreteType)

        val lval = self.genExpression(left, concreteGenerics)
        val condVal = self.ssaValue(IrType.Bool, Operation.OptionIsNone(innerTy, lval), None)

        val ifBody = self.withinBlock("coalesce_fail", false, () => {
          val rval = self.genExpression(right, concreteGenerics)
          Some(rval)
        })
        val elseBody = self.withinBlock("coalesce_pass", false, () => {
          Some(self.ssaValue(innerTy, Operation.OptionUnwrap(innerTy, lval), None))
        })

        self.ssaValue(innerTy, Operation.If(innerTy, condVal, ifBody, elseBody), dst)
      }
      BinaryOp.Eq => self.genEq(concreteGenerics, left, right, false, dst)
      BinaryOp.Neq => self.genEq(concreteGenerics, left, right, true, dst)
      BinaryOp.LT => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Bool(l < r)
              Const.Float(r) => Const.Bool(l < r)
              else => unreachable("[genBinary lt]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Bool(l < r)
              Const.Float(r) => Const.Bool(l < r)
              else => unreachable("[genBinary lt]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary lt]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Lt(lval, rval), dst)
      }
      BinaryOp.LTE => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Bool(l <= r)
              Const.Float(r) => Const.Bool(l <= r)
              else => unreachable("[genBinary lte]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Bool(l <= r)
              Const.Float(r) => Const.Bool(l <= r)
              else => unreachable("[genBinary lte]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary lte]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Lte(lval, rval), dst)
      }
      BinaryOp.Shl => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval { Const.Int(r) => Const.Int(l << r), else => unreachable("[genBinary shl]: unexpected const value ($rval)") }
            else => unreachable("[genBinary shl]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.I64, Operation.Shl(lval, rval), dst)
      }
      BinaryOp.GT => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Bool(l > r)
              Const.Float(r) => Const.Bool(l > r)
              else => unreachable("[genBinary gt]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Bool(l > r)
              Const.Float(r) => Const.Bool(l > r)
              else => unreachable("[genBinary gt]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary gt]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Gt(lval, rval), dst)
      }
      BinaryOp.GTE => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval {
              Const.Int(r) => Const.Bool(l >= r)
              Const.Float(r) => Const.Bool(l >= r)
              else => unreachable("[genBinary gte]: unexpected const value ($rval)")
            }
            Const.Float(l) => match rval {
              Const.Int(r) => Const.Bool(l >= r)
              Const.Float(r) => Const.Bool(l >= r)
              else => unreachable("[genBinary gte]: unexpected const value ($rval)")
            }
            else => unreachable("[genBinary gte]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.Bool, Operation.Gte(lval, rval), dst)
      }
      BinaryOp.Shr => {
        val lval = self.genExpression(left, concreteGenerics)
        val rval = self.genExpression(right, concreteGenerics)

        if self.valuesAsCompileTime(lval, rval) |(lval, rval)| {
          val const = match lval {
            Const.Int(l) => match rval { Const.Int(r) => Const.Int(l >> r), else => unreachable("[genBinary shr]: unexpected const value ($rval)") }
            else => unreachable("[genBinary shr]: unexpected const value ($lval)")
          }

          return self.ssaValueComptime(const, dst)
        }

        self.ssaValue(IrType.I64, Operation.Shr(lval, rval), dst)
      }
    }
  }

  func genEq(self, concreteGenerics: Map<String, ConcreteType>, left: tc.TypedAstNode, right: tc.TypedAstNode, negate: Bool, dst: String?): Value {
    val leftConcreteType = self.getConcreteTypeFromType(left.ty, concreteGenerics)
    val leftIrTy = self.getIrTypeForConcreteType(leftConcreteType)
    val rightConcreteType = self.getConcreteTypeFromType(right.ty, concreteGenerics)
    val rightIrTy = self.getIrTypeForConcreteType(rightConcreteType)
    if leftIrTy != rightIrTy unreachable("equality operators require matching types")

    val lval = self.genExpression(left, concreteGenerics)
    val rval = self.genExpression(right, concreteGenerics)

    self.genEqLogic(leftConcreteType, lval, rval, negate, dst)
  }

  func genEqLogic(self, concreteType: ConcreteType, left: Value, right: Value, negate: Bool, dst: String?): Value {
    if self.valuesAsCompileTime(left, right) |(lval, rval)| {
      val const = match lval {
        Const.Int(l) => match rval { Const.Int(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
        Const.Float(l) => match rval { Const.Float(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
        Const.Bool(l) => match rval { Const.Bool(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
        Const.Char(l) => match rval { Const.Char(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
        Const.String(l) => match rval { Const.String(r) => Const.Bool((l == r) ^ negate), else => unreachable("[genBinary n/eq]: unexpected const value ($rval)") }
      }

      return self.ssaValueComptime(const, dst)
    }

    val irTy = self.getIrTypeForConcreteType(concreteType)
    val op = if irTy == IrType.I64 || irTy == IrType.F64 || irTy == IrType.Bool || irTy == IrType.Byte {
      Operation.Eq(negate: negate, left, right)
    } else {
      val newConcreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
      val eqFn = self.getMethodByName(concreteType.instanceKind, "eq", staticMethod: false)
      val eqFnName = self.fnName(Some(concreteType), eqFn, newConcreteGenerics, [])
      self.enqueueFunction(eqFn, eqFnName, [], Some(concreteType), newConcreteGenerics)

      val op = Operation.Call(ret: IrType.Bool, fnName: eqFnName, args: [left, right])

      if negate {
        Operation.Negate(self.ssaValue(IrType.Bool, op, None))
      } else {
        op
      }
    }

    self.ssaValue(IrType.Bool, op, dst)
  }

  func genHashLogic(self, concreteType: ConcreteType, value: Value, dst: String?): Value {
    val irTy = self.getIrTypeForConcreteType(concreteType)
    if irTy == IrType.I64 return value
    if irTy == IrType.F64 {
      return self.ssaValue(IrType.I64, Operation.Builtin(IrType.I64, Builtin.FloatBitsToInt(value)), None)
    }
    if irTy == IrType.Bool {
      val ifBody = self.withinBlock("hash_bool_true", false, () => Some(Value.Const(Const.Int(1))))
      val elseBody = self.withinBlock("hash_bool_false", false, () => Some(Value.Const(Const.Int(0))))
      return self.ssaValue(IrType.I64, Operation.If(IrType.I64, value, ifBody, elseBody), dst)
    }
    if irTy == IrType.Byte return value

    val newConcreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
    val hashFn = self.getMethodByName(concreteType.instanceKind, "hash", staticMethod: false)
    val hashFnName = self.fnName(Some(concreteType), hashFn, newConcreteGenerics, [])
    self.enqueueFunction(hashFn, hashFnName, [], Some(concreteType), newConcreteGenerics)

    val op = Operation.Call(ret: IrType.I64, fnName: hashFnName, args: [value])
    self.ssaValue(IrType.I64, op, dst)
  }

  func intrinsicArgs1(self, name: String, arguments: tc.TypedAstNode?[]): tc.TypedAstNode {
    val arg0 = try arguments[0] else unreachable("'$name' has 1 required argument")
    try arg0 else unreachable("'$name' has 1 required argument")
  }

  func intrinsicArgs2(self, name: String, arguments: tc.TypedAstNode?[]): (tc.TypedAstNode, tc.TypedAstNode) {
    val _arg0 = try arguments[0] else unreachable("'$name' has 2 required arguments")
    val arg0 = try _arg0 else unreachable("'$name' has 2 required arguments")

    val _arg1 = try arguments[1] else unreachable("'$name' has 2 required arguments")
    val arg1 = try _arg1 else unreachable("'$name' has 2 required arguments")

    (arg0, arg1)
  }

  func intrinsicArgs4(self, name: String, arguments: tc.TypedAstNode?[]): (tc.TypedAstNode, tc.TypedAstNode, tc.TypedAstNode, tc.TypedAstNode) {
    val _arg0 = try arguments[0] else unreachable("'$name' has 4 required arguments")
    val arg0 = try _arg0 else unreachable("'$name' has 4 required arguments")

    val _arg1 = try arguments[1] else unreachable("'$name' has 4 required arguments")
    val arg1 = try _arg1 else unreachable("'$name' has 4 required arguments")

    val _arg2 = try arguments[2] else unreachable("'$name' has 4 required arguments")
    val arg2 = try _arg2 else unreachable("'$name' has 4 required arguments")

    val _arg3 = try arguments[3] else unreachable("'$name' has 4 required arguments")
    val arg3 = try _arg3 else unreachable("'$name' has 4 required arguments")

    (arg0, arg1, arg2, arg3)
  }

  func genCall(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, innerConcreteGenerics: Map<String, ConcreteType>, dst: String?, invokee: tc.TypedInvokee, args: tc.TypedAstNode?[]): Value {
    val argValues: Value[] = []

    val (fnName, returnType) = match invokee {
      TypedInvokee.Function(fn) => {
        if self.getExternDecName(fn) |fnName| {
          self.enqueueFunction(fn, fnName, [], None, {})
          val concreteReturnType = if fn.returnType.kind == tc.TypeKind.PrimitiveUnit {
            None
          } else {
            Some(self.getConcreteTypeFromType(fn.returnType, innerConcreteGenerics))
          }
          (fnName, concreteReturnType)
        } else if self.getIntrinsicDecName(fn) |intrinsicName| {
          return match intrinsicName {
            "pointer_malloc" => {
              val count = self.genExpression(self.intrinsicArgs1("pointer_malloc", args), innerConcreteGenerics)
              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_malloc) could not resolve T for Pointer<T>"))

              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.Malloc(count: count, itemTy: itemTy)), dst)
            }
            "byte_from_int" => {
              val arg = self.intrinsicArgs1("byte_from_int", args)
              self.genExpression(arg, innerConcreteGenerics, dst)
            }
            "char_as_int" => {
              val arg = self.intrinsicArgs1("char_as_int", args)
              self.genExpression(arg, innerConcreteGenerics, dst)
            }
            "int_as_char" => {
              val arg = self.intrinsicArgs1("int_as_char", args)
              self.genExpression(arg, innerConcreteGenerics, dst)
            }
            "int_as_float" => {
              val arg = self.intrinsicArgs1("int_as_float", args)
              val intVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.F64, Operation.Builtin(ret: IrType.F64, builtin: Builtin.IntAsFloat(intVal)), dst)
            }
            "float_as_int" => {
              val arg = self.intrinsicArgs1("float_as_int", args)
              val floatVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.I64, Operation.Builtin(ret: IrType.I64, builtin: Builtin.FloatAsInt(floatVal)), dst)
            }
            "float_ceil" => {
              val arg = self.intrinsicArgs1("float_ceil", args)
              val floatVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.I64, Operation.Builtin(ret: IrType.I64, builtin: Builtin.FloatCeil(floatVal)), dst)
            }
            "float_floor" => {
              val arg = self.intrinsicArgs1("float_floor", args)
              val floatVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.I64, Operation.Builtin(ret: IrType.I64, builtin: Builtin.FloatFloor(floatVal)), dst)
            }
            "float_round" => {
              val arg = self.intrinsicArgs1("float_round", args)
              val floatVal = self.genExpression(arg, innerConcreteGenerics, dst)

              self.ssaValue(IrType.I64, Operation.Builtin(ret: IrType.I64, builtin: Builtin.FloatRound(floatVal)), dst)
            }
            "u64_to_string" => {
              val arg = self.intrinsicArgs1("u64_to_string", args)
              val u64Val = self.genExpression(arg, innerConcreteGenerics, dst)

              val strTy = IrType.Composite(self.knowns.stringType().name)
              self.ssaValue(strTy, Operation.Builtin(ret: strTy, builtin: Builtin.U64ToString(u64Val)), dst)
            }
            "uninitialized" => {
              val innerTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_malloc) could not resolve T for Pointer<T>"))
              self.ssaValue(innerTy, Operation.Builtin(ret: innerTy, builtin: Builtin.Uninitialized), dst)
            }
            "__callstack" => {
              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.Callstack), dst)
            }
            "__callstackp" => {
              self.ssaValue(IrType.I64, Operation.Builtin(ret: IrType.I64, builtin: Builtin.CallstackPtr), dst)
            }
            "modulenames" => {
              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.ModuleNames), dst)
            }
            "functionnames" => {
              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.FunctionNames), dst)
            }
            else => todo("Unimplemented static/standalone intrinsic '$intrinsicName'")
          }
        } else {
          // todo: check for closure

          val paramsNeedingDefaultValue = args.map((arg, idx) => !!fn.params[idx]?.defaultValue && !arg)
          val fnName = self.fnName(None, fn, innerConcreteGenerics, paramsNeedingDefaultValue)
          self.enqueueFunction(fn, fnName, paramsNeedingDefaultValue, None, innerConcreteGenerics)

          val concreteReturnType = if fn.returnType.kind == tc.TypeKind.PrimitiveUnit {
            None
          } else {
            Some(self.getConcreteTypeFromType(fn.returnType, innerConcreteGenerics))
          }
          (fnName, concreteReturnType)
        }
      }
      TypedInvokee.Method(fn, selfVal, isOptSafe) => {
        if self.getExternDecName(fn) |fnName| {
          todo("Unimplemented external method '$fnName'")
        } else if self.getIntrinsicDecName(fn) |intrinsicName| {
          return match intrinsicName {
            "pointer_realloc" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val count = self.intrinsicArgs1("pointer_realloc", args)

              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_realloc) could not resolve T for Pointer<T>"))
              val countVal = self.genExpression(count, innerConcreteGenerics)

              self.ssaValue(IrType.Ptr, Operation.Builtin(ret: IrType.Ptr, builtin: Builtin.Realloc(ptr: ptrVal, count: countVal, itemTy: Some(itemTy))), dst)
            }
            "pointer_store_at" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val (value, offset) = self.intrinsicArgs2("pointer_store_at", args)

              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_store) could not resolve T for Pointer<T>"))
              val valueVal = self.genExpression(value, innerConcreteGenerics)
              val offsetVal = self.genExpression(offset, innerConcreteGenerics)

              self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: Builtin.Store(ptr: ptrVal, value: valueVal, offset: offsetVal, itemTy: itemTy))))
              Value.Unit
            }
            "pointer_load_at" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val offset = self.intrinsicArgs1("pointer_load_at", args)

              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_load) could not resolve T for Pointer<T>"))
              val offsetVal = self.genExpression(offset, innerConcreteGenerics)

              self.ssaValue(itemTy, Operation.Builtin(ret: itemTy, builtin: Builtin.Load(ptr: ptrVal, offset: offsetVal, itemTy: itemTy)), dst)
            }
            "pointer_copy_from" => {
              val ptrVal = self.genExpression(selfVal, concreteGenerics)
              val (dstOffset, src, srcOffset, size) = self.intrinsicArgs4("pointer_copy_from", args)

              val dstOffsetVal = self.genExpression(dstOffset, innerConcreteGenerics)
              val srcVal = self.genExpression(src, innerConcreteGenerics)
              val srcOffsetVal = self.genExpression(srcOffset, innerConcreteGenerics)
              val sizeVal = self.genExpression(size, innerConcreteGenerics)

              val itemTy = self.getIrTypeForConcreteType(try innerConcreteGenerics["T"] else unreachable("(pointer_copy_from) could not resolve T for Pointer<T>"))

              val builtin = Builtin.CopyFrom(dst: ptrVal, dstOffset: dstOffsetVal, src: srcVal, srcOffset: srcOffsetVal, size: sizeVal, itemTy: itemTy)
              self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: builtin)))
              Value.Unit
            }
            "byte_as_int" => {
              self.genExpression(selfVal, concreteGenerics)
            }
            else => todo("Unimplemented method intrinsic '$intrinsicName'")
          }
        } else {
          // todo: check for closure

          val paramsNeedingDefaultValue = args.map((arg, idx) => !!fn.params[idx]?.defaultValue && !arg)
          val selfConcreteType = self.getConcreteTypeFromType(selfVal.ty, concreteGenerics)
          val extracted = self.extractConcreteGenericsFromConcreteType(selfConcreteType)
          for (_, label) in fn.typeParams {
            extracted[label.name] = try innerConcreteGenerics[label.name] else unreachable("unfulfilled generic '${label.name}' for method '${fn.label.name}'")
          }
          val method = match selfVal.ty.kind {
            TypeKind.Generic => {
              if fn.label.name == "toString" || fn.label.name == "eq" || fn.label.name == "hash" {
                self.getMethodByName(selfConcreteType.instanceKind, fn.label.name, staticMethod: false)
              } else {
                unreachable("no other methods can exist on a value of generic type")
              }
            }
            else => fn
          }
          val fnName = self.fnName(Some(selfConcreteType), method, extracted, paramsNeedingDefaultValue)
          self.enqueueFunction(method, fnName, paramsNeedingDefaultValue, Some(selfConcreteType), extracted)

          argValues.push(self.genExpression(selfVal, concreteGenerics))

          val concreteReturnType = if method.returnType.kind == tc.TypeKind.PrimitiveUnit {
            None
          } else {
            Some(self.getConcreteTypeFromType(method.returnType, innerConcreteGenerics))
          }
          (fnName, concreteReturnType)
        }
      }
      TypedInvokee.Struct(s) => {
        val typeArgs: ConcreteType[] = []
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        for tp in s.typeParams {
          val concreteGeneric = try innerConcreteGenerics[tp] else unreachable("Could not resolve generic '$tp' for struct initializer '${s.label.name}'")
          typeArgs.push(concreteGeneric)
          newConcreteGenerics[tp] = concreteGeneric
        }
        val concreteType = ConcreteType(instanceKind: InstanceKind.Struct(s), typeArgs: typeArgs)

        val fieldsNeedingDefaultValue = args.map((arg, idx) => !!s.fields[idx]?.initializer && !arg)
        val fnName = self.structInitFnName(concreteType, fieldsNeedingDefaultValue)
        self.enqueueInitializer(concreteType, None, fnName, fieldsNeedingDefaultValue, None, newConcreteGenerics)

        (fnName, Some(concreteType))
      }
      TypedInvokee.EnumVariant(enum_, variant) => {
        val typeArgs: ConcreteType[] = []
        val newConcreteGenerics: Map<String, ConcreteType> = {}
        for tp in enum_.typeParams {
          val concreteGeneric = try innerConcreteGenerics[tp] else unreachable("Could not resolve generic '$tp' for struct initializer '${enum_.label.name}'")
          typeArgs.push(concreteGeneric)
          newConcreteGenerics[tp] = concreteGeneric
        }
        val concreteType = ConcreteType(instanceKind: InstanceKind.Enum(enum_), typeArgs: typeArgs)

        if enum_ == self.project.preludeOptionEnum {
          if variant.label.name != "Some" unreachable()

          val arg = try try args[0] else unreachable() else unreachable() // ew lol
          val argVal = self.genExpression(arg, concreteGenerics)

          val irType = self.getIrTypeForConcreteType(concreteType)
          val typeArg = try concreteType.typeArgs[0] else unreachable()
          val typeArgIrType = self.getIrTypeForConcreteType(typeArg)
          return self.ssaValue(irType, Operation.OptionSome(typeArgIrType, argVal), dst)
        }

        val fields = match variant.kind {
          EnumVariantKind.Constant => unreachable("cannot invoke constant enum variant")
          EnumVariantKind.Container(fields) => fields
        }

        val fieldsNeedingDefaultValue = args.map((arg, idx) => !!fields[idx]?.initializer && !arg)
        val fnName = self.enumVariantInitFnName(concreteType, variant, fieldsNeedingDefaultValue)
        self.enqueueInitializer(concreteType, Some(variant), fnName, fieldsNeedingDefaultValue, None, newConcreteGenerics)

        (fnName, Some(concreteType))
      }
      TypedInvokee.Expr(e) => {
        val fnVal = self.genExpression(e, concreteGenerics)
        val returnType = match e.ty.kind {
          TypeKind.Func(_, returnType) => if returnType.kind == tc.TypeKind.PrimitiveUnit None else Some(self.getConcreteTypeFromType(returnType, concreteGenerics))
          else => unreachable()
        }

        for arg in args {
          if arg |arg| {
            argValues.push(self.genExpression(arg, concreteGenerics))
          }
        }

        return if returnType |concreteReturnType| {
          val retTy = self.getIrTypeForConcreteType(concreteReturnType)

          self.ssaValue(retTy, Operation.CallValue(ret: retTy, fnVal: fnVal, args: argValues), dst)
        } else {
          val op = Operation.CallValue(ret: IrType.Unit, fnVal: fnVal, args: argValues)
          self.emit(Instruction(op: op))

          Value.Unit
        }
      }
    }

    for arg in args {
      if arg |arg| {
        argValues.push(self.genExpression(arg, concreteGenerics))
      }
    }

    if returnType |concreteReturnType| {
      val retTy = self.getIrTypeForConcreteType(concreteReturnType)

      self.ssaValue(retTy, Operation.Call(ret: retTy, fnName: fnName, args: argValues), dst)
    } else {
      val op = Operation.Call(ret: IrType.Unit, fnName: fnName, args: argValues)
      self.emit(Instruction(op: op))

      Value.Unit
    }
  }

  func genIdentifier(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, name: String, variable: tc.Variable, fnAliasTypeHint: ((tc.Type, Bool)[], tc.Type)?, varImportModule: tc.TypedModule?): Value {
    val varConcreteType = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varTy = self.getIrTypeForConcreteType(varConcreteType)

    if variable.isParameter {
      if variable.isCaptured {
        return self.genLoadCapturedVar(pos, concreteGenerics, variable, deref: true)
      }

      return Value.Ident(self.curCtx.addLocal(varTy, Some(name)))
    }

    match variable.alias {
      VariableAlias.Function(fn) => {
        val targetParamTypes = if fnAliasTypeHint |(paramHints, _)| Some(paramHints) else None

        val captures = if fn.isClosure() {
          val captures: Value[] = []
          for variable in fn.captures {
            captures.push(self.genLoadCapturedVar(variable.label.position, concreteGenerics, variable, deref: false))
          }
          Some(captures)
        } else {
          None
        }

        self.genFunctionValue(concreteGenerics, fn, targetParamTypes, dst, captures)
      }
      else => {
        if varImportModule |mod| {
          val globalName = self.globalName(mod.id, variable.label.name)
          val global = self.getGlobal(globalName, pos)
          if global.initialValue |v| {
            Value.Const(v)
          } else {
            global.referenced = true
            Value.Global(global)
          }
        } else if self.variableIsGlobal(variable) |modId| {
          val globalName = self.globalName(modId, variable.label.name)
          val global = self.getGlobal(globalName, pos)
          if global.initialValue |v| {
            Value.Const(v)
          } else {
            global.referenced = true
            Value.Global(global)
          }
        } else if variable.isCaptured {
          // Note: captured top-level variables are "global" and are handled above; variables handled here are not top-level
          self.genLoadCapturedVar(pos, concreteGenerics, variable, deref: true)
        } else if variable.mutable {
          val varName = self.varName(variable)
          val local = self.curCtx.getLocal(varName, pos)
          val ident = match local { Value.Ident(i) => i, else => unreachable("expected ident for local '$varName'") }
          self.ssaValue(varTy, Operation.LoadVar(ty: varTy, ident: ident), dst)
        } else {
          val varName = self.varName(variable)
          self.curCtx.getLocal(varName, pos)
        }
      }
    }
  }

  func genLoadCapturedVar(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, variable: tc.Variable, deref: Bool): Value {
    val varConcreteType = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varTy = self.getIrTypeForConcreteType(varConcreteType)
    val varName = self.varName(variable)

    if self.curCtx.typedFn |fn| {
      for v, idx in fn.captures {
        if v.label.name == variable.label.name {
          val src = CaptureSource.WithinCapturingFn(idx: idx, name: varName, mutable: variable.mutable)
          return self.ssaValue(varTy, Operation.LoadCapturedVar(ty: varTy, src: src, deref: deref), None)
        }
      }
    }

    if variable.isParameter {
      return self.curCtx.getLocal(variable.label.name, pos)
    }

    val local = self.curCtx.getLocal(varName, pos)
    if variable.mutable {
      val ident = match local { Value.Ident(i) => i, else v => unreachable("expected ident but got '$v'") }
      val src = CaptureSource.OutsideFn(ident: ident)
      self.ssaValue(varTy, Operation.LoadCapturedVar(ty: varTy, src: src, deref: deref), None)
    } else {
      local
    }
  }

  func genStoreCapturedVar(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, variable: tc.Variable, value: Value) {
    val varConcreteType = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varTy = self.getIrTypeForConcreteType(varConcreteType)
    val varName = self.varName(variable)

    if self.curCtx.typedFn |fn| {
      for v, idx in fn.captures {
        if v.label.name == variable.label.name {
          val src = CaptureSource.WithinCapturingFn(idx: idx, name: varName, mutable: true)
          self.emit(Instruction(op: Operation.StoreCapturedVar(ty: varTy, value: value, src: src)))
          return
        }
      }
    }

    val ident = match self.curCtx.getLocal(varName, pos) { Value.Ident(i) => i, else v => unreachable("expected ident but got '$v'") }
    val src = CaptureSource.OutsideFn(ident: ident)
    self.emit(Instruction(op: Operation.StoreCapturedVar(ty: varTy, value: value, src: src)))
  }

  func followAccessorPath(self, head: tc.TypedAstNode, middle: tc.AccessorPathSegment[], tail: tc.AccessorPathSegment, concreteGenerics: Map<String, ConcreteType>, dst: String?, storeVal: Value? = None): Value {
    val segs = middle.concat([tail])

    var (workingVal, concreteType) = match segs[0] {
      AccessorPathSegment.EnumVariant(label, ty, enum_, variant) => {
        match variant.kind {
          EnumVariantKind.Container => unreachable("non-constant enum variant missing instantation")
          _ => {}
        }

        val concreteType = self.getConcreteTypeFromType(ty, concreteGenerics)
        val (_, variantIdx) = try enum_.variants.findIndex(v => v.label.name == variant.label.name) else unreachable("${enum_.label.name}.${variant.label.name} must exist")
        val variantVal = if enum_ == self.project.preludeOptionEnum {
          if variant.label.name != "None" unreachable()

          val irType = self.getIrTypeForConcreteType(concreteType)
          val typeArg = try concreteType.typeArgs[0] else unreachable()
          val typeArgIrType = self.getIrTypeForConcreteType(typeArg)
          self.ssaValue(irType, Operation.OptionNone(typeArgIrType), dst)
        } else {
          val global = self.getOrAddConstEnumVariant(concreteType, variant, variantIdx)
          global.initialValue = Some(Const.Int(variantIdx))
          global.referenced = true
          Value.Global(global)
        }

        (variantVal, concreteType)
      }
      else => {
        val concreteType = self.getConcreteTypeFromType(head.ty, concreteGenerics)
        val headVal = self.genExpression(head, concreteGenerics)

        (headVal, concreteType)
      }
    }

    var resVal = Value.Unit

    for seg, idx in segs {
      match seg {
        AccessorPathSegment.EnumVariant => {
          if idx != segs.length - 1 unreachable("enum variant must be in first position")
          if storeVal |res| unreachable("cannot store into enum variant")

          resVal = workingVal
          break
        }
        AccessorPathSegment.Method => todo("followAccessorPath: methods")
        AccessorPathSegment.Field(label, ty, field, isOptSafe) => {
          if isOptSafe todo()

          match concreteType.instanceKind {
            InstanceKind.Struct(struct) => {
              val (f, fieldIdx) = try struct.fields.findIndex(f => f.name.name == field.name.name) else unreachable("no such field '${field.name.name}'")
              val offset = fieldIdx * ALIGNMENT
              val newConcreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
              val fieldConcreteType = self.getConcreteTypeFromType(f.ty, newConcreteGenerics)
              val fieldTy = self.getIrTypeForConcreteType(fieldConcreteType)

              if idx == segs.length - 1 {
                resVal = if storeVal |res| {
                  self.emit(Instruction(op: Operation.StoreField(ty: fieldTy, value: res, mem: workingVal, name: f.name.name, offset: offset)))
                  Value.Unit
                } else {
                  self.ssaValue(fieldTy, Operation.LoadField(ty: fieldTy, mem: workingVal, name: f.name.name, offset: offset), dst)
                }
                break
              }

              workingVal = self.ssaValue(fieldTy, Operation.LoadField(ty: fieldTy, mem: workingVal, name: f.name.name, offset: offset), None)
              concreteType = self.getConcreteTypeFromType(ty, newConcreteGenerics)
            }
            InstanceKind.Enum => todo("enum field accessor")
          }
        }
      }
    }

    resVal
  }

  func genArray(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, arrayTy: tc.Type, items: tc.TypedAstNode[]): Value {
    val arrayConcreteType = self.getConcreteTypeFromType(arrayTy, concreteGenerics)
    val arrayItemConcreteType = try arrayConcreteType.typeArgs[0] else unreachable("ConcreteType for array must have 1 type argument")

    val arrayItemIrTy = self.getIrTypeForConcreteType(arrayItemConcreteType)
    val values = items.map(item => self.genExpression(item, concreteGenerics))

    self.generateArrayWithItems(pos, arrayItemConcreteType, dst, values)
  }

  func genSet(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, setTy: tc.Type, items: tc.TypedAstNode[]): Value {
    val setConcreteType = self.getConcreteTypeFromType(setTy, concreteGenerics)
    val setIrTy = self.getIrTypeForConcreteType(setConcreteType)
    val setItemConcreteType = try setConcreteType.typeArgs[0] else unreachable("ConcreteType for set must have 1 type argument")

    val setConcreteGenerics = { "T": setItemConcreteType } // `T` is the known generic of `Set.new`
    val setNewFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeSetStruct), "new", staticMethod: true)
    val setNewFnName = self.fnName(None, setNewFn, setConcreteGenerics, [true])
    self.enqueueFunction(setNewFn, setNewFnName, [true], None, setConcreteGenerics)

    val setVal = self.ssaValue(setIrTy, Operation.Call(ret: setIrTy, fnName: setNewFnName, args: []), None)

    if !items.isEmpty() {
      val setInsertFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeSetStruct), "insert", staticMethod: false)
      val setInsertFnName = self.fnName(Some(setConcreteType), setInsertFn, setConcreteGenerics, [])
      self.enqueueFunction(setInsertFn, setInsertFnName, [], Some(setConcreteType), setConcreteGenerics)

      for item in items {
        val itemVal = self.genExpression(item, setConcreteGenerics)
        self.emit(Instruction(op: Operation.Call(ret: IrType.Unit, fnName: setInsertFnName, args: [setVal, itemVal])))
      }
    }

    setVal
  }

  func genMap(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, mapTy: tc.Type, items: (tc.TypedAstNode, tc.TypedAstNode)[]): Value {
    val mapConcreteType = self.getConcreteTypeFromType(mapTy, concreteGenerics)
    val mapIrTy = self.getIrTypeForConcreteType(mapConcreteType)
    val mapKeyConcreteType = try mapConcreteType.typeArgs[0] else unreachable("ConcreteType for map must have 2 type arguments")
    val mapValConcreteType = try mapConcreteType.typeArgs[1] else unreachable("ConcreteType for map must have 2 type arguments")
    val mapKeyIrTy = self.getIrTypeForConcreteType(mapKeyConcreteType)
    val mapValIrTy = self.getIrTypeForConcreteType(mapValConcreteType)

    val mapConcreteGenerics = { "K": mapKeyConcreteType, "V": mapValConcreteType } // `K`, and `V` are the known generics of `Map.new`
    val mapNewFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeMapStruct), "new", staticMethod: true)
    val mapNewFnName = self.fnName(None, mapNewFn, mapConcreteGenerics, [true])
    self.enqueueFunction(mapNewFn, mapNewFnName, [true], None, mapConcreteGenerics)

    val mapVal = self.ssaValue(mapIrTy, Operation.Call(ret: mapIrTy, fnName: mapNewFnName, args: []), None)

    if !items.isEmpty() {
      val mapInsertFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeMapStruct), "insert", staticMethod: false)
      val mapInsertFnName = self.fnName(Some(mapConcreteType), mapInsertFn, mapConcreteGenerics, [])
      self.enqueueFunction(mapInsertFn, mapInsertFnName, [], Some(mapConcreteType), mapConcreteGenerics)

      for (k, v) in items {
        val keyVal = self.genExpression(k, mapConcreteGenerics)
        val valVal = self.genExpression(v, mapConcreteGenerics)
        self.emit(Instruction(op: Operation.Call(ret: IrType.Unit, fnName: mapInsertFnName, args: [mapVal, keyVal, valVal])))
      }
    }

    mapVal
  }

  func genIndexing(self, pos: Position, concreteGenerics: Map<String, ConcreteType>, dst: String?, node: tc.TypedIndexingNode): Value {
    match node {
      TypedIndexingNode.ArrayLike(expr, mode) => {
        val exprVal = self.genExpression(expr, concreteGenerics)
        val exprConcreteType = self.getConcreteTypeFromType(expr.ty, concreteGenerics)
        val exprIrTy = self.getIrTypeForConcreteType(exprConcreteType)

        match mode {
          IndexingMode.Single(idxExpr) => {
            val idxVal = self.genExpression(idxExpr, concreteGenerics)

            if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeArrayStruct) {
              val arrItemConcreteType = try exprConcreteType.typeArgs[0] else unreachable("ConcreteType for array must have 1 type argument")
              val arrConcreteGenerics = { "T": arrItemConcreteType } // `T` is the known generic of `Array#get`

              val arrayGetFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "get", staticMethod: false)
              val arrayGetFnName = self.fnName(Some(exprConcreteType), arrayGetFn, arrConcreteGenerics, [])
              self.enqueueFunction(arrayGetFn, arrayGetFnName, [], Some(exprConcreteType), arrConcreteGenerics)

              val optWrapperConcreteType = ConcreteType(instanceKind: InstanceKind.Enum(self.project.preludeOptionEnum), typeArgs: [arrItemConcreteType])
              val optWrapperIrTy = self.getIrTypeForConcreteType(optWrapperConcreteType)

              self.ssaValue(optWrapperIrTy, Operation.Call(ret: optWrapperIrTy, fnName: arrayGetFnName, args: [exprVal, idxVal]), dst)
            } else if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeStringStruct) {
              val stringGetFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeStringStruct), "get", staticMethod: false)
              val stringGetFnName = self.fnName(Some(exprConcreteType), stringGetFn, {}, [])
              self.enqueueFunction(stringGetFn, stringGetFnName, [], Some(exprConcreteType), {})

              self.ssaValue(exprIrTy, Operation.Call(ret: exprIrTy, fnName: stringGetFnName, args: [exprVal, idxVal]), dst)
            } else {
              unreachable("unsupported type for indexing operator")
            }
          }
          IndexingMode.Range(startExpr, endExpr) => {
            val startVal = if startExpr |startExpr| Some(self.genExpression(startExpr, concreteGenerics)) else None
            val endVal = if endExpr |endExpr| Some(self.genExpression(endExpr, concreteGenerics)) else None

            val paramsNeedingDefaultValue = [!startVal, !endVal]
            val fnName = if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeArrayStruct) {
              val arrItemConcreteType = try exprConcreteType.typeArgs[0] else unreachable("ConcreteType for array must have 1 type argument")
              val arrConcreteGenerics = { "T": arrItemConcreteType } // `T` is the known generic of `Array#getRange`

              val arrayGetRangeFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "getRange", staticMethod: false)
              val arrayGetRangeFnName = self.fnName(Some(exprConcreteType), arrayGetRangeFn, arrConcreteGenerics, paramsNeedingDefaultValue)
              self.enqueueFunction(arrayGetRangeFn, arrayGetRangeFnName, paramsNeedingDefaultValue, Some(exprConcreteType), arrConcreteGenerics)

              arrayGetRangeFnName
            } else if exprConcreteType.instanceKind == InstanceKind.Struct(self.project.preludeStringStruct) {
              val stringGetRangeFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeStringStruct), "getRange", staticMethod: false)
              val stringGetRangeFnName = self.fnName(Some(exprConcreteType), stringGetRangeFn, {}, paramsNeedingDefaultValue)
              self.enqueueFunction(stringGetRangeFn, stringGetRangeFnName, paramsNeedingDefaultValue, Some(exprConcreteType), {})

              stringGetRangeFnName
            } else {
              unreachable("unsupported type for range indexing operator")
            }

            val args = if startVal |startVal| {
              if endVal |endVal| {
                [exprVal, startVal, endVal]
              } else {
                [exprVal, startVal]
              }
            } else if endVal |endVal| {
              [exprVal, endVal]
            } else {
              [exprVal]
            }

            self.ssaValue(exprIrTy, Operation.Call(ret: exprIrTy, fnName: fnName, args: args), dst)
          }
        }
      }
      TypedIndexingNode.Map(mapExpr, idxExpr) => {
        val idxVal = self.genExpression(idxExpr, concreteGenerics)

        val mapVal = self.genExpression(mapExpr, concreteGenerics)
        val mapConcreteType = self.getConcreteTypeFromType(mapExpr.ty, concreteGenerics)
        val mapIrTy = self.getIrTypeForConcreteType(mapConcreteType)

        val mapKeyConcreteType = try mapConcreteType.typeArgs[0] else unreachable("ConcreteType for map must have 2 type arguments")
        val mapValConcreteType = try mapConcreteType.typeArgs[1] else unreachable("ConcreteType for map must have 2 type arguments")
        val mapKeyIrTy = self.getIrTypeForConcreteType(mapKeyConcreteType)
        val mapValIrTy = self.getIrTypeForConcreteType(mapValConcreteType)

        val mapConcreteGenerics = { "K": mapKeyConcreteType, "V": mapValConcreteType } // `K`, and `V` are the known generics of `Map.get`
        val mapGetFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeMapStruct), "get", staticMethod: false)
        val mapGetFnName = self.fnName(Some(mapConcreteType), mapGetFn, mapConcreteGenerics, [])
        self.enqueueFunction(mapGetFn, mapGetFnName, [], Some(mapConcreteType), mapConcreteGenerics)

        val optWrapperConcreteType = ConcreteType(instanceKind: InstanceKind.Enum(self.project.preludeOptionEnum), typeArgs: [mapValConcreteType])
        val optWrapperIrTy = self.getIrTypeForConcreteType(optWrapperConcreteType)

        self.ssaValue(optWrapperIrTy, Operation.Call(ret: optWrapperIrTy, fnName: mapGetFnName, args: [mapVal, idxVal]), dst)
      }
      TypedIndexingNode.Tuple(tupleExpr, idx) => {
        val tupleVal = self.genExpression(tupleExpr, concreteGenerics)
        val tupleConcreteType = self.getConcreteTypeFromType(tupleExpr.ty, concreteGenerics)

        val fieldConcreteType = try tupleConcreteType.typeArgs[idx] else unreachable("Tuple of size ${tupleConcreteType.typeArgs.length} must have an index $idx")
        val fieldIrType = self.getIrTypeForConcreteType(fieldConcreteType)

        self.ssaValue(fieldIrType, Operation.LoadField(ty: fieldIrType, mem: tupleVal, name: "__$idx", offset: idx * ALIGNMENT), dst)
      }
    }
  }

  func genLambda(self, concreteGenerics: Map<String, ConcreteType>, fn: tc.Function, typeHint: ((tc.Type, Bool)[], tc.Type)?, dst: String?): Value {
    val targetParamTypes = if typeHint |(paramHints, _)| Some(paramHints) else None

    val captures = if fn.isClosure() {
      val captures: Value[] = []
      for variable in fn.captures {
        captures.push(self.genLoadCapturedVar(variable.label.position, concreteGenerics, variable, deref: false))
      }
      Some(captures)
    } else {
      None
    }

    self.genFunctionValue(concreteGenerics, fn, targetParamTypes, dst, captures)
  }

  func genTry(self, concreteGenerics: Map<String, ConcreteType>, expr: tc.TypedAstNode, elseClause: tc.TypedTryElseClause?, dst: String?): Value {
    if elseClause todo("genTry: else blocks")

    val v = self.genExpression(expr, concreteGenerics)
    if self.project.typeIsOption(expr.ty) |innerType| {
      val innerConcreteType = self.getConcreteTypeFromType(innerType, concreteGenerics)
      val innerTy = self.getIrTypeForConcreteType(innerConcreteType)
      val condVal = self.ssaValue(IrType.Bool, Operation.OptionIsNone(innerTy, v), None)

      val ifBody = self.withinBlock("try_fail", true, () => {
        self.emit(Instruction(op: Operation.Return(Some(v))))
        None
      })
      val elseBody = self.withinBlock("try_pass", false, () => {
        Some(self.ssaValue(innerTy, Operation.OptionUnwrap(innerTy, v), None))
      })

      self.ssaValue(innerTy, Operation.If(innerTy, condVal, ifBody, elseBody), dst)
    } else {
      todo("genTry: result type")
    }
  }

  // codegen helpers

  func genFunctionValue(self, concreteGenerics: Map<String, ConcreteType>, fn: tc.Function, targetParamTypes: (tc.Type, Bool)[]?, dst: String?, captures: Value[]?): Value {
    val concreteParamTypes = if targetParamTypes |paramTypes| {
      paramTypes.filter(_p => _p[1]).map(_p => self.getConcreteTypeFromType(_p[0], concreteGenerics))
    } else {
      fn.params.filter(p => !p.defaultValue).map(p => self.getConcreteTypeFromType(p.ty, concreteGenerics))
    }
    val targetArity = concreteParamTypes.length

    val fnName = if targetArity == fn.params.length {
      val fnName = self.fnName(None, fn, concreteGenerics, [])
      self.enqueueFunction(fn, fnName, [], None, concreteGenerics)
      fnName
    } else if targetArity < fn.params.length {
      val paramsNeedingDefaultValue = fn.params.map((param, idx) => {
        if concreteParamTypes[idx] {
          false
        } else {
          if !param.defaultValue unreachable("creating fn val for fn '${fn.label}' with arity $targetArity param '${param.label.name}' to be optional")
          true
        }
      })
      val fnName = self.fnName(None, fn, concreteGenerics, paramsNeedingDefaultValue)
      self.enqueueFunction(fn, fnName, paramsNeedingDefaultValue, None, concreteGenerics)
      fnName
    } else {
      val toDiscard = concreteParamTypes[fn.params.length:]
      val fnName = self.fnName(None, fn, concreteGenerics, [], !toDiscard.isEmpty())
      self.enqueueFunction(fn, fnName, [], None, concreteGenerics, toDiscard)

      fnName
    }

    if captures |captures| {
      self.ssaValue(IrType.Ptr, Operation.CreateClosure(fnName: fnName, captures: captures), dst)
    } else {
      self.ssaValue(IrType.Ptr, Operation.FunctionPointer(fnName: fnName), dst)
    }
  }

  func generateArrayWithItems(self, pos: Position, arrayItemConcreteType: ConcreteType, dst: String?, values: Value[]): Value {
    val arrayConcreteType = ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeArrayStruct), typeArgs: [arrayItemConcreteType])
    val arrConcreteGenerics = { "T": arrayItemConcreteType } // `T` is the known generic of `Array.withCapacity`
    val arrayWithCapacityFn = self.getMethodByName(InstanceKind.Struct(self.project.preludeArrayStruct), "withCapacity", staticMethod: true)
    val arrayWithCapacityFnName = self.fnName(None, arrayWithCapacityFn, arrConcreteGenerics, [])
    self.enqueueFunction(arrayWithCapacityFn, arrayWithCapacityFnName, [], None, arrConcreteGenerics)

    val sizeVal = Value.Const(Const.Int(values.length.nextPowerOf2()))
    val arrayIrTy = self.getIrTypeForConcreteType(arrayConcreteType)
    val op = Operation.Call(ret: arrayIrTy, fnName: arrayWithCapacityFnName, args: [sizeVal])
    val arrVal = self.ssaValue(arrayIrTy, op, dst)

    val (_, lengthFieldIdx) = try self.project.preludeArrayStruct.fields.findIndex(f => f.name.name == "length") else unreachable("no such field 'length'")
    self.emit(Instruction(op: Operation.StoreField(ty: IrType.I64, value: Value.Const(Const.Int(values.length)), mem: arrVal, name: "length", offset: lengthFieldIdx * ALIGNMENT)))

    val (_, bufferFieldIdx) = try self.project.preludeArrayStruct.fields.findIndex(f => f.name.name == "_buffer") else unreachable("no such field '_buffer'")
    val bufferVal = self.ssaValue(IrType.Ptr, Operation.LoadField(ty: IrType.Ptr, mem: arrVal, name: "_buffer", offset: bufferFieldIdx * ALIGNMENT), None)

    val arrayItemIrTy = self.getIrTypeForConcreteType(arrayItemConcreteType)
    for value, idx in values {
      val builtin = Builtin.Store(ptr: bufferVal, value: value, offset: Value.Const(Const.Int(idx)), itemTy: arrayItemIrTy)
      self.emit(Instruction(op: Operation.Builtin(ret: IrType.Unit, builtin: builtin)))
    }

    arrVal
  }

  func genToStringLogicForStructuredData(self, prefix: String, data: (String, ConcreteType, Value)[]): Value {
    val strTy = self.knowns.stringType()
    val strIrType = IrType.Composite(strTy.name)

    val prefixStr = Value.Const(Const.String(prefix))
    var knownConstLen = prefix.length + 2 + (data.length - 1) * 2 // account for '(' and ')', as well as ',' and ' ' between items. NB: does not include NULL
    var lenVal = Value.Const(Const.Int(0))

    val reprVals: (IrType, String, Value)[] = []
    for (itemName, itemConcreteType, itemVal), idx in data {
      val itemIrTy = self.getIrTypeForConcreteType(itemConcreteType)
      val itemConcreteGenerics = self.extractConcreteGenericsFromConcreteType(itemConcreteType)

      // If the item label is meant to be output, account for the label as well as ':' and ' ' between the label and the value
      if !itemName.isEmpty() { knownConstLen += (itemName.length + 2) }

      val toStringFn = self.getMethodByName(itemConcreteType.instanceKind, "toString", staticMethod: false)
      val toStringFnName = self.fnName(Some(itemConcreteType), toStringFn, itemConcreteGenerics, [])
      self.enqueueFunction(toStringFn, toStringFnName, [], Some(itemConcreteType), itemConcreteGenerics)

      val toStringVal = self.ssaValue(strIrType, Operation.Call(ret: strIrType, fnName: toStringFnName, args: [itemVal]), None)
      val toStringValLen = self.ssaValue(IrType.I64, Operation.LoadField(ty: IrType.I64, mem: toStringVal, name: "length", offset: 0), None)
      lenVal = self.ssaValue(IrType.I64, Operation.Add(lenVal, toStringValLen), None)

      if itemIrTy == strIrType {
        // account for opening and closing " chars
        lenVal = self.ssaValue(IrType.I64, Operation.Add(lenVal, Value.Const(Const.Int(2))), None)
      }

      reprVals.push((itemIrTy, itemName, toStringVal))
    }

    val totalLenVal = self.ssaValue(IrType.I64, Operation.Add(lenVal, Value.Const(Const.Int(knownConstLen))), None)
    self.ssaValue(strIrType, Operation.StructuredToString(prefix: prefix, lenVal: totalLenVal, fields: reprVals), None)
  }

  func genEqLogicForStructuredData(self, data: (ConcreteType, Value, Value)[]): Value {
    var acc = Value.Const(Const.Bool(true))
    for (itemConcreteType, selfVal, otherVal), idx in data {
      val eq = self.genCompoundValue(() => self.genEqLogic(itemConcreteType, selfVal, otherVal, negate: false, dst: None))
      acc = self.ssaValue(IrType.Bool, Operation.BoolAnd(acc, eq), None)
    }

    acc
  }

  func genHashLogicForStructuredData(self, data: (ConcreteType, Value)[]): Value {
    var acc = Value.Const(Const.Int(1))
    for (itemConcreteType, selfVal), idx in data {
      val hash = self.genHashLogic(itemConcreteType, selfVal, dst: None)
      val prod = self.ssaValue(IrType.I64, Operation.Mul(Value.Const(Const.Int(31)), hash), None)
      acc = self.ssaValue(IrType.I64, Operation.Add(acc, prod), None)
    }

    acc
  }

  func ssaValueComptime(self, const: Const, name: String?): Value {
    if name |name| {
      val (op, ty) = match const {
        Const.Int(value) => (Operation.ConstInt(value), IrType.I64)
        Const.Float(value) => (Operation.ConstFloat(value), IrType.F64)
        Const.Bool(value) => (Operation.ConstBool(value), IrType.Bool)
        Const.Char(value) => (Operation.ConstChar(value), IrType.I64)
        Const.String(value) => {
          val strTy = IrType.Composite(self.knowns.stringType().name)
          (Operation.ConstString(value), strTy)
        }
      }

      self.ssaValue(ty, op, Some(name))
    } else {
      Value.Const(const)
    }
  }

  func ssaValue(self, ty: IrType, op: Operation, name: String?): Value {
    val ident = self.curCtx.addLocal(ty, name)
    self.emit(Instruction(assignee: Some(ident), op: op))
    Value.Ident(ident)
  }

  func genCallToStringMethod(self, value: Value, concreteType: ConcreteType, dst: String? = None): Value {
    val strTy = IrType.Composite(self.knowns.stringType().name)

    val concreteGenerics = self.extractConcreteGenericsFromConcreteType(concreteType)
    val toStringFn = self.getMethodByName(concreteType.instanceKind, "toString", staticMethod: false)
    val toStringFnName = self.fnName(Some(concreteType), toStringFn, concreteGenerics, [])
    self.enqueueFunction(toStringFn, toStringFnName, [], Some(concreteType), concreteGenerics)

    self.ssaValue(strTy, Operation.Call(ret: strTy, fnName: toStringFnName, args: [value]), dst)
  }

  // helpers

  func varName(self, variable: tc.Variable): String {
    val name = variable.label.name
    val idx = variable.scope.idxInFn
    "_${name}_${idx}"
  }

  func enterFunction(self, fn: IrFunction, typedFn: tc.Function?): Context {
    val prevCtx = self.curCtx
    val params = fn.params.map(p => Ident(ty: IrType.I64, kind: p.kind))
    val locals = Map.fromPairs(fn.params.map(p => (p.kind.name(), Value.Ident(p))))
    self.curCtx = Context(fn: fn, typedFn: typedFn, block: fn.block, locals: locals)

    prevCtx
  }

  func withinBlock(self, name: String, terminates: Bool, fn: () => Value?): Block {
    val prevBlock = self.curCtx.block

    val instrs: Instruction[] = []
    self.curCtx.block = (name, instrs)
    val finalVal = fn()
    self.curCtx.block = prevBlock

    Block(name: name, body: instrs, result: finalVal, terminates: terminates)
  }

  func genCompoundValue(self, fn: () => Value): CompoundValue {
    val prevBlock = self.curCtx.block

    val instrs: Instruction[] = []
    self.curCtx.block = ("_compoundvalue", instrs)
    val finalVal = fn()
    self.curCtx.block = prevBlock

    CompoundValue(body: instrs, result: finalVal)
  }

  func enqueueFunction(self, fn: tc.Function, fnName: String, paramsNeedingDefaultValue: Bool[], methodInstanceType: ConcreteType?, concreteGenerics: Map<String, ConcreteType>, paramsToDiscard: ConcreteType[] = []) {
    self.fnQueue.push(FunctionToCompile(callable: CallableToCompile.Function(fn), fnName: fnName, paramsNeedingDefaultValue: paramsNeedingDefaultValue, concreteGenerics: concreteGenerics, methodInstanceType: methodInstanceType, paramsToDiscard: paramsToDiscard))
  }

  func enqueueInitializer(self, ty: ConcreteType, enumVariant: tc.TypedEnumVariant?, fnName: String, paramsNeedingDefaultValue: Bool[], methodInstanceType: ConcreteType?, concreteGenerics: Map<String, ConcreteType>) {
    if enumVariant |variant| {
      self.fnQueue.push(FunctionToCompile(callable: CallableToCompile.EnumVariant(ty, variant), fnName: fnName, paramsNeedingDefaultValue: paramsNeedingDefaultValue, concreteGenerics: concreteGenerics, methodInstanceType: methodInstanceType))
    } else {
      self.fnQueue.push(FunctionToCompile(callable: CallableToCompile.Initializer(ty), fnName: fnName, paramsNeedingDefaultValue: paramsNeedingDefaultValue, concreteGenerics: concreteGenerics, methodInstanceType: methodInstanceType))
    }
  }

  func addFunction(self, fnName: String, fn: IrFunction) {
    self.functions.push(fn)
    self.functionsByName[fnName] = fn
  }

  func getOrAddConstEnumVariant(self, concreteType: ConcreteType, variant: tc.TypedEnumVariant, variantIdx: Int): GlobalVariable {
    val typeName = self.typeName(concreteType, withTypeArgs: true)
    val globalName = "${typeName}_${variant.label.name}"
    if self.globals[globalName] |g| return g

    val ty = self.getIrTypeForConcreteType(concreteType)

    val v = GlobalVariable(name: globalName, ty: ty, mutable: false)
    self.globals[globalName] = v

    v
  }

  func addGlobal(self, variable: tc.Variable, modId: Int, concreteGenerics: Map<String, ConcreteType>): GlobalVariable {
    val globalName = self.globalName(modId, variable.label.name)
    if self.globals[globalName] |g| return g

    val varConcreteType = self.getConcreteTypeFromType(variable.ty, concreteGenerics)
    val varTy = self.getIrTypeForConcreteType(varConcreteType)

    val v = GlobalVariable(name: globalName, ty: varTy, mutable: variable.mutable)
    self.globals[globalName] = v

    v
  }

  func getGlobal(self, name: String, pos: Position): GlobalVariable {
    try self.globals[name] else unreachable("no such global '$name' ($pos)")
  }

  func globalName(self, modId: Int, name: String): String = "_${modId}_$name"

  func typeName(self, ty: ConcreteType, withTypeArgs = true): String {
    val (id, baseName) = match ty.instanceKind {
      InstanceKind.Struct(s) => (s.moduleId, s.label.name)
      InstanceKind.Enum(e) => (e.moduleId, e.label.name)
    }

    val parts = [id.toString(), baseName]
    if withTypeArgs {
      for typeArg in ty.typeArgs {
        parts.push(self.typeName(typeArg))
      }
    }

    parts.join("_")
  }

  func tupleStruct(self, arity: Int): tc.Struct {
    val name = "Tuple$arity"

    self.tupleStructs.getOrInsert(name, () => {
      val dummyModuleId = 0
      val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      val typeParams = alphabet[:arity].split("")
      val fields = typeParams.map((p, idx) => ("__$idx", tc.Type(kind: TypeKind.Generic(name: p))))
      tc.Struct.makeDummy(moduleId: dummyModuleId, name: name, typeParams: typeParams, fields: fields)
    })
  }

  func isTupleStruct(self, struct: tc.Struct): Bool = if self.tupleStructs[struct.label.name] |s| s == struct else false

  func functionStruct(self, arity: Int, returns: Bool): tc.Struct {
    val name = if returns "Function${arity + 1}" else "UFunction${arity}"

    self.functionStructs.getOrInsert(name, () => {
      val dummyModuleId = 0
      val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      val typeParams = (if returns { ["Ret"] } else []).concat(alphabet[:arity].split(""))
      tc.Struct.makeDummy(moduleId: dummyModuleId, name: name, typeParams: typeParams, fields: [])
    })
  }

  func getConcreteTypeFromType(self, ty: tc.Type, concreteGenerics: Map<String, ConcreteType>): ConcreteType {
    match ty.kind {
      TypeKind.CouldNotDetermine => unreachable("Encountered CouldNotDetermine type")
      TypeKind.PrimitiveUnit => unreachable("getConcreteTypeFromType: Unit")
      TypeKind.PrimitiveInt => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeIntStruct), typeArgs: [])
      TypeKind.PrimitiveFloat => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeFloatStruct), typeArgs: [])
      TypeKind.PrimitiveBool => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeBoolStruct), typeArgs: [])
      TypeKind.PrimitiveChar => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeCharStruct), typeArgs: [])
      TypeKind.PrimitiveString => ConcreteType(instanceKind: InstanceKind.Struct(self.project.preludeStringStruct), typeArgs: [])
      TypeKind.Never => unreachable("Encountered Never type")
      TypeKind.Generic(name) => try concreteGenerics[name] else unreachable("getConcreteTypeFromType: generic '$name'")
      TypeKind.Instance(instanceKind, typeArgs) => {
        val concreteTypeArgs = typeArgs.map(t => self.getConcreteTypeFromType(t, concreteGenerics))
        ConcreteType(instanceKind: instanceKind, typeArgs: concreteTypeArgs)
      }
      TypeKind.Func(paramTypes, returnType) => {
        val returns = returnType.kind != tc.TypeKind.PrimitiveUnit
        val struct = self.functionStruct(paramTypes.length, returns)
        val concreteTypeArgs: ConcreteType[] = []
        if returns {
          concreteTypeArgs.push(self.getConcreteTypeFromType(returnType, concreteGenerics))
        }
        for (t, _) in paramTypes {
          concreteTypeArgs.push(self.getConcreteTypeFromType(t, concreteGenerics))
        }

        ConcreteType(instanceKind: InstanceKind.Struct(struct), typeArgs: concreteTypeArgs)
      }
      TypeKind.Type(type_) => todo("TypeKind.Type")
      TypeKind.Tuple(types) => {
        val struct = self.tupleStruct(types.length)
        val concreteTypeArgs = types.map(t => self.getConcreteTypeFromType(t, concreteGenerics))

        ConcreteType(instanceKind: InstanceKind.Struct(struct), typeArgs: concreteTypeArgs)
      }
      TypeKind.Hole => todo("TypeKind.Hole")
    }
  }

  func extractConcreteGenericsFromConcreteType(self, concreteType: ConcreteType): Map<String, ConcreteType> {
    val typeParams = match concreteType.instanceKind {
      InstanceKind.Struct(s) => s.typeParams
      InstanceKind.Enum(e) => e.typeParams
    }

    val concreteGenerics: Map<String, ConcreteType> = {}
    for typeParam, idx in typeParams {
      val concreteGeneric = try concreteType.typeArgs[idx] else unreachable()
      concreteGenerics[typeParam] = concreteGeneric
    }

    concreteGenerics
  }

  func fnName(self, methodInstTy: ConcreteType?, fn: tc.Function, concreteGenerics: Map<String, ConcreteType>, paramsNeedingDefaultValue: Bool[] = [], discard = false): String {
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))
    val base = match fn.kind {
      FunctionKind.Standalone => {
        val (defModId, _) = try fn.scope.findParentModule() else unreachable("could not find parent module for function '${fn.label.name}'")
        "_${defModId}_"
      }
      FunctionKind.InstanceMethod => {
        val typeName = self.typeName(try methodInstTy else unreachable("InstanceMethod without methodInstTy"))
        "_${typeName}_"
      }
      FunctionKind.StaticMethod(instanceKind, _) => {
        val typeName = self.typeName(ConcreteType(instanceKind: instanceKind), withTypeArgs: false)
        "_${typeName}__"
      }
    }

    val parts = ["${base}${fn.label.name}"]

    for (_, label) in fn.typeParams {
      val concreteGeneric = try concreteGenerics[label.name] else unreachable("Could not resolve generic '${label.name}' for function '${fn.label.name}'")
      parts.push(self.typeName(concreteGeneric))
    }

    if defaultValuesFlag != 0 parts.push("$defaultValuesFlag")
    if discard parts.push("discard")

    parts.join("_")
  }

  func structInitFnName(self, ty: ConcreteType, paramsNeedingDefaultValue: Bool[] = []): String {
    val typeName = self.typeName(ty)
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))

    val prefix = "_${typeName}__init__"
    if defaultValuesFlag == 0 {
      prefix
    } else {
      "${prefix}_$defaultValuesFlag"
    }
  }

  func enumVariantInitFnName(self, ty: ConcreteType, variant: tc.TypedEnumVariant, paramsNeedingDefaultValue: Bool[] = []): String {
    val typeName = self.typeName(ty)
    val defaultValuesFlag = paramsNeedingDefaultValue.reduce(0, (acc, f) => (acc << 1) || (if f 1 else 0))

    val prefix = "_${typeName}__${variant.label.name}"
    if defaultValuesFlag == 0 {
      prefix
    } else {
      "${prefix}_$defaultValuesFlag"
    }
  }

  func getIrTypeForConcreteType(self, ty: ConcreteType): IrType {
    match ty.instanceKind {
      InstanceKind.Struct(s) => {
        if s == self.project.preludeIntStruct return IrType.I64
        if s == self.project.preludeFloatStruct return IrType.F64
        if s == self.project.preludeBoolStruct return IrType.Bool
        if s == self.project.preludeCharStruct return IrType.I64

        if s.builtin == Some(tc.BuiltinModule.Intrinsics) {
          if s.label.name == "Byte" return IrType.Byte
        }

        val t = self.getOrAddCompositeType(ty)
        IrType.Composite(name: t.name)
      }
      InstanceKind.Enum => {
        val t = self.getOrAddCompositeType(ty)
        IrType.Composite(name: t.name)
      }
    }
  }

  func getOrAddCompositeType(self, ty: ConcreteType): CompositeType {
    val typeName = self.typeName(ty)

    if self.types[typeName] |(t, _)| return t

    // TODO
    // val fields = match instanceKind {
    //   InstanceKind.Struct(s) => {
    //     s.fields.map(f => (f.name.name, self.getIrTypeForTcType(f.ty)))
    //   }
    //   InstanceKind.Enum => todo("getOrAddCompositeType for enums")
    // }

    val t = CompositeType(name: typeName, fields: [])
    self.types[typeName] = (t, ty)

    t
  }

  func emit(self, inst: Instruction) = self.curCtx.block[1].push(inst)

  func getMethodByName(self, parent: InstanceKind, name: String, staticMethod = false): tc.Function {
    val (parentName, methods) = match parent {
      InstanceKind.Struct(s) => (s.label.name, if staticMethod s.staticMethods else s.instanceMethods)
      InstanceKind.Enum(e) => (e.label.name, if staticMethod e.staticMethods else e.instanceMethods)
    }

    try methods.find(m => m.label.name == name) else {
      val sep = if staticMethod "." else "#"
      unreachable("$parentName$sep$name must exist")
    }
  }

  func variableIsGlobal(self, variable: tc.Variable): Int? {
    // Top-level variables in a module are only globals if they're captured; otherwise they're treated as locals within the module wrapper function.
    // Exported variables (which _should_ also be top-level) are necessarily hoisted to global scope.
    val modId = variable.isGlobal()
    if variable.isExported {
      if !modId unreachable("a variable should only be able to be exported if it's at the top-level")
      return modId
    }

    if !variable.isCaptured return None

    modId
  }

  func valueAsCompileTime(self, value: Value): Const? {
    if !self.foldConstants return None

    // A value is said to be known at compile time if it's a constant (int, float, bool, char, or string), or if it's an immutable global.
    match value {
      Value.Unit => None // should be unreachable, but it's ok to return None here
      Value.Const(const) => Some(const)
      Value.Ident(ident) => ident.compileTimeValue
      Value.Global(global) => if global.mutable None else global.initialValue
    }
  }

  func valuesAsCompileTime(self, value1: Value, value2: Value): (Const, Const)? {
    if self.valueAsCompileTime(value1) |v1| {
      if self.valueAsCompileTime(value2) |v2| {
        return Some((v1, v2))
      }
    }

    None
  }

  func getValueTy(self, value: Value): IrType {
    match value {
      Value.Unit => IrType.Unit
      Value.Const(const) => match const {
        Const.Int => IrType.I64
        Const.Float => IrType.F64
        Const.Bool => IrType.Bool
        Const.Char => IrType.I64
        Const.String => IrType.Composite(name: self.knowns.stringType().name)
      }
      Value.Ident(ident) => ident.ty
      Value.Global(global) => global.ty
    }
  }

  func getExternDecName(self, fn: tc.Function): String? {
    if fn.decorators.find(dec => dec.label.name == "external") |dec| {
      match dec.arguments[0] {
        LiteralAstNode.String(value) => Some(value)
        _ => unreachable("@external decorator requires 1 string argument for the name")
      }
    } else {
      None
    }
  }

  func getIntrinsicDecName(self, fn: tc.Function): String? {
    if fn.decorators.find(dec => dec.label.name == "intrinsic") |dec| {
      match dec.arguments[0] {
        LiteralAstNode.String(value) => Some(value)
        _ => unreachable("@external decorator requires 1 string argument for the name")
      }
    } else {
      None
    }
  }
}
