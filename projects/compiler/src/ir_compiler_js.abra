import File from "fs"
import Writer, IR, IrFunction, IrType, Instruction, Operation, Value, Const, Ident, IdentKind, GlobalVariable, Builtin, CaptureSource, ClosureEnvLocation from "./ir"
import ModuleBuilder, QbeType from "./qbe"
import "./qbe" as qbe

val jsReservedWords = #{
  "abstract", "arguments", "async", "await", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue",
  "debugger", "default", "delete", "do", "double", "else", "enum", "eval", "export", "extends", "false", "final", "finally",
  "float", "for", "function", "goto", "if", "implements", "function", "import", "in", "instanceof", "int", "interface", "let", "long",
  "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized",
  "this", "throw", "throws", "transient", "true", "try", "typeof", "using", "var", "void", "volatile", "while", "with", "yield"
}
func jsIdentName(name: String): String = if jsReservedWords.contains(name) return "${name}_" else name

pub type Compiler {
  ir: IR
  writer: Writer
  numTemps: Int = 0
  indentLevel: Int = 0

  pub func compile(ir: IR, w: Writer) {
    val compiler = Compiler(ir: ir, writer: w)

    w.writeln("export default function(externs, builtins, args) {")
    w.write("const { ")
    for fn in ir.functions {
      if !fn.extern continue
      w.write(jsIdentName(fn.name))
      w.write(", ")
    }
    w.writeln("} = externs;")
    w.writeln("const { \$mkstr, \$interp, \$mkargs, \$encodestr } = builtins;")
    w.writeln("const \$\$args = \$mkargs(args);")
    w.writeln()

    for g in ir.globals {
      compiler.compileGlobal(g)
    }
    w.writeln()

    compiler.compileMainFunction(ir.mainFunction)
    w.writeln()

    val mainFnName = jsIdentName(ir.mainFunction.name)
    w.writeln("$mainFnName();")

    for fn in ir.functions {
      compiler.compileFunction(fn)
      w.writeln()
    }

    w.writeln("}")
  }

  func compileGlobal(self, global: GlobalVariable) {
    if !global.referenced return

    val globalName = jsIdentName(global.name)
    if global.initialValue |init| {
      val keyword = if global.mutable "let" else "const"
      self.writer.write("$keyword $globalName = ")
      self.emitIrConstToJsValue(init)
      self.writer.writeln(";")
    } else {
      self.writer.writeln("let $globalName;")
    }
  }

  func compileMainFunction(self, fn: IrFunction) {
    self.writer.write("function ")
    self.writer.write(jsIdentName(fn.name))
    self.writer.writeln("() {")

    self.indentLevel += 1
    for inst in fn.block[1] {
      self.compileInstruction(inst)
    }
    self.indentLevel -= 1

    self.writer.writeln("}")
  }

  func compileFunction(self, fn: IrFunction) {
    if fn.extern return

    self.numTemps = 0

    val fnName = jsIdentName(fn.name)
    self.writer.write("function $fnName(")
    if fn.isClosure {
      self.writer.write("__env__")
      if !fn.params.isEmpty() self.writer.write(", ")
    }
    for param, idx in fn.params {
      val paramName = match param.kind { IdentKind.Named(name, _) => name, else => unreachable("expected IdentKind.Named for param") }
      self.writer.write(jsIdentName(paramName))
      if idx != fn.params.length - 1 {
        self.writer.write(", ")
      }
    }
    self.writer.writeln(") {")

    self.indentLevel += 1
    for inst in fn.block[1] {
      self.compileInstruction(inst)
    }
    self.indentLevel -= 1

    self.writer.writeln("}")
  }

  func genConst(self, dst: String, const: Const) {
    self.writer.write("const $dst = ")
    self.emitIrConstToJsValue(const)
    self.writer.writeln(";")
  }

  func genBinary(self, dst: String, op: String, left: Value, right: Value) {
    self.writer.write("const $dst = ")
    self.emitIrValueToJsValue(left)
    self.writer.write(" $op ")
    self.emitIrValueToJsValue(right)
    self.writer.writeln(";")
  }

  func compileInstruction(self, inst: Instruction) {
    val dst = jsIdentName(inst.assignee?.kind?.name() ?: self.nextTemp())

    self.emitIndent()

    match inst.op {
      Operation.NewLocal(ty, isCaptured, initialValue) => {
        self.writer.write("let $dst")
        if initialValue |init| {
          self.writer.write(" = ")
          if isCaptured {
            self.writer.write("{\$:")
            self.emitIrValueToJsValue(init)
            self.writer.write("}")
          } else {
            self.emitIrValueToJsValue(init)
          }
        } else {
          // no initial value to emit
        }
        self.writer.writeln(";")
      }
      Operation.ConstInt(int) => self.genConst(dst, Const.Int(int))
      Operation.ConstFloat(float) => self.genConst(dst, Const.Float(float))
      Operation.ConstBool(bool) => self.genConst(dst, Const.Bool(bool))
      Operation.ConstChar(char) => self.genConst(dst, Const.Char(char))
      Operation.ConstString(str) => self.genConst(dst, Const.String(str))
      Operation.Minus(v) => {
        self.writer.write("const $dst = -")
        self.emitIrValueToJsValue(v)
        self.writer.writeln(";")
      }
      Operation.Negate(v) => {
        self.writer.write("const $dst = !")
        self.emitIrValueToJsValue(v)
        self.writer.writeln(";")
      }
      Operation.Add(l, r) => self.genBinary(dst, "+", l, r)
      Operation.Sub(l, r) => self.genBinary(dst, "-", l, r)
      Operation.Mul(l, r) => self.genBinary(dst, "*", l, r)
      Operation.Div(l, r) => self.genBinary(dst, "/", l, r)
      Operation.Mod(l, r) => self.genBinary(dst, "%", l, r)
      Operation.Pow(l, r) => self.genBinary(dst, "**", l, r)
      Operation.BitAnd(l, r) => self.genBinary(dst, "&", l, r)
      Operation.BoolAnd(l, r) => {
        self.writer.writeln("let $dst;")

        self.emitIndent()
        val lTmp = self.nextTemp()
        self.writer.write("const $lTmp = ")
        self.emitIrValueToJsValue(l)
        self.writer.writeln(";")

        self.emitIndent()
        self.writer.writeln("if (!$lTmp)")
        self.emitIndent()
        self.writer.writeln("  $dst = false;")
        self.emitIndent()
        self.writer.writeln("else {")
        for inst in r.body {
          self.emitIndent()
          self.compileInstruction(inst)
        }
        self.writer.write("  $dst = ")
        self.emitIrValueToJsValue(r.result)
        self.writer.writeln(";")
        self.emitIndent()
        self.writer.writeln("}")

      }
      Operation.BitOr(l, r) => self.genBinary(dst, "|", l, r)
      Operation.BoolOr(l, r) => {
        self.writer.writeln("let $dst;")

        self.emitIndent()
        val lTmp = self.nextTemp()
        self.writer.write("const $lTmp = ")
        self.emitIrValueToJsValue(l)
        self.writer.writeln(";")

        self.emitIndent()
        self.writer.writeln("if ($lTmp)")
        self.emitIndent()
        self.writer.writeln("  $dst = true;")
        self.emitIndent()
        self.writer.writeln("else {")
        for inst in r.body {
          self.emitIndent()
          self.compileInstruction(inst)
        }
        self.writer.write("  $dst = ")
        self.emitIrValueToJsValue(r.result)
        self.writer.writeln(";")
        self.emitIndent()
        self.writer.writeln("}")
      }
      Operation.Xor(bitwise, l, r) => {
        if bitwise {
          self.writer.write("const $dst = (")
        } else {
          self.writer.write("const $dst = !!(")
        }
        self.emitIrValueToJsValue(l)
        self.writer.write(" ^ ")
        self.emitIrValueToJsValue(r)
        self.writer.writeln(");")
      }
      Operation.Eq(negate, l, r) => self.genBinary(dst, if negate "!==" else "===", l, r)
      Operation.Lt(l, r) => self.genBinary(dst, "<", l, r)
      Operation.Lte(l, r) => self.genBinary(dst, "<=", l, r)
      Operation.Shl(l, r) => self.genBinary(dst, "<<", l, r)
      Operation.Gt(l, r) => self.genBinary(dst, ">", l, r)
      Operation.Gte(l, r) => self.genBinary(dst, ">=", l, r)
      Operation.Shr(l, r) => self.genBinary(dst, ">>", l, r)
      Operation.LoadVar(ty, ident) => {
        val identName = jsIdentName(ident.kind.name())
        self.writer.writeln("const $dst = $identName;")
      }
      Operation.LoadCapturedVar(ty, src, deref) => {
        match src {
          CaptureSource.WithinCapturingFn(idx, _, mutable) => {
            if mutable {
              if deref {
                self.writer.writeln("const {\$:$dst} = __env__[$idx];")
              } else {
                self.writer.writeln("const $dst = __env__[$idx];")
              }
            } else {
              self.writer.writeln("const $dst = __env__[$idx];")
            }
          }
          CaptureSource.OutsideFn(ident) => {
            val identName = jsIdentName(ident.kind.name())
            if deref {
              self.writer.writeln("const {\$:$dst} = $identName;")
            } else {
              self.writer.writeln("const $dst = $identName;")
            }
          }
        }
      }
      Operation.LoadField(ty, mem, name, _) => {
        self.writer.write("const $dst = ")
        self.emitIrValueToJsValue(mem)
        self.writer.writeln(".$name;")
      }
      Operation.StoreVar(ty, value, ident) => {
        self.writer.write(jsIdentName(ident.kind.name()))
        self.writer.write(" = ")
        self.emitIrValueToJsValue(value)
        self.writer.writeln(";")
      }
      Operation.StoreCapturedVar(ty, value, src) => {
        val name = match src {
          CaptureSource.WithinCapturingFn(idx, _, _) => "__env__[$idx]"
          CaptureSource.OutsideFn(ident) => jsIdentName(ident.kind.name())
        }
        self.writer.write("$name.\$ = ")
        self.emitIrValueToJsValue(value)
        self.writer.writeln(";")
      }
      Operation.StoreGlobal(ty, value, global) => {
        self.writer.write(jsIdentName(global.name))
        self.writer.write(" = ")
        self.emitIrValueToJsValue(value)
        self.writer.writeln(";")
      }
      Operation.StoreField(ty, value, mem, name, _) => {
        self.emitIrValueToJsValue(mem)
        self.writer.write(".$name = ")
        self.emitIrValueToJsValue(value)
        self.writer.writeln(";")
      }
      Operation.If(ty, cond, thenBlock, elseBlock) => {
        val isStmt = ty == IrType.Unit

        if !isStmt {
          self.writer.writeln("let $dst;")
          self.emitIndent()
        }

        val condVal = self.irValueToJsValue(cond)
        self.writer.writeln("if ($condVal) {")
        self.indentLevel += 1
        for inst, idx in thenBlock.body {
          self.compileInstruction(inst)
        }
        if thenBlock.result |v| {
          self.emitIndent()
          self.writer.write("$dst = ")
          self.emitIrValueToJsValue(v)
          self.writer.writeln(";")
        }
        self.indentLevel -= 1

        if !elseBlock.body.isEmpty() || !!elseBlock.result {
          self.emitIndent()
          self.writer.writeln("} else {")

          self.indentLevel += 1
          for inst, idx in elseBlock.body {
            self.compileInstruction(inst)
          }
          if elseBlock.result |v| {
            self.emitIndent()
            self.writer.write("$dst = ")
            self.emitIrValueToJsValue(v)
            self.writer.writeln(";")
          }
          self.indentLevel -= 1
        }

        self.emitIndent()
        self.writer.writeln("}")
      }
      Operation.WhileLoopStart => {
        self.writer.writeln("while (true) {")
        self.indentLevel += 1
      }
      Operation.While(cond, body) => {
        self.emitIndent()
        self.writer.write("if (!")
        self.emitIrValueToJsValue(cond)
        self.writer.writeln(") break;")

        for inst in body.body {
          self.compileInstruction(inst)
        }
        self.indentLevel -= 1

        self.emitIndent()
        self.writer.writeln("}")
      }
      Operation.ForRanged(start, end, iteratee, idx, body) => {
        val iterateeName = jsIdentName(iteratee.kind.name())

        self.writer.write("for (let $iterateeName = ")
        self.emitIrValueToJsValue(start)
        if idx |idx| {
          val idxName = jsIdentName(idx.kind.name())
          self.writer.write(", $idxName = 0")
        }

        self.writer.write(";; $iterateeName += 1")
        if idx |idx| {
          val idxName = jsIdentName(idx.kind.name())
          self.writer.write(", $idxName += 1")
        }
        self.writer.writeln(") {")
        self.indentLevel += 1

        for inst in end.body {
          self.compileInstruction(inst)
        }

        self.emitIndent()
        self.writer.write("if ($iterateeName >= ")
        self.emitIrValueToJsValue(end.result)
        self.writer.writeln(") break;")

        for inst in body.body {
          self.compileInstruction(inst)
        }

        self.indentLevel -= 1
        self.writer.writeln("}")
      }
      Operation.FunctionPointer(fnName) => {
        self.writer.writeln("const $dst = $fnName;")
      }
      Operation.CreateClosure(fnName, captures, capturedSelf) => {
        self.writer.write("const $dst = (...args) => $fnName(")
        if capturedSelf |v| {
          self.emitIrValueToJsValue(v)
          self.writer.write(",")
        }
        if !captures.isEmpty() {
          self.writer.write("[")
          for c, idx in captures {
            self.emitIrValueToJsValue(c)
            if idx != captures.length - 1 {
              self.writer.write(", ")
            }
          }
          self.writer.write("],")
        }
        self.writer.writeln("...args);")
      }
      Operation.Call(ret, fnName, args, envLocation) => {
        if ret != IrType.Unit {
          self.writer.write("const $dst = ")
        }

        self.writer.write("$fnName(")
        match envLocation {
          None => {}
          ClosureEnvLocation.Passthrough => {
            self.writer.write("__env__")
            if !args.isEmpty() {
              self.writer.write(", ")
            }
          }
        }
        for arg, idx in args {
          self.emitIrValueToJsValue(arg)
          if idx != args.length - 1 {
            self.writer.write(", ")
          }
        }
        self.writer.writeln(");")
      }
      Operation.CallValue(ret, fn, args) => {
        if ret != IrType.Unit {
          self.writer.write("const $dst = ")
        }

        self.emitIrValueToJsValue(fn)
        self.writer.write("(")
        for arg, idx in args {
          self.emitIrValueToJsValue(arg)
          if idx != args.length - 1 {
            self.writer.write(", ")
          }
        }
        self.writer.writeln(");")
      }
      Operation.Break => self.writer.writeln("break;")
      Operation.Continue => self.writer.writeln("continue;")
      Operation.Return(value) => {
        self.writer.write("return")
        if value |v| {
          self.writer.write(" ")
          self.emitIrValueToJsValue(v)
        }
        self.writer.writeln(";")
      }
      Operation.Unreachable(message) => {
        self.writer.write("throw new Error(\"$message\")")
      }
      Operation.GetEnumVariantIdx(value, numVariants) => {
        val jsVal = self.irValueToJsValue(value)
        self.writer.writeln("const $dst = typeof $jsVal === 'number' ? $jsVal : $jsVal.\$idx;")
      }
      Operation.OptionNone => {
        self.writer.writeln("const $dst = null;")
      }
      Operation.OptionSome(_, value) => {
        self.writer.write("const $dst = ")
        self.emitIrValueToJsValue(value)
        self.writer.writeln(";")
      }
      Operation.OptionIsNone(_, value) => {
        self.writer.write("const $dst = ")
        self.emitIrValueToJsValue(value)
        self.writer.writeln(" === null;")
      }
      Operation.OptionUnwrap(_, value) => {
        self.writer.write("const $dst = ")
        self.emitIrValueToJsValue(value)
        self.writer.writeln(";")
      }
      Operation.StructuredToString(prefix, lenVal, fields) => {
        val strIrTy = IrType.Composite(self.ir.knowns.stringType().name, isEnum: false)
        val strTemplateLiteralParts = ["`$prefix("]

        for (fieldIrType, fieldName, fieldStrValue), idx in fields {
          val fieldValue = self.irValueToJsValue(fieldStrValue)

          val fieldPart = if fieldIrType == strIrTy { "\"\${$fieldValue}\"" } else { "\${$fieldValue}" }
          val sepPart = if idx == fields.length - 1 { ")" } else { ", " }
          if fieldName.isEmpty() {
            strTemplateLiteralParts.push("$fieldPart$sepPart")
          } else {
            strTemplateLiteralParts.push("$fieldName: $fieldPart$sepPart")
          }
        }
        strTemplateLiteralParts.push("`")

        val buf = self.nextTemp()
        self.writer.writeln("const $buf = \$interp${strTemplateLiteralParts.join()};")

        val strInitFn = self.ir.knowns.stringInitializerFn()
        self.emitIndent()
        val len = self.irValueToJsValue(lenVal)
        self.writer.writeln("const $dst = ${strInitFn.name}($len, $buf);")
      }
      Operation.Builtin(ret, builtin) => {
        match builtin {
          Builtin.Argc => {
            self.writer.writeln("const $dst = \$\$args.length;")
          }
          Builtin.Argv => {
            self.writer.writeln("const $dst = \$\$args;")
          }
          Builtin.Malloc(count, itemTy) => {
            self.writer.write("const $dst = ")
            // If there's no type being malloc'd, then it can be modeled as an object. If the type is Byte then it's
            // modeled as a Uint8Array; otherwise it's just a simple array.
            match ret {
              IrType.Composite => {
                self.writer.write("{};")
              }
              else => match itemTy {
                IrType.Byte => {
                  self.writer.write("new Uint8Array(")
                  self.emitIrValueToJsValue(count)
                  self.writer.write(");")
                }
                else => self.writer.write("[];")
              }
            }
            self.writer.writeln(" // builtin(malloc)")
          }
          Builtin.Null => {
            self.writer.writeln("const $dst = null; // pointer_null")
          }
          Builtin.IsNull(ptr) => {
            self.writer.write("const $dst = ")
            self.emitIrValueToJsValue(ptr)
            self.writer.writeln(" === null; // pointer_is_null")
          }
          Builtin.Realloc(ptr, count, _) => {
            self.writer.write("const $dst = ")
            self.emitIrValueToJsValue(ptr)
            self.writer.writeln("; // realloc (no-op)")
          }
          Builtin.Store(ptr, value, offset, _) => {
            self.emitIrValueToJsValue(ptr)
            self.writer.write("[")
            self.emitIrValueToJsValue(offset)
            self.writer.write("] = ")
            self.emitIrValueToJsValue(value)
            self.writer.writeln("; // builtin(ptr_store)")
          }
          Builtin.Load(ptr, offset, _) => {
            self.writer.write("const $dst = ")
            self.emitIrValueToJsValue(ptr)
            self.writer.write("[")
            self.emitIrValueToJsValue(offset)
            self.writer.writeln("]; // builtin(ptr_load)")
          }
          Builtin.CopyFrom(dst, dstOffset, src, srcOffset, count, _) => {
            val countVal = self.irValueToJsValue(count)
            self.writer.writeln("for (let i = 0; i < $countVal; i++) {")
            self.indentLevel += 1

            self.emitIndent()
            self.emitIrValueToJsValue(dst)
            self.writer.write("[")
            self.emitIrValueToJsValue(dstOffset)
            self.writer.write(" + i] = ")
            self.emitIrValueToJsValue(src)
            self.writer.write("[")
            self.emitIrValueToJsValue(srcOffset)
            self.writer.writeln(" + i]; // builtin(copy_from)")

            self.indentLevel -= 1
            self.emitIndent()
            self.writer.writeln("}")
          }
          Builtin.I64ToString(int) => {
            val strInitFn = self.ir.knowns.stringInitializerFn()

            val strTmp = self.nextTemp()
            self.writer.write("const $strTmp = \$encodestr(")
            self.emitIrValueToJsValue(int)
            self.writer.writeln(".toString());")

            self.emitIndent()
            self.writer.writeln("const $dst = ${strInitFn.name}($strTmp.length-1, $strTmp);")
          }
          Builtin.U64ToString(int) => {
            val strInitFn = self.ir.knowns.stringInitializerFn()

            val strTmp = self.nextTemp()
            self.writer.write("const $strTmp = \$encodestr(BigInt.asUintN(64, BigInt(")
            self.emitIrValueToJsValue(int)
            self.writer.writeln(")).toString());")

            self.emitIndent()
            self.writer.writeln("const $dst = ${strInitFn.name}($strTmp.length-1, $strTmp);")
          }
          Builtin.F64ToString(float) => {
            val strInitFn = self.ir.knowns.stringInitializerFn()

            val floatVal = self.irValueToJsValue(float)

            self.writer.writeln("let $dst;")
            self.emitIndent()
            self.writer.writeln("if ($floatVal === -0) {")
            self.emitIndent()
            self.writer.writeln("  $dst = ${self.makeConstString("-0")};")
            self.emitIndent()
            self.writer.writeln("} else {")

            self.indentLevel += 1
            val strTmp = self.nextTemp()
            self.emitIndent()
            self.writer.writeln("const $strTmp = \$encodestr($floatVal.toPrecision(6).replace(/0+$/, '').replace(/\\.$/, ''));")

            self.emitIndent()
            self.writer.writeln("$dst = ${strInitFn.name}($strTmp.length-1, $strTmp);")
            self.indentLevel -= 1

            self.emitIndent()
            self.writer.writeln("}")
          }
          Builtin.BoolToString(bool) => {
            val strInitFn = self.ir.knowns.stringInitializerFn()

            val strTmp = self.nextTemp()
            self.writer.write("const $strTmp = \$encodestr(")
            self.emitIrValueToJsValue(bool)
            self.writer.writeln(".toString());")

            self.emitIndent()
            self.writer.writeln("const $dst = ${strInitFn.name}($strTmp.length-1, $strTmp);")
          }
          Builtin.IntAsFloat(int) => {
            self.writer.write("const $dst = ")
            self.emitIrValueToJsValue(int)
            self.writer.writeln(";")
          }
          Builtin.FloatAsInt(float) => {
            self.writer.write("const $dst = Math.trunc(")
            self.emitIrValueToJsValue(float)
            self.writer.writeln(");")
          }
          Builtin.FloatCeil(float) => {
            self.writer.write("const $dst = Math.ceil(")
            self.emitIrValueToJsValue(float)
            self.writer.writeln(");")
          }
          Builtin.FloatFloor(float) => {
            self.writer.write("const $dst = Math.floor(")
            self.emitIrValueToJsValue(float)
            self.writer.writeln(");")
          }
          Builtin.FloatRound(float) => {
            self.writer.write("const $dst = Math.round(")
            self.emitIrValueToJsValue(float)
            self.writer.writeln(");")
          }
          Builtin.FloatBitsToInt(float) => {
            val floatArray = self.nextTemp()
            self.writer.writeln("const $floatArray = new Float32Array(1);")
            val intArray = self.nextTemp()
            self.writer.writeln("const $intArray = new Uint32Array($floatArray.buffer);")
            self.writer.write("$floatArray[0] = ")
            self.emitIrValueToJsValue(float)
            self.writer.writeln(";")

            self.writer.writeln("const $dst = $intArray[0];")
          }
          Builtin.Uninitialized => self.writer.writeln("const $dst = undefined;")
          // TODO: real implementations for callstack, modulenames, and functionnames
          Builtin.Callstack => self.writer.writeln("const $dst = undefined;")
          Builtin.CallstackPtr => self.writer.writeln("const $dst = 0;")
          Builtin.ModuleNames => self.writer.writeln("const $dst = undefined;")
          Builtin.FunctionNames => self.writer.writeln("const $dst = undefined;")
          Builtin.Errno => self.writer.writeln("const $dst = externs.errno();")
        }
      }
    }
  }

  func nextTemp(self): String {
    val name = "_t${self.numTemps}"
    self.numTemps += 1
    name
  }

  func emitIndent(self) {
    self.writer.write("  ".repeat(self.indentLevel))
  }

  func emitIrConstToJsValue(self, c: Const) = self.writer.write(self.irConstToJsValue(c))

  func irConstToJsValue(self, const: Const): String = match const {
    Const.Int(i) => {
      // JS can only accurately represent integer literals up to 53 bits; otherwise BigInt is required (see `Number.MAX_SAFE_INTEGER` in JS)
      val jsMaxSafeInteger = (1 << 53) + 1
      if i.abs() > jsMaxSafeInteger {
        "${i}n"
      } else {
        i.toString()
      }
    }
    Const.Float(f) => f.toString()
    Const.Bool(b) => b.toString()
    Const.Char(c) => c.toString()
    Const.String(s) => self.makeConstString(s)
  }

  func makeConstString(self, s: String): String {
    val str = s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"").replaceAll("\n", "\\n").replaceAll("\r", "\\r")
    "\$mkstr(${s.length}, \"$str\")"
  }

  func emitIrValueToJsValue(self, v: Value) = self.writer.write(self.irValueToJsValue(v))

  func irValueToJsValue(self, v: Value): String {
    match v {
      Value.Unit => unreachable("values cannot be of type unit")
      Value.Const(const) => self.irConstToJsValue(const)
      Value.Ident(i) => jsIdentName(i.kind.name())
      Value.Global(g) => jsIdentName(g.name)
    }
  }
}
