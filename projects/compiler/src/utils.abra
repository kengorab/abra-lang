import "fs" as fs

pub func valueIfValidHexDigit(ch: Int): Int? {
  if 48 <= ch && ch <= 57 { // 0-9
    Some(ch - 48)
  } else if 65 <= ch && ch <= 70 { // A-F
    Some((ch - 65) + 10)
  } else if 97 <= ch && ch <= 102 { // a-f
    Some((ch - 97) + 10)
  } else {
    None
  }
}

// TODO: Move this elsewhere, probably into std somewhere
pub func getAbsolutePath(fileName: String): String[] {
  val parts = if fileName[0] == "/" {
    fileName.split("/")
  } else {
    val cwd = fs.getCurrentWorkingDirectory()
    val path = cwd + "/" + fileName
    path.split("/")
  }

  val sanitizedParts: String[] = []
  for part in parts {
    if part.isEmpty() || part == "." continue
    if part == ".." {
      sanitizedParts.pop()
      continue
    }

    sanitizedParts.push(part)
  }

  sanitizedParts
}

// TODO: Move this elsewhere, probably into std somewhere
pub func resolveRelativePath(path: String, relativeTo: String): String[] {
  val absParentPath = getAbsolutePath(fileName: relativeTo)
  absParentPath.pop() // remove file part to obtain parent dir

  val pathSegs = path.split("/")

  for part in pathSegs {
    if part.isEmpty() || part == "." continue
    if part == ".." {
      absParentPath.pop()
      continue
    }

    absParentPath.push(part)
  }

  absParentPath
}

pub func getCursorLine(lineNum: Int, colNum: Int, contents: String, cursorLength = 1): String {
  val line = getLine(contents, lineNum - 1)
  val len = colNum - 1 + cursorLength
  val cursor = Array.fill(len, " ")
  for i in (len - cursorLength):len {
    cursor[i] = "^"
  }
  "  |  $line\n     ${cursor.join()}"
}

// TODO: move to prelude
func getLine(str: String, line: Int): String {
  if line < 0 return ""

  var seenLines = 0
  var idx = 0
  var prevStart = 0
  while idx < str.length {
    if str._buffer.loadAt(idx).asInt() == '\n'.asByte().asInt() {
      if line == seenLines return str[prevStart:idx]

      seenLines += 1
      prevStart = idx + 1
    }

    idx += 1
  }

  if line == seenLines return str[prevStart:idx]

  ""
}
