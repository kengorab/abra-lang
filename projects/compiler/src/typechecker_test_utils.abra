import LiteralAstNode, IndexingMode from "./parser"
import Type, TypeKind, TypedModule, TypedAstNode, TypedAstNodeKind, Variable, Function, FunctionKind, Scope, Struct, Enum, InstanceKind, AccessorPathSegment, TypedInvokee, TypedIndexingNode, TypedAssignmentMode, Field, EnumVariantKind, Export, TypedMatchCaseKind from "./typechecker"
import printTokenAsJson, printLabelAsJson, printBindingPatternAsJson from "./test_utils"

pub type Jsonifier {
  pub allowPlaceholderNodes: Bool = false
  indentLevel: Int = 0

  pub func printModules(self, modules: TypedModule[]) {
    val manyModules = modules.length > 1

    if manyModules {
      printlnv2("[")
      self.indentInc()
    }

    for mod, idx in modules {
      self.indent()
      self.printModule(mod)
      if manyModules {
        if idx != modules.length - 1 {
          printv2(",")
        }
        printlnv2("")
      }
    }

    if manyModules {
      self.indentDec()
      printv2("]")
    }

    printlnv2("")
  }

  func printModule(self, mod: TypedModule) {
    printlnv2("{")
    self.indentInc()

    self.printlnv2("\"id\": ${mod.id},")
    self.printlnv2("\"name\": \"${mod.name}\",")

    if !mod.exports.isEmpty() {
      self.printlnv2("\"exports\": [")
      self.indentInc()

      for (name, exp), idx in mod.exports {
        self.printlnv2("{")
        self.indentInc()

        match exp {
          Export.Variable => self.printlnv2("\"kind\": \"variable\",")
          Export.Function => self.printlnv2("\"kind\": \"function\",")
          Export.Type => self.printlnv2("\"kind\": \"type\",")
        }
        self.printlnv2("\"name\": \"$name\"")

        self.indentDec()
        self.printv2("}")

        val comma = if idx != mod.exports.size - 1 "," else ""
        printlnv2(comma)
      }
      self.indentDec()
      self.printlnv2("],")
    }

    self.printv2("\"code\": ")
    self.printNodes(mod.code)
    printlnv2("")

    self.indentDec()
    self.printv2("}")
  }

  func printNodes(self, nodes: TypedAstNode[]) {
    printlnv2("[")
    self.indentInc()

    for node, idx in nodes {
      self.indent()
      self.printNode(node)
      val comma = if idx != nodes.length - 1 "," else ""
      printlnv2(comma)
    }

    self.indentDec()
    self.printv2("]")
  }

  func printType(self, ty: Type) {
    printlnv2("{")
    self.indentInc()

    match ty.kind {
      TypeKind.CouldNotDetermine => {
        self.printlnv2("\"kind\": \"could not determine\"")
      }
      TypeKind.Any => {
        self.printlnv2("\"kind\": \"primitive\",")
        self.printlnv2("\"primitive\": \"Any\"")
      }
      TypeKind.PrimitiveUnit => {
        self.printlnv2("\"kind\": \"primitive\",")
        self.printlnv2("\"primitive\": \"Unit\"")
      }
      TypeKind.PrimitiveInt => {
        self.printlnv2("\"kind\": \"primitive\",")
        self.printlnv2("\"primitive\": \"Int\"")
      }
      TypeKind.PrimitiveFloat => {
        self.printlnv2("\"kind\": \"primitive\",")
        self.printlnv2("\"primitive\": \"Float\"")
      }
      TypeKind.PrimitiveBool => {
        self.printlnv2("\"kind\": \"primitive\",")
        self.printlnv2("\"primitive\": \"Bool\"")
      }
      TypeKind.PrimitiveString => {
        self.printlnv2("\"kind\": \"primitive\",")
        self.printlnv2("\"primitive\": \"String\"")
      }
      TypeKind.Never => {
        self.printlnv2("\"kind\": \"never\"")
      }
      TypeKind.Generic(name) => {
        self.printlnv2("\"kind\": \"generic\",")
        self.printlnv2("\"name\": \"$name\"")
      }
      TypeKind.Instance(instanceKind, generics) => {
        match instanceKind {
          InstanceKind.Struct(struct) => {
            self.printlnv2("\"kind\": \"instance\",")
            self.printlnv2("\"struct\": { \"moduleId\": ${struct.moduleId}, \"name\": \"${struct.label.name}\" },")
          }
          InstanceKind.Enum(enum_) => {
            self.printlnv2("\"kind\": \"enumInstance\",")
            self.printlnv2("\"enum\": { \"moduleId\": ${enum_.moduleId}, \"name\": \"${enum_.label.name}\" },")
          }
        }
        self.printv2("\"typeParams\": ")
        self.array(generics, t => self.printType(t))
        printlnv2("")
      }
      TypeKind.Tuple(types) => {
        self.printlnv2("\"kind\": \"tuple\",")
        self.printv2("\"types\": ")
        self.array(types, t => self.printType(t))
        printlnv2("")
      }
      TypeKind.Func(params, ret) => {
        self.printlnv2("\"kind\": \"function\",")
        self.printv2("\"parameters\": ")
        self.array(params, p => {
          printlnv2("{")
          self.indentInc()

          self.printlnv2("\"required\": ${p[1]},")

          self.printv2("\"type\": ")
          self.printType(p[0])
          printlnv2("")

          self.indentDec()
          self.printv2("}")
        })
        printlnv2(",")
        self.printv2("\"returnType\": ")
        self.printType(ret)
        printlnv2("")
      }
      TypeKind.Type(instanceKind) => {
        match instanceKind {
          InstanceKind.Struct(struct) => {
            self.printlnv2("\"kind\": \"struct\",")
            self.printv2("\"struct\": ")
            self.printStruct(struct: struct, abridged: true)
          }
          InstanceKind.Enum(enum_) => {
            self.printlnv2("\"kind\": \"enum\",")
            self.printv2("\"enum\": ")
            self.printEnum(enum_: enum_, abridged: true)
          }
        }
        printlnv2("")
      }
      TypeKind.Hole => self.printlnv2("\"kind\": \"hole\"")
    }

    self.indentDec()
    self.printv2("}")
  }

  func printStruct(self, struct: Struct, abridged: Bool) {
    if abridged {
      printv2("{ \"moduleId\": ${struct.moduleId}, \"name\": \"${struct.label.name}\" }")
      return
    }

    printlnv2("{")
    self.indentInc()

    self.printlnv2("\"moduleId\": ${struct.moduleId},")

    self.printv2("\"name\": ")
    printLabelAsJson(struct.label)
    printlnv2(",")

    self.printv2("\"typeParams\": ")
    self.array(struct.typeParams, p => printv2("\"$p\""))
    printlnv2(",")

    self.printv2("\"fields\": ")
    self.array(struct.fields, f => self.printField(f))
    printlnv2(",")

    self.printv2("\"instanceMethods\": ")
    self.array(struct.instanceMethods, m => self.printFunc(m))
    printlnv2(",")

    self.printv2("\"staticMethods\": ")
    self.array(struct.staticMethods, m => self.printFunc(m))
    printlnv2("")

    self.indentDec()
    self.printv2("}")
  }

  func printField(self, field: Field) {
    printlnv2("{")
    self.indentInc()

    self.printv2("\"name\": ")
    printLabelAsJson(field.name)
    printlnv2(",")

    self.printv2("\"type\": ")
    self.printType(field.ty)
    printlnv2(",")

    self.printv2("\"initializer\": ")
    self.opt(field.initializer, n => self.printNode(n))

    if field.isPublic {
      printlnv2(",")
      self.printv2("\"isPublic\": true")
    }
    printlnv2("")

    self.indentDec()
    self.printv2("}")
  }

  func printEnum(self, enum_: Enum, abridged: Bool) {
    if abridged {
      printv2("{ \"moduleId\": ${enum_.moduleId}, \"name\": \"${enum_.label.name}\" }")
      return
    }

    printlnv2("{")
    self.indentInc()

    self.printlnv2("\"moduleId\": ${enum_.moduleId},")

    self.printv2("\"name\": ")
    printLabelAsJson(enum_.label)
    printlnv2(",")

    self.printv2("\"typeParams\": ")
    self.array(enum_.typeParams, p => printv2("\"$p\""))
    printlnv2(",")

    self.printv2("\"variants\": ")
    self.array(enum_.variants, v => {
      printlnv2("{")
      self.indentInc()

      self.printv2("\"label\": ")
      printLabelAsJson(v.label)
      printlnv2(",")

      match v.kind {
        EnumVariantKind.Constant => {
          self.printlnv2("\"kind\": \"constant\"")
        }
        EnumVariantKind.Container(fields) => {
          self.printlnv2("\"kind\": \"container\",")
          self.printv2("\"fields\": ")
          self.array(fields, f => self.printField(f))
          printlnv2("")
        }
      }

      self.indentDec()
      self.printv2("}")
    })
    printlnv2(",")

    self.printv2("\"instanceMethods\": ")
    self.array(enum_.instanceMethods, m => self.printFunc(m))
    printlnv2(",")

    self.printv2("\"staticMethods\": ")
    self.array(enum_.staticMethods, m => self.printFunc(m))
    printlnv2("")

    self.indentDec()
    self.printv2("}")
  }

  func printNode(self, node: TypedAstNode) {
    printlnv2("{")
    self.indentInc()

    self.printv2("\"token\": ")
    printTokenAsJson(node.token, 0, self.indentLevel)
    printlnv2(",")

    self.printv2("\"type\": ")
    self.printType(node.ty)
    printlnv2(",")

    self.printv2("\"node\": ")
    self.printNodeKind(node.kind)
    printlnv2("")

    self.indentDec()
    self.printv2("}")
  }

  func printNodeKind(self, kind: TypedAstNodeKind) {
    printlnv2("{")
    self.indentInc()

    match kind {
      TypedAstNodeKind.Literal(value) => {
        self.printlnv2("\"kind\": \"literal\",")
        match value {
          LiteralAstNode.Int(value) => self.printlnv2("\"value\": $value")
          LiteralAstNode.Float(value) => self.printlnv2("\"value\": $value")
          LiteralAstNode.Bool(value) => self.printlnv2("\"value\": $value")
          LiteralAstNode.Char(value) => self.printlnv2("\"value\": \"${value.hex()}\"")
          LiteralAstNode.String(value) => self.printlnv2("\"value\": \"$value\"")
        }
      }
      TypedAstNodeKind.StringInterpolation(exprs) => {
        self.printlnv2("\"kind\": \"stringInterpolation\",")

        self.printv2("\"exprs\": ")
        self.array(exprs, n => self.printNode(n))
        printlnv2("")
      }
      TypedAstNodeKind.Unary(op, expr) => {
        self.printlnv2("\"kind\": \"unary\",")
        self.printlnv2("\"op\": \"$op\",")
        self.printv2("\"expr\": ")
        self.printNode(expr)
        printlnv2("")
      }
      TypedAstNodeKind.Binary(left, op, right) => {
        self.printlnv2("\"kind\": \"binary\",")
        self.printlnv2("\"op\": \"$op\",")
        self.printv2("\"left\": ")
        self.printNode(left)
        printlnv2(",")
        self.printv2("\"right\": ")
        self.printNode(right)
        printlnv2("")
      }
      TypedAstNodeKind.Grouped(inner) => {
        self.printlnv2("\"kind\": \"grouped\",")
        self.printv2("\"expr\": ")
        self.printNode(inner)
        printlnv2("")
      }
      TypedAstNodeKind.Identifier(name, _, _, _) => {
        self.printlnv2("\"kind\": \"identifier\",")

        self.printv2("\"name\": \"$name\"")
        printlnv2("")
      }
      TypedAstNodeKind.Accessor(head, middle, tail) => {
        self.printlnv2("\"kind\": \"accessor\",")

        self.printv2("\"head\": ")
        self.printNode(head)
        printlnv2(",")

        self.printv2("\"middle\": ")
        self.array(middle, seg => {
          printlnv2("{")
          self.indentInc()

          match seg {
            AccessorPathSegment.EnumVariant(_, _, enum_, variant) => {
              self.printlnv2("\"kind\": \"enumVariant\",")
              self.printlnv2("\"name\": \"${enum_.label.name}.${variant.label.name}\"")
            }
            AccessorPathSegment.Method(_, f, _, _) => {
              self.printlnv2("\"kind\": \"method\",")
              self.printlnv2("\"name\": \"${f.label.name}\"")
            }
            AccessorPathSegment.Field(_, ty, f, _) => {
              self.printlnv2("\"kind\": \"field\",")
              self.printlnv2("\"name\": \"${f.name.name}\",")
              self.printv2("\"type\": ")
              self.printType(ty)
              printlnv2("")
            }
          }

          self.indentDec()
          self.printv2("}")
        })
        printlnv2(",")

        self.printlnv2("\"tail\": {")
        self.indentInc()
        match tail {
          AccessorPathSegment.EnumVariant(_, _, enum_, variant) => {
            self.printlnv2("\"kind\": \"enumVariant\",")
            self.printlnv2("\"name\": \"${enum_.label.name}.${variant.label.name}\"")
          }
          AccessorPathSegment.Method(_, f, _, _) => {
            self.printlnv2("\"kind\": \"method\",")
            self.printlnv2("\"name\": \"${f.label.name}\"")
          }
          AccessorPathSegment.Field(_, ty, f, _) => {
            self.printlnv2("\"kind\": \"field\",")
            self.printlnv2("\"name\": \"${f.name.name}\",")
            self.printv2("\"type\": ")
            self.printType(ty)
            printlnv2("")
          }
        }
        self.indentDec()
        self.printlnv2("}")
      }
      TypedAstNodeKind.Invocation(invokee, arguments, _) => {
        self.printlnv2("\"kind\": \"invocation\",")

        self.printv2("\"invokee\": ")
        match invokee {
          TypedInvokee.Method(fn, selfVal, isOptSafe) => {
            printlnv2("{")
            self.indentInc()

            self.printlnv2("\"method\": \"${fn.label.name}\",")

            self.printv2("\"type\": ")
            self.printType(fn.getType())
            printlnv2(",")

            self.printlnv2("\"isOptSafe\": $isOptSafe,")
            self.printv2("\"self\": ")
            self.printNode(selfVal)
            printlnv2("")

            self.indentDec()
            self.printv2("}")
          }
          TypedInvokee.Function(fn) => {
            printlnv2("{")
            self.indentInc()

            self.printlnv2("\"function\": \"${fn.label.name}\",")

            self.printv2("\"type\": ")
            self.printType(fn.getType())
            printlnv2("")

            self.indentDec()
            self.printv2("}")
          }
          TypedInvokee.Struct(struct) => self.printStruct(struct: struct, abridged: true)
          TypedInvokee.Expr(expr) => self.printNode(expr)
          TypedInvokee.EnumVariant(enum_, variant) => printv2("\"${enum_.label.name}.${variant.label.name}\"")
        }
        printlnv2(",")

        self.printv2("\"arguments\": ")
        self.array(arguments, n => self.opt(n, n => self.printNode(n)))
        printlnv2("")
      }
      TypedAstNodeKind.Array(items) => {
        self.printlnv2("\"kind\": \"array\",")

        self.printv2("\"items\": ")
        self.array(items, n => self.printNode(n))
        printlnv2("")
      }
      TypedAstNodeKind.Set(items) => {
        self.printlnv2("\"kind\": \"set\",")

        self.printv2("\"items\": ")
        self.array(items, n => self.printNode(n))
        printlnv2("")
      }
      TypedAstNodeKind.Map(pairs) => {
        self.printlnv2("\"kind\": \"map\",")

        self.printv2("\"pairs\": ")
        self.array(pairs, p => {
          self.array([p[0], p[1]], n => self.printNode(n))
        })
        printlnv2("")
      }
      TypedAstNodeKind.Tuple(items) => {
        self.printlnv2("\"kind\": \"tuple\",")

        self.printv2("\"items\": ")
        self.array(items, n => self.printNode(n))
        printlnv2("")
      }
      TypedAstNodeKind.Indexing(node) => {
        self.printlnv2("\"kind\": \"indexing\",")

        self.printv2("\"node\": ")
        self.printTypedIndexingNode(node)
        printlnv2("")
      }
      TypedAstNodeKind.Lambda(fn, _) => {
        self.printlnv2("\"kind\": \"lambda\",")
        self.printv2("\"function\": ")
        self.printFunc(fn)
        printlnv2("")
      }
      TypedAstNodeKind.Assignment(mode, op, expr) => {
        self.printlnv2("\"kind\": \"assignment\",")

        self.printv2("\"expr\": ")
        self.printNode(expr)
        printlnv2(",")

        self.printlnv2("\"op\": \"$op\",")

        self.printv2("\"mode\": ")

        match mode {
          TypedAssignmentMode.Variable(v) => {
            printlnv2("{")
            self.indentInc()

            self.printlnv2("\"kind\": \"variable\",")
            self.printv2("\"variable\": ")
            self.printVariable(v)
            printlnv2("")

            self.indentDec()
            self.printv2("}")
            printlnv2("")
          }
          TypedAssignmentMode.Indexing(typedIndexingNode) => {
            printlnv2("{")
            self.indentInc()

            self.printlnv2("\"kind\": \"indexing\",")
            self.printv2("\"indexNode\": ")
            self.printTypedIndexingNode(typedIndexingNode)
            printlnv2("")

            self.indentDec()
            self.printv2("}")
            printlnv2("")
          }
          TypedAssignmentMode.Accessor(head, mid, tail) => {
            self.printNodeKind(TypedAstNodeKind.Accessor(head, mid, tail))
            printlnv2("")
          }
        }
      }
      TypedAstNodeKind.If(isStatement, condition, conditionBindingPattern, ifBlock, _, elseBlock, _) => {
        self.printlnv2("\"kind\": \"if\",")

        self.printlnv2("\"isStatement\": $isStatement,")

        self.printv2("\"condition\": ")
        self.printNode(condition)
        printlnv2(",")

        self.printv2("\"conditionBindingPattern\": ")
        self.opt(conditionBindingPattern, pair => {
          printlnv2("{")
          self.indentInc()

          self.printv2("\"bindingPattern\": ")
          printBindingPatternAsJson(pair[0], 0, self.indentLevel)
          printlnv2(",")

          self.printv2("\"variables\": ")
          self.array(pair[1], v => self.printVariable(v))
          printlnv2("")

          self.indentDec()
          self.printv2("}")
        })
        printlnv2(",")

        self.printv2("\"ifBlock\": ")
        self.array(ifBlock, n => self.printNode(n))
        printlnv2(",")

        self.printv2("\"elseBlock\": ")
        self.array(elseBlock, n => self.printNode(n))
        printlnv2("")
      }

      TypedAstNodeKind.Match(isStatement, subject, cases) => {
        self.printlnv2("\"kind\": \"match\",")

        self.printlnv2("\"isStatement\": $isStatement,")

        self.printv2("\"subject\": ")
        self.printNode(subject)
        printlnv2(",")

        self.printv2("\"cases\": ")
        self.array(cases, case => {
          printlnv2("{")
          self.indentInc()

          self.printv2("\"kind\": ")
          match case.kind {
            TypedMatchCaseKind.Type(ty) => {
              printlnv2("{")
              self.indentInc()

              self.printlnv2("\"kind\": \"type\",")
              self.printv2("\"type\": ")
              self.printType(ty)
              printlnv2("")

              self.indentDec()
              self.printv2("}")
            }
            TypedMatchCaseKind.EnumVariant(enum_, _, variantIdx, destructuredVariables) => {
              printlnv2("{")
              self.indentInc()

              self.printlnv2("\"kind\": \"enumVariant\",")
              self.printlnv2("\"variantIdx\": $variantIdx,")
              self.printv2("\"enum\": ")
              self.printEnum(enum_: enum_, abridged: true)
              printlnv2(",")
              self.printv2("\"destructuredVariables\": ")
              self.array(destructuredVariables, v => self.printVariable(v))
              printlnv2("")

              self.indentDec()
              self.printv2("}")
            }
            TypedMatchCaseKind.Literal(value) => {
              printlnv2("{")
              self.indentInc()

              self.printlnv2("\"kind\": \"literal\",")
              match value {
                LiteralAstNode.Int(value) => self.printlnv2("\"value\": $value")
                LiteralAstNode.Float(value) => self.printlnv2("\"value\": $value")
                LiteralAstNode.Bool(value) => self.printlnv2("\"value\": $value")
                LiteralAstNode.String(value) => self.printlnv2("\"value\": \"$value\"")
              }

              self.indentDec()
              self.printv2("}")
            }
            TypedMatchCaseKind.None_ => printv2("\"None\"")
            TypedMatchCaseKind.Else => printv2("\"else\"")
          }
          printlnv2(",")

          self.printv2("\"binding\": ")
          self.opt(case.binding, v => self.printVariable(v))
          printlnv2(",")

          self.printv2("\"body\": ")
          self.array(case.body, n => self.printNode(n))
          printlnv2("")

          self.indentDec()
          self.printv2("}")
        })
        printlnv2("")
      }
      TypedAstNodeKind.Try(expr, elseClause) => {
        self.printlnv2("\"kind\": \"try\",")

        self.printv2("\"expr\": ")
        self.printNode(expr)
        if elseClause |elseClause| {
          printlnv2(",")
          self.printv2("\"elseBindingPattern\": ")
          self.opt(elseClause.pattern, _pair => {
            val (pat, vars) = _pair
            printlnv2("{")
            self.indentInc()

            self.printv2("\"bindingPattern\": ")
            printBindingPatternAsJson(pat, 0, self.indentLevel)
            printlnv2(",")

            self.printv2("\"variables\": ")
            self.array(vars, v => self.printVariable(v))
            printlnv2("")

            self.indentDec()
            self.printv2("}")
          })

          printlnv2(",")

          self.printv2("\"elseBlock\": ")
          self.array(elseClause.block, n => self.printNode(n))
        }
        printlnv2("")
      }

      // Statements
      TypedAstNodeKind.While(condition, conditionBindingPattern, block, _) => {
        self.printlnv2("\"kind\": \"while\",")

        self.printv2("\"condition\": ")
        self.printNode(condition)
        printlnv2(",")

        self.printv2("\"conditionBindingPattern\": ")
        self.opt(conditionBindingPattern, _pair => {
          val (pat, vars) = _pair
          printlnv2("{")
          self.indentInc()

          self.printv2("\"bindingPattern\": ")
          printBindingPatternAsJson(pat, 0, self.indentLevel)
          printlnv2(",")

          self.printv2("\"variables\": ")
          self.array(vars, v => self.printVariable(v))
          printlnv2("")

          self.indentDec()
          self.printv2("}")
        })
        printlnv2(",")

        self.printv2("\"block\": ")
        self.array(block, n => self.printNode(n))
        printlnv2("")
      }
      TypedAstNodeKind.For(iterator, itemBindingPattern, indexBinding, block) => {
        self.printlnv2("\"kind\": \"for\",")

        self.printv2("\"iterator\": ")
        self.printNode(iterator)
        printlnv2(",")

        self.printlnv2("\"itemBindingPattern\": {")
        self.indentInc()
        self.printv2("\"bindingPattern\": ")
        printBindingPatternAsJson(itemBindingPattern[0], 0, self.indentLevel)
        printlnv2(",")
        self.printv2("\"variables\": ")
        self.array(itemBindingPattern[1], v => self.printVariable(v))
        printlnv2("")
        self.indentDec()
        self.printlnv2("},")

        self.printv2("\"indexBinding\": ")
        self.opt(indexBinding, v => self.printVariable(v))
        printlnv2(",")

        self.printv2("\"block\": ")
        self.array(block, n => self.printNode(n))
        printlnv2("")
      }
      TypedAstNodeKind.BindingDeclaration(node) => {
        self.printlnv2("\"kind\": \"bindingDeclaration\",")

        self.printv2("\"pattern\": ")
        printBindingPatternAsJson(node.bindingPattern, 0, self.indentLevel)
        printlnv2(",")

        self.printv2("\"variables\": ")
        self.array(node.variables, v => self.printVariable(v))
        printlnv2(",")

        self.printv2("\"expr\": ")
        self.opt(node.expr, n => self.printNode(n))
        printlnv2("")
      }
      TypedAstNodeKind.FunctionDeclaration(fn) => {
        self.printlnv2("\"kind\": \"functionDeclaration\",")
        self.printv2("\"function\": ")
        self.printFunc(fn)
        printlnv2("")
      }
      TypedAstNodeKind.TypeDeclaration(struct) => {
        self.printlnv2("\"kind\": \"typeDeclaration\",")
        self.printv2("\"struct\": ")
        self.printStruct(struct: struct, abridged: false)
        printlnv2("")
      }
      TypedAstNodeKind.EnumDeclaration(enum_) => {
        self.printlnv2("\"kind\": \"enumDeclaration\",")
        self.printv2("\"enum\": ")
        self.printEnum(enum_: enum_, abridged: false)
        printlnv2("")
      }
      TypedAstNodeKind.Break => {
        self.printlnv2("\"kind\": \"break\"")
      }
      TypedAstNodeKind.Continue => {
        self.printlnv2("\"kind\": \"continue\"")
      }
      TypedAstNodeKind.Return(expr) => {
        self.printlnv2("\"kind\": \"return\",")
        self.printv2("\"expr\": ")
        self.opt(expr, n => self.printNode(n))
        printlnv2("")
      }
      TypedAstNodeKind.Placeholder => {
        if self.allowPlaceholderNodes {
          self.printlnv2("\"kind\": \"placeholder\"")
        } else {
          self.printlnv2("ERROR: There should never be a Placeholder node emitted")
        }
      }
    }

    self.indentDec()
    self.printv2("}")
  }

  func printVariable(self, variable: Variable) {
    printlnv2("{")
    self.indentInc()

    self.printv2("\"label\": ")
    printLabelAsJson(variable.label)
    printlnv2(",")

    self.printlnv2("\"mutable\": ${variable.mutable},")

    if variable.isCaptured {
      self.printlnv2("\"isCaptured\": true,")
    }

    self.printv2("\"type\": ")
    self.printType(variable.ty)
    printlnv2("")

    self.indentDec()
    self.printv2("}")
  }

  func printFunc(self, function: Function) {
    printlnv2("{")
    self.indentInc()

    self.printv2("\"label\": ")
    printLabelAsJson(function.label)
    printlnv2(",")

    self.printv2("\"scope\": ")
    self.printScope(function.scope)
    printlnv2(",")

    if function.isGenerated {
      self.printlnv2("\"isGenerated\": ${function.isGenerated},")
    }

    self.printv2("\"kind\": ")
    match function.kind {
      FunctionKind.Standalone => printv2("\"FunctionKind.Standalone\"")
      FunctionKind.InstanceMethod(_, isPublic) => {
        printv2("\"FunctionKind.InstanceMethod\"")
        printlnv2(",")
        self.printv2("\"isPublic\": $isPublic")
      }
      FunctionKind.StaticMethod(_, isPublic) => {
        printv2("\"FunctionKind.StaticMethod\"")
        printlnv2(",")
        self.printv2("\"isPublic\": $isPublic")
      }
    }
    printlnv2(",")

    self.printv2("\"typeParameters\": ")
    self.array(function.typeParams, typeParam => {
      printlnv2("{")
      self.indentInc()

      self.printv2("\"label\": ")
      printLabelAsJson(typeParam[1])
      printlnv2(",")

      self.printv2("\"type\": ")
      self.printType(typeParam[0])
      printlnv2("")

      self.indentDec()
      self.printv2("}")
    })
    printlnv2(",")

    self.printv2("\"parameters\": ")
    self.array(function.params, param => {
      printlnv2("{")
      self.indentInc()

      self.printv2("\"label\": ")
      printLabelAsJson(param.label)
      printlnv2(",")

      self.printv2("\"type\": ")
      self.printType(param.ty)
      printlnv2(",")

      self.printv2("\"defaultValue\": ")
      self.opt(param.defaultValue, v => self.printNode(v))
      printlnv2(",")

      self.printlnv2("\"isVariadic\": ${param.isVariadic}")

      self.indentDec()
      self.printv2("}")
    })
    printlnv2(",")

    self.printv2("\"returnType\": ")
    self.printType(function.returnType)
    printlnv2(",")

    if !function.captures.isEmpty() {
      self.printv2("\"captures\": ")
      self.array(function.captures, v => {
        self.printVariable(v)
      })
      printlnv2(",")
    }

    if !function.capturedClosures.isEmpty() {
      self.printv2("\"capturedClosures\": ")
      self.array(function.capturedClosures, fn => {
        printv2("\"${fn.label.name}\"")
      })
      printlnv2(",")
    }

    self.printv2("\"body\": ")
    self.array(function.body, n => self.printNode(n))
    printlnv2("")

    self.indentDec()
    self.printv2("}")
  }

  func printScope(self, scope: Scope) {
    printlnv2("{")
    self.indentInc()

    self.printlnv2("\"name\": \"${scope.name}\",")

    self.printv2("\"variables\": ")
    self.array(scope.variables, v => self.printVariable(v))
    printlnv2(",")

    self.printv2("\"functions\": ")
    self.array(scope.functions, f => self.printFunc(f))
    printlnv2(",")

    self.printv2("\"types\": ")
    self.array(scope.types, t => self.printType(t))
    printlnv2("")

    self.indentDec()
    self.printv2("}")
  }

  func printTypedIndexingNode(self, node: TypedIndexingNode) {
    printlnv2("{")
    self.indentInc()

    match node {
      TypedIndexingNode.ArrayLike(expr, indexingMode) => {
        self.printlnv2("\"kind\": \"arraylike\",")
        self.printv2("\"expr\": ")
        self.printNode(expr)
        printlnv2(",")

        match indexingMode {
          IndexingMode.Single(idxNode) => {
            self.printv2("\"index\": ")
            self.printNode(idxNode)
            printlnv2("")
          }
          IndexingMode.Range(startNode, endNode) => {
            self.printv2("\"startIndex\": ")
            if startNode |n| self.printNode(n) else printv2("null")
            printlnv2(",")
            self.printv2("\"endIndex\": ")
            if endNode |n| self.printNode(n) else printv2("null")
            printlnv2("")
          }
        }
      }
      TypedIndexingNode.Map(expr, idx) => {
        self.printlnv2("\"kind\": \"map\",")
        self.printv2("\"expr\": ")
        self.printNode(expr)
        printlnv2(",")
        self.printv2("\"index\": ")
        self.printNode(idx)
        printlnv2("")
      }
      TypedIndexingNode.Tuple(expr, idx) => {
        self.printlnv2("\"kind\": \"tuple\",")
        self.printlnv2("\"index\": $idx,")
        self.printv2("\"expr\": ")
        self.printNode(expr)
        printlnv2("")
      }
    }

    self.indentDec()
    self.printv2("}")
  }

  func indent(self) = printv2("  ".repeat(self.indentLevel))

  func indentInc(self) { self.indentLevel += 1 }

  func indentDec(self) { self.indentLevel -= 1 }

  func printv2(self, str: String) {
    self.indent()
    printv2(str)
  }

  func printlnv2(self, str: String) {
    self.indent()
    printlnv2(str)
  }

  func array<T>(self, arr: T[], fn: (T) => Unit) {
    if arr.isEmpty() {
      printv2("[]")
    } else {
      printlnv2("[")
      self.indentInc()

      for item, idx in arr {
        self.indent()
        fn(item)

        val comma = if idx != arr.length - 1 "," else ""
        printlnv2(comma)
      }

      self.indentDec()
      self.printv2("]")
    }
  }

  func opt<T>(self, v: T?, fn: (T) => Unit) {
    if v |v| {
      fn(v)
    } else {
      printv2("null")
    }
  }
}