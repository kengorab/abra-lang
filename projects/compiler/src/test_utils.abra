import Token, TokenKind, StringInterpolationChunk from "./lexer"
import Label, ImportKind, ParsedModule, AstNode, AstNodeKind, LiteralAstNode, IdentifierKind, IndexingMode, TypeIdentifier, AssignmentMode, BindingPattern, MatchCaseKind, DecoratorNode, EnumVariant from "./parser"

pub func printTokenAsJson(token: Token, indentLevelStart: Int, currentIndentLevel: Int) {
  val startIndent = "  ".repeat(indentLevelStart)
  val fieldsIndent = "  ".repeat(currentIndentLevel + 1)
  val endIndent = "  ".repeat(currentIndentLevel)

  printlnv2("$startIndent{\n$fieldsIndent\"position\": [${token.position.line}, ${token.position.col}],")
  printv2("$fieldsIndent\"kind\": ")
  printTokenKindAsJson(kind: token.kind, indentLevelStart: 0, currentIndentLevel: currentIndentLevel + 1)
  printv2("$endIndent}")
}

func printTokenKindAsJson(kind: TokenKind, indentLevelStart: Int, currentIndentLevel: Int) {
  val startIndent = "  ".repeat(indentLevelStart)
  val fieldsIndent = "  ".repeat(currentIndentLevel + 1)
  val endIndent = "  ".repeat(currentIndentLevel)

  printlnv2("$startIndent{")
  match kind {
    TokenKind.Int(value) => {
      printlnv2("$fieldsIndent\"name\": \"Int\",")
      printlnv2("$fieldsIndent\"value\": $value")
    }
    TokenKind.Float(value) => {
      printlnv2("$fieldsIndent\"name\": \"Float\",")
      printlnv2("$fieldsIndent\"value\": $value")
    }
    TokenKind.Bool(value) => {
      printlnv2("$fieldsIndent\"name\": \"Bool\",")
      printlnv2("$fieldsIndent\"value\": $value")
    }
    TokenKind.Char(intVal) => {
      printlnv2("$fieldsIndent\"name\": \"Char\",")
      printlnv2("$fieldsIndent\"value\": \"${intVal.hex()}\"")
    }
    TokenKind.String(value) => {
      printlnv2("$fieldsIndent\"name\": \"String\",")
      printlnv2("$fieldsIndent\"value\": \"$value\"")
    }
    TokenKind.StringInterpolation(chunks) => {
      printlnv2("$fieldsIndent\"name\": \"StringInterpolation\",")
      printlnv2("$fieldsIndent\"chunks\": [")
      for chunk, idx in chunks {
        match chunk {
          StringInterpolationChunk.String(pos, value) => {
            printTokenAsJson(Token(position: pos, kind: TokenKind.String(value)), indentLevelStart + currentIndentLevel + 2, currentIndentLevel + 2)
          }
          StringInterpolationChunk.Interpolation(tokens) => {
            printlnv2("$fieldsIndent  [")
            for token, idx in tokens {
              printTokenAsJson(token, indentLevelStart + currentIndentLevel + 3, currentIndentLevel + 3)

              val comma = if idx != tokens.length - 1 "," else ""
              printlnv2(comma)
            }
            printv2("$fieldsIndent  ]")
          }
        }
        val comma = if idx != chunks.length - 1 "," else ""
        printlnv2(comma)
      }
      printlnv2("$fieldsIndent]")
    }
    TokenKind.Ident(name) => {
      printlnv2("$fieldsIndent\"name\": \"Ident\",")
      printlnv2("$fieldsIndent\"value\": \"$name\"")
    }
    TokenKind.If => printlnv2("$fieldsIndent\"name\": \"If\"")
    TokenKind.Else => printlnv2("$fieldsIndent\"name\": \"Else\"")
    TokenKind.Val => printlnv2("$fieldsIndent\"name\": \"Val\"")
    TokenKind.Var => printlnv2("$fieldsIndent\"name\": \"Var\"")
    TokenKind.Func => printlnv2("$fieldsIndent\"name\": \"Func\"")
    TokenKind.Self => printlnv2("$fieldsIndent\"name\": \"Self\"")
    TokenKind.While => printlnv2("$fieldsIndent\"name\": \"While\"")
    TokenKind.Break => printlnv2("$fieldsIndent\"name\": \"Break\"")
    TokenKind.Continue => printlnv2("$fieldsIndent\"name\": \"Continue\"")
    TokenKind.For => printlnv2("$fieldsIndent\"name\": \"For\"")
    TokenKind.In => printlnv2("$fieldsIndent\"name\": \"In\"")
    TokenKind.Match => printlnv2("$fieldsIndent\"name\": \"Match\"")
    TokenKind.Type => printlnv2("$fieldsIndent\"name\": \"Type\"")
    TokenKind.Enum => printlnv2("$fieldsIndent\"name\": \"Enum\"")
    TokenKind.Decorator => printlnv2("$fieldsIndent\"name\": \"Decorator\"")
    TokenKind.Return => printlnv2("$fieldsIndent\"name\": \"Return\"")
    TokenKind.Readonly => printlnv2("$fieldsIndent\"name\": \"Readonly\"")
    TokenKind.Import => printlnv2("$fieldsIndent\"name\": \"Import\"")
    TokenKind.From => printlnv2("$fieldsIndent\"name\": \"From\"")
    TokenKind.As => printlnv2("$fieldsIndent\"name\": \"As\"")
    TokenKind.Try => printlnv2("$fieldsIndent\"name\": \"Try\"")
    TokenKind.None_ => printlnv2("$fieldsIndent\"name\": \"None\"")
    TokenKind.Pub => printlnv2("$fieldsIndent\"name\": \"Pub\"")
    TokenKind.Plus => printlnv2("$fieldsIndent\"name\": \"Plus\"")
    TokenKind.PlusEq => printlnv2("$fieldsIndent\"name\": \"PlusEq\"")
    TokenKind.Minus => printlnv2("$fieldsIndent\"name\": \"Minus\"")
    TokenKind.MinusEq => printlnv2("$fieldsIndent\"name\": \"MinusEq\"")
    TokenKind.Star => printlnv2("$fieldsIndent\"name\": \"Star\"")
    TokenKind.StarEq => printlnv2("$fieldsIndent\"name\": \"StarEq\"")
    TokenKind.StarStar => printlnv2("$fieldsIndent\"name\": \"StarStar\"")
    TokenKind.Slash => printlnv2("$fieldsIndent\"name\": \"Slash\"")
    TokenKind.SlashEq => printlnv2("$fieldsIndent\"name\": \"SlashEq\"")
    TokenKind.Percent => printlnv2("$fieldsIndent\"name\": \"Percent\"")
    TokenKind.PercentEq => printlnv2("$fieldsIndent\"name\": \"PercentEq\"")
    TokenKind.LT => printlnv2("$fieldsIndent\"name\": \"LT\"")
    TokenKind.LTE => printlnv2("$fieldsIndent\"name\": \"LTE\"")
    TokenKind.GT => printlnv2("$fieldsIndent\"name\": \"GT\"")
    TokenKind.GTE => printlnv2("$fieldsIndent\"name\": \"GTE\"")
    TokenKind.Bang => printlnv2("$fieldsIndent\"name\": \"Bang\"")
    TokenKind.Eq => printlnv2("$fieldsIndent\"name\": \"Assign\"")
    TokenKind.EqEq => printlnv2("$fieldsIndent\"name\": \"Eq\"")
    TokenKind.Neq => printlnv2("$fieldsIndent\"name\": \"Neq\"")
    TokenKind.Arrow => printlnv2("$fieldsIndent\"name\": \"Arrow\"")
    TokenKind.Dot => printlnv2("$fieldsIndent\"name\": \"Dot\"")
    TokenKind.Or => printlnv2("$fieldsIndent\"name\": \"Or\"")
    TokenKind.OrEq => printlnv2("$fieldsIndent\"name\": \"OrEq\"")
    TokenKind.And => printlnv2("$fieldsIndent\"name\": \"And\"")
    TokenKind.AndEq => printlnv2("$fieldsIndent\"name\": \"AndEq\"")
    TokenKind.Caret => printlnv2("$fieldsIndent\"name\": \"Caret\"")
    TokenKind.LParen => printlnv2("$fieldsIndent\"name\": \"LParen\"")
    TokenKind.RParen => printlnv2("$fieldsIndent\"name\": \"RParen\"")
    TokenKind.LBrack => printlnv2("$fieldsIndent\"name\": \"LBrack\"")
    TokenKind.RBrack => printlnv2("$fieldsIndent\"name\": \"RBrack\"")
    TokenKind.LBrace => printlnv2("$fieldsIndent\"name\": \"LBrace\"")
    TokenKind.RBrace => printlnv2("$fieldsIndent\"name\": \"RBrace\"")
    TokenKind.Pipe => printlnv2("$fieldsIndent\"name\": \"Pipe\"")
    TokenKind.Comma => printlnv2("$fieldsIndent\"name\": \"Comma\"")
    TokenKind.Colon => printlnv2("$fieldsIndent\"name\": \"Colon\"")
    TokenKind.Question => printlnv2("$fieldsIndent\"name\": \"Question\"")
    TokenKind.Elvis => printlnv2("$fieldsIndent\"name\": \"Elvis\"")
    TokenKind.ElvisEq => printlnv2("$fieldsIndent\"name\": \"ElvisEq\"")
    TokenKind.QuestionDot => printlnv2("$fieldsIndent\"name\": \"QuestionDot\"")
    TokenKind.HashBrace => printlnv2("$fieldsIndent\"name\": \"LBraceHash\"")
    TokenKind.At => printlnv2("$fieldsIndent\"name\": \"At\"")
  }
  printlnv2("$endIndent}")
}

pub func printParsedModuleAsJson(module: ParsedModule) {
  printlnv2("{")
  if module.imports.isEmpty() {
    printlnv2("  \"imports\": [],")
  } else {
    printlnv2("  \"imports\": [")
    for importNode, idx in module.imports {
      printlnv2("    {")
      printv2("      \"token\": ")
      printTokenAsJson(importNode.token, 0, 3)
      printv2(",\n      \"moduleName\": ")
      printLabelAsJson(importNode.moduleName)
      printlnv2(",\n      \"importKind\": {")
      match importNode.kind {
        ImportKind.Alias(alias) => {
          printlnv2("        \"kind\": \"alias\",")
          printv2("        \"alias\": ")
          printLabelAsJson(alias)
          printlnv2("")
        }
        ImportKind.List(names) => {
          printlnv2("        \"kind\": \"list\",")
          printlnv2("        \"names\": [")
          for name, idx in names {
            printv2("          ")
            printLabelAsJson(name)
            val comma = if idx != names.length - 1 "," else ""
            printlnv2(comma)
          }
          printlnv2("        ]")
        }
      }
      printlnv2("      }")
      val comma = if idx != module.imports.length - 1 "," else ""
      printlnv2("    }$comma")
    }
    printlnv2("  ],")
  }
  if module.nodes.isEmpty() {
    printlnv2("  \"nodes\": []")
  } else {
    printlnv2("  \"nodes\": [")
    for node, idx in module.nodes {
      printAstNodeAsJson(node, 2, 2)
      val comma = if idx != module.nodes.length - 1 "," else ""
      printlnv2(comma)
    }
    printlnv2("  ]")
  }
  printlnv2("}")
}

pub func printLabelAsJson(label: Label) {
  printv2("{ \"name\": \"${label.name}\", \"position\": [${label.position.line}, ${label.position.col}] }")
}

func printTypeIdentifierAsJson(typeIdentifier: TypeIdentifier, indentLevelStart: Int, currentIndentLevel: Int) {
  val startIndent = "  ".repeat(indentLevelStart)
  val fieldsIndent = "  ".repeat(currentIndentLevel + 1)
  val endIndent = "  ".repeat(currentIndentLevel)

  printv2("$startIndent{\n$fieldsIndent\"kind\": ")
  match typeIdentifier {
    TypeIdentifier.Normal(label, typeArguments, path) => {
      printlnv2("\"normal\",")
      if !path.isEmpty() {
        printlnv2("$fieldsIndent\"path\": [")
        for seg, idx in path {
          printv2("$fieldsIndent  ")
          printLabelAsJson(seg)
          val comma = if idx != path.length - 1 "," else ""
          printlnv2(comma)
        }
        printlnv2("$fieldsIndent],")
      }
      printv2("$fieldsIndent\"label\": ")
      printLabelAsJson(label)
      if typeArguments.isEmpty() {
        printlnv2(",\n$fieldsIndent\"typeArguments\": []")
      } else {
        printlnv2(",\n$fieldsIndent\"typeArguments\": [")
        for arg, idx in typeArguments {
          printTypeIdentifierAsJson(arg, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != typeArguments.length - 1 "," else ""
          printlnv2(comma)
        }
        printlnv2("$fieldsIndent]")
      }
    }
    TypeIdentifier.Array(inner) => {
      printv2("\"array\",\n$fieldsIndent\"inner\": ")
      printTypeIdentifierAsJson(inner, 0, currentIndentLevel + 1)
      printlnv2("")
    }
    TypeIdentifier.Option(inner) => {
      printv2("\"option\",\n$fieldsIndent\"inner\": ")
      printTypeIdentifierAsJson(inner, 0, currentIndentLevel + 1)
      printlnv2("")
    }
    TypeIdentifier.Tuple(typeArguments) => {
      printlnv2("\"tuple\",\n$fieldsIndent\"typeArguments\": [")
      for arg, idx in typeArguments {
        printTypeIdentifierAsJson(arg, currentIndentLevel + 2, currentIndentLevel + 2)
        val comma = if idx != typeArguments.length - 1 "," else ""
        printlnv2(comma)
      }
      printlnv2("$fieldsIndent]")
    }
    TypeIdentifier.Function(argTypes, retType) => {
      printlnv2("\"function\",")
      if argTypes.isEmpty() {
        printlnv2("$fieldsIndent\"argumentTypes\": [],")
      } else {
        printlnv2("$fieldsIndent\"argumentTypes\": [")
        for arg, idx in argTypes {
          printTypeIdentifierAsJson(arg, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != argTypes.length - 1 "," else ""
          printlnv2(comma)
        }
        printv2("$fieldsIndent],\n")
      }
      printv2("$fieldsIndent\"returnType\": ")
      printTypeIdentifierAsJson(retType, 0, currentIndentLevel + 1)
      printlnv2("")
    }
  }
  printv2("$endIndent}")
}

func printDecoratorNodeAsJson(dec: DecoratorNode, indentLevelStart: Int, currentIndentLevel: Int) {
  val startIndent = "  ".repeat(indentLevelStart)
  val fieldsIndent = "  ".repeat(currentIndentLevel + 1)
  val endIndent = "  ".repeat(currentIndentLevel)

  printv2("$startIndent{\n$fieldsIndent\"name\": ")
  printLabelAsJson(dec.name)

  if dec.arguments.isEmpty() {
    printlnv2(",\n$fieldsIndent\"arguments\": []")
  } else {
    printlnv2(",\n$fieldsIndent\"arguments\": [")
    val pathIndent = "  ".repeat(currentIndentLevel + 2)
    val pathsIndent = "  ".repeat(currentIndentLevel + 3)
    for arg, idx in dec.arguments {
      printv2("$pathIndent{\n$pathsIndent\"label\": ")
      if arg.label |label| {
        printLabelAsJson(label)
        printlnv2(",")
      } else {
        printlnv2("null,")
      }
      printv2("$pathsIndent\"value\": ")
      printAstNodeAsJson(arg.value, 0, currentIndentLevel + 3)
      val comma = if idx != dec.arguments.length - 1 "," else ""
      printlnv2("\n$pathIndent}$comma")
    }
    printlnv2("$fieldsIndent]")
  }

  printv2("$endIndent}")
}

pub func printBindingPatternAsJson(bindingPattern: BindingPattern, indentLevelStart: Int, currentIndentLevel: Int) {
  val startIndent = "  ".repeat(indentLevelStart)
  val fieldsIndent = "  ".repeat(currentIndentLevel + 1)
  val endIndent = "  ".repeat(currentIndentLevel)

  printv2("$startIndent{\n$fieldsIndent\"kind\": ")
  match bindingPattern {
    BindingPattern.Variable(label) => {
      printv2("\"variable\",\n$fieldsIndent\"label\": ")
      printLabelAsJson(label)
    }
    BindingPattern.Tuple(_, patterns) => {
      printlnv2("\"tuple\",\n$fieldsIndent\"patterns\": [")
      for pat, idx in patterns {
        printBindingPatternAsJson(pat, currentIndentLevel + 2, currentIndentLevel + 2)
        if idx != patterns.length - 1 {
          printlnv2(",")
        }
      }
      printv2("\n$fieldsIndent]")
    }
  }
  printv2("\n$endIndent}")
}

func printAstNodeAsJson(node: AstNode, indentLevelStart: Int, currentIndentLevel: Int) {
  val startIndent = "  ".repeat(indentLevelStart)
  val fieldsIndent = "  ".repeat(currentIndentLevel + 1)
  val endIndent = "  ".repeat(currentIndentLevel)

  printv2("$startIndent{\n$fieldsIndent\"token\": ")
  printTokenAsJson(token: node.token, indentLevelStart: 0, currentIndentLevel: currentIndentLevel + 1)
  printv2(",\n$fieldsIndent\"kind\": ")
  printAstNodeKindAsJson(kind: node.kind, indentLevelStart: 0, currentIndentLevel: currentIndentLevel + 1)
  printv2("\n$endIndent}")
}

func printAstNodeKindAsJson(kind: AstNodeKind, indentLevelStart: Int, currentIndentLevel: Int) {
  val startIndent = "  ".repeat(indentLevelStart)
  val fieldsIndent = "  ".repeat(currentIndentLevel + 1)
  val endIndent = "  ".repeat(currentIndentLevel)

  printlnv2("$startIndent{")
  match kind {
    AstNodeKind.Literal(literal) => {
      val (kind, value) = match literal {
        LiteralAstNode.Int(value) => ("int", value.toString())
        LiteralAstNode.Float(value) => ("float", value.toString())
        LiteralAstNode.Bool(value) => ("bool", value.toString())
        LiteralAstNode.Char(value) => {
          ("char", "\"${value.hex()}\"")
        }
        LiteralAstNode.String(value) => ("string", "\"$value\"")
      }

      printlnv2("$fieldsIndent\"name\": \"literal\",")
      printlnv2("$fieldsIndent\"type\": \"$kind\",")
      printlnv2("$fieldsIndent\"value\": $value")
    }
    AstNodeKind.StringInterpolation(exprs) => {
      printlnv2("$fieldsIndent\"name\": \"stringInterpolation\",")
      if exprs.isEmpty() {
        printlnv2("$fieldsIndent\"exprs\": []")
      } else {
        printlnv2("$fieldsIndent\"exprs\": [")
        for item, idx in exprs {
          printAstNodeAsJson(item, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != exprs.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.Unary(unaryNode) => {
      printlnv2("$fieldsIndent\"name\": \"unary\",")
      printlnv2("$fieldsIndent\"op\": \"${unaryNode.op}\",")
      printv2("$fieldsIndent\"expr\": ")
      printAstNodeAsJson(unaryNode.expr, 0, currentIndentLevel + 1)
      printlnv2("")
    }
    AstNodeKind.Binary(binaryNode) => {
      printlnv2("$fieldsIndent\"name\": \"binary\",")
      printlnv2("$fieldsIndent\"op\": \"${binaryNode.op}\",")
      printv2("$fieldsIndent\"left\": ")
      printAstNodeAsJson(binaryNode.left, 0, currentIndentLevel + 1)
      printv2(",\n$fieldsIndent\"right\": ")
      printAstNodeAsJson(binaryNode.right, 0, currentIndentLevel + 1)
      printlnv2("")
    }
    AstNodeKind.Grouped(inner) => {
      printlnv2("$fieldsIndent\"name\": \"grouped\",")
      printv2("$fieldsIndent\"inner\": ")
      printAstNodeAsJson(inner, 0, currentIndentLevel + 1)
      printlnv2("")
    }
    AstNodeKind.Identifier(kind) => {
      printlnv2("$fieldsIndent\"name\": \"identifier\",")
      printv2("$fieldsIndent\"ident\": ")
      match kind {
        IdentifierKind.Named(name) => printlnv2("\"$name\"")
        IdentifierKind.None_ => printlnv2("\"None\"")
        IdentifierKind.Self => printlnv2("\"self\"")
        IdentifierKind.Discard => printlnv2("\"_\"")
      }
    }
    AstNodeKind.Accessor(accessorNode) => {
      printlnv2("$fieldsIndent\"name\": \"accessor\",")
      printv2("$fieldsIndent\"root\": ")
      printAstNodeAsJson(accessorNode.root, 0, currentIndentLevel + 1)
      printlnv2(",\n$fieldsIndent\"path\": [")
      val pathIndent = "  ".repeat(currentIndentLevel + 2)
      val pathsIndent = "  ".repeat(currentIndentLevel + 3)
      for (dotToken, label), idx in accessorNode.path {
        printv2("$pathIndent{\n$pathsIndent\"dotToken\": ")
        printTokenAsJson(dotToken, 0, currentIndentLevel + 3)
        printlnv2(",\n$pathsIndent\"ident\": \"${label.name}\",")
        printlnv2("$pathsIndent\"position\": [${label.position.line}, ${label.position.col}]")
        val comma = if idx != accessorNode.path.length - 1 "," else ""
        printlnv2("$pathIndent}$comma")
      }
      printlnv2("$fieldsIndent]")
    }
    AstNodeKind.Invocation(invocationNode) => {
      printlnv2("$fieldsIndent\"name\": \"invocation\",")
      printv2("$fieldsIndent\"invokee\": ")
      printAstNodeAsJson(invocationNode.invokee, 0, currentIndentLevel + 1)
      if invocationNode.typeArguments.isEmpty() {
        printlnv2(",\n$fieldsIndent\"typeArguments\": [],")
      } else {
        printlnv2(",\n$fieldsIndent\"typeArguments\": [")
        for typeArg, idx in invocationNode.typeArguments {
          printTypeIdentifierAsJson(typeArg, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != invocationNode.typeArguments.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }

      if invocationNode.arguments.isEmpty() {
        printlnv2("$fieldsIndent\"arguments\": []")
      } else {
        printlnv2("$fieldsIndent\"arguments\": [")
        val pathIndent = "  ".repeat(currentIndentLevel + 2)
        val pathsIndent = "  ".repeat(currentIndentLevel + 3)
        for arg, idx in invocationNode.arguments {
          printv2("$pathIndent{\n$pathsIndent\"label\": ")
          if arg.label |label| {
            printLabelAsJson(label)
            printlnv2(",")
          } else {
            printlnv2("null,")
          }
          printv2("$pathsIndent\"value\": ")
          printAstNodeAsJson(arg.value, 0, currentIndentLevel + 3)
          val comma = if idx != invocationNode.arguments.length - 1 "," else ""
          printlnv2("\n$pathIndent}$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.Array(items) => {
      printlnv2("$fieldsIndent\"name\": \"array\",")
      if items.isEmpty() {
        printlnv2("$fieldsIndent\"items\": []")
      } else {
        printlnv2("$fieldsIndent\"items\": [")
        for item, idx in items {
          printAstNodeAsJson(item, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != items.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.Set(items) => {
      printlnv2("$fieldsIndent\"name\": \"set\",")
      if items.isEmpty() {
        printlnv2("$fieldsIndent\"items\": []")
      } else {
        printlnv2("$fieldsIndent\"items\": [")
        for item, idx in items {
          printAstNodeAsJson(item, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != items.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.Map(items) => {
      printlnv2("$fieldsIndent\"name\": \"map\",")
      if items.isEmpty() {
        printlnv2("$fieldsIndent\"items\": []")
      } else {
        printlnv2("$fieldsIndent\"items\": [")
        for (key, value), idx in items {
          printlnv2("$fieldsIndent  {")
          printv2("$fieldsIndent    \"key\": ")
          printAstNodeAsJson(key, 0, currentIndentLevel + 3)
          printv2(",\n$fieldsIndent    \"value\": ")
          printAstNodeAsJson(value, 0, currentIndentLevel + 3)
          val comma = if idx != items.length - 1 "," else ""
          printlnv2("\n$fieldsIndent  }$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.Tuple(items) => {
      printlnv2("$fieldsIndent\"name\": \"tuple\",")
      if items.isEmpty() {
        printlnv2("$fieldsIndent\"items\": []")
      } else {
        printlnv2("$fieldsIndent\"items\": [")
        for item, idx in items {
          printAstNodeAsJson(item, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != items.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.Indexing(expr, indexMode) => {
      printlnv2("$fieldsIndent\"name\": \"indexing\",")
      printv2("$fieldsIndent\"expr\": ")
      printAstNodeAsJson(expr, 0, currentIndentLevel + 1)
      printlnv2(",\n$fieldsIndent\"index\": {")
      match indexMode {
        IndexingMode.Single(item) => {
          printlnv2("$fieldsIndent  \"indexKind\": \"single\",")
          printv2("$fieldsIndent  \"value\": ")
          printAstNodeAsJson(item, 0, currentIndentLevel + 2)
        }
        IndexingMode.Range(start, end) => {
          printlnv2("$fieldsIndent  \"indexKind\": \"range\",")
          if start |start| {
            printv2("$fieldsIndent  \"start\": ")
            printAstNodeAsJson(start, 0, currentIndentLevel + 2)
            printlnv2(",")
          } else {
            printlnv2("$fieldsIndent  \"start\": null,")
          }
          if end |end| {
            printv2("$fieldsIndent  \"end\": ")
            printAstNodeAsJson(end, 0, currentIndentLevel + 2)
          } else {
            printv2("$fieldsIndent  \"end\": null")
          }
        }
      }
      printlnv2("\n$fieldsIndent}")
    }
    AstNodeKind.Lambda(node) => {
      printlnv2("$fieldsIndent\"name\": \"lambda\",")
      if node.params.isEmpty() {
        printlnv2("$fieldsIndent\"params\": [],")
      } else {
        printlnv2("$fieldsIndent\"params\": [")
        for p, idx in node.params {
          printlnv2("$fieldsIndent  {")
          printv2("$fieldsIndent    \"label\": ")
          printLabelAsJson(p.label)
          printlnv2(",\n$fieldsIndent    \"isVariadic\": ${p.isVariadic},")
          printv2("$fieldsIndent    \"typeAnnotation\": ")
          if p.typeAnnotation |ann| {
            printTypeIdentifierAsJson(ann, 0, currentIndentLevel + 3)
          } else {
            printv2("null")
          }
          printv2(",\n$fieldsIndent    \"defaultValue\": ")
          if p.defaultValue |defaultValue| {
            printAstNodeAsJson(defaultValue, 0, currentIndentLevel + 3)
          } else {
            printv2("null")
          }
          val comma = if idx != node.params.length - 1 "," else ""
          printlnv2("\n$fieldsIndent  }$comma")
        }
        printlnv2("$fieldsIndent],")
      }
      if node.body.isEmpty() {
        printlnv2("$fieldsIndent\"body\": []")
      } else {
        printlnv2("$fieldsIndent\"body\": [")
        for n, idx in node.body {
          printAstNodeAsJson(n, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.body.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.Assignment(expr, op, mode) => {
      printlnv2("$fieldsIndent\"name\": \"assignment\",")
      printv2("$fieldsIndent\"expr\": ")
      printAstNodeAsJson(expr, 0, currentIndentLevel + 1)
      printlnv2(",\n$fieldsIndent\"op\": \"$op\",")
      printv2("$fieldsIndent\"mode\": ")
      match mode {
        AssignmentMode.Variable(name, _) => {
          printlnv2("{\n$fieldsIndent  \"mode\": \"variable\",")
          printlnv2("$fieldsIndent  \"variable\": \"$name\"")
          printlnv2("$fieldsIndent}")
        }
        AssignmentMode.Indexing(expr, indexExpr) => {
          printlnv2("{\n$fieldsIndent  \"mode\": \"indexing\",")
          printv2("$fieldsIndent  \"expr\": ")
          printAstNodeAsJson(expr, 0, currentIndentLevel + 2)
          printlnv2(",")
          printv2("$fieldsIndent  \"indexExpr\": ")
          printAstNodeAsJson(indexExpr, 0, currentIndentLevel + 2)
          printlnv2("\n$fieldsIndent}")
        }
        AssignmentMode.Accessor(node) => {
          printAstNodeKindAsJson(AstNodeKind.Accessor(node), 0, currentIndentLevel + 1)
          printlnv2("")
        }
      }
    }
    AstNodeKind.If(condition, conditionBinding, ifBlock, elseBlock) => {
      printlnv2("$fieldsIndent\"name\": \"if\",")
      printv2("$fieldsIndent\"condition\": ")
      printAstNodeAsJson(condition, 0, currentIndentLevel + 1)
      if conditionBinding |pat| {
        printv2(",\n$fieldsIndent\"conditionBinding\": ")
        printBindingPatternAsJson(pat, 0, currentIndentLevel + 1)
      } else {
        printv2(",\n$fieldsIndent\"conditionBinding\": null")
      }
      if ifBlock.isEmpty() {
        printlnv2(",\n$fieldsIndent\"ifBlock\": [],")
      } else {
        printlnv2(",\n$fieldsIndent\"ifBlock\": [")
        for node, idx in ifBlock {
          printAstNodeAsJson(node, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != ifBlock.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }
      if elseBlock |block| {
        if block.isEmpty() {
          printlnv2("$fieldsIndent\"elseBlock\": []")
        } else {
          printlnv2("$fieldsIndent\"elseBlock\": [")
          for node, idx in block {
            printAstNodeAsJson(node, currentIndentLevel + 2, currentIndentLevel + 2)
            val comma = if idx != block.length - 1 "," else ""
            printlnv2("$comma")
          }
          printlnv2("$fieldsIndent]")
        }
      } else {
        printlnv2("$fieldsIndent\"elseBlock\": null")
      }
    }
    AstNodeKind.Match(expr, cases) => {
      printlnv2("$fieldsIndent\"name\": \"match\",")
      printv2("$fieldsIndent\"expr\": ")
      printAstNodeAsJson(expr, 0, currentIndentLevel + 1)
      if cases.isEmpty() {
        printlnv2(",\n$fieldsIndent\"cases\": [],")
      } else {
        printlnv2(",\n$fieldsIndent\"cases\": [")
        for case, idx in cases {
          printlnv2("$fieldsIndent  {")
          printlnv2("$fieldsIndent    \"caseKind\": {")
          match case.kind {
            MatchCaseKind.None_ => {
              printlnv2("$fieldsIndent      \"kind\": \"none\"")
            }
            MatchCaseKind.Literal(literal) => {
              printlnv2("$fieldsIndent      \"kind\": \"literal\",")
              val (kind, value) = match literal {
                LiteralAstNode.Int(value) => ("int", value.toString())
                LiteralAstNode.Float(value) => ("float", value.toString())
                LiteralAstNode.Bool(value) => ("bool", value.toString())
                LiteralAstNode.Char(value) => {
                  ("char", "\"${value.hex()}\"")
                }
                LiteralAstNode.String(value) => ("string", "\"$value\"")
              }

              printlnv2("$fieldsIndent      \"type\": \"$kind\",")
              printlnv2("$fieldsIndent      \"value\": $value")
            }
            MatchCaseKind.Type(path, last, args) => {
              printlnv2("$fieldsIndent      \"kind\": \"type\",")
              printlnv2("$fieldsIndent      \"path\": [")
              val fullPath = path.concat([last])
              for label, idx in fullPath {
                printv2("$fieldsIndent        ")
                printLabelAsJson(label)
                val comma = if idx != fullPath.length - 1 "," else ""
                printlnv2("$comma")
              }
              printlnv2("$fieldsIndent      ],")
              printlnv2("$fieldsIndent      \"arguments\": [")
              for label, idx in args {
                printv2("$fieldsIndent        ")
                printLabelAsJson(label)
                val comma = if idx != args.length - 1 "," else ""
                printlnv2("$comma")
              }
              printlnv2("$fieldsIndent      ]")
            }
            MatchCaseKind.Else => {
              printlnv2("$fieldsIndent      \"kind\": \"else\"")
            }
          }
          printlnv2("$fieldsIndent    },")
          if case.binding |binding| {
            printv2("$fieldsIndent    \"caseBinding\": ")
            printLabelAsJson(binding)
            printlnv2(",")
          } else {
            printlnv2("$fieldsIndent    \"caseBinding\": null,")
          }
          if case.body.isEmpty() {
            printlnv2("$fieldsIndent    \"body\": []")
          } else {
            printlnv2("$fieldsIndent    \"body\": [")
            for node, idx in case.body {
              printAstNodeAsJson(node, currentIndentLevel + 4, currentIndentLevel + 4)
              val comma = if idx != case.body.length - 1 "," else ""
              printlnv2("$comma")
            }
            printlnv2("$fieldsIndent    ]")
          }
          val comma = if idx != cases.length - 1 "," else ""
          printlnv2("$fieldsIndent  }$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.Try(expr, elseClause) => {
      printlnv2("$fieldsIndent\"name\": \"try\",")
      printv2("$fieldsIndent\"expr\": ")
      printAstNodeAsJson(expr, 0, currentIndentLevel + 1)
      if elseClause |(_, bindingPattern, block)| {
        if bindingPattern |pat| {
          printv2(",\n$fieldsIndent\"elseBindingPattern\": ")
          printBindingPatternAsJson(pat, 0, currentIndentLevel + 1)
        } else {
          printv2(",\n$fieldsIndent\"elseBindingPattern\": null")
        }

        if block.isEmpty() {
          printlnv2(",\n$fieldsIndent\"elseBlock\": []")
        } else {
          printlnv2(",\n$fieldsIndent\"elseBlock\": [")
          for node, idx in block {
            printAstNodeAsJson(node, currentIndentLevel + 2, currentIndentLevel + 2)
            val comma = if idx != block.length - 1 "," else ""
            printlnv2("$comma")
          }
          printv2("$fieldsIndent]")
        }
      }
      printlnv2("")
    }
    AstNodeKind.While(condition, conditionBinding, block) => {
      printlnv2("$fieldsIndent\"name\": \"while\",")
      printv2("$fieldsIndent\"condition\": ")
      printAstNodeAsJson(condition, 0, currentIndentLevel + 1)
      if conditionBinding |pat| {
        printv2(",\n$fieldsIndent\"conditionBinding\": ")
        printBindingPatternAsJson(pat, 0, currentIndentLevel + 1)
      } else {
        printv2(",\n$fieldsIndent\"conditionBinding\": null")
      }
      if block.isEmpty() {
        printlnv2(",\n$fieldsIndent\"block\": []")
      } else {
        printlnv2(",\n$fieldsIndent\"block\": [")
        for node, idx in block {
          printAstNodeAsJson(node, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != block.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.For(itemPattern, indexPattern, iterator, block) => {
      printlnv2("$fieldsIndent\"name\": \"for\",")
      printv2("$fieldsIndent\"itemPattern\": ")
      printBindingPatternAsJson(itemPattern, 0, currentIndentLevel + 1)
      if indexPattern |pat| {
        printv2(",\n$fieldsIndent\"indexPattern\": ")
        printBindingPatternAsJson(pat, 0, currentIndentLevel + 1)
      } else {
        printv2(",\n$fieldsIndent\"indexPattern\": null")
      }
      printv2(",\n$fieldsIndent\"iterator\": ")
      printAstNodeAsJson(iterator, 0, currentIndentLevel + 1)
      if block.isEmpty() {
        printlnv2(",\n$fieldsIndent\"block\": []")
      } else {
        printlnv2(",\n$fieldsIndent\"block\": [")
        for node, idx in block {
          printAstNodeAsJson(node, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != block.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.BindingDeclaration(value) => {
      printlnv2("$fieldsIndent\"name\": \"bindingDecl\",")
      if value.decorators.isEmpty() {
        printlnv2("$fieldsIndent\"decorators\": [],")
      } else {
        printlnv2("$fieldsIndent\"decorators\": [")
        for dec, idx in value.decorators {
          printDecoratorNodeAsJson(dec, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != value.decorators.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }
      if value.pubToken |token| {
        printv2("$fieldsIndent\"pubToken\": ")
        printTokenAsJson(token, 0, currentIndentLevel + 1)
        printlnv2(",")
      } else {
        printlnv2("$fieldsIndent\"pubToken\": null,")
      }
      printv2("$fieldsIndent\"bindingPattern\": ")
      printBindingPatternAsJson(value.bindingPattern, 0, currentIndentLevel + 1)
      printlnv2(",")
      if value.typeAnnotation |ann| {
        printv2("$fieldsIndent\"typeAnnotation\": ")
        printTypeIdentifierAsJson(ann, 0, currentIndentLevel + 1)
      } else {
        printv2("$fieldsIndent\"typeAnnotation\": null")
      }
      if value.expr |expr| {
        printv2(",\n$fieldsIndent\"expr\": ")
        printAstNodeAsJson(expr, 0, currentIndentLevel + 1)
      } else {
        printv2(",\n$fieldsIndent\"expr\": null")
      }
      printv2("\n")
    }
    AstNodeKind.FunctionDeclaration(node) => {
      printlnv2("$fieldsIndent\"name\": \"function\",")
      if node.decorators.isEmpty() {
        printlnv2("$fieldsIndent\"decorators\": [],")
      } else {
        printlnv2("$fieldsIndent\"decorators\": [")
        for dec, idx in node.decorators {
          printDecoratorNodeAsJson(dec, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.decorators.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }
      if node.pubToken |token| {
        printv2("$fieldsIndent\"pubToken\": ")
        printTokenAsJson(token, 0, currentIndentLevel + 1)
        printlnv2(",")
      } else {
        printlnv2("$fieldsIndent\"pubToken\": null,")
      }
      printv2("$fieldsIndent\"ident\": ")
      printLabelAsJson(node.name)
      if node.typeParams.isEmpty() {
        printlnv2(",\n$fieldsIndent\"typeParams\": [],")
      } else {
        printlnv2(",\n$fieldsIndent\"typeParams\": [")
        for label, idx in node.typeParams {
          printv2("$fieldsIndent  ")
          printLabelAsJson(label)
          val comma = if idx != node.typeParams.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }
      if node.params.isEmpty() {
        printlnv2("$fieldsIndent\"params\": [],")
      } else {
        printlnv2("$fieldsIndent\"params\": [")
        for p, idx in node.params {
          printlnv2("$fieldsIndent  {")
          printv2("$fieldsIndent    \"label\": ")
          printLabelAsJson(p.label)
          printlnv2(",\n$fieldsIndent    \"isVariadic\": ${p.isVariadic},")
          printv2("$fieldsIndent    \"typeAnnotation\": ")
          if p.typeAnnotation |ann| {
            printTypeIdentifierAsJson(ann, 0, currentIndentLevel + 3)
          } else {
            printv2("null")
          }
          printv2(",\n$fieldsIndent    \"defaultValue\": ")
          if p.defaultValue |defaultValue| {
            printAstNodeAsJson(defaultValue, 0, currentIndentLevel + 3)
          } else {
            printv2("null")
          }
          val comma = if idx != node.params.length - 1 "," else ""
          printlnv2("\n$fieldsIndent  }$comma")
        }
        printlnv2("$fieldsIndent],")
      }
      if node.body.isEmpty() {
        printlnv2("$fieldsIndent\"body\": []")
      } else {
        printlnv2("$fieldsIndent\"body\": [")
        for n, idx in node.body {
          printAstNodeAsJson(n, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.body.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.TypeDeclaration(node) => {
      printlnv2("$fieldsIndent\"name\": \"typeDeclaration\",")
      if node.decorators.isEmpty() {
        printlnv2("$fieldsIndent\"decorators\": [],")
      } else {
        printlnv2("$fieldsIndent\"decorators\": [")
        for dec, idx in node.decorators {
          printDecoratorNodeAsJson(dec, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.decorators.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }
      if node.pubToken |token| {
        printv2("$fieldsIndent\"pubToken\": ")
        printTokenAsJson(token, 0, currentIndentLevel + 1)
        printlnv2(",")
      } else {
        printlnv2("$fieldsIndent\"pubToken\": null,")
      }
      if node.isDecorator {
        printlnv2("$fieldsIndent\"isDecorator\": true,")
      }
      printv2("$fieldsIndent\"typeName\": ")
      printLabelAsJson(node.name)

      if node.typeParams.isEmpty() {
        printlnv2(",\n$fieldsIndent\"typeParams\": [],")
      } else {
        printlnv2(",\n$fieldsIndent\"typeParams\": [")
        for label, idx in node.typeParams {
          printv2("$fieldsIndent  ")
          printLabelAsJson(label)
          val comma = if idx != node.typeParams.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }

      if node.fields.isEmpty() {
        printlnv2("$fieldsIndent\"fields\": [],")
      } else {
        printlnv2("$fieldsIndent\"fields\": [")
        for f, idx in node.fields {
          printlnv2("$fieldsIndent  {")
          printv2("$fieldsIndent    \"label\": ")
          printLabelAsJson(f.name)
          if f.pubToken |token| {
            printv2(",\n$fieldsIndent    \"pubToken\": ")
            printTokenAsJson(token, 0, currentIndentLevel + 3)
          }
          printv2(",\n$fieldsIndent    \"typeAnnotation\": ")
          printTypeIdentifierAsJson(f.typeAnnotation, 0, currentIndentLevel + 3)
          printv2(",\n$fieldsIndent    \"initializer\": ")
          if f.initializer |initializer| {
            printAstNodeAsJson(initializer, 0, currentIndentLevel + 3)
          } else {
            printv2("null")
          }
          val comma = if idx != node.fields.length - 1 "," else ""
          printlnv2("\n$fieldsIndent  }$comma")
        }
        printlnv2("$fieldsIndent],")
      }

      if node.methods.isEmpty() {
        printlnv2("$fieldsIndent\"methods\": [],")
      } else {
        printlnv2("$fieldsIndent\"methods\": [")
        for method, idx in node.methods {
          printAstNodeKindAsJson(AstNodeKind.FunctionDeclaration(method), currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.methods.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }

      if node.types.isEmpty() {
        printlnv2("$fieldsIndent\"nestedTypes\": [],")
      } else {
        printlnv2("$fieldsIndent\"nestedTypes\": [")
        for nestedType, idx in node.types {
          printAstNodeKindAsJson(AstNodeKind.TypeDeclaration(nestedType), currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.types.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }

      if node.enums.isEmpty() {
        printlnv2("$fieldsIndent\"nestedEnums\": []")
      } else {
        printlnv2("$fieldsIndent\"nestedEnums\": [")
        for nestedEnum, idx in node.enums {
          printAstNodeKindAsJson(AstNodeKind.EnumDeclaration(nestedEnum), currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.types.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.EnumDeclaration(node) => {
      printlnv2("$fieldsIndent\"name\": \"enumDeclaration\",")
      if node.decorators.isEmpty() {
        printlnv2("$fieldsIndent\"decorators\": [],")
      } else {
        printlnv2("$fieldsIndent\"decorators\": [")
        for dec, idx in node.decorators {
          printDecoratorNodeAsJson(dec, currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.decorators.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }
      if node.pubToken |token| {
        printv2("$fieldsIndent\"pubToken\": ")
        printTokenAsJson(token, 0, currentIndentLevel + 1)
        printlnv2(",")
      } else {
        printlnv2("$fieldsIndent\"pubToken\": null,")
      }
      printv2("$fieldsIndent\"typeName\": ")
      printLabelAsJson(node.name)

      if node.typeParams.isEmpty() {
        printlnv2(",\n$fieldsIndent\"typeParams\": [],")
      } else {
        printlnv2(",\n$fieldsIndent\"typeParams\": [")
        for label, idx in node.typeParams {
          printv2("$fieldsIndent  ")
          printLabelAsJson(label)
          val comma = if idx != node.typeParams.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }

      if node.variants.isEmpty() {
        printlnv2("$fieldsIndent\"variants\": [],")
      } else {
        printlnv2("$fieldsIndent\"variants\": [")
        for v, idx in node.variants {
          printlnv2("$fieldsIndent  {")
          match v {
            EnumVariant.Constant(name) => {
              printlnv2("$fieldsIndent    \"kind\": \"constant\",")
              printv2("$fieldsIndent    \"name\": ")
              printLabelAsJson(name)
            }
            EnumVariant.Container(name, fields) => {
              printlnv2("$fieldsIndent    \"kind\": \"container\",")
              printv2("$fieldsIndent    \"name\": ")
              printLabelAsJson(name)
              if fields.isEmpty() {
                // unreachable
              } else {
                printlnv2(",\n$fieldsIndent    \"fields\": [")
                for f, idx in fields {
                  printlnv2("$fieldsIndent      {")
                  printv2("$fieldsIndent        \"label\": ")
                  printLabelAsJson(f.name)
                  printv2(",\n$fieldsIndent        \"typeAnnotation\": ")
                  printTypeIdentifierAsJson(f.typeAnnotation, 0, currentIndentLevel + 5)
                  printv2(",\n$fieldsIndent        \"initializer\": ")
                  if f.initializer |initializer| {
                    printAstNodeAsJson(initializer, 0, currentIndentLevel + 5)
                  } else {
                    printv2("null")
                  }
                  val comma = if idx != fields.length - 1 "," else ""
                  printlnv2("\n$fieldsIndent      }$comma")
                }
                printv2("$fieldsIndent    ]")
              }
            }
          }
          val comma = if idx != node.variants.length - 1 "," else ""
          printlnv2("\n$fieldsIndent  }$comma")
        }
        printlnv2("$fieldsIndent],")
      }

      if node.methods.isEmpty() {
        printlnv2("$fieldsIndent\"methods\": [],")
      } else {
        printlnv2("$fieldsIndent\"methods\": [")
        for method, idx in node.methods {
          printAstNodeKindAsJson(AstNodeKind.FunctionDeclaration(method), currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.methods.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }

      if node.types.isEmpty() {
        printlnv2("$fieldsIndent\"nestedTypes\": [],")
      } else {
        printlnv2("$fieldsIndent\"nestedTypes\": [")
        for nestedType, idx in node.types {
          printAstNodeKindAsJson(AstNodeKind.TypeDeclaration(nestedType), currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.types.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent],")
      }

      if node.enums.isEmpty() {
        printlnv2("$fieldsIndent\"nestedEnums\": []")
      } else {
        printlnv2("$fieldsIndent\"nestedEnums\": [")
        for nestedEnum, idx in node.enums {
          printAstNodeKindAsJson(AstNodeKind.EnumDeclaration(nestedEnum), currentIndentLevel + 2, currentIndentLevel + 2)
          val comma = if idx != node.types.length - 1 "," else ""
          printlnv2("$comma")
        }
        printlnv2("$fieldsIndent]")
      }
    }
    AstNodeKind.Break => printlnv2("$fieldsIndent\"name\": \"break\"")
    AstNodeKind.Continue => printlnv2("$fieldsIndent\"name\": \"continue\"")
    AstNodeKind.Return(expr) => {
      printlnv2("$fieldsIndent\"name\": \"return\",")

      if expr |expr| {
        printv2("$fieldsIndent\"expr\": ")
        printAstNodeAsJson(expr, 0, currentIndentLevel + 1)
        printlnv2("")
      } else {
        printlnv2("$fieldsIndent\"expr\": null")
      }
    }
  }
  printv2("$endIndent}")
}
