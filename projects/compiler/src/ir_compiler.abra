import File from "fs"
import IR, IrFunction, IrType, Instruction, Operation, Ident, Value, Const, IdentKind, GlobalVariable, Builtin from "./ir"
import ModuleBuilder, QbeType from "./qbe"
import "./qbe" as qbe
import i64ToString, u64ToString, f64ToString from "./ir_compiler_builtins"

pub type CompilationResult {
  builder: ModuleBuilder
  builtinI64ToStringUsed: Bool
  builtinU64ToStringUsed: Bool
  builtinF64ToStringUsed: Bool

  pub func writeToFile(self, file: File) {
    self.builder.writeToFile(file)

    if self.builtinI64ToStringUsed {
      file.write(i64ToString.code)
    }

    if self.builtinU64ToStringUsed {
      file.write(u64ToString.code)
    }

    if self.builtinF64ToStringUsed {
      file.write(f64ToString.code)
    }
  }
}

pub type Compiler {
  ir: IR
  builder: ModuleBuilder
  currentFn: qbe.QbeFunction
  numTemps: Int = 0
  loopStack: (/* start: */ qbe.Label, /* end: */ qbe.Label)[] = []
  builtinI64ToStringUsed: Bool = false
  builtinU64ToStringUsed: Bool = false
  builtinF64ToStringUsed: Bool = false
  mallocFn: qbe.QbeFunction = qbe.QbeFunction.spec(name: "GC_malloc", returnType: Some(QbeType.Pointer))
  reallocFn: qbe.QbeFunction = qbe.QbeFunction.spec(name: "GC_realloc", returnType: Some(QbeType.Pointer))
  memcpyFn: qbe.QbeFunction = qbe.QbeFunction.spec(name: "memcpy", returnType: None)

  pub func compile(ir: IR): CompilationResult {
    val builder = ModuleBuilder()

    val compiler = Compiler(
      ir: ir,
      builder: builder,
      currentFn: qbe.QbeFunction.spec(name: "dummy"),
    )

    compiler.compileMainFunction(ir.mainFunction)

    for g in ir.globals {
      compiler.compileGlobal(g)
    }

    for fn in ir.functions {
      compiler.compileFunction(fn)
    }

    CompilationResult(
      builder: builder,
      builtinI64ToStringUsed: compiler.builtinI64ToStringUsed,
      builtinU64ToStringUsed: compiler.builtinU64ToStringUsed,
      builtinF64ToStringUsed: compiler.builtinF64ToStringUsed,
    )
  }

  func compileGlobal(self, global: GlobalVariable) {
    if !global.referenced return

    val globalTy = self.irTypeToQbeType(global.ty)
    val globalData = if global.initialValue |init| {
      self.irConstToQbeValue(init)
    } else {
      globalTy.zeroValue()
    }
    self.builder.addData(qbe.QbeData(name: global.name, kind: qbe.QbeDataKind.Constants([(globalTy, globalData)])))
  }

  func compileMainFunction(self, fn: IrFunction) {
    val f = self.builder.buildFunction(name: fn.name, returnType: Some(qbe.QbeType.U64), exported: true)
    self.currentFn = f

    // TODO: persist to globals
    val argcVal = f.addParameter("argc", qbe.QbeType.U64)
    val argvVal = f.addParameter("argv", qbe.QbeType.U64)

    f.block.buildVoidCallRaw("GC_init", [])

    for inst in fn.block[1] {
      self.compileInstruction(inst)
    }
  }

  func compileFunction(self, fn: IrFunction) {
    if fn.extern return

    val returnType = self.irTypeToQbeReturnType(fn.ret)
    val f = self.builder.buildFunction(name: fn.name, returnType: returnType)
    self.currentFn = f
    self.numTemps = 0

    for param in fn.params {
      val ty = self.irTypeToQbeType(param.ty)
      val paramName = match param.kind { IdentKind.Named(name) => name, else => unreachable("expected IdentKind.Named for param") }
      f.addParameter(paramName, ty)
    }

    for inst in fn.block[1] {
      self.compileInstruction(inst)
    }
  }

  func compileInstruction(self, inst: Instruction) {
    val dst = inst.assignee?.kind?.name()

    match inst.op {
      Operation.NewLocal(ty, initialValue) => {
        if !dst unreachable("Operation.NewLocal requires a destination")

        val qbeTy = self.irTypeToQbeType(ty)
        val slot = match qbeTy {
          QbeType.U8 => self.currentFn.block.buildAlloc8(1, dst)      // 'b'
          QbeType.U16 => self.currentFn.block.buildAlloc4(1, dst)     // 'h' (should be unreachable)
          QbeType.U32 => self.currentFn.block.buildAlloc4(1, dst)     // 'w' (should be unreachable)
          QbeType.U64 => self.currentFn.block.buildAlloc8(1, dst)     // 'l'
          QbeType.Pointer => self.currentFn.block.buildAlloc8(1, dst) // 'l'
          QbeType.F32 => self.currentFn.block.buildAlloc4(1, dst)     // 's' (should be unreachable)
          QbeType.F64 => self.currentFn.block.buildAlloc8(1, dst)     // 'd'
        }

        if initialValue |initialValue| {
          val v = self.irValueToQbeValue(initialValue)
          self.currentFn.block.buildStore(qbeTy, v, slot)
        }
      }
      Operation.ConstInt(int) => {
        self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(int), dst)
      }
      Operation.ConstFloat(float) => {
        self.currentFn.block.buildAdd(qbe.Value.Float(0.0), qbe.Value.Float(float), dst)
      }
      Operation.ConstChar(int) => {
        self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(int), dst)
      }
      Operation.ConstBool(b) => {
        if b {
          self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(1), dst)
        } else {
          self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
        }
      }
      Operation.ConstString(str) => {
        val slot = self.makeConstString(str)
        try self.currentFn.block.buildAdd(qbe.Value.Int(0), slot, dst) else |e| unreachable(e)
      }
      Operation.Minus(v) => {
        val value = self.irValueToQbeValue(v)
        try self.currentFn.block.buildNeg(value, dst) else |e| unreachable(e)
      }
      Operation.Negate(v) => {
        val value = self.irValueToQbeValue(v)
        try self.currentFn.block.buildXor(value, qbe.Value.Int(1), dst) else |e| unreachable(e)
      }
      Operation.Add(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Add: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        try self.currentFn.block.buildAdd(left, right, dst) else |e| unreachable(e)
      }
      Operation.Sub(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Sub: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        try self.currentFn.block.buildSub(left, right, dst) else |e| unreachable(e)
      }
      Operation.Mul(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Mul: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        try self.currentFn.block.buildMul(left, right, dst) else |e| unreachable(e)
      }
      Operation.Div(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() != qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }
        if right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Div: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        try self.currentFn.block.buildDiv(left, right, dst) else |e| unreachable(e)
      }
      Operation.Mod(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.U64 && right.ty() == qbe.QbeType.U64 {
          try self.currentFn.block.buildRem(left, right, dst) else |e| unreachable(e)
        } else {
          if left.ty() != qbe.QbeType.F64 {
            left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
          }
          if right.ty() != qbe.QbeType.F64 {
            right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
          }

          try self.currentFn.block.buildCallRaw("fmod", qbe.QbeType.F64, [left, right], dst) else |e| unreachable(e)
        }
      }
      Operation.Pow(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        val bothInts = left.ty() == qbe.QbeType.U64 && right.ty() == qbe.QbeType.U64
        if left.ty() != qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }
        if right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        }

        if bothInts {
          try self.currentFn.block.buildCallRaw("pow", qbe.QbeType.F64, [left, right], dst) else |e| unreachable(e)
        } else {
          // if a < 0 { -(-a ** b) } else { a ** b }
          val labelThen = self.currentFn.block.addLabel("fpow_neg")
          val labelElse = self.currentFn.block.addLabel("fpow_pos")
          val labelCont = self.currentFn.block.addLabel("fpow_cont")
          val cond = try self.currentFn.block.buildCompareLt(left, qbe.Value.Float(0.0), Some(self.nextTemp())) else |e| unreachable(e)
          self.currentFn.block.buildJnz(cond, labelThen, labelElse)

          self.currentFn.block.registerLabel(labelThen)
          val leftValNeg = try self.currentFn.block.buildMul(left, qbe.Value.Float(-1.0), Some(self.nextTemp())) else |e| unreachable(e)
          val thenValNeg = try self.currentFn.block.buildCallRaw("pow", QbeType.F64, [leftValNeg, right], Some(self.nextTemp())) else |e| unreachable(e)
          val thenVal = try self.currentFn.block.buildMul(thenValNeg, qbe.Value.Float(-1.0), Some(self.nextTemp())) else |e| unreachable(e)
          self.currentFn.block.buildJmp(labelCont)

          self.currentFn.block.registerLabel(labelElse)
          val elseVal = try self.currentFn.block.buildCallRaw("pow", QbeType.F64, [left, right], Some(self.nextTemp())) else |e| unreachable(e)
          self.currentFn.block.buildJmp(labelCont)

          self.currentFn.block.registerLabel(labelCont)

          val phiCases = [(labelThen, thenVal), (labelElse, elseVal)]
          try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable(e)
        }
      }
      Operation.BitAnd(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        try self.currentFn.block.buildAnd(left, right, dst) else |e| unreachable(e)
      }
      Operation.BoolAnd(l, r) => {
        var left = self.irValueToQbeValue(l)

        val labelThen = self.currentFn.block.addLabel("bool_and_then")
        val labelElse = self.currentFn.block.addLabel("bool_and_else")
        val labelCont = self.currentFn.block.addLabel("bool_and_cont")

        self.currentFn.block.buildJnz(left, labelThen, labelElse)

        self.currentFn.block.registerLabel(labelThen)
        for inst in r.body {
          self.compileInstruction(inst)
        }
        val right = self.irValueToQbeValue(r.result)
        val rightLabel = self.currentFn.block.currentLabel
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelElse)
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelCont)

        val phiCases = [(rightLabel, right), (labelElse, left)]
        try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable(e)
      }
      Operation.BitOr(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        try self.currentFn.block.buildOr(left, right, dst) else |e| unreachable(e)
      }
      Operation.BoolOr(l, r) => {
        var left = self.irValueToQbeValue(l)

        val labelThen = self.currentFn.block.addLabel("bool_or_then")
        val labelElse = self.currentFn.block.addLabel("bool_or_else")
        val labelCont = self.currentFn.block.addLabel("bool_or_cont")

        self.currentFn.block.buildJnz(left, labelThen, labelElse)

        self.currentFn.block.registerLabel(labelThen)
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelElse)
        for inst in r.body {
          self.compileInstruction(inst)
        }
        val right = self.irValueToQbeValue(r.result)
        val rightLabel = self.currentFn.block.currentLabel
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelCont)

        val phiCases = [(labelThen, left), (rightLabel, right)]
        try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable(e)
      }
      Operation.Xor(_, l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        try self.currentFn.block.buildXor(left, right, dst) else |e| unreachable(e)
      }
      Operation.Eq(primitive, negate, l, r) => {
        if !primitive todo("non-primitive Eq operation")

        val left = self.irValueToQbeValue(l)
        val right = self.irValueToQbeValue(r)

        val res = if negate {
          try self.currentFn.block.buildCompareNeq(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        } else {
          try self.currentFn.block.buildCompareEq(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        }
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Lt(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Lt: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        val res = try self.currentFn.block.buildCompareLt(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Lte(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Lte: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        val res = try self.currentFn.block.buildCompareLte(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Shl(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() != right.ty() unreachable("Operation.Shl: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        self.currentFn.block.buildShl(left, right, dst)
      }
      Operation.Gt(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Lt: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        val res = try self.currentFn.block.buildCompareGt(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Gte(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Lte: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        val res = try self.currentFn.block.buildCompareGte(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Shr(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() != right.ty() unreachable("Operation.Shr: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        self.currentFn.block.buildShr(left, right, dst)
      }
      Operation.Load(ty, mem) => {
        val ptr = self.irValueToQbeValue(mem)
        self.currentFn.block.buildLoad(self.irTypeToQbeType(ty), ptr, dst)
      }
      Operation.LoadField(ty, mem, _, offset) => {
        val ptr = if offset == 0 {
          self.irValueToQbeValue(mem)
        } else {
          val memVal = self.irValueToQbeValue(mem)
          try self.currentFn.block.buildAdd(qbe.Value.Int(offset), memVal, Some(self.nextTemp())) else |e| unreachable(e)
        }
        self.currentFn.block.buildLoad(self.irTypeToQbeType(ty), ptr, dst)
      }
      Operation.Store(ty, value, mem) => {
        val v = self.irValueToQbeValue(value)
        val qbeTy = self.irTypeToQbeType(ty)
        match mem {
          Value.Ident(ident) => {
            val mem = qbe.Value.Ident(name: ident.kind.name(), ty: qbeTy)
            self.currentFn.block.buildStore(self.irTypeToQbeType(ty), v, mem)
          }
          Value.Global(global) => {
            val mem = qbe.Value.Global(name: global.name, ty: qbeTy)
            self.currentFn.block.buildStore(self.irTypeToQbeType(ty), v, mem)
          }
          else => unreachable("Storing into non-ident/global")
        }
      }
      Operation.StoreField(ty, value, mem, _, offset) => {
        val ptr = if offset == 0 {
          self.irValueToQbeValue(mem)
        } else {
          val memVal = self.irValueToQbeValue(mem)
          try self.currentFn.block.buildAdd(qbe.Value.Int(offset), memVal, Some(self.nextTemp())) else |e| unreachable(e)
        }

        val v = self.irValueToQbeValue(value)
        self.currentFn.block.buildStore(self.irTypeToQbeType(ty), v, ptr)
      }
      Operation.If(ty, cond, thenBlock, elseBlock) => {
        val isStmt = ty == IrType.Unit
        val condVal = self.irValueToQbeValue(cond)

        val labelThen = self.currentFn.block.addLabel(thenBlock.name)
        val labelCont = self.currentFn.block.addLabel("cont")

        if !elseBlock.body.isEmpty() || !!elseBlock.result {
          val labelElse = self.currentFn.block.addLabel(elseBlock.name)

          self.currentFn.block.buildJnz(condVal, labelThen, labelElse)
          self.currentFn.block.registerLabel(labelThen)
          for inst in thenBlock.body {
            self.compileInstruction(inst)
          }
          if !thenBlock.terminates {
            self.currentFn.block.buildJmp(labelCont)
          }

          val thenPhiValue = if thenBlock.result |v| {
            val label = self.currentFn.block.currentLabel
            val thenVal = self.irValueToQbeValue(v)
            Some((label, thenVal))
          } else {
            None
          }

          self.currentFn.block.registerLabel(labelElse)
          for inst in elseBlock.body {
            self.compileInstruction(inst)
          }
          if !elseBlock.terminates {
            self.currentFn.block.buildJmp(labelCont)
          }
          val elsePhiValue = if elseBlock.result |v| {
            val label = self.currentFn.block.currentLabel
            val elseVal = self.irValueToQbeValue(v)
            Some((label, elseVal))
          } else {
            None
          }

          self.currentFn.block.registerLabel(labelCont)

          if !thenBlock.result && !elseBlock.result {
            // in if-exprs that are missing both then- and else-values, emit unreachable
            if !isStmt self.currentFn.block.buildHalt()
          } else {
            val phiCases: (qbe.Label, qbe.Value)[] = []
            if thenPhiValue |(label, v)| phiCases.push((label, v))
            if elsePhiValue |(label, v)| phiCases.push((label, v))

            try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable("$e ($thenBlock)")
          }
        } else {
          if !isStmt unreachable("must be a statement at this point")

          self.currentFn.block.buildJnz(condVal, labelThen, labelCont)
          self.currentFn.block.registerLabel(labelThen)
          for inst in thenBlock.body {
            self.compileInstruction(inst)
          }
          if !thenBlock.terminates {
            self.currentFn.block.buildJmp(labelCont)
          }

          self.currentFn.block.registerLabel(labelCont)
        }
      }
      Operation.WhileLoopStart(name) => {
        val labelCond = self.currentFn.block.addLabel("${name}_cond")
        self.loopStack.push((labelCond, labelCond))
        self.currentFn.block.registerLabel(labelCond)
      }
      Operation.While(cond, body) => {
        val labelCond = if self.loopStack.pop() |(loopStartLabel, _)| loopStartLabel else unreachable("unexpected empty loop stack")
        val labelBody = self.currentFn.block.addLabel("${body.name}_body")
        val labelCont = self.currentFn.block.addLabel("${body.name}_cont")

        self.loopStack.push((labelCond, labelCont))

        val condVal = self.irValueToQbeValue(cond)
        self.currentFn.block.buildJnz(condVal, labelBody, labelCont)

        self.currentFn.block.registerLabel(labelBody)
        for inst in body.body {
          self.compileInstruction(inst)
        }
        if !body.terminates {
          self.currentFn.block.buildJmp(labelCond)
        }

        self.currentFn.block.registerLabel(labelCont)

        self.loopStack.pop()
      }
      Operation.Call(ret, fnName, args) => {
        val argVals = args.map(a => self.irValueToQbeValue(a))
        if self.irTypeToQbeReturnType(ret) |ret| {
          try self.currentFn.block.buildCallRaw(fnName, ret, argVals, dst) else |e| unreachable(e)
        } else {
          self.currentFn.block.buildVoidCallRaw(fnName, argVals)
        }
      }
      Operation.Break => {
        if self.loopStack[-1] |(_, loopEndLabel)| {
          self.currentFn.block.buildJmp(loopEndLabel)

          Ok(None)
        } else {
          unreachable("cannot have a break statement outside of a loop")
        }
      }
      Operation.Continue => {
        if self.loopStack[-1] |(loopStartLabel, _)| {
          self.currentFn.block.buildJmp(loopStartLabel)
        } else {
          unreachable("cannot have a continue statement outside of a loop")
        }
      }
      Operation.Return(value) => {
        if value |v| {
          self.currentFn.block.buildReturn(Some(self.irValueToQbeValue(v)))
        } else {
          self.currentFn.block.buildReturn()
        }
      }
      Operation.OptionNone => {
        self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
      }
      Operation.OptionSome(innerTy, value) => {
        val qbeVal = self.irValueToQbeValue(value)
        if innerTy == IrType.I64 {
          val mem = self.callMalloc(qbe.Value.Int(8), dst)
          self.currentFn.block.buildStoreL(qbeVal, mem)
        } else if innerTy == IrType.F64 {
          self.currentFn.block.buildAdd(qbe.Value.Float(0.0), qbeVal, dst)
        } else {
          self.currentFn.block.buildAdd(qbe.Value.Int(0), qbeVal, dst)
        }
      }
      Operation.OptionIsNone(value) => {
        val qbeVal = self.irValueToQbeValue(value)
        val res = try self.currentFn.block.buildCompareEq(qbe.Value.Int(0), qbeVal, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.OptionUnwrap(innerTy, value) => {
        val qbeVal = self.irValueToQbeValue(value)
        if innerTy == IrType.I64 {
          self.currentFn.block.buildLoadL(qbeVal, dst)
        } else if innerTy == IrType.F64 {
          self.currentFn.block.buildAdd(qbe.Value.Float(0.0), qbeVal, dst)
        } else {
          self.currentFn.block.buildAdd(qbe.Value.Int(0), qbeVal, dst)
        }
      }
      Operation.StructuredToString(prefix, lenVal, fields) => self.compileStructuredToString(prefix, lenVal, fields, dst)
      Operation.Builtin(ret, builtin) => {
        val sizeOfType = (irType: IrType) => match irType {
          IrType.Unit => unreachable("values cannot be of type unit")
          IrType.I64 => (8, QbeType.U64)
          IrType.F64 => (8, QbeType.F64)
          IrType.Bool => (8, QbeType.U64)
          IrType.Byte => (1, QbeType.U8)
          IrType.Composite => (8, QbeType.U64)
          IrType.Ptr => (8, QbeType.U64)
        }

        match builtin {
          Builtin.Malloc(count, itemTy) => {
            val countVal = self.irValueToQbeValue(count)
            val sizeVal = if itemTy |itemTy| {
              val (size, _) = sizeOfType(itemTy)
              try self.currentFn.block.buildMul(qbe.Value.Int(size), countVal, Some(self.nextTemp())) else |e| unreachable(e)
            } else {
              countVal
            }

            self.callMalloc(sizeVal, dst)
          }
          Builtin.Realloc(ptr, count, itemTy) => {
            val ptrVal = self.irValueToQbeValue(ptr)
            val countVal = self.irValueToQbeValue(count)
            val sizeVal = if itemTy |itemTy| {
              val (size, _) = sizeOfType(itemTy)
              try self.currentFn.block.buildMul(qbe.Value.Int(size), countVal, Some(self.nextTemp())) else |e| unreachable(e)
            } else {
              countVal
            }

            self.callRealloc(ptrVal, sizeVal, dst)
          }
          Builtin.Store(ptr, value, offset, itemTy) => {
            val ptrVal = self.irValueToQbeValue(ptr)
            val valueVal = self.irValueToQbeValue(value)
            val offsetVal = self.irValueToQbeValue(offset)

            val (size, qbeTy) = sizeOfType(itemTy)
            val sizeVal = try self.currentFn.block.buildMul(qbe.Value.Int(size), offsetVal, Some(self.nextTemp())) else |e| unreachable(e)
            val mem = try self.currentFn.block.buildAdd(sizeVal, ptrVal, Some(self.nextTemp())) else |e| unreachable(e)

            if size == 1 {
              self.currentFn.block.buildStoreB(valueVal, mem)
            } else {
              self.currentFn.block.buildStore(qbeTy, valueVal, mem)
            }
          }
          Builtin.Load(ptr, offset, itemTy) => {
            val ptrVal = self.irValueToQbeValue(ptr)
            val offsetVal = self.irValueToQbeValue(offset)

            val (size, qbeTy) = sizeOfType(itemTy)
            val sizeVal = try self.currentFn.block.buildMul(qbe.Value.Int(size), offsetVal, Some(self.nextTemp())) else |e| unreachable(e)
            val mem = try self.currentFn.block.buildAdd(sizeVal, ptrVal, Some(self.nextTemp())) else |e| unreachable(e)

            if size == 1 {
              self.currentFn.block.buildLoadB(mem, dst)
            } else {
              self.currentFn.block.buildLoad(qbeTy, mem, dst)
            }
          }
          Builtin.CopyFrom(dst, dstOffset, src, srcOffset, count, itemTy) => {
            val dstVal = self.irValueToQbeValue(dst)
            val dstOffsetVal = self.irValueToQbeValue(dstOffset)
            val srcVal = self.irValueToQbeValue(src)
            val srcOffsetVal = self.irValueToQbeValue(srcOffset)
            val countVal = self.irValueToQbeValue(count)

            val (size, _) = sizeOfType(itemTy)
            self.compileMemcpy(dstVal, dstOffsetVal, srcVal, srcOffsetVal, countVal, qbe.Value.Int(size))
          }
          Builtin.I64ToString(int) => {
            self.builtinI64ToStringUsed = true

            val intVal = self.irValueToQbeValue(int)
            val lenPtr = self.currentFn.block.buildAlloc8(1, Some("lenptr"))
            val mem = try self.currentFn.block.buildCallRaw(i64ToString.name, qbe.QbeType.Pointer, [intVal, lenPtr], Some(self.nextTemp())) else |e| unreachable(e)
            val lenVal = self.currentFn.block.buildLoadL(lenPtr, Some(self.nextTemp()))
            self.constructString(mem, lenVal, dst)
          }
          Builtin.U64ToString(int) => {
            self.builtinU64ToStringUsed = true

            val intVal = self.irValueToQbeValue(int)
            val lenPtr = self.currentFn.block.buildAlloc8(1, Some("lenptr"))
            val mem = try self.currentFn.block.buildCallRaw(u64ToString.name, qbe.QbeType.Pointer, [intVal, lenPtr], Some(self.nextTemp())) else |e| unreachable(e)
            val lenVal = self.currentFn.block.buildLoadL(lenPtr, Some(self.nextTemp()))
            self.constructString(mem, lenVal, dst)
          }
          Builtin.F64ToString(float) => {
            self.builtinF64ToStringUsed = true

            val floatVal = self.irValueToQbeValue(float)
            val lenPtr = self.currentFn.block.buildAlloc8(1, Some("lenptr"))
            val mem = try self.currentFn.block.buildCallRaw(f64ToString.name, qbe.QbeType.Pointer, [floatVal, lenPtr], Some(self.nextTemp())) else |e| unreachable(e)
            val lenVal = self.currentFn.block.buildLoadL(lenPtr, Some(self.nextTemp()))
            self.constructString(mem, lenVal, dst)
          }
          Builtin.BoolToString(bool) => {
            val boolVal = self.irValueToQbeValue(bool)

            val labelTrue = self.currentFn.block.addLabel("true")
            val labelFalse = self.currentFn.block.addLabel("false")
            val labelCont = self.currentFn.block.addLabel("cont")
            self.currentFn.block.buildJnz(boolVal, labelTrue, labelFalse)

            val phiCases: (qbe.Label, qbe.Value)[] = []

            self.currentFn.block.registerLabel(labelTrue)
            phiCases.push((labelTrue, self.makeConstString("true")))
            self.currentFn.block.buildJmp(labelCont)

            self.currentFn.block.registerLabel(labelFalse)
            phiCases.push((labelFalse, self.makeConstString("false")))
            self.currentFn.block.buildJmp(labelCont)

            self.currentFn.block.registerLabel(labelCont)
            try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable(e)
          }
          Builtin.IntAsFloat(int) => {
            val intVal = self.irValueToQbeValue(int)

            self.currentFn.block.buildLToF(intVal, true, dst)
          }
          Builtin.FloatAsInt(float) => {
            val floatVal = self.irValueToQbeValue(float)

            self.currentFn.block.buildFToL(floatVal, true, dst)
          }
          Builtin.FloatCeil(float) => {
            val floatVal = self.irValueToQbeValue(float)

            val ceilRes = try self.currentFn.block.buildCallRaw("ceil", QbeType.F64, [floatVal], Some(self.nextTemp())) else |e| unreachable(e)
            self.currentFn.block.buildFToL(ceilRes, true, dst)
          }
          Builtin.FloatFloor(float) => {
            val floatVal = self.irValueToQbeValue(float)

            val floorRes = try self.currentFn.block.buildCallRaw("floor", QbeType.F64, [floatVal], Some(self.nextTemp())) else |e| unreachable(e)
            self.currentFn.block.buildFToL(floorRes, true, dst)
          }
          Builtin.FloatRound(float) => {
            val floatVal = self.irValueToQbeValue(float)

            val roundRes = try self.currentFn.block.buildCallRaw("round", QbeType.F64, [floatVal], Some(self.nextTemp())) else |e| unreachable(e)
            self.currentFn.block.buildFToL(roundRes, true, dst)
          }
          Builtin.Uninitialized => {
            self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
          }
        }
      }
    }
  }

  func compileStructuredToString(self, prefix: String, lenVal: Value, fields: (IrType, String, Value)[], dst: String?): qbe.Value {
    val strIrTy = IrType.Composite(self.ir.knowns.stringType().name)

    val lenQbeVal = self.irValueToQbeValue(lenVal)
    val lenPlusOneQbeVal = try self.currentFn.block.buildAdd(qbe.Value.Int(1), lenQbeVal, Some(self.nextTemp())) else |e| unreachable(e)
    val buf = self.callMalloc(lenPlusOneQbeVal, Some(self.nextTemp()))

    val prefixVal = self.makeConstString(prefix)
    val (prefixLen, prefixBuf) = self.strValGetParts(prefixVal)

    self.compileMemcpy(buf, qbe.Value.Int(0), prefixBuf, qbe.Value.Int(0), prefixLen, qbe.Value.Int(1))
    var offsetVal = prefixLen

    offsetVal = self._insertCharAt('(', buf, offsetVal)

    for (fieldIrType, fieldName, fieldStrValue), idx in fields {
      val fieldNameVal = self.makeConstString(fieldName)
      val (fieldNameLen, fieldNameBuf) = self.strValGetParts(fieldNameVal)

      self.compileMemcpy(buf, offsetVal, fieldNameBuf, qbe.Value.Int(0), fieldNameLen, qbe.Value.Int(1))
      offsetVal = try self.currentFn.block.buildAdd(offsetVal, fieldNameLen, Some(self.nextTemp())) else |e| unreachable(e)

      if !fieldName.isEmpty() {
        offsetVal = self._insertCharAt(':', buf, offsetVal)
        offsetVal = self._insertCharAt(' ', buf, offsetVal)
      }

      val fieldStrQbeVal = self.irValueToQbeValue(fieldStrValue)
      val (fieldStrLen, fieldStrBuf) = self.strValGetParts(fieldStrQbeVal)
      if fieldIrType == strIrTy { offsetVal = self._insertCharAt('"', buf, offsetVal) }
      self.compileMemcpy(buf, offsetVal, fieldStrBuf, qbe.Value.Int(0), fieldStrLen, qbe.Value.Int(1))
      offsetVal = try self.currentFn.block.buildAdd(offsetVal, fieldStrLen, Some(self.nextTemp())) else |e| unreachable(e)
      if fieldIrType == strIrTy { offsetVal = self._insertCharAt('"', buf, offsetVal) }

      if idx != fields.length - 1 {
        offsetVal = self._insertCharAt(',', buf, offsetVal)
        offsetVal = self._insertCharAt(' ', buf, offsetVal)
      }
    }
    self._insertCharAt(')', buf, offsetVal)

    self.constructString(buf, lenQbeVal, dst)
  }

  // helper function, used within `#compileStructuredToString`
  // TODO: support nested methods for scoping?
  func _insertCharAt(self, ch: Char, buf: qbe.Value, offsetVal: qbe.Value): qbe.Value {
    val cursor = try self.currentFn.block.buildAdd(offsetVal, buf, Some(self.nextTemp())) else |e| unreachable(e)
    self.currentFn.block.buildStoreB(qbe.Value.Int(ch.asInt()), cursor)
    try self.currentFn.block.buildAdd(offsetVal, qbe.Value.Int(1), Some(self.nextTemp())) else |e| unreachable(e)
  }

  func compileMemcpy(self, dstPtr: qbe.Value, dstOffset: qbe.Value, srcPtr: qbe.Value, srcOffset: qbe.Value, amount: qbe.Value, itemSize: qbe.Value) {
    val dstMem = try self.currentFn.block.buildAdd(
      try self.currentFn.block.buildMul(itemSize, dstOffset, Some(self.nextTemp())) else |e| unreachable(e),
      dstPtr,
      Some(self.nextTemp()),
    ) else |e| unreachable(e)
    val srcMem = try self.currentFn.block.buildAdd(
      try self.currentFn.block.buildMul(itemSize, srcOffset, Some(self.nextTemp())) else |e| unreachable(e),
      srcPtr,
      Some(self.nextTemp()),
    ) else |e| unreachable(e)

    self.currentFn.block.buildVoidCall(qbe.Callable.Function(self.memcpyFn), [dstMem, srcMem, amount])
  }

  func nextTemp(self): String {
    val name = "_t${self.numTemps}"
    self.numTemps += 1
    name
  }

  func irTypeToQbeType(self, irType: IrType): qbe.QbeType {
    match irType {
      IrType.I64 => QbeType.U64
      IrType.F64 => QbeType.F64
      IrType.Bool => QbeType.U64
      IrType.Composite => QbeType.U64 // pointer to GC'd object
      IrType.Ptr => QbeType.U64 // raw pointer
      IrType.Unit => unreachable("values cannot be of type Unit")
      IrType.Byte => QbeType.U64 // treat bytes as longs when they're ordinary values; but use `loadb`/`storeb`
    }
  }

  func irTypeToQbeReturnType(self, irType: IrType): qbe.QbeType? = match irType { IrType.Unit => None, else t => Some(self.irTypeToQbeType(t)) }

  func irConstToQbeValue(self, const: Const): qbe.Value = match const {
    Const.Int(i) => qbe.Value.Int(i)
    Const.Float(f) => qbe.Value.Float(f)
    Const.Bool(b) => qbe.Value.Int(if b 1 else 0)
    Const.Char(c) => qbe.Value.Int(c)
    Const.String(s) => self.makeConstString(s)
  }

  func irValueToQbeValue(self, v: Value): qbe.Value {
    match v {
      Value.Unit => unreachable("values cannot be of type unit")
      Value.Const(const) => self.irConstToQbeValue(const)
      Value.Ident(i) => {
        val ty = self.irTypeToQbeType(i.ty)
        qbe.Value.Ident(name: i.kind.name(), ty: ty)
      }
      Value.Global(g) => {
        val ty = self.irTypeToQbeType(g.ty)
        self.currentFn.block.buildLoad(ty, qbe.Value.Global(name: g.name, ty: ty), Some(self.nextTemp()))
      }
    }
  }

  func makeConstString(self, s: String): qbe.Value {
    val str = s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"").replaceAll("\n", "\\n").replaceAll("\r", "\\r")
    val (dataPtr, data, newlyAdded) = self.builder.buildGlobalString(str)

    val globalName = "${data.name}str"
    if newlyAdded {
      val (slot, _) = self.builder.addData(qbe.QbeData(
        name: globalName,
        kind: qbe.QbeDataKind.Constants([(qbe.QbeType.U64, qbe.Value.Int(s.length)), (qbe.QbeType.Pointer, dataPtr)])
      ))
      slot
    } else {
      qbe.Value.Global(name: globalName, ty: qbe.QbeType.Pointer)
    }
  }

  func strValGetParts(self, strVal: qbe.Value): (qbe.Value, qbe.Value) {
    val strLen = self.currentFn.block.buildLoadL(
      try self.currentFn.block.buildAdd(qbe.Value.Int(0), strVal, Some(self.nextTemp())) else |e| unreachable(e),
      Some(self.nextTemp()),
    )
    val strBuf = self.currentFn.block.buildLoadL(
      try self.currentFn.block.buildAdd(qbe.Value.Int(8), strVal, Some(self.nextTemp())) else |e| unreachable(e),
      Some(self.nextTemp()),
    )

    (strLen, strBuf)
  }

  func constructString(self, ptrVal: qbe.Value, lenVal: qbe.Value, dst: String? = None): qbe.Value {
    val strTy = self.irTypeToQbeType(IrType.Composite(self.ir.knowns.stringType().name))
    val strInitFn = self.ir.knowns.stringInitializerFn()
    try self.currentFn.block.buildCallRaw(strInitFn.name, strTy, [lenVal, ptrVal], dst) else |e| unreachable(e)
  }

  func callMalloc(self, sizeVal: qbe.Value, dst: String? = None): qbe.Value {
    try self.currentFn.block.buildCall(qbe.Callable.Function(self.mallocFn), [sizeVal], dst) else |e| unreachable(e)
  }

  func callRealloc(self, ptrVal: qbe.Value, sizeVal: qbe.Value, dst: String? = None): qbe.Value {
    try self.currentFn.block.buildCall(qbe.Callable.Function(self.reallocFn), [ptrVal, sizeVal], dst) else |e| unreachable(e)
  }
}
