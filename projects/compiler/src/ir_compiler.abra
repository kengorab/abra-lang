import File from "fs"
import IR, IrFunction, IrType, Instruction, Operation, Ident, Value, Const, IdentKind, GlobalVariable, Builtin, ClosureEnvLocation, CaptureSource from "./ir"
import ModuleBuilder, QbeType from "./qbe"
import "./qbe" as qbe
import i64ToString, u64ToString, f64ToString from "./ir_compiler_builtins"

pub type CompilationResult {
  builder: ModuleBuilder
  builtinI64ToStringUsed: Bool
  builtinU64ToStringUsed: Bool
  builtinF64ToStringUsed: Bool

  pub func writeToFile(self, file: File) {
    self.builder.writeToFile(file)

    if self.builtinI64ToStringUsed {
      file.write(i64ToString.code)
    }

    if self.builtinU64ToStringUsed {
      file.write(u64ToString.code)
    }

    if self.builtinF64ToStringUsed {
      file.write(f64ToString.code)
    }
  }
}

pub type Compiler {
  ir: IR
  builder: ModuleBuilder
  currentFn: qbe.QbeFunction
  currentFnEnv: qbe.Value? = None
  numTemps: Int = 0
  loopStack: (/* start: */ qbe.Label, /* end: */ qbe.Label)[] = []
  builtinI64ToStringUsed: Bool = false
  builtinU64ToStringUsed: Bool = false
  builtinF64ToStringUsed: Bool = false
  mallocFn: qbe.QbeFunction = qbe.QbeFunction.spec(name: "GC_malloc", returnType: Some(QbeType.Pointer))
  reallocFn: qbe.QbeFunction = qbe.QbeFunction.spec(name: "GC_realloc", returnType: Some(QbeType.Pointer))
  memcpyFn: qbe.QbeFunction = qbe.QbeFunction.spec(name: "memcpy", returnType: None)
  callFunctions: Map<String, qbe.QbeFunction> = {}

  pub func compile(ir: IR): CompilationResult {
    val builder = ModuleBuilder()

    val compiler = Compiler(
      ir: ir,
      builder: builder,
      currentFn: qbe.QbeFunction.spec(name: "dummy"),
    )

    compiler.compileMainFunction(ir.mainFunction)

    for g in ir.globals {
      compiler.compileGlobal(g)
    }

    for fn in ir.functions {
      compiler.compileFunction(fn)
    }

    CompilationResult(
      builder: builder,
      builtinI64ToStringUsed: compiler.builtinI64ToStringUsed,
      builtinU64ToStringUsed: compiler.builtinU64ToStringUsed,
      builtinF64ToStringUsed: compiler.builtinF64ToStringUsed,
    )
  }

  func compileGlobal(self, global: GlobalVariable) {
    if !global.referenced return

    val globalTy = self.irTypeToQbeType(global.ty)
    val globalData = if global.initialValue |init| {
      self.irConstToQbeValue(init)
    } else {
      globalTy.zeroValue()
    }
    self.builder.addData(qbe.QbeData(name: global.name, kind: qbe.QbeDataKind.Constants([(globalTy, globalData)])))
  }

  func compileMainFunction(self, fn: IrFunction) {
    val f = self.builder.buildFunction(name: fn.name, returnType: Some(qbe.QbeType.U64), exported: true)
    self.currentFn = f

    // TODO: persist to globals
    val argcVal = f.addParameter("argc", qbe.QbeType.U64)
    val argvVal = f.addParameter("argv", qbe.QbeType.U64)

    f.block.buildVoidCallRaw("GC_init", [])

    for inst in fn.block[1] {
      self.compileInstruction(inst)
    }
  }

  func compileFunction(self, fn: IrFunction) {
    if fn.extern return

    val returnType = self.irTypeToQbeReturnType(fn.ret)
    val f = self.builder.buildFunction(name: fn.name, returnType: returnType)
    if fn.isClosure {
      self.currentFnEnv = Some(f.addEnv())
    }
    self.currentFn = f
    self.numTemps = 0

    for param in fn.params {
      val ty = self.irTypeToQbeType(param.ty)
      val paramName = match param.kind { IdentKind.Named(name, _) => name, else => unreachable("expected IdentKind.Named for param") }
      f.addParameter(paramName, ty)
    }

    for inst in fn.block[1] {
      self.compileInstruction(inst)
    }
  }

  func compileInstruction(self, inst: Instruction) {
    val dst = inst.assignee?.kind?.name()

    match inst.op {
      Operation.NewLocal(ty, captured, initialValue) => {
        if !dst unreachable("Operation.NewLocal requires a destination")

        val qbeTy = self.irTypeToQbeType(ty)
        val slot = if captured {
          val size = match qbeTy {
            QbeType.U8 => 8      // 'b'
            QbeType.U16 => 4     // 'h' (should be unreachable)
            QbeType.U32 => 4     // 'w' (should be unreachable)
            QbeType.U64 => 8     // 'l'
            QbeType.Pointer => 8 // 'l'
            QbeType.F32 => 4     // 's' (should be unreachable)
            QbeType.F64 => 8     // 'd'
          }
          val mem = self.callMalloc(qbe.Value.Int(size), Some(self.nextTemp()))
          val slot = self.currentFn.block.buildAlloc8(1, dst)
          self.currentFn.block.buildStoreL(mem, slot)
          mem
        } else {
          match qbeTy {
            QbeType.U8 => self.currentFn.block.buildAlloc8(1, dst)      // 'b'
            QbeType.U16 => self.currentFn.block.buildAlloc4(1, dst)     // 'h' (should be unreachable)
            QbeType.U32 => self.currentFn.block.buildAlloc4(1, dst)     // 'w' (should be unreachable)
            QbeType.U64 => self.currentFn.block.buildAlloc8(1, dst)     // 'l'
            QbeType.Pointer => self.currentFn.block.buildAlloc8(1, dst) // 'l'
            QbeType.F32 => self.currentFn.block.buildAlloc4(1, dst)     // 's' (should be unreachable)
            QbeType.F64 => self.currentFn.block.buildAlloc8(1, dst)     // 'd'
          }
        }

        if initialValue |initialValue| {
          val v = self.irValueToQbeValue(initialValue)
          self.currentFn.block.buildStore(qbeTy, v, slot)
        }
      }
      Operation.ConstInt(int) => {
        self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(int), dst)
      }
      Operation.ConstFloat(float) => {
        self.currentFn.block.buildAdd(qbe.Value.Float(0.0), qbe.Value.Float(float), dst)
      }
      Operation.ConstChar(int) => {
        self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(int), dst)
      }
      Operation.ConstBool(b) => {
        if b {
          self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(1), dst)
        } else {
          self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
        }
      }
      Operation.ConstString(str) => {
        val slot = self.makeConstString(str)
        try self.currentFn.block.buildAdd(qbe.Value.Int(0), slot, dst) else |e| unreachable(e)
      }
      Operation.Minus(v) => {
        val value = self.irValueToQbeValue(v)
        try self.currentFn.block.buildNeg(value, dst) else |e| unreachable(e)
      }
      Operation.Negate(v) => {
        val value = self.irValueToQbeValue(v)
        try self.currentFn.block.buildXor(value, qbe.Value.Int(1), dst) else |e| unreachable(e)
      }
      Operation.Add(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Add: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        try self.currentFn.block.buildAdd(left, right, dst) else |e| unreachable(e)
      }
      Operation.Sub(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Sub: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        try self.currentFn.block.buildSub(left, right, dst) else |e| unreachable(e)
      }
      Operation.Mul(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Mul: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        try self.currentFn.block.buildMul(left, right, dst) else |e| unreachable(e)
      }
      Operation.Div(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() != qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }
        if right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Div: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        try self.currentFn.block.buildDiv(left, right, dst) else |e| unreachable(e)
      }
      Operation.Mod(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.U64 && right.ty() == qbe.QbeType.U64 {
          try self.currentFn.block.buildRem(left, right, dst) else |e| unreachable(e)
        } else {
          if left.ty() != qbe.QbeType.F64 {
            left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
          }
          if right.ty() != qbe.QbeType.F64 {
            right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
          }

          try self.currentFn.block.buildCallRaw("fmod", qbe.QbeType.F64, [left, right], dst) else |e| unreachable(e)
        }
      }
      Operation.Pow(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        val bothInts = left.ty() == qbe.QbeType.U64 && right.ty() == qbe.QbeType.U64
        if left.ty() != qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }
        if right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        }

        if bothInts {
          try self.currentFn.block.buildCallRaw("pow", qbe.QbeType.F64, [left, right], dst) else |e| unreachable(e)
        } else {
          // if a < 0 { -(-a ** b) } else { a ** b }
          val labelThen = self.currentFn.block.addLabel("fpow_neg")
          val labelElse = self.currentFn.block.addLabel("fpow_pos")
          val labelCont = self.currentFn.block.addLabel("fpow_cont")
          val cond = try self.currentFn.block.buildCompareLt(left, qbe.Value.Float(0.0), Some(self.nextTemp())) else |e| unreachable(e)
          self.currentFn.block.buildJnz(cond, labelThen, labelElse)

          self.currentFn.block.registerLabel(labelThen)
          val leftValNeg = try self.currentFn.block.buildMul(left, qbe.Value.Float(-1.0), Some(self.nextTemp())) else |e| unreachable(e)
          val thenValNeg = try self.currentFn.block.buildCallRaw("pow", QbeType.F64, [leftValNeg, right], Some(self.nextTemp())) else |e| unreachable(e)
          val thenVal = try self.currentFn.block.buildMul(thenValNeg, qbe.Value.Float(-1.0), Some(self.nextTemp())) else |e| unreachable(e)
          self.currentFn.block.buildJmp(labelCont)

          self.currentFn.block.registerLabel(labelElse)
          val elseVal = try self.currentFn.block.buildCallRaw("pow", QbeType.F64, [left, right], Some(self.nextTemp())) else |e| unreachable(e)
          self.currentFn.block.buildJmp(labelCont)

          self.currentFn.block.registerLabel(labelCont)

          val phiCases = [(labelThen, thenVal), (labelElse, elseVal)]
          try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable(e)
        }
      }
      Operation.BitAnd(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        try self.currentFn.block.buildAnd(left, right, dst) else |e| unreachable(e)
      }
      Operation.BoolAnd(l, r) => {
        var left = self.irValueToQbeValue(l)

        val labelThen = self.currentFn.block.addLabel("bool_and_then")
        val labelElse = self.currentFn.block.addLabel("bool_and_else")
        val labelCont = self.currentFn.block.addLabel("bool_and_cont")

        self.currentFn.block.buildJnz(left, labelThen, labelElse)

        self.currentFn.block.registerLabel(labelThen)
        for inst in r.body {
          self.compileInstruction(inst)
        }
        val right = self.irValueToQbeValue(r.result)
        val rightLabel = self.currentFn.block.currentLabel
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelElse)
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelCont)

        val phiCases = [(rightLabel, right), (labelElse, left)]
        try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable(e)
      }
      Operation.BitOr(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        try self.currentFn.block.buildOr(left, right, dst) else |e| unreachable(e)
      }
      Operation.BoolOr(l, r) => {
        var left = self.irValueToQbeValue(l)

        val labelThen = self.currentFn.block.addLabel("bool_or_then")
        val labelElse = self.currentFn.block.addLabel("bool_or_else")
        val labelCont = self.currentFn.block.addLabel("bool_or_cont")

        self.currentFn.block.buildJnz(left, labelThen, labelElse)

        self.currentFn.block.registerLabel(labelThen)
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelElse)
        for inst in r.body {
          self.compileInstruction(inst)
        }
        val right = self.irValueToQbeValue(r.result)
        val rightLabel = self.currentFn.block.currentLabel
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelCont)

        val phiCases = [(labelThen, left), (rightLabel, right)]
        try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable(e)
      }
      Operation.Xor(_, l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        try self.currentFn.block.buildXor(left, right, dst) else |e| unreachable(e)
      }
      Operation.Eq(negate, l, r) => {
        val left = self.irValueToQbeValue(l)
        val right = self.irValueToQbeValue(r)

        val res = if negate {
          try self.currentFn.block.buildCompareNeq(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        } else {
          try self.currentFn.block.buildCompareEq(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        }
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Lt(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Lt: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        val res = try self.currentFn.block.buildCompareLt(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Lte(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Lte: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        val res = try self.currentFn.block.buildCompareLte(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Shl(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() != right.ty() unreachable("Operation.Shl: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        self.currentFn.block.buildShl(left, right, dst)
      }
      Operation.Gt(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Lt: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        val res = try self.currentFn.block.buildCompareGt(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Gte(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() == qbe.QbeType.F64 && right.ty() != qbe.QbeType.F64 {
          right = self.currentFn.block.buildLToF(right, true, Some(self.nextTemp()))
        } else if left.ty() != qbe.QbeType.F64 && right.ty() == qbe.QbeType.F64 {
          left = self.currentFn.block.buildLToF(left, true, Some(self.nextTemp()))
        }

        if left.ty() != right.ty() unreachable("Operation.Lte: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        val res = try self.currentFn.block.buildCompareGte(left, right, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.Shr(l, r) => {
        var left = self.irValueToQbeValue(l)
        var right = self.irValueToQbeValue(r)

        if left.ty() != right.ty() unreachable("Operation.Shr: left.ty (${left.ty()}) != right.ty (${right.ty()})")

        self.currentFn.block.buildShr(left, right, dst)
      }
      Operation.LoadVar(ty, ident) => {
        val ptr = qbe.Value.Ident(name: ident.kind.name(), ty: self.irTypeToQbeType(ident.ty))
        self.currentFn.block.buildLoad(self.irTypeToQbeType(ty), ptr, dst)
      }
      Operation.LoadCapturedVar(ty, src, deref) => {
        val varTy = self.irTypeToQbeType(ty)
        match src {
          CaptureSource.WithinCapturingFn(idx, name, mutable) => {
            val env = try self.currentFnEnv else unreachable("Operation.LoadCapturedVar(idx: $idx, name: '$name'): no env for current function '${self.currentFn.name}'")
            val captureSlot = try self.currentFn.block.buildAdd(qbe.Value.Int(idx * 8), env, Some(self.nextTemp())) else |e| unreachable(e)

            if mutable {
              if deref {
                val varPtr = self.currentFn.block.buildLoadL(captureSlot, Some(self.nextTemp()))
                self.currentFn.block.buildLoad(varTy, varPtr, dst)
              } else {
                self.currentFn.block.buildLoadL(captureSlot, dst)
              }
            } else {
              self.currentFn.block.buildLoad(varTy, captureSlot, dst)
            }
          }
          CaptureSource.OutsideFn(ident) => {
            val varIdent = qbe.Value.Ident(name: ident.kind.name(), ty: varTy)
            if deref {
              val varPtr = self.currentFn.block.buildLoad(qbe.QbeType.Pointer, varIdent, Some(self.nextTemp()))
              self.currentFn.block.buildLoad(varTy, varPtr, dst)
            } else {
              self.currentFn.block.buildLoad(varTy, varIdent, dst)
            }
          }
        }
      }
      Operation.LoadField(ty, mem, _, offset) => {
        val ptr = if offset == 0 {
          self.irValueToQbeValue(mem)
        } else {
          val memVal = self.irValueToQbeValue(mem)
          try self.currentFn.block.buildAdd(qbe.Value.Int(offset), memVal, Some(self.nextTemp())) else |e| unreachable(e)
        }
        self.currentFn.block.buildLoad(self.irTypeToQbeType(ty), ptr, dst)
      }
      Operation.StoreVar(ty, value, ident) => {
        val v = self.irValueToQbeValue(value)
        val qbeTy = self.irTypeToQbeType(ty)
        val mem = qbe.Value.Ident(name: ident.kind.name(), ty: qbeTy)
        self.currentFn.block.buildStore(self.irTypeToQbeType(ty), v, mem)
      }
      Operation.StoreCapturedVar(ty, value, src) => {
        val varTy = self.irTypeToQbeType(ty)
        val v = self.irValueToQbeValue(value)
        match src {
          CaptureSource.WithinCapturingFn(idx, name, _) => {
            val env = try self.currentFnEnv else unreachable("Operation.StoreCapturedVar(idx: $idx, name: '$name'): no env for current function '${self.currentFn.name}'")
            val captureSlot = try self.currentFn.block.buildAdd(qbe.Value.Int(idx * 8), env, Some(self.nextTemp())) else |e| unreachable(e)

            val varPtr = self.currentFn.block.buildLoadL(captureSlot, Some(self.nextTemp()))
            self.currentFn.block.buildStore(varTy, v, varPtr)
          }
          CaptureSource.OutsideFn(ident) => {
            val ptr = qbe.Value.Ident(name: ident.kind.name(), ty: varTy)
            val varPtr = self.currentFn.block.buildLoadL(ptr, Some(self.nextTemp()))
            self.currentFn.block.buildStore(varTy, v, varPtr)
          }
        }
      }
      Operation.StoreGlobal(ty, value, global) => {
        val v = self.irValueToQbeValue(value)
        val qbeTy = self.irTypeToQbeType(ty)
        val mem = qbe.Value.Global(name: global.name, ty: qbeTy)
        self.currentFn.block.buildStore(self.irTypeToQbeType(ty), v, mem)
      }
      Operation.StoreField(ty, value, mem, _, offset) => {
        val ptr = if offset == 0 {
          self.irValueToQbeValue(mem)
        } else {
          val memVal = self.irValueToQbeValue(mem)
          try self.currentFn.block.buildAdd(qbe.Value.Int(offset), memVal, Some(self.nextTemp())) else |e| unreachable(e)
        }

        val v = self.irValueToQbeValue(value)
        self.currentFn.block.buildStore(self.irTypeToQbeType(ty), v, ptr)
      }
      Operation.If(ty, cond, thenBlock, elseBlock) => {
        val isStmt = ty == IrType.Unit
        val condVal = self.irValueToQbeValue(cond)

        val labelThen = self.currentFn.block.addLabel(thenBlock.name)
        val labelCont = self.currentFn.block.addLabel("cont")

        if !elseBlock.body.isEmpty() || !!elseBlock.result {
          val labelElse = self.currentFn.block.addLabel(elseBlock.name)

          self.currentFn.block.buildJnz(condVal, labelThen, labelElse)
          self.currentFn.block.registerLabel(labelThen)
          for inst in thenBlock.body {
            self.compileInstruction(inst)
          }
          if !thenBlock.terminates {
            self.currentFn.block.buildJmp(labelCont)
          }

          val thenPhiValue = if thenBlock.result |v| {
            val label = self.currentFn.block.currentLabel
            val thenVal = self.irValueToQbeValue(v)
            Some((label, thenVal))
          } else {
            None
          }

          self.currentFn.block.registerLabel(labelElse)
          for inst in elseBlock.body {
            self.compileInstruction(inst)
          }
          if !elseBlock.terminates {
            self.currentFn.block.buildJmp(labelCont)
          }
          val elsePhiValue = if elseBlock.result |v| {
            val label = self.currentFn.block.currentLabel
            val elseVal = self.irValueToQbeValue(v)
            Some((label, elseVal))
          } else {
            None
          }

          if !(thenBlock.terminates && elseBlock.terminates) {
            self.currentFn.block.registerLabel(labelCont)

            if !thenBlock.result && !elseBlock.result {
              // in if-exprs that are missing both then- and else-values, emit unreachable
              if !isStmt {
                self.currentFn.block.addComment("if-expr missing both then- and else-values")
                self.currentFn.block.buildHalt()
              }
            } else {
              val phiCases: (qbe.Label, qbe.Value)[] = []
              if thenPhiValue |(label, v)| phiCases.push((label, v))
              if elsePhiValue |(label, v)| phiCases.push((label, v))

              try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable("$e ($thenBlock) ($elseBlock)")
            }
          }
        } else {
          if !isStmt unreachable("must be a statement at this point")

          self.currentFn.block.buildJnz(condVal, labelThen, labelCont)
          self.currentFn.block.registerLabel(labelThen)
          for inst in thenBlock.body {
            self.compileInstruction(inst)
          }
          if !thenBlock.terminates {
            self.currentFn.block.buildJmp(labelCont)
          }

          self.currentFn.block.registerLabel(labelCont)
        }
      }
      Operation.WhileLoopStart(name) => {
        val labelCond = self.currentFn.block.addLabel("${name}_cond")
        self.loopStack.push((labelCond, labelCond))
        self.currentFn.block.registerLabel(labelCond)
      }
      Operation.While(cond, body) => {
        val labelCond = if self.loopStack.pop() |(loopStartLabel, _)| loopStartLabel else unreachable("unexpected empty loop stack")
        val labelBody = self.currentFn.block.addLabel("${body.name}_body")
        val labelCont = self.currentFn.block.addLabel("${body.name}_cont")

        self.loopStack.push((labelCond, labelCont))

        val condVal = self.irValueToQbeValue(cond)
        self.currentFn.block.buildJnz(condVal, labelBody, labelCont)

        self.currentFn.block.registerLabel(labelBody)
        for inst in body.body {
          self.compileInstruction(inst)
        }
        if !body.terminates {
          self.currentFn.block.buildJmp(labelCond)
        }

        self.currentFn.block.registerLabel(labelCont)

        self.loopStack.pop()
      }
      Operation.ForRanged(start, end, iteratee, idx, body) => {
        val labelCond = self.currentFn.block.addLabel("${body.name}_cond")
        val labelBody = self.currentFn.block.addLabel("${body.name}_body")
        val labelInc = self.currentFn.block.addLabel("${body.name}_inc")
        val labelCont = self.currentFn.block.addLabel("${body.name}_cont")

        self.loopStack.push((labelInc, labelCont))

        val itSlot = self.currentFn.block.buildAlloc8(1, Some(iteratee.kind.name()))
        val startVal = self.irValueToQbeValue(start)
        self.currentFn.block.buildStoreL(startVal, itSlot)

        val idxSlot = if idx |idx| {
          val slot = self.currentFn.block.buildAlloc8(1, Some(idx.kind.name()))
          self.currentFn.block.buildStoreL(qbe.Value.Int(0), slot)
          Some(slot)
        } else {
          None
        }

        self.currentFn.block.registerLabel(labelCond)
        val itVal = self.currentFn.block.buildLoadL(itSlot, Some(self.nextTemp()))
        for inst in end.body {
          self.compileInstruction(inst)
        }
        val endVal = self.irValueToQbeValue(end.result)
        val condVal = try self.currentFn.block.buildCompareLt(itVal, endVal, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildJnz(condVal, labelBody, labelCont)

        self.currentFn.block.registerLabel(labelBody)
        for inst in body.body {
          self.compileInstruction(inst)
        }
        if !body.terminates {
          self.currentFn.block.registerLabel(labelInc)

          val itVal = self.currentFn.block.buildLoadL(itSlot, Some(self.nextTemp()))
          val itPlusOne = try self.currentFn.block.buildAdd(qbe.Value.Int(1), itVal, Some(self.nextTemp())) else |e| unreachable(e)
          self.currentFn.block.buildStoreL(itPlusOne, itSlot)

          if idxSlot |idxSlot| {
            val idxVal = self.currentFn.block.buildLoadL(idxSlot, Some(self.nextTemp()))
            val idxPlusOne = try self.currentFn.block.buildAdd(qbe.Value.Int(1), idxVal, Some(self.nextTemp())) else |e| unreachable(e)
            self.currentFn.block.buildStoreL(idxPlusOne, idxSlot)
          }

          self.currentFn.block.buildJmp(labelCond)
        }

        self.currentFn.block.registerLabel(labelCont)

        self.loopStack.pop()
      }
      Operation.FunctionPointer(fnName) => {
        val shl = try self.currentFn.block.buildShl(qbe.Value.Global(fnName, qbe.QbeType.Pointer), qbe.Value.Int(1), Some(self.nextTemp())) else |e| unreachable(e)
        try self.currentFn.block.buildOr(shl, qbe.Value.Int(1), dst) else |e| unreachable(e)
      }
      Operation.CreateClosure(fnName, captures, capturedSelf) => {
        val closureMem = self.callMalloc(qbe.Value.Int((captures.length + 2) * 8), dst)

        val capturedSelfVal = if capturedSelf |capturedSelf| {
          self.irValueToQbeValue(capturedSelf)
        } else {
          qbe.Value.Int(0)
        }

        self.currentFn.block.buildStore(capturedSelfVal.ty(), capturedSelfVal, closureMem)

        val cursor = try self.currentFn.block.buildAdd(qbe.Value.Int(8), closureMem, Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildStoreL(qbe.Value.Global(fnName, qbe.QbeType.Pointer), cursor)


        for capture, idx in captures {
          val cursor = try self.currentFn.block.buildAdd(qbe.Value.Int((idx + 2) * 8), closureMem, Some(self.nextTemp())) else |e| unreachable(e)
          val captureVal = self.irValueToQbeValue(capture)
          self.currentFn.block.buildStore(captureVal.ty(), captureVal, cursor)
        }
      }
      Operation.Call(ret, fnName, args, envLocation) => {
        val env = match envLocation {
          None => None
          ClosureEnvLocation.Passthrough => {
            val env = try self.currentFn.env else unreachable("fn '$fnName' defined with passthrough closure env location, but no env declared in scope")
            Some(env)
          }
        }
        val argVals = args.map(a => self.irValueToQbeValue(a))
        if self.irTypeToQbeReturnType(ret) |ret| {
          try self.currentFn.block.buildCallRaw(fnName, ret, argVals, dst, env) else |e| unreachable(e)
        } else {
          self.currentFn.block.buildVoidCallRaw(fnName, argVals, env)
        }
      }
      Operation.CallValue(ret, fn, args) => {
        val fnValQbe = self.irValueToQbeValue(fn)
        val argVals = [fnValQbe]
        val argTypes: qbe.QbeType[] = []
        for arg in args {
          val qbeVal = self.irValueToQbeValue(arg)
          argVals.push(qbeVal)
          argTypes.push(qbeVal.ty())
        }

        val retTy = self.irTypeToQbeReturnType(ret)
        val callFn = self.getOrGenerateFnValCallFunction(argTypes, retTy)
        if retTy {
          try self.currentFn.block.buildCall(qbe.Callable.Function(callFn), argVals, dst) else |e| unreachable(e)
        } else {
          self.currentFn.block.buildVoidCall(qbe.Callable.Function(callFn), argVals)
        }
      }
      Operation.Break => {
        if self.loopStack[-1] |(_, loopEndLabel)| {
          self.currentFn.block.buildJmp(loopEndLabel)

          Ok(None)
        } else {
          unreachable("cannot have a break statement outside of a loop")
        }
      }
      Operation.Continue => {
        if self.loopStack[-1] |(loopStartLabel, _)| {
          self.currentFn.block.buildJmp(loopStartLabel)
        } else {
          unreachable("cannot have a continue statement outside of a loop")
        }
      }
      Operation.Return(value) => {
        if value |v| {
          self.currentFn.block.buildReturn(Some(self.irValueToQbeValue(v)))
        } else {
          self.currentFn.block.buildReturn()
        }
      }
      Operation.Unreachable(message) => {
        self.currentFn.block.addComment(message)
        self.currentFn.block.buildHalt()
      }
      Operation.GetEnumVariantIdx(value, numVariants) => {
        val v = self.irValueToQbeValue(value)

        val labelThen = self.currentFn.block.addLabel("variant_idx_is_const_variant")
        val labelElse = self.currentFn.block.addLabel("variant_idx_is_container")
        val labelCont = self.currentFn.block.addLabel("variant_idx_cont")
        val cond = try self.currentFn.block.buildCompareLt(v, qbe.Value.Int(numVariants), Some(self.nextTemp())) else |e| unreachable(e)
        self.currentFn.block.buildJnz(cond, labelThen, labelElse)

        self.currentFn.block.registerLabel(labelThen)
        val thenVal = v
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelElse)
        val elseVal = self.currentFn.block.buildLoadL(v, Some(self.nextTemp()))
        self.currentFn.block.buildJmp(labelCont)

        self.currentFn.block.registerLabel(labelCont)

        val phiCases = [(labelThen, thenVal), (labelElse, elseVal)]
        try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable(e)
      }
      Operation.OptionNone(innerTy) => {
        match innerTy {
          IrType.F64 => {
            // A None instance of type `Float?` is represented as a IEEE 754 Quiet NaN, with the lsb also set (to
            // distinguish it from an actual NaN, in which the lsb is unset):
            // 0b0_11111111111_1100000000000000000000000000000000000000000000000001
            //   S EEEEEEEEEEE MMMM ...                                    ... MMMM
            // (All exp bits + msb of mantissa set = Quiet NaN). 2nd msb of mantissa is set to avoid conflict with
            // Intel's QNaN Floating-Point Indefinite value.
            self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0x7ffc000000000001), dst)
          }
          IrType.Bool => {
            self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(2), dst)
          }
          IrType.Composite(_, isEnum) => {
            if isEnum {
              // Enum values can either be a 64 bit integer or a pointer to a chunk of memory containing field values.
              // A None value of `T?`, where T is an enum, must not be 0 because then it would be indistinguishable
              // from a Some value of the first variant (which, for a Constant variant, would just be the literal 0).
              // So instead, a None value here is represented as U64_MAX value, since it's near impossible that there
              // will ever be an enum which has that many variants.
              self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0xffffffffffffffff), dst)
            } else {
              self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
            }
          }
          else => {
            self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
          }
        }
      }
      Operation.OptionSome(innerTy, value) => {
        val qbeVal = self.irValueToQbeValue(value)
        if innerTy == IrType.I64 {
          val mem = self.callMalloc(qbe.Value.Int(8), dst)
          self.currentFn.block.buildStoreL(qbeVal, mem)
        } else if innerTy == IrType.F64 {
          self.currentFn.block.buildCast(qbe.QbeType.U64, qbeVal, dst)
        } else {
          try self.currentFn.block.buildAdd(qbe.Value.Int(0), qbeVal, dst) else |e| unreachable(e)
        }
      }
      Operation.OptionIsNone(innerTy, value) => {
        val qbeVal = self.irValueToQbeValue(value)
        val res = match innerTy {
          IrType.F64 => {
            // Check for None instance of type `Float?` by comparing against magic value (see comment above in Operation.OptionNone)
            try self.currentFn.block.buildCompareEq(qbe.Value.Int(0x7ffc000000000001), qbeVal, Some(self.nextTemp())) else |e| unreachable(e)
          }
          IrType.Bool => {
            try self.currentFn.block.buildCompareEq(qbe.Value.Int(2), qbeVal, Some(self.nextTemp())) else |e| unreachable(e)
          }
          IrType.Composite(_, isEnum) => {
            if isEnum {
              // Check for None instance by comparing against magic value of U64_MAX (see comment above in Operation.OptionNone)
              try self.currentFn.block.buildCompareEq(qbe.Value.Int(0xfffffffffffffffff), qbeVal, Some(self.nextTemp())) else |e| unreachable(e)
            } else {
              try self.currentFn.block.buildCompareEq(qbe.Value.Int(0), qbeVal, Some(self.nextTemp())) else |e| unreachable(e)
            }
          }
          else => {
            try self.currentFn.block.buildCompareEq(qbe.Value.Int(0), qbeVal, Some(self.nextTemp())) else |e| unreachable(e)
          }
        }
        self.currentFn.block.buildExt(res, false, dst)
      }
      Operation.OptionUnwrap(innerTy, value) => {
        val qbeVal = self.irValueToQbeValue(value)
        if innerTy == IrType.I64 {
          self.currentFn.block.buildLoadL(qbeVal, dst)
        } else if innerTy == IrType.F64 {
          self.currentFn.block.buildCast(qbe.QbeType.F64, qbeVal, dst)
        } else {
          try self.currentFn.block.buildAdd(qbe.Value.Int(0), qbeVal, dst) else |e| unreachable(e)
        }
      }
      Operation.StructuredToString(prefix, lenVal, fields) => self.compileStructuredToString(prefix, lenVal, fields, dst)
      Operation.Builtin(_, builtin) => {
        val sizeOfType = (irType: IrType) => match irType {
          IrType.Unit => unreachable("values cannot be of type unit")
          IrType.I64 => (8, QbeType.U64)
          IrType.F64 => (8, QbeType.F64)
          IrType.Bool => (8, QbeType.U64)
          IrType.Byte => (1, QbeType.U8)
          IrType.Composite => (8, QbeType.U64)
          IrType.Ptr => (8, QbeType.U64)
        }

        match builtin {
          Builtin.Malloc(count, itemTy) => {
            val countVal = self.irValueToQbeValue(count)
            val (size, _) = sizeOfType(itemTy)
            val sizeVal = try self.currentFn.block.buildMul(qbe.Value.Int(size), countVal, Some(self.nextTemp())) else |e| unreachable(e)

            self.callMalloc(sizeVal, dst)
          }
          Builtin.Realloc(ptr, count, itemTy) => {
            val ptrVal = self.irValueToQbeValue(ptr)
            val countVal = self.irValueToQbeValue(count)
            val sizeVal = if itemTy |itemTy| {
              val (size, _) = sizeOfType(itemTy)
              try self.currentFn.block.buildMul(qbe.Value.Int(size), countVal, Some(self.nextTemp())) else |e| unreachable(e)
            } else {
              countVal
            }

            self.callRealloc(ptrVal, sizeVal, dst)
          }
          Builtin.Store(ptr, value, offset, itemTy) => {
            val ptrVal = self.irValueToQbeValue(ptr)
            val valueVal = self.irValueToQbeValue(value)
            val offsetVal = self.irValueToQbeValue(offset)

            val (size, qbeTy) = sizeOfType(itemTy)
            val sizeVal = try self.currentFn.block.buildMul(qbe.Value.Int(size), offsetVal, Some(self.nextTemp())) else |e| unreachable(e)
            val mem = try self.currentFn.block.buildAdd(sizeVal, ptrVal, Some(self.nextTemp())) else |e| unreachable(e)

            if size == 1 {
              self.currentFn.block.buildStoreB(valueVal, mem)
            } else {
              self.currentFn.block.buildStore(qbeTy, valueVal, mem)
            }
          }
          Builtin.Load(ptr, offset, itemTy) => {
            val ptrVal = self.irValueToQbeValue(ptr)
            val offsetVal = self.irValueToQbeValue(offset)

            val (size, qbeTy) = sizeOfType(itemTy)
            val sizeVal = try self.currentFn.block.buildMul(qbe.Value.Int(size), offsetVal, Some(self.nextTemp())) else |e| unreachable(e)
            val mem = try self.currentFn.block.buildAdd(sizeVal, ptrVal, Some(self.nextTemp())) else |e| unreachable(e)

            if size == 1 {
              self.currentFn.block.buildLoadB(mem, dst)
            } else {
              self.currentFn.block.buildLoad(qbeTy, mem, dst)
            }
          }
          Builtin.CopyFrom(dst, dstOffset, src, srcOffset, count, itemTy) => {
            val dstVal = self.irValueToQbeValue(dst)
            val dstOffsetVal = self.irValueToQbeValue(dstOffset)
            val srcVal = self.irValueToQbeValue(src)
            val srcOffsetVal = self.irValueToQbeValue(srcOffset)
            val countVal = self.irValueToQbeValue(count)

            val (size, _) = sizeOfType(itemTy)
            self.compileMemcpy(dstVal, dstOffsetVal, srcVal, srcOffsetVal, countVal, qbe.Value.Int(size))
          }
          Builtin.I64ToString(int) => {
            self.builtinI64ToStringUsed = true

            val intVal = self.irValueToQbeValue(int)
            val lenPtr = self.currentFn.block.buildAlloc8(1, Some("lenptr"))
            val mem = try self.currentFn.block.buildCallRaw(i64ToString.name, qbe.QbeType.Pointer, [intVal, lenPtr], Some(self.nextTemp())) else |e| unreachable(e)
            val lenVal = self.currentFn.block.buildLoadL(lenPtr, Some(self.nextTemp()))
            self.constructString(mem, lenVal, dst)
          }
          Builtin.U64ToString(int) => {
            self.builtinU64ToStringUsed = true

            val intVal = self.irValueToQbeValue(int)
            val lenPtr = self.currentFn.block.buildAlloc8(1, Some("lenptr"))
            val mem = try self.currentFn.block.buildCallRaw(u64ToString.name, qbe.QbeType.Pointer, [intVal, lenPtr], Some(self.nextTemp())) else |e| unreachable(e)
            val lenVal = self.currentFn.block.buildLoadL(lenPtr, Some(self.nextTemp()))
            self.constructString(mem, lenVal, dst)
          }
          Builtin.F64ToString(float) => {
            self.builtinF64ToStringUsed = true

            val floatVal = self.irValueToQbeValue(float)
            val lenPtr = self.currentFn.block.buildAlloc8(1, Some("lenptr"))
            val mem = try self.currentFn.block.buildCallRaw(f64ToString.name, qbe.QbeType.Pointer, [floatVal, lenPtr], Some(self.nextTemp())) else |e| unreachable(e)
            val lenVal = self.currentFn.block.buildLoadL(lenPtr, Some(self.nextTemp()))
            self.constructString(mem, lenVal, dst)
          }
          Builtin.BoolToString(bool) => {
            val boolVal = self.irValueToQbeValue(bool)

            val labelTrue = self.currentFn.block.addLabel("true")
            val labelFalse = self.currentFn.block.addLabel("false")
            val labelCont = self.currentFn.block.addLabel("cont")
            self.currentFn.block.buildJnz(boolVal, labelTrue, labelFalse)

            val phiCases: (qbe.Label, qbe.Value)[] = []

            self.currentFn.block.registerLabel(labelTrue)
            phiCases.push((labelTrue, self.makeConstString("true")))
            self.currentFn.block.buildJmp(labelCont)

            self.currentFn.block.registerLabel(labelFalse)
            phiCases.push((labelFalse, self.makeConstString("false")))
            self.currentFn.block.buildJmp(labelCont)

            self.currentFn.block.registerLabel(labelCont)
            try self.currentFn.block.buildPhi(phiCases, dst) else |e| unreachable(e)
          }
          Builtin.IntAsFloat(int) => {
            val intVal = self.irValueToQbeValue(int)

            self.currentFn.block.buildLToF(intVal, true, dst)
          }
          Builtin.FloatAsInt(float) => {
            val floatVal = self.irValueToQbeValue(float)

            self.currentFn.block.buildFToL(floatVal, true, dst)
          }
          Builtin.FloatCeil(float) => {
            val floatVal = self.irValueToQbeValue(float)

            val ceilRes = try self.currentFn.block.buildCallRaw("ceil", QbeType.F64, [floatVal], Some(self.nextTemp())) else |e| unreachable(e)
            self.currentFn.block.buildFToL(ceilRes, true, dst)
          }
          Builtin.FloatFloor(float) => {
            val floatVal = self.irValueToQbeValue(float)

            val floorRes = try self.currentFn.block.buildCallRaw("floor", QbeType.F64, [floatVal], Some(self.nextTemp())) else |e| unreachable(e)
            self.currentFn.block.buildFToL(floorRes, true, dst)
          }
          Builtin.FloatRound(float) => {
            val floatVal = self.irValueToQbeValue(float)

            val roundRes = try self.currentFn.block.buildCallRaw("round", QbeType.F64, [floatVal], Some(self.nextTemp())) else |e| unreachable(e)
            self.currentFn.block.buildFToL(roundRes, true, dst)
          }
          Builtin.FloatBitsToInt(float) => {
            val floatVal = self.irValueToQbeValue(float)

            self.currentFn.block.buildCast(qbe.QbeType.U64, floatVal, dst)
          }
          Builtin.Uninitialized => {
            self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
          }
          // TODO: real implementations for callstack, modulenames, and functionnames
          Builtin.Callstack => {
            self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
          }
          Builtin.CallstackPtr => {
            self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
          }
          Builtin.ModuleNames => {
            self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
          }
          Builtin.FunctionNames => {
            self.currentFn.block.buildAdd(qbe.Value.Int(0), qbe.Value.Int(0), dst)
          }
        }
      }
    }
  }

  func compileStructuredToString(self, prefix: String, lenVal: Value, fields: (IrType, String, Value)[], dst: String?): qbe.Value {
    val strIrTy = IrType.Composite(self.ir.knowns.stringType().name, isEnum: false)

    val lenQbeVal = self.irValueToQbeValue(lenVal)
    val lenPlusOneQbeVal = try self.currentFn.block.buildAdd(qbe.Value.Int(1), lenQbeVal, Some(self.nextTemp())) else |e| unreachable(e)
    val buf = self.callMalloc(lenPlusOneQbeVal, Some(self.nextTemp()))

    val prefixVal = self.makeConstString(prefix)
    val (prefixLen, prefixBuf) = self.strValGetParts(prefixVal)

    self.compileMemcpy(buf, qbe.Value.Int(0), prefixBuf, qbe.Value.Int(0), prefixLen, qbe.Value.Int(1))
    var offsetVal = prefixLen

    offsetVal = self._insertCharAt('(', buf, offsetVal)

    for (fieldIrType, fieldName, fieldStrValue), idx in fields {
      val fieldNameVal = self.makeConstString(fieldName)
      val (fieldNameLen, fieldNameBuf) = self.strValGetParts(fieldNameVal)

      self.compileMemcpy(buf, offsetVal, fieldNameBuf, qbe.Value.Int(0), fieldNameLen, qbe.Value.Int(1))
      offsetVal = try self.currentFn.block.buildAdd(offsetVal, fieldNameLen, Some(self.nextTemp())) else |e| unreachable(e)

      if !fieldName.isEmpty() {
        offsetVal = self._insertCharAt(':', buf, offsetVal)
        offsetVal = self._insertCharAt(' ', buf, offsetVal)
      }

      val fieldStrQbeVal = self.irValueToQbeValue(fieldStrValue)
      val (fieldStrLen, fieldStrBuf) = self.strValGetParts(fieldStrQbeVal)
      if fieldIrType == strIrTy { offsetVal = self._insertCharAt('"', buf, offsetVal) }
      self.compileMemcpy(buf, offsetVal, fieldStrBuf, qbe.Value.Int(0), fieldStrLen, qbe.Value.Int(1))
      offsetVal = try self.currentFn.block.buildAdd(offsetVal, fieldStrLen, Some(self.nextTemp())) else |e| unreachable(e)
      if fieldIrType == strIrTy { offsetVal = self._insertCharAt('"', buf, offsetVal) }

      if idx != fields.length - 1 {
        offsetVal = self._insertCharAt(',', buf, offsetVal)
        offsetVal = self._insertCharAt(' ', buf, offsetVal)
      }
    }
    self._insertCharAt(')', buf, offsetVal)

    self.constructString(buf, lenQbeVal, dst)
  }

  // helper function, used within `#compileStructuredToString`
  // TODO: support nested methods for scoping?
  func _insertCharAt(self, ch: Char, buf: qbe.Value, offsetVal: qbe.Value): qbe.Value {
    val cursor = try self.currentFn.block.buildAdd(offsetVal, buf, Some(self.nextTemp())) else |e| unreachable(e)
    self.currentFn.block.buildStoreB(qbe.Value.Int(ch.asInt()), cursor)
    try self.currentFn.block.buildAdd(offsetVal, qbe.Value.Int(1), Some(self.nextTemp())) else |e| unreachable(e)
  }

  func getOrGenerateFnValCallFunction(self, argTypes: qbe.QbeType[], retTy: qbe.QbeType?): qbe.QbeFunction {
    val argTypesRepr = argTypes.map(t => t.repr()).join()
    val retTyRepr = retTy?.repr() ?: "unit"

    val key = "($argTypesRepr)->$retTyRepr"
    if self.callFunctions[key] |fn| return fn

    val prevFn = self.currentFn
    val prevTemps = self.numTemps
    val f = self.builder.buildFunction(name: "__call_fn_${argTypesRepr}_${retTyRepr}__", returnType: retTy)
    self.callFunctions[key] = f

    self.currentFn = f
    self.numTemps = 0

    val fnVal = f.addParameter("fn_val", qbe.QbeType.Pointer)
    val argVals = argTypes.map((ty, idx) => f.addParameter("arg_$idx", ty))

    val isFnPtrCond = try self.currentFn.block.buildAnd(fnVal, qbe.Value.Int(1), Some(self.nextTemp())) else |e| unreachable(e)
    val labelIsRawFnPtr = self.currentFn.block.addLabel("fn_is_ptr_true")
    val labelIsFnValue = self.currentFn.block.addLabel("fn_is_ptr_false")
    val labelCont = self.currentFn.block.addLabel("fn_is_ptr_cont")
    self.currentFn.block.buildJnz(isFnPtrCond, labelIsRawFnPtr, labelIsFnValue)

    val phiCases: (qbe.Label, qbe.Value)[] = []

    self.currentFn.block.registerLabel(labelIsRawFnPtr)
    val fnPtr = try self.currentFn.block.buildShr(fnVal, qbe.Value.Int(1), Some(self.nextTemp())) else |e| unreachable(e)
    if retTy |ret| {
      val fnPtrResult = try self.currentFn.block.buildCall(qbe.Callable.Value(fnPtr, Some(ret)), argVals, Some(self.nextTemp())) else |e| unreachable(e)
      phiCases.push((labelIsRawFnPtr, fnPtrResult))
    } else {
      self.currentFn.block.buildVoidCall(qbe.Callable.Value(fnPtr, None), argVals)
    }
    self.currentFn.block.buildJmp(labelCont)

    self.currentFn.block.registerLabel(labelIsFnValue)
    val capturedSelfVal = self.currentFn.block.buildLoadL(fnVal, Some(self.nextTemp()))
    val closureFnPtr = self.currentFn.block.buildLoadL(
      try self.currentFn.block.buildAdd(qbe.Value.Int(8), fnVal, Some(self.nextTemp())) else |e| unreachable(e),
      Some(self.nextTemp())
    )
    val closureCapturesPtr = try self.currentFn.block.buildAdd(qbe.Value.Int(16), fnVal, Some(self.nextTemp())) else |e| unreachable(e)

    val labelHasCapturedSelf = self.currentFn.block.addLabel("fn_captured_self_true")
    val labelHasNoCapturedSelf = self.currentFn.block.addLabel("fn_captured_self_false")
    val labelCapturedSelfCont = self.currentFn.block.addLabel("fn_captured_self_cont")
    self.currentFn.block.buildJnz(capturedSelfVal, labelHasCapturedSelf, labelHasNoCapturedSelf)

    self.currentFn.block.registerLabel(labelHasCapturedSelf)
    val capturedSelfArgVals = [capturedSelfVal].concat(argVals)
    if retTy |ret| {
      val capturedSelfRes = try self.currentFn.block.buildCall(qbe.Callable.Value(closureFnPtr, Some(ret)), capturedSelfArgVals, Some(self.nextTemp()), Some(closureCapturesPtr)) else |e| unreachable(e)
      self.currentFn.block.buildJmp(labelCapturedSelfCont)

      self.currentFn.block.registerLabel(labelHasNoCapturedSelf)
      val noCapturedSelfRes = try self.currentFn.block.buildCall(qbe.Callable.Value(closureFnPtr, Some(ret)), argVals, Some(self.nextTemp()), Some(closureCapturesPtr)) else |e| unreachable(e)
      self.currentFn.block.buildJmp(labelCapturedSelfCont)

      self.currentFn.block.registerLabel(labelCapturedSelfCont)
      val closureResult = try self.currentFn.block.buildPhi([(labelHasCapturedSelf, capturedSelfRes), (labelHasNoCapturedSelf, noCapturedSelfRes)], Some(self.nextTemp())) else |e| unreachable(e)

      phiCases.push((labelCapturedSelfCont, closureResult))
    } else {
      self.currentFn.block.buildVoidCall(qbe.Callable.Value(closureFnPtr, None), capturedSelfArgVals, Some(closureCapturesPtr))
      self.currentFn.block.buildJmp(labelCapturedSelfCont)

      self.currentFn.block.registerLabel(labelHasNoCapturedSelf)
      self.currentFn.block.buildVoidCall(qbe.Callable.Value(closureFnPtr, None), argVals, Some(closureCapturesPtr))
      self.currentFn.block.buildJmp(labelCapturedSelfCont)

      self.currentFn.block.registerLabel(labelCapturedSelfCont)
    }
    self.currentFn.block.buildJmp(labelCont)

    self.currentFn.block.registerLabel(labelCont)
    if retTy {
      val res = try self.currentFn.block.buildPhi(phiCases, Some(self.nextTemp())) else |e| unreachable(e)
      self.currentFn.block.buildReturn(Some(res))
    } else {
      self.currentFn.block.buildReturn()
    }

    self.currentFn = prevFn
    self.numTemps = prevTemps

    f
  }

  func compileMemcpy(self, dstPtr: qbe.Value, dstOffset: qbe.Value, srcPtr: qbe.Value, srcOffset: qbe.Value, amount: qbe.Value, itemSize: qbe.Value) {
    val dstMem = try self.currentFn.block.buildAdd(
      try self.currentFn.block.buildMul(itemSize, dstOffset, Some(self.nextTemp())) else |e| unreachable(e),
      dstPtr,
      Some(self.nextTemp()),
    ) else |e| unreachable(e)
    val srcMem = try self.currentFn.block.buildAdd(
      try self.currentFn.block.buildMul(itemSize, srcOffset, Some(self.nextTemp())) else |e| unreachable(e),
      srcPtr,
      Some(self.nextTemp()),
    ) else |e| unreachable(e)
    val numBytes = try self.currentFn.block.buildMul(itemSize, amount, Some(self.nextTemp())) else |e| unreachable(e)

    self.currentFn.block.buildVoidCall(qbe.Callable.Function(self.memcpyFn), [dstMem, srcMem, numBytes])
  }

  func nextTemp(self): String {
    val name = "_t${self.numTemps}"
    self.numTemps += 1
    name
  }

  func irTypeToQbeType(self, irType: IrType): qbe.QbeType {
    match irType {
      IrType.I64 => QbeType.U64
      IrType.F64 => QbeType.F64
      IrType.Bool => QbeType.U64
      IrType.Composite => QbeType.U64 // pointer to GC'd object
      IrType.Ptr => QbeType.U64 // raw pointer
      IrType.Unit => unreachable("values cannot be of type Unit")
      IrType.Byte => QbeType.U64 // treat bytes as longs when they're ordinary values; but use `loadb`/`storeb`
    }
  }

  func irTypeToQbeReturnType(self, irType: IrType): qbe.QbeType? = match irType { IrType.Unit => None, else t => Some(self.irTypeToQbeType(t)) }

  func irConstToQbeValue(self, const: Const): qbe.Value = match const {
    Const.Int(i) => qbe.Value.Int(i)
    Const.Float(f) => qbe.Value.Float(f)
    Const.Bool(b) => qbe.Value.Int(if b 1 else 0)
    Const.Char(c) => qbe.Value.Int(c)
    Const.String(s) => self.makeConstString(s)
  }

  func irValueToQbeValue(self, v: Value): qbe.Value {
    match v {
      Value.Unit => unreachable("values cannot be of type unit")
      Value.Const(const) => self.irConstToQbeValue(const)
      Value.Ident(i) => {
        val ty = self.irTypeToQbeType(i.ty)
        qbe.Value.Ident(name: i.kind.name(), ty: ty)
      }
      Value.Global(g) => {
        val ty = self.irTypeToQbeType(g.ty)
        self.currentFn.block.buildLoad(ty, qbe.Value.Global(name: g.name, ty: ty), Some(self.nextTemp()))
      }
    }
  }

  func makeConstString(self, s: String): qbe.Value {
    val str = s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"").replaceAll("\n", "\\n").replaceAll("\r", "\\r")
    val (dataPtr, data, newlyAdded) = self.builder.buildGlobalString(str)

    val globalName = "${data.name}str"
    if newlyAdded {
      val (slot, _) = self.builder.addData(qbe.QbeData(
        name: globalName,
        kind: qbe.QbeDataKind.Constants([(qbe.QbeType.U64, qbe.Value.Int(s.length)), (qbe.QbeType.Pointer, dataPtr)])
      ))
      slot
    } else {
      qbe.Value.Global(name: globalName, ty: qbe.QbeType.Pointer)
    }
  }

  func strValGetParts(self, strVal: qbe.Value): (qbe.Value, qbe.Value) {
    val strLen = self.currentFn.block.buildLoadL(
      try self.currentFn.block.buildAdd(qbe.Value.Int(0), strVal, Some(self.nextTemp())) else |e| unreachable(e),
      Some(self.nextTemp()),
    )
    val strBuf = self.currentFn.block.buildLoadL(
      try self.currentFn.block.buildAdd(qbe.Value.Int(8), strVal, Some(self.nextTemp())) else |e| unreachable(e),
      Some(self.nextTemp()),
    )

    (strLen, strBuf)
  }

  func constructString(self, ptrVal: qbe.Value, lenVal: qbe.Value, dst: String? = None): qbe.Value {
    val strTy = self.irTypeToQbeType(IrType.Composite(self.ir.knowns.stringType().name, isEnum: false))
    val strInitFn = self.ir.knowns.stringInitializerFn()
    try self.currentFn.block.buildCallRaw(strInitFn.name, strTy, [lenVal, ptrVal], dst) else |e| unreachable(e)
  }

  func callMalloc(self, sizeVal: qbe.Value, dst: String? = None): qbe.Value {
    try self.currentFn.block.buildCall(qbe.Callable.Function(self.mallocFn), [sizeVal], dst) else |e| unreachable(e)
  }

  func callRealloc(self, ptrVal: qbe.Value, sizeVal: qbe.Value, dst: String? = None): qbe.Value {
    try self.currentFn.block.buildCall(qbe.Callable.Function(self.reallocFn), [ptrVal, sizeVal], dst) else |e| unreachable(e)
  }
}
