// When executed directly, this will perform typechecking and compilation, using javascript as
// the compilation target.
//
// Example usage (from projects/compiler):
//   abra ./src/target-js/ir_compiler_js.cmd.abra ./example.abra
//   node ./._abra/_main_wrapper.mjs

import "fs" as fs
import "process" as process
import getAbsolutePath from "../utils"
import ModuleLoader, Project, Typechecker, TypedModule from "../typechecker"
import Generator, Writer from "../ir"
import Compiler from "./ir_compiler_js"
import ComptimeFunctionEvaluator from "../comptime_evaluator"

func main() {
  val abraStdRoot = try process.getEnvVar("ABRA_HOME") else {
    stdoutWriteln("Could not find ABRA_HOME (make sure \$ABRA_HOME environment variable is set)")
    process.exit(1)
  }

  val args = process.args()

  if args[1] |fileName| {
    val absPathSegs = getAbsolutePath(fileName)
    val filePathAbs = "/" + absPathSegs.join("/")

    val moduleLoader = ModuleLoader(stdRoot: abraStdRoot)
    val project = Project()
    val comptimeFuncEvaluator = ComptimeFunctionEvaluator.init(project)
    val typechecker = Typechecker(moduleLoader: moduleLoader, project: project, comptimeFuncEvaluator: comptimeFuncEvaluator.eval)

    typechecker.typecheckEntrypoint(filePathAbs)

    val readFileErrors: String[] = []
    val errorMessages: String[] = []
    for mod in project.modules.values().sortBy(m => -m.id) {
      if mod.readFileError {
        readFileErrors.push(mod.name)
        continue
      }
      val contents = try moduleLoader.loadFileContents(mod.name) else {
        readFileErrors.push(mod.name)
        continue
      }

      for err in mod.lexParseErrors {
        errorMessages.push(err.getMessage(mod.name, contents))
      }

      for err in mod.typeErrors {
        errorMessages.push(err.getMessage(mod.name, contents))
      }
    }

    if !errorMessages.isEmpty() {
      for msg, idx in errorMessages {
        stdoutWriteln(msg)
        if idx != errorMessages.length - 1 stdoutWriteln("") // spacer
      }
      process.exit(1)
    } else if !readFileErrors.isEmpty() {
      for path, idx in readFileErrors {
        stdoutWriteln("Could not read file '$path'")
        if idx != readFileErrors.length - 1 stdoutWriteln("") // spacer
      }
      process.exit(1)
    }

    val ir = Generator.generateIR(project, foldConstants: true)

    // TODO: right now the code assumes that the output file and directory will exist prior to writing
    // to it. Instead, we should create the directory and file if we need to.
    val cwd = fs.getCurrentWorkingDirectory()
    val outFileName = args[2] ?: "_main"
    val outPath = "$cwd/._abra/$outFileName.mjs"
    val outFile = match fs.openFile(outPath, fs.AccessMode.WriteOnly) {
      Ok(v) => v
      Err(e) => {
        stdoutWriteln(e.toString())
        process.exit(1)
      }
    }

    val writer = Writer(write: str => outFile.write(str))
    Compiler.compile(ir, writer)
  } else {
    stdoutWriteln("Missing required argument <file-name>")
    process.exit(1)
  }
}

main()
