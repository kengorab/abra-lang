// Test raw construction of map
if true {
  val m0: Map<Int, String> = Map.new()
  /// Expect: {}
  println(m0)

  val m1: Map<Int, String> = Map.new()
  m1.insert(24, "hello")
  /// Expect: { 24: hello }
  println(m1)

  val m2: Map<Int, String> = Map.new()
  m2.insert(24, "hello")
  m2.insert(17, "bonjour")
  /// Expect: { 17: bonjour, 24: hello }
  println(m2)

  // Forcing a hash-collision
  val m3: Map<Int, String> = Map.new()
  m3.insert(1, "hello")
  m3.insert(m3.getCapacity() + 1, "world")
  /// Expect: { 1: hello, 17: world }
  println(m3)
}

// Test map literal construction
if true {
  val m0: Map<Int, String> = {}
  /// Expect: {}
  println(m0)

  val m1 = { (24): "hello" }
  /// Expect: { 24: hello }
  println(m1)

  val m2 = { (24): "hello", (17): "bonjour" }
  /// Expect: { 17: bonjour, 24: hello }
  println(m2)

  // Forcing a hash-collision (16 initial buckets by default)
  val m3 = { (1): "hello", (17): "world" }
  /// Expect: { 1: hello, 17: world }
  println(m3)
}

// == operator (also Map#eq)
if true {
  val map = { a: "abc", b: "def" }

  /// Expect: true
  println(map == { b: "def", a: "abc" })
  /// Expect: true
  println({ (1): { (1): ["a"], (2): ["b"] } } == { (1): { (1): ["a"], (2): ["b"] } })
}

// Map.fromPairs
if true {
  // TODO: The typechecker won't recognize this if it's inlined for some reason
  val pairs = [("a", 1), ("b", 2), ("c", 3)]
  val m = Map.fromPairs(pairs)

  /// Expect: { c: 3, b: 2, a: 1 }
  println(m)
}

// Map#keys
if true {
  val map1 = { a: 1, b: 2 }
  /// Expect: #{b, a}
  println(map1.keys())

  val map2 = { ((1, 1)): true, ((0, 1)): false }
  /// Expect: #{(0, 1), (1, 1)}
  println(map2.keys())
}

// Map#values
if true {
  val map1 = { a: 1, b: 2 }
  /// Expect: [2, 1]
  println(map1.values())

  val map2 = { ((1, 1)): true, ((0, 1)): false }
  /// Expect: [false, true]
  println(map2.values())
}

// Map#entries
if true {
  val map1 = { a: 1, b: 2 }
  /// Expect: #{("b", 2), ("a", 1)}
  println(map1.entries())

  // The non-ir compiler does not properly compute the hashcode for the tuple, unlike the ir compiler.
  // Therefore, this test is commented out to ensure the same test suite passes for both. Eventually,
  // when the ir compiler replaces the non-ir compiler, this can be uncommented as an additional test case.
  // val map2 = { ((1, 1)): true, ((0, 1)): false }
  // /// Expect: #{((1, 1), true), ((0, 1), false)}
  // println(map2.entries())

  val map2 = { ([1, 2]): true, ([3, 4]): false }
  /// Expect: #{([1, 2], true), ([3, 4], false)}
  println(map2.entries())
}

// Map#iterator
if true {
  val m = { a: 1, b: 2, c: 3 }
  val iter = m.iterator()

  /// Expect: Option.Some(value: ("c", 3))
  println(iter.next())
  /// Expect: Option.Some(value: ("b", 2))
  println(iter.next())
  /// Expect: Option.Some(value: ("a", 1))
  println(iter.next())
  /// Expect: Option.None
  println(iter.next())
  /// Expect: Option.None
  println(iter.next())
}

// For-loops
/// Expect: ("c", 3) 0
/// Expect: ("b", 2) 1
/// Expect: ("a", 1) 2
for ch, idx in { a: 1, b: 2, c: 3 } {
  println("$ch $idx")
}

// Map#containsKey
if true {
  val m = { (1): "a", (2): "b" }

  /// Expect: true
  println(m.containsKey(1))
  /// Expect: false
  println(m.containsKey(3))
}

// Map#mapValues
if true {
  val m1 = { (1): "abc", (2): "defg" }

  val m2 = m1.mapValues((_, v) => v + "!")
  /// Expect: { 1: abc!, 2: defg! }
  println(m2)

  val m3 = m1.mapValues((_, v) => v.length)
  /// Expect: { 1: 3, 2: 4 }
  println(m3)
}

// Map#insert (also []= operator)
if true {
  val m = { a: 1, b: 2 }
  m.insert("c", 3)
  m["d"] = 4
  /// Expect: { d: 4, c: 3, b: 2, a: 1 }
  println(m)

  val letters = ["e", "f", "g", "h", "i", "j", "l", "k", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
  for ch, idx in letters {
    m[ch] = idx + 4
  }
  // Map should have been resized
  /// Expect: { y: 24, w: 22, u: 20, s: 18, q: 16, o: 14, m: 12, k: 11, i: 8, g: 6, e: 4, c: 3, a: 1, z: 25, x: 23, v: 21, t: 19, r: 17, p: 15, n: 13, l: 10, j: 9, h: 7, f: 5, d: 4, b: 2 }
  println(m)
  /// Expect: false
  println(m._needsResize())
}

// Map#get
if true {
  val m = { (1): "a", (2): "b" }

  /// Expect: Option.Some(value: "a")
  println(m.get(1))
  /// Expect: Option.Some(value: "b")
  println(m.get(2))
  /// Expect: Option.None
  println(m.get(3))
}

// Map#getOr
if true {
  val m = { (1): "a", (2): "b" }

  /// Expect: a
  println(m.getOr(1, "c"))
  /// Expect: b
  println(m.getOr(2, "c"))
  /// Expect: c
  println(m.getOr(3, "c"))
}

// Map#getOrElse
if true {
  val m = { (1): "a", (2): "b" }

  /// Expect: a
  val v1 = m.getOrElse(1, () => {
    println("calling default fn")
    "c"
  })
  println(v1)

  /// Expect: b
  val v2 = m.getOrElse(2, () => {
    println("calling default fn")
    "c"
  })
  println(v2)

  /// Expect: calling default fn
  /// Expect: c
  val v3 = m.getOrElse(3, () => {
    println("calling default fn")
    "c"
  })
  println(v3)
}

// Map#update
if true {
  val m = { (1): "a", (2): "b" }

  /// Expect: { 1: a, 2: b }
  println(m)

  val old1 = m.update(1, () => "A")
  /// Expect: { 1: A, 2: b }
  println(m)
  /// Expect: Option.Some(value: "a")
  println(old1)

  val old2 = m.update(4, () => "???")
  /// Expect: { 1: A, 2: b }
  println(m)
  /// Expect: Option.None
  println(old2)
}

// Map#remove
if true {
  val m = {
    a: 1,
    b: 2,
    c: 3,
    d: 4,
    s: 5,
    t: 6
  }
  /// Expect: { d: 4, t: 6, c: 3, s: 5, b: 2, a: 1 }
  println(m)

  /// Expect: Option.None
  println(m.remove("x"))
  /// Expect: 6
  println(m.size)

  /// Expect: Option.Some(value: 2)
  println(m.remove("b"))
  /// Expect: { d: 4, t: 6, c: 3, s: 5, a: 1 }
  println(m)
  /// Expect: 5
  println(m.size)

  // Kinda dirty, but needed in order to test removing keys with the same hash
  /// Expect: true
  println(m._getKeyHash("c") == m._getKeyHash("s"))

  /// Expect: Option.Some(value: 5)
  println(m.remove("s"))
  /// Expect: { d: 4, t: 6, c: 3, a: 1 }
  println(m)
  /// Expect: 4
  println(m.size)
  /// Expect: Option.Some(value: 3)
  println(m.remove("c"))
  /// Expect: { d: 4, t: 6, a: 1 }
  println(m)
  /// Expect: 3
  println(m.size)

  /// Expect: true
  println(m._getKeyHash("d") == m._getKeyHash("t"))

  /// Expect: Option.Some(value: 4)
  println(m.remove("d"))
  /// Expect: { t: 6, a: 1 }
  println(m)
  /// Expect: 2
  println(m.size)
  /// Expect: Option.Some(value: 6)
  println(m.remove("t"))
  /// Expect: { a: 1 }
  println(m)
  /// Expect: 1
  println(m.size)
}
