import "./_intrinsics" as intrinsics
import Pointer, Byte from "./_intrinsics"
import "libc" as libc

var _args: String[]? = None
export func args(): String[] {
  if _args |args| return args

  val argc = intrinsics.argc()
  val argv = intrinsics.argv()

  val args: String[] = Array.withCapacity(argc)
  for i in range(0, argc) {
    val str = argv.offset(i).load()
    val len = libc.strlen(str)
    args.push(String(length: len, _buffer: str))
  }

  _args = Some(args)
  args
}

export func getEnvVar(name: String): String? {
  val str = libc.getenv(name._buffer)
  if str.isNullPtr() return None

  val len = libc.strlen(str)
  Some(String(length: len, _buffer: str))
}

export type Uname {
  sysname: String
  nodename: String
  release: String
  version: String
  machine: String
}

var _uname: Uname? = None
export func uname(): Uname {
  if _uname |uname| return uname

  // On macOS, each field in the utsname struct is a char[256]; on other platforms it's different, so
  // this can be wasteful of memory.
  var utsnameBuf = Pointer.malloc<Byte>(256 * 5)
  val res = libc.uname(utsnameBuf)
  if res != 0 { /* todo: handle error code */ }

  val sysnameLen = libc.strlen(utsnameBuf)
  val sysname = String.withLength(sysnameLen)
  sysname._buffer.copyFrom(utsnameBuf, sysnameLen)

  // The utsname struct has 5 fields (6 on some platforms), of constant and equal sizes, but the size of
  // each field differs per platform. After extracting the first string, skip over the \0 bytes until we
  // reach the start of the next string. From that offset, we can determine the size of each field, and
  // extract the remaining fields more efficiently.
  var offset = sysnameLen
  utsnameBuf = utsnameBuf.offset(offset)
  while utsnameBuf.load().asInt() == 0 {
    utsnameBuf = utsnameBuf.offset(1)
    offset += 1
  }

  val nodenameLen = libc.strlen(utsnameBuf)
  val nodename = String.withLength(nodenameLen)
  nodename._buffer.copyFrom(utsnameBuf, nodenameLen)
  utsnameBuf = utsnameBuf.offset(offset)

  val releaseLen = libc.strlen(utsnameBuf)
  val release = String.withLength(releaseLen)
  release._buffer.copyFrom(utsnameBuf, releaseLen)
  utsnameBuf = utsnameBuf.offset(offset)

  val versionLen = libc.strlen(utsnameBuf)
  val version = String.withLength(versionLen)
  version._buffer.copyFrom(utsnameBuf, versionLen)
  utsnameBuf = utsnameBuf.offset(offset)

  val machineLen = libc.strlen(utsnameBuf)
  val machine = String.withLength(machineLen)
  machine._buffer.copyFrom(utsnameBuf, machineLen)

  val uname = Uname(sysname: sysname, nodename: nodename, release: release, version: version, machine: machine)
  _uname = Some(uname)
  uname
}

@noreturn
export func exit(status = 1) = libc.exit(status)

export func getStackTrace(message = "Stack trace:"): String {
  val frames = callstack()
  val lines = [message]
  // Skip first frame, which will be the call to `callstack()` itself
  for frame in frames[1:] {
    lines.push("  at ${frame.callee} (${frame.file}:${frame.line})")
  }
  lines.join("\n")
}

export type StackFrame {
  callee: String
  file: String
  line: Int
}

export func callstack(): StackFrame[] {
  val s = intrinsics.callstack()
  var sp = (intrinsics.callstackPtr() / 8).floor() - 1

  val moduleNames = getModuleNames()
  val functionNames = getFunctionNames()

  val stack = Array.withCapacity<StackFrame>(sp)
  while sp >= 0 {
    val frame = s.offset(sp).load()

    val line = frame && 0xffff

    val modId = (frame >> 16) && 0xff
    val modName = if modId == 0 {
      "<builtin>"
    } else if moduleNames[modId - 1] |name| {
      name
    } else {
      "unknown"
    }

    val fnId = (frame >> 32) && 0xff
    val fnName = if fnId == 0 {
      "<expression>"
    } else if functionNames[fnId - 1] |name| {
      name
    } else {
      "unknown"
    }

    stack.push(StackFrame(callee: fnName, file: modName, line: line))
    sp -= 1
  }

  stack
}

var _moduleNames: String[]? = None
func getModuleNames(): String[] {
  if _moduleNames |moduleNames| moduleNames

  val moduleNames: String[] = []
  val buf = intrinsics.moduleNames()
  var idx = 0
  var len = 0
  while true {
    val byte = buf.offset(idx).load().asInt()
    if byte == 0 {
      if len == 0 break

      val str = String.withLength(len)
      str._buffer.copyFrom(buf.offset(idx - len), len)
      moduleNames.push(str)

      idx += 1
      len = 0
      continue
    }

    idx += 1
    len += 1
  }

  _moduleNames = Some(moduleNames)
  moduleNames
}

var _functionNames: String[]? = None
func getFunctionNames(): String[] {
  if _functionNames |functionNames| functionNames

  val functionNames: String[] = []
  val buf = intrinsics.functionNames()
  var idx = 0
  var len = 0
  while true {
    val byte = buf.offset(idx).load().asInt()
    if byte == 0 {
      if len == 0 break

      val str = String.withLength(len)
      str._buffer.copyFrom(buf.offset(idx - len), len)
      functionNames.push(str)

      idx += 1
      len = 0
      continue
    }

    idx += 1
    len += 1
  }

  _functionNames = Some(functionNames)
  functionNames
}
