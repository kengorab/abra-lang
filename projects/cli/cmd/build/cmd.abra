import "process" as process
import "fs" as fs
import "libc" as libc
import Path from "path"
import Compiler from "../../../compiler/src/compiler"
import typecheck from "../common"

pub type BuildCmd {
  pub outputFile: String?
  pub inputFile: String
  pub target: BuildTarget
}

pub enum BuildTarget {
  NativeBin
  JavaScript
}

pub func runBuild(cmd: BuildCmd): String? {
  val abraRoot = try process.getEnvVar("ABRA_ROOT") else {
    stdoutWriteln("Could not find ABRA_ROOT (make sure \$ABRA_ROOT environment variable is set)")
    process.exit(1)
  }
  val abraStdRoot = try process.getEnvVar("ABRA_STD") else "$abraRoot/std"

  val inputPath = Path.fromString(cmd.inputFile)
  val (entryMod, project) = try typecheck(abraStdRoot, inputPath) else return None

  val builder = try Compiler.compile(project, entryMod) else |e| {
    println(e.getMessage())
    process.exit(1)
  }

  var compilationUnitName = if cmd.outputFile |outputFile| {
    val outputPath = Path.fromString(outputFile)
    try outputPath.segments[-1] else {
      println("Empty output file provided, cannot proceed")
      process.exit(1)
    }
  } else {
    val lastSegment = try inputPath.segments[-1] else {
      println("Empty input file provided, cannot proceed")
      process.exit(1)
    }
    lastSegment.replaceAll(".abra", "") // todo: better Path API to get extensionless segment
  }

  val cwd = fs.getCurrentWorkingDirectory()
  println("before creating dotAbraDir")
  stdoutWriteln(process.Command(program: "ls")
    .addArg("-la")
    .addArg(cwd)
    .execAndCaptureOutput()
    .stdout
  )

  val dotAbraDir = "$cwd/.abra"
  if !fs.File.exists(dotAbraDir) {
    if !fs.createDir(dotAbraDir) {
      println("Error creating .abra directory at '$cwd', cannot proceed")
      process.exit(1)
    }
  }

  println("after creating $dotAbraDir")
  stdoutWriteln(process.Command(program: "ls")
    .addArg("-la")
    .addArg(cwd)
    .execAndCaptureOutput()
    .stdout
  )

  val ssaOutPath = "$dotAbraDir/$compilationUnitName.ssa"
  debug(ssaOutPath)
  val ssaOutFile = try fs.File.create(ssaOutPath) else |e| {
    println(e.toString())
    process.exit(1)
  }
  debug(ssaOutFile)

  val lsRes = process.Command(program: "ls")
    .addArg("-la")
    .addArg(dotAbraDir)
    .execAndCaptureOutput()
  if !lsRes.status.isSuccess() {
    if !lsRes.stderr.isEmpty() {
      println(lsRes.stderr)
    } else {
      println(lsRes.stdout)
    }
    process.exit(1)
  }
  println(lsRes.stdout)

  builder.writeToFile(ssaOutFile)
  ssaOutFile.close()

  val objOutPath = "$dotAbraDir/$compilationUnitName.s"
  val qbeCmdRes = process.Command(program: "qbe")
    .addArg("-o").addArg(objOutPath)
    .addArg(ssaOutPath)
    .execAndCaptureOutput()
  if !qbeCmdRes.status.isSuccess() {
    if !qbeCmdRes.stderr.isEmpty() {
      println(qbeCmdRes.stderr)
    } else {
      println(qbeCmdRes.stdout)
    }

    val lsRes = process.Command(program: "ls")
      .addArg("-la")
      .addArg(dotAbraDir)
      .execAndCaptureOutput()
    if !lsRes.status.isSuccess() {
      if !lsRes.stderr.isEmpty() {
        println(lsRes.stderr)
      } else {
        println(lsRes.stdout)
      }
      process.exit(1)
    }
    println(lsRes.stdout)

    process.exit(1)
  }

  val execOutPath = cmd.outputFile ?: "$dotAbraDir/$compilationUnitName"
  val clangCmdRes = process.Command(program: "clang") // todo: switch to gcc?
    .addArg("$abraRoot/include/libgc.a")
    .addArg(objOutPath)
    .addArg("-o").addArg(execOutPath)
    .addArg("-lm")
    .addArg("-Wno-override-module")
    .addArg("-Wl,-w")
    .execAndCaptureOutput()
  if !clangCmdRes.status.isSuccess() {
    if !clangCmdRes.stderr.isEmpty() {
      println(clangCmdRes.stderr)
    } else {
      println(clangCmdRes.stdout)
    }
    process.exit(1)
  }

  Some(execOutPath)
}
