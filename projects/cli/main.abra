import "process" as process
import "./cmd/build/cmd" as cmdBuild
import "./cmd/emit_ir/cmd" as cmdEmitIr

enum SubcommandParseError {
  NoCommand
  MissingRequiredValue(name: String, subcommand: String? = None)
  MissingRequiredPositionalArg(name: String, subcommand: String? = None)
  InvalidArgumentValue(name: String, value: String, options: String[] = [])
  UnknownFlag(name: String, subcommand: String? = None)
}

type DefaultCmd {
  inputFile: String
  programArguments: String[]
}

enum Subcommand {
  Help
  Default(inner: DefaultCmd)
  Build(inner: cmdBuild.BuildCmd)
  EmitIr(inner: cmdEmitIr.EmitIrCmd)

  func printUsage() {
    stdoutWriteln("USAGE")
    stdoutWriteln("  abra <file-path> [<program-args>...]")
    stdoutWriteln("  abra [subcommand]")
    stdoutWriteln()
    stdoutWriteln("DEFAULT MODE              Compiles and runs abra source file")
    stdoutWriteln("  USAGE")
    stdoutWriteln("    abra <file-path> [<program-args>...]")
    stdoutWriteln("  ARGS")
    stdoutWriteln("    <file-path>           Path to the abra root source file to build and run")
    stdoutWriteln("    <program-args>...     Arguments to pass to the built abra program when running")
    stdoutWriteln()
    stdoutWriteln("SUBCOMMANDS")
    stdoutWriteln("  help/-h                 Prints this usage info")
    stdoutWriteln("    USAGE")
    stdoutWriteln("      abra help")
    stdoutWriteln("      abra -h")
    stdoutWriteln()
    stdoutWriteln("  build                   Compiles the abra source file to selected target")
    stdoutWriteln("    USAGE")
    stdoutWriteln("      abra build [OPTIONS] <input-path>")
    stdoutWriteln("    OPTIONS")
    stdoutWriteln("      -t/--target         Compile target, available options are:")
    stdoutWriteln("                            bin    Native binary (default option)")
    stdoutWriteln("                            js     JavaScript")
    stdoutWriteln("      -o <out-path>       Where the built artifact should be placed (defaults to ./.abra/<input>)")
    stdoutWriteln("    ARGS")
    stdoutWriteln("      <file-path>         Path to the abra root source file to build")
    stdoutWriteln()
    stdoutWriteln("  emit-ir                 Outputs intermediate representation, depending on <mode>")
    stdoutWriteln("    USAGE")
    stdoutWriteln("      abra emit-ir [OPTIONS] <input-path>")
    stdoutWriteln("    OPTIONS")
    stdoutWriteln("      -m/--mode           Which info to emit for file at <input-path>, available options are:")
    stdoutWriteln("                            TOKENS_ONLY    The tokenized representation")
    stdoutWriteln("                            AST            The parsed Abstract Syntax Tree")
    stdoutWriteln("                            TYPED_AST      The parsed Abstract Syntax Tree, with type information added")
    stdoutWriteln("                            IR             The target-agnostic intermediate representation (default option)")
    stdoutWriteln("      -i/--ignore-errors  Ignore errors when building selected info, emit info anyway (defaults to false)")
    stdoutWriteln("                          Note: only applicable for TYPED_AST mode, will be ignored otherwise")
    stdoutWriteln("    ARGS")
    stdoutWriteln("      <file-path>         Path to the abra root source file to build")
  }

  func parse(programArguments: String[]): Result<Subcommand, SubcommandParseError> {
    val args = programArguments.iterator()

    val progName = try args.next() else unreachable("prog name is always first arg")

    val subcommand = try args.next() else return Err(SubcommandParseError.NoCommand)
    match subcommand {
      "help" => Ok(Subcommand.Help)
      "-h" => Ok(Subcommand.Help)
      "build" => {
        var outputFile: String? = None
        var inputFileArg: String? = None
        var buildTarget = cmdBuild.BuildTarget.NativeBin

        while true {
          val arg = try args.next() else break
          if arg == "-t" || arg == "--target" {
            val modeStr = try args.next() else return Err(SubcommandParseError.MissingRequiredValue(arg, Some("build")))
            buildTarget = match modeStr {
              "bin" => cmdBuild.BuildTarget.NativeBin
              "js" => cmdBuild.BuildTarget.JavaScript
              else => return Err(SubcommandParseError.InvalidArgumentValue(arg, modeStr, ["bin", "js"]))
            }
            continue
          }
          if arg == "-o" {
            val dir = try args.next() else return Err(SubcommandParseError.MissingRequiredValue("-o", Some("build")))
            outputFile = Some(dir)
          }
          if arg.startsWith("-") return Err(SubcommandParseError.UnknownFlag(arg, Some("build")))

          inputFileArg = Some(arg)
          break
        }
        val inputFile = try inputFileArg else return Err(SubcommandParseError.MissingRequiredPositionalArg("input file", Some("build")))

        val cmd = cmdBuild.BuildCmd(outputFile: outputFile, inputFile: inputFile, target: buildTarget)
        Ok(Subcommand.Build(cmd))
      }
      "emit-ir" => {
        var inputFileArg: String? = None
        var mode = cmdEmitIr.EmitIrMode.Ir
        var ignoreErrors = false

        while true {
          val arg = try args.next() else break
          if arg == "-m" || arg == "--mode" {
            val modeStr = try args.next() else return Err(SubcommandParseError.MissingRequiredValue(arg, Some("emit-ir")))
            mode = match modeStr {
              "TOKENS_ONLY" => cmdEmitIr.EmitIrMode.TokensOnly
              "AST" => cmdEmitIr.EmitIrMode.Ast
              "TYPED_AST" => cmdEmitIr.EmitIrMode.TypedAst
              "IR" => cmdEmitIr.EmitIrMode.Ir
              else => return Err(SubcommandParseError.InvalidArgumentValue(arg, modeStr, ["TOKENS_ONLY", "AST", "TYPED_AST", "IR"]))
            }
            continue
          }
          if arg == "-i" || arg == "--ignore-errors" {
            ignoreErrors = true
            continue
          }

          if arg.startsWith("-") return Err(SubcommandParseError.UnknownFlag(arg, Some("emit-ir")))

          inputFileArg = Some(arg)
          break
        }
        val inputFile = try inputFileArg else return Err(SubcommandParseError.MissingRequiredPositionalArg("input file", Some("emit-ir")))

        Ok(Subcommand.EmitIr(cmdEmitIr.EmitIrCmd(mode: mode, inputFile: inputFile, ignoreErrors: ignoreErrors)))
      }
      else arg => {
        if arg.startsWith("-") return Err(SubcommandParseError.UnknownFlag(arg))

        val programArgs: String[] = []
        while args.next() |arg| programArgs.push(arg)

        val cmd = DefaultCmd(inputFile: arg, programArguments: programArgs)
        Ok(Subcommand.Default(cmd))
      }
    }
  }
}

func handleDefault(cmd: DefaultCmd) {

}

func main() {
  val cmd = try Subcommand.parse(process.args()) else |err| {
    var msg = match err {
      SubcommandParseError.NoCommand => "no command given"
      SubcommandParseError.MissingRequiredValue(name, cmd) => {
        val suffix = if cmd |cmd| " for command '$cmd'" else ""
        "value required for option '$name'$suffix"
      }
      SubcommandParseError.MissingRequiredPositionalArg(name, cmd) => {
        val suffix = if cmd |cmd| " for command '$cmd'" else ""
        "value required for positional argument '$name'$suffix"
      }
      SubcommandParseError.InvalidArgumentValue(name, value, options) => {
        val first = "invalid value for argument '$name': '$value'"

        if !options.isEmpty() {
          val second = "valid options include ${options.map(o => "'$o'").join(", ")}"
          first + "\n" + second
        } else {
          first
        }
      }
      SubcommandParseError.UnknownFlag(name, cmd) => {
        val suffix = if cmd |cmd| " for command '$cmd'" else ""
        "unknown flag '$name'$suffix"
      }
    }
    stdoutWriteln("Error: $msg\n")

    Subcommand.printUsage()
    process.exit(1)
  }

  match cmd {
    Subcommand.Help => Subcommand.printUsage()
    Subcommand.Build(cmd) => cmdBuild.run(cmd)
    Subcommand.Default(cmd) => handleDefault(cmd)
    Subcommand.EmitIr(cmd) => cmdEmitIr.run(cmd)
  }
}
main()
