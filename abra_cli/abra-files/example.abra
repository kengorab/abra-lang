func foo(a: Int, b: Bool, c = bar()): Int = -1
func bar(a: Int): Int = a

/*

Given code:
  func foo(a: Int, b: Bool, c = bar()): Int = -1
  func bar(): Int = 123
Pass 0:
  - We know about a function called `foo` which returns `Int`
  - We know about a function called `bar` which returns `Int`
Pass 1:
  - Check `foo`
    - Check args, seeing that `a` is `Int`, `b` is `Bool`, and that `c` has a default value of `bar()`
      - We know about `bar`, which is a function that returns `Int` -> `c` is of type `Int`
  - Check `bar`
Pass 2:
  - Check any default-valued args & body of `foo`
  - Check any default-valued args & body of `bar`

------------------------------

Given code:
  func foo(a: Int, b: Bool, c = bar): Int = -1
  func bar(): Int = 123
Pass 0:
  - We know about a function called `foo` which returns `Int`
  - We know about a function called `bar` which returns `Int`
Pass 1:
  - Check `foo`
    - Check args, seeing that `a` is `Int`, `b` is `Bool`, and that `c` has a default value of `bar`
      - We know about `bar`, which is a function that returns `Int` -> `c` is of type `() => Int`
  - Check `bar`
Pass 2:
  - Check any default-valued args & body of `foo`
  - Check any default-valued args & body of `bar`

------------------------------

Given code:
  func foo(a: Int, b: Bool, c = bar()): Int = -1
  func bar(a: Int): Int = 123
Pass 0:
  - We know about a function called `foo` which returns `Int`
  - We know about a function called `bar` which returns `Int`
Pass 1:
  - Check `foo`
    - Check args, seeing that `a` is `Int`, `b` is `Bool`, and that `c` has a default value of `bar()`
      - We know about `bar`, which is a function that returns `Int` -> `c` is of type `Int`
      - At this point we don't care about whether `c`'s default value passes typechecking, we only care about the return type
  - Check `bar`
Pass 2:
  - Check any default-valued args & body of `foo`
    - Now, we see that the default value of `c` is missing an argument in the call to `bar`
    - Typecheck fails
  - Check any default-valued args & body of `bar`

------------------------------

Given code:
  func foo(a: Int, b: Bool, c = bar()): Int = -1
  func bar<T>(): T? = None
Pass 0:
  - We know about a function called `foo` which returns `Int`
  - We know about a function called `bar` which returns `T?`
Pass 1:
  - Check `foo`
    - Check args, seeing that `a` is `Int`, `b` is `Bool`, and that `c` has a default value of `bar()`
      - We know about `bar`, which is a function that returns `T?` -> `c` is of type `T?`
      - At this point we don't care about whether `c`'s default value passes typechecking, we only care about the return type
  - Check `bar`
Pass 2:
  - Check any default-valued args & body of `foo`
    - Now, we see that the default value of `c` results in an unbound generic (`T`)
    - Typecheck fails
  - Check any default-valued args & body of `bar`

------------------------------

Given code:
  func foo(a: Int, b: Bool, c = bar()): Int = -1
  func bar(a = foo()): Int = 1
Pass 0:
  - We know about a function called `foo` which returns `Int`
  - We know about a function called `bar` which returns `Int`
Pass 1:
  - Check `foo`
    - Check args, seeing that `a` is `Int`, `b` is `Bool`, and that `c` has a default value of `bar()`
      - We know about `bar`, which is a function that returns `Int` -> `c` is of type `Int`
      - At this point we don't care about whether `c`'s default value passes typechecking, we only care about the return type
  - Check `bar`
    - Check args, seeing that `a` has a default value of `foo()`
      - We know about `foo`, which is a function that returns `Int` -> `a` is of type `Int`
      - At this point we don't care about whether `a`'s default value passes typechecking, we only care about the return type
Pass 2:
  - Check any default-valued args & body of `foo`
    - Typecheck passes
  - Check any default-valued args & body of `bar`
    - Typecheck fails, since `foo` has 2 required arguments but 0 were provided

------------------------------

Given code:
  func foo(a: Int, b: Bool, c = 1 + bar()): Int = -1
  func bar(): Int = 1
Pass 0:
  - We know about a function called `foo` which returns `Int`
  - We know about a function called `bar` which returns `Int`
Pass 1:
  - Check `foo`
    - Check args, seeing that `a` is `Int`, `b` is `Bool`, and that `c` has a default value of `1 + bar()`
      - Since we need to typecheck a whole expression, which contains a function call, we need to have some way of knowing
        that we're only on pass 1 of function typechecking, and that we should only consider the return type when trying
        to determine the type of `bar()` within `1 + bar()`.
      - We know about `bar`, which is a function that returns `Int` -> `c` is of type `Int`
      - At this point we don't care about whether `c`'s default value passes typechecking, we only care about the return type
  - Check `bar`
Pass 2:
  - Check any default-valued args & body of `foo`
  - Check any default-valued args & body of `bar`

------------------------------

Given code:
  func foo(a: Int, b: Bool, c = 1 + bar(1)): Int = -1
  func bar<T>(t: T): T = t
Pass 0:
  - We know about a function called `foo` which returns `Int`
  - We know about a function called `bar` which returns `T`
Pass 1:
  - Check `foo`
    - Check args, seeing that `a` is `Int`, `b` is `Bool`, and that `c` has a default value of `1 + bar(1)`
      - (See note above about knowing that we're on pass 1)
      - We know about `bar` which is a function that returns `T`
      - At this point, we know _nothing_ about the arguments of `bar`, or that its param supplies the type for `T`
      - Since a TypeError will occur (`Int + T`), let the type of `c` be `Unknown` and mark it as `checking_incomplete`
  - Check `bar`
Pass 2:
  - Check any default-valued args & body of `foo`
    - Re-check any default-valued args, and if `checking_incomplete` update its type
  - Check any default-valued args & body of `bar`

------------------------------

Given code:
  func baz<T>(t: T, f = 1 + foo(1, "b")): T = t
  func foo<T>(a: T, b = 1 + baz(1)): T = a
Pass 0:
  - We know about a function called `baz` which returns `T`
  - We know about a function called `foo` which returns `T`
Pass 1:
  - Check `baz`
    - Check args, seeing that `f` has a default value of `foo(1, "b")`
      - We know about `foo` which is a function that returns `T`
      - Since a TypeError will occur (`Int + T`), let the type of `f` be `Unknown` and mark it as `checking_incomplete`
  - Check `foo`
    - Check args, seeing that `a` is `Int`, and that `b` has a default value of `1 + bar(1)`
      - We know about `bar` which is a function that returns `T`
      - At this point, we know _nothing_ about the arguments of `bar`, or that its param supplies the type for `T`
      - Since a TypeError will occur (`Int + T`), let the type of `b` be `Unknown` and mark it as `checking_incomplete`
Pass 2:
  - Check any default-valued args & body of `baz`
    - Try to check default value of `f`, but will still get `checking_incomplete` since `foo` is still `checking_incomplete`
    - Place on some queue to revisit
  - Check any default-valued args & body of `foo`
    - Try to check default value of `b`, which _is_ doable since second arg to `baz` is optional
    - Because of this, we know that the type of `b` should be Int
  - Revisit the queue, and attempt to re-typecheck `baz`
    - Since we now know the type of `foo`, we'll see that there's a TypeError (`String` != `Int`)
    - Typechecking fails

------------------------------

Given code:
  func baz<T>(t: T, f = 1 + foo(1, "b")): T = t
  func foo<T>(a: T, b = 1 + baz(1, "b")): T = a
Pass 0:
  - We know about a function called `baz` which returns `T`
  - We know about a function called `foo` which returns `T`
Pass 1:
  - Check `baz`
    - Check args, seeing that `f` has a default value of `foo(1, "b")`
      - We know about `foo` which is a function that returns `T`
      - Since a TypeError will occur (`Int + T`), let the type of `f` be `Unknown` and mark it as `checking_incomplete`
  - Check `foo`
    - Check args, seeing that `a` is `Int`, and that `b` has a default value of `1 + bar(1, "b")`
      - We know about `bar` which is a function that returns `T`
      - At this point, we know _nothing_ about the arguments of `bar`, or that its param supplies the type for `T`
      - Since a TypeError will occur (`Int + T`), let the type of `b` be `Unknown` and mark it as `checking_incomplete`
Pass 2:
  - Check any default-valued args & body of `baz`
    - Try to check default value of `f`, but will still get `checking_incomplete` since `foo` is still `checking_incomplete`
    - Place `baz` on some queue to revisit
  - Check any default-valued args & body of `foo`
    - Try to check default value of `b`, but will still get `checking_incomplete` since `baz` is still `checking_incomplete`
    - Because of this, we cannot proceed; place `foo` on some queue to revisit
  - Revisit the queue, and attempt to re-typecheck `baz`
    - Since no progress has been made on `foo` (it's still `checking_incomplete`), we should be able to deduce that we're
      at deadlock and typechecking fails.
*/
