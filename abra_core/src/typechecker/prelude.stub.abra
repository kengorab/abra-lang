func println(*items: Any[])
func print(*items: Any[])
func range(start: Int, end: Int, stepBy = 1): Int[]

type Int {
  func abs(self): Int
  func asBase(self, base: Int): String
  func isEven(self): Bool
  func isOdd(self): Bool
  func isBetween(self, lower: Int, upper: Int, inclusive = false): Bool
}

type Float {
  func abs(self): Float
  func floor(self): Int
  func ceil(self): Int
  func round(self): Int
  func withPrecision(self, precision: Int): Float
}

type Bool {
  // No methods for Bool
}

type String {
  length: Int readonly

  func isEmpty(self): Bool
  func toLower(self): String
  func toUpper(self): String
  func padLeft(self, totalSize: Int, padding = " "): String
  func trim(self): String
  func trimStart(self, pattern: String? = None): String
  func trimEnd(self, pattern: String? = None): String
  func split(self, by = ""): String[]
  func splitAt(self, index: Int): (String, String)
  func lines(self): String[]
  func parseInt(self, radix = 10): Int?
  func parseFloat(self): Float?
  func concat(self, suffix: Any, *others: Any[]): String
  func replaceAll(self, pattern: String, replacement: String): String
}

type Array<T> {
  length: Int readonly

  func isEmpty(self): Bool
  func enumerate(self): (T, Int)[]
  func push(self, item: T, *others: T[])
  func pop(self): T?
  func popFront(self): T?
  func splitAt(self, index: Int): (T[], T[])
  func concat(self, other: T[]): T[]
  func map<U>(self, fn: (T) => U): U[]
  func filter(self, fn: (T) => Bool): T[]
  func reduce<U>(self, initialValue: U, fn: (U, T) => U): U
  func forEach(self, fn: (T) => Unit)
  func join(self, joiner = ""): String
  func contains(self, item: T): Bool
  func find(self, fn: (T) => Bool): T?
  func findIndex(self, fn: (T) => Bool): (T, Int)?
  func any(self, fn: (T) => Bool): Bool
  func all(self, fn: (T) => Bool): Bool
  func none(self, fn: (T) => Bool): Bool
  func sortBy(self, fn: (T) => Int, reverse = false): T[]
  func dedupe(self): T[]
  func dedupeBy<U>(self, fn: (T) => U): T[]
  func partition<U>(self, fn: (T) => U): Map<U, T[]>
  func tally(self): Map<T, Int>
  func tallyBy<U>(self, fn: (T) => U): Map<U, Int>
  func asSet(self): Set<T>
  func getOr(self, index: Int, default: T): T
  func getOrElse(self, index: Int, getDefault: () => T): T
  func update(self, index: Int, updater: (T) => T)
  func reverse(self): T[]
}

type Set<T> {
  size: Int readonly

  func isEmpty(self): Bool
  func enumerate(self): (T, Int)[]
  func contains(self, item: T): Bool
  func insert(self, item: T)
  func remove(self, item: T): T?
  func map<U>(self, fn: (T) => U): U[]
  func filter(self, fn: (T) => Bool): Set<T>
  func reduce<U>(self, initialValue: U, fn: (U, T) => U): U
  func asArray(self): T[]
  func union(self, other: Set<T>): Set<T>
  func difference(self, other: Set<T>): Set<T>
  func intersection(self, other: Set<T>): Set<T>
}

type Map<K, V> {
  size: Int readonly

  func isEmpty(self): Bool
  func enumerate(self): (K, V)[]
  func keys(self): Set<K>
  func values(self): V[]
  func entries(self): Set<(K, V)>
  func containsKey(self, key: K): Bool
  func mapValues<U>(self, fn: (K, V) => U): Map<K, U>
  func getOr(self, key: K, default: V): V
  func getOrElse(self, key: K, getDefault: () => V): V
  func update(self, key: K, updater: (V) => V)
  func remove(self, key: K): V?
}
