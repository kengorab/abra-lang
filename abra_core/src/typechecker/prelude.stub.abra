@Intrinsic("stdout_write")
func stdoutWrite(str: String)

func print(*items: Any[]) {
  var i = 0
  while i < items.length {
    val item = items._buffer.offset(i).load()
    stdoutWrite(item.toString())

    if i != items.length - 1 {
      stdoutWrite(" ")
    }

    i += 1
  }
}

func println(*items: Any[]) {
  print(items: items)
  stdoutWrite("\n")
}

@Stub func range(start: Int, end: Int, stepBy = 1): Int[]

func flattenOption<T>(value: T??): T? = if value |v| v else None

type Byte {
  @Intrinsic("byte_from_int")
  func fromInt(value: Int): Byte

  @Intrinsic("byte_as_int")
  func asInt(self): Int
}

type Pointer<T> {
  @Intrinsic("pointer_null")
  func null<T>(): Pointer<T>

  @Intrinsic("pointer_malloc")
  func malloc<T>(count = 1): Pointer<T>

  //@Intrinsic("pointer_realloc")
  //func realloc(self, count: Int): Pointer<T>

  @Intrinsic("pointer_address")
  func address(self): Int

  @Intrinsic("pointer_store")
  func store(self, value: T)

  @Intrinsic("pointer_load")
  func load(self): T

  @Intrinsic("pointer_offset")
  func offset(self, offset: Int): Pointer<T>

  @Intrinsic("pointer_copy_from")
  func copyFrom(self, other: Pointer<T>, size: Int)
}

type Int {
  @Stub func abs(self): Int
  @Stub func asBase(self, base: Int): String
  @Stub func isEven(self): Bool
  @Stub func isOdd(self): Bool
  @Stub func isBetween(self, lower: Int, upper: Int, inclusive = false): Bool
}

type Float {
  @Stub func abs(self): Float
  @Stub func floor(self): Int
  @Stub func ceil(self): Int
  @Stub func round(self): Int
  @Stub func withPrecision(self, precision: Int): Float
}

type Bool {
  // No methods for Bool
}

type String {
  length: Int readonly
  _buffer: Pointer<Byte> = Pointer.null()

  func withLength(length: Int): String {
    String(length: length, _buffer: Pointer.malloc(length))
  }

  func hash(self): Int {
    var hash = 31 * self.length
    var i = 0
    while i < self.length {
      val byte = self._buffer.offset(i).load()
      hash = hash + 31 * byte.asInt()
      i += 1
    }
    hash
  }

  func eq(self, other: String): Bool {
    if self.length != other.length { return false }

    var i = 0
    while i < self.length {
      val selfCh = self._buffer.offset(i).load().asInt()
      val otherCh = other._buffer.offset(i).load().asInt()
      if selfCh != otherCh { return false }
      i += 1
    }

    true
  }

  func isEmpty(self): Bool = self.length == 0

  @Stub func toLower(self): String
  @Stub func toUpper(self): String
  @Stub func padLeft(self, totalSize: Int, padding = " "): String
  @Stub func trim(self): String
  @Stub func trimStart(self, pattern: String? = None): String
  @Stub func trimEnd(self, pattern: String? = None): String
  @Stub func split(self, by = ""): String[]
  @Stub func splitAt(self, index: Int): (String, String)
  @Stub func lines(self): String[]
  @Stub func parseInt(self, radix = 10): Int?
  @Stub func parseFloat(self): Float?

  func concat<T>(self, suffix: T, *others: Any[]): String {
    val suffixStr = suffix.toString()
    val othersRepr = others.join()
    var newLength = self.length + suffixStr.length + othersRepr.length

    val newString = String.withLength(newLength)
    newString._buffer.copyFrom(self._buffer, self.length)
    newString._buffer
      .offset(self.length)
      .copyFrom(suffixStr._buffer, suffixStr.length)
    newString._buffer
      .offset(self.length + suffixStr.length)
      .copyFrom(othersRepr._buffer, othersRepr.length)
    newString
  }

  @Stub func replaceAll(self, pattern: String, replacement: String): String

  func get(self, index: Int): String {
    var idx = if index < 0 index + self.length else index
    if idx >= self.length || idx < 0 {
      ""
    } else {
      val str = String.withLength(1)
      str._buffer.copyFrom(self._buffer.offset(idx), 1)
      str
    }
  }

  func getRange(self, startIndex = 0, endIndex = self.length): String {
    val start = if startIndex < 0 startIndex + self.length else startIndex
    val end = if endIndex > self.length self.length else endIndex
    val length = end - start
    val subString = String.withLength(length)
    subString._buffer.copyFrom(self._buffer.offset(start), length)

    subString
  }
}

type Array<T> {
  length: Int
  _buffer: Pointer<T> = Pointer.null()
  _capacity: Int = 0

  func withCapacity<T>(initialCapacity: Int): T[] {
    Array(length: 0, _buffer: Pointer.malloc(initialCapacity), _capacity: initialCapacity)
  }

  func fill<T>(length: Int, value: T): T[] {
    val buffer = Pointer.malloc<T>(length)
    var i = 0
    while i < length {
      buffer.offset(i).store(value)
      i += 1
    }

    Array(length: length, _buffer: buffer, _capacity: length)
  }

  func fillBy<T>(length: Int, fn: (Int) => T): T[] {
    val buffer = Pointer.malloc<T>(length)
    var i = 0
    while i < length {
      val item = fn(i)
      buffer.offset(i).store(item)
      i += 1
    }

    Array(length: length, _buffer: buffer, _capacity: length)
  }

  func toString(self): String {
    if self.isEmpty() return "[]"

    val reprs: String[] = Array.withCapacity(self.length)
    var len = 2 // account for '[' and ']'
    var i = 0
    while i < self.length {
      val item = self._buffer.offset(i).load()
      val repr = item.toString()
      reprs.push(repr)
      len += repr.length
      if i != self.length - 1 {
        len += 2 // account for ", " unless last item
      }
      i += 1
    }

    // we have an extra 2 bytes for the trailing ", " but we need an extra 1 for the null termination anyway
    val str = String.withLength(len)
    var offset = 0
    str._buffer.offset(offset).store(Byte.fromInt(91)) // '['
    offset += 1

    i = 0
    while i < self.length {
      val repr = reprs._buffer.offset(i).load()
      str._buffer.offset(offset).copyFrom(repr._buffer, repr.length)
      offset += repr.length

      if i != self.length - 1 {
        str._buffer.offset(offset).store(Byte.fromInt(44)) // ','
        offset += 1
        str._buffer.offset(offset).store(Byte.fromInt(32)) // ' '
        offset += 1
      }

      i += 1
    }

    str._buffer.offset(offset).store(Byte.fromInt(93)) // ']'

    str
  }

  func hash(self): Int {
    var hash = 31 * self.length
    var i = 0
    while i < self.length {
      val item = self._buffer.offset(i).load()
      hash = hash + 31 * item.hash()
      i += 1
    }
    hash
  }

  func eq(self, other: Array<T>): Bool {
    if self.length != other.length return false

    var i = 0
    while i < self.length {
      val selfItem = self._buffer.offset(i).load()
      val otherItem = other._buffer.offset(i).load()

      if selfItem != otherItem { return false }
      i += 1
    }

    true
  }

  func isEmpty(self): Bool = self.length == 0

  @Stub func enumerate(self): (T, Int)[]

  func push(self, item: T) {
    self._buffer.offset(self.length).store(item)
    self.length += 1
  }

  func pop(self): T? {
    if self.length == 0 {
      None
    } else {
      self.length -= 1
      self._buffer.offset(self.length).load()
    }
  }

  @Stub func popFront(self): T?
  @Stub func splitAt(self, index: Int): (T[], T[])
  @Stub func concat(self, other: T[]): T[]

  func map<U>(self, fn: (T, Int) => U): U[] {
    val newArray: U[] = Array.withCapacity(self.length)
    var i = 0
    while i < self.length {
      val item = self._buffer.offset(i).load()
      val result = fn(item, i)
      newArray.push(result)
      i += 1
    }

    newArray
  }

  func filter(self, fn: (T, Int) => Bool): T[] {
    val newArray: T[] = Array.withCapacity(self.length)
    var i = 0
    while i < self.length {
      val item = self._buffer.offset(i).load()
      if fn(item, i) {
        newArray.push(item)
      }
      i += 1
    }

    newArray
  }

  func reduce<U>(self, initialValue: U, fn: (U, T, Int) => U): U {
    var acc = initialValue
    var i = 0
    while i < self.length {
      val item = self._buffer.offset(i).load()
      acc = fn(acc, item, i)
      i += 1
    }

    acc
  }

  func forEach(self, fn: (T, Int) => Unit) {
    var i = 0
    while i < self.length {
      val item = self._buffer.offset(i).load()
      fn(item, i)
      i += 1
    }
  }

  func join(self, joiner = ""): String {
    val reprs: String[] = Array.withCapacity(self.length)
    var length = 0
    var i = 0
    while i < self.length {
      val item = self._buffer.offset(i).load()
      val repr = item.toString()
      reprs.push(repr)
      length += repr.length
      if i != self.length - 1 {
        length += joiner.length
      }
      i += 1
    }

    val str = String.withLength(length)
    i = 0
    var offset = 0
    while i < reprs.length {
      val repr = reprs._buffer.offset(i).load()
      str._buffer.offset(offset).copyFrom(repr._buffer, repr.length)
      offset += repr.length
      if i != reprs.length - 1 {
        str._buffer.offset(offset).copyFrom(joiner._buffer, joiner.length)
        offset += joiner.length
      }
      i += 1
    }

    str
  }

  @Stub func contains(self, item: T): Bool
  @Stub func find(self, fn: (T) => Bool): T?
  @Stub func findIndex(self, fn: (T) => Bool): (T, Int)?
  @Stub func any(self, fn: (T) => Bool): Bool
  @Stub func all(self, fn: (T) => Bool): Bool
  @Stub func none(self, fn: (T) => Bool): Bool
  @Stub func sortBy(self, fn: (T) => Int, reverse = false): T[]
  @Stub func dedupe(self): T[]
  @Stub func dedupeBy<U>(self, fn: (T) => U): T[]
  @Stub func partition<U>(self, fn: (T) => U): Map<U, T[]>
  @Stub func tally(self): Map<T, Int>
  @Stub func tallyBy<U>(self, fn: (T) => U): Map<U, Int>
  @Stub func asSet(self): Set<T>

  func get(self, index: Int): T? {
    val idx = if index < 0 index + self.length else index
    if idx >= self.length || idx < 0 {
      None
    } else {
      self._buffer.offset(idx).load()
    }
  }

  @Stub func getOr(self, index: Int, default: T): T
  @Stub func getOrElse(self, index: Int, getDefault: () => T): T

  func getRange(self, startIndex = 0, endIndex = self.length): T[] {
    val start = if startIndex < 0 startIndex + self.length else startIndex
    val end = if endIndex > self.length self.length else endIndex
    val length = end - start
    val subArray: T[] = Array.withCapacity(length)
    subArray.length = length
    subArray._buffer.copyFrom(self._buffer.offset(start), length)

    subArray
  }

  func set(self, index: Int, value: T): T? {
    val idx = if index < 0 index + self.length else index
    if idx >= self.length || idx < 0 {
      None
    } else {
      val old = self.get(index)
      self._buffer.offset(idx).store(value)
      old
    }
  }

  @Stub func update(self, index: Int, updater: (T) => T)
  @Stub func reverse(self): T[]
}

type Set<T> {
  size: Int
  _map: Map<T, Bool> = Map.new()

  func new<T>(initialCapacity = 16): Set<T> {
    Set<T>(size: 0, _map: Map.new(initialCapacity))
  }

  func toString(self): String {
    if self.isEmpty() return "#{}"

    val reprs: String[] = Array.withCapacity(self._map.size)
    self.forEach(item => reprs.push(item.toString()))

    val items = reprs.join(", ")
    "#{${items}}"
  }

  func eq(self, other: Set<T>): Bool {
    self._map == other._map
  }

  func isEmpty(self): Bool {
    self._map.isEmpty()
  }

  @Stub func enumerate(self): (T, Int)[]

  func contains(self, item: T): Bool {
    self._map.containsKey(item)
  }

  func insert(self, item: T) {
    self._map.insert(item, true)
    self.size = self._map.size
  }

  func forEach(self, fn: (T) => Unit) {
    self._map.forEach(key => fn(key))
  }

  @Stub func remove(self, item: T): T?

  func map<U>(self, fn: (T) => U): U[] {
    val arr: U[] = Array.withCapacity(self.size)
    self.forEach(item => arr.push(fn(item)))

    arr
  }

  func filter(self, fn: (T) => Bool): Set<T> {
    val newSet: Set<T> = Set.new()
    self.forEach(item => if fn(item) newSet.insert(item))

    newSet
  }

  @Stub func reduce<U>(self, initialValue: U, fn: (U, T) => U): U

  func asArray(self): T[] {
    val arr: T[] = Array.withCapacity(self.size)
    self.forEach(item => arr.push(item))

    arr
  }

  func union(self, other: Set<T>): Set<T> {
    val newSet: Set<T> = Set.new()
    self.forEach(item => newSet.insert(item))
    other.forEach(item => newSet.insert(item))

    newSet
  }

  func difference(self, other: Set<T>): Set<T> {
    val newSet: Set<T> = Set.new()
    self.forEach(item => if !other.contains(item) newSet.insert(item))

    newSet
  }

  func intersection(self, other: Set<T>): Set<T> {
    val newSet: Set<T> = Set.new()
    self.forEach(item => if other.contains(item) newSet.insert(item))

    newSet
  }
}

type MapEntry<K, V> {
  key: K
  value: V
  next: MapEntry<K, V>? = None
}

type Map<K, V> {
  size: Int
  _entries: MapEntry<K, V>?[] = []
  _capacity: Int = 16
  _loadFactor: Float = 0.75

  func new<K, V>(initialCapacity = 16): Map<K, V> {
    // Find a power of 2 >= initialCapacity, if non-default value provided
    val capacity = if initialCapacity != 16 {
      var cap = 1
      while cap < initialCapacity {
        cap = cap << 1
      }
      cap
    } else {
      initialCapacity
    }

    val entries: MapEntry<K, V>?[] = Array.fillBy(capacity, () => None)
    Map(size: 0, _capacity: capacity, _entries: entries)
  }

  func toString(self): String {
    if self.isEmpty() return "{}"

    val reprs: String[] = Array.withCapacity(self.size)
    var i = 0
    while i < self._entries.length {
      if self._entries[i] |bucket| {
        var cursor = bucket
        while cursor |cur| {
          val item = "${cur.key}: ${cur.value}"
          reprs.push(item)
          cursor = cur.next
        }
      }
      i += 1
    }

    val items = reprs.join(", ")
    "{ ${items} }"
  }

  func eq(self, other: Map<K, V>): Bool {
    if self.size != other.size return false

    var i = 0
    while i < self._entries.length {
      if self._entries[i] |bucket| {
        var cursor = bucket

        while cursor |cur| {
          if other.get(cur.key) |otherValue| {
            if otherValue != cur.value return false
          } else {
            return false
          }
          cursor = cur.next
        }
      }
      i += 1
    }

    true
  }

  func isEmpty(self): Bool = self.size == 0

  func forEach(self, fn: (K, V) => Unit) {
    var i = 0
    while i < self._entries.length {
      if self._entries[i] |bucket| {
        var cursor = bucket
        while cursor |cur| {
          fn(cur.key, cur.value)
          cursor = cur.next
        }
      }
      i += 1
    }
  }

  @Stub func enumerate(self): (K, V)[]
  @Stub func keys(self): Set<K>
  @Stub func values(self): V[]

  func entries(self): Set<(K, V)> {
    val entries: Set<(K, V)> = Set.new()
    self.forEach((k, v) => entries.insert((k, v)))

    entries
  }

  func _getKeyHash(self, key: K): Int = key.hash() && (self._entries._capacity - 1)

  func containsKey(self, key: K): Bool = if self._getEntry(key) true else false

  func mapValues<U>(self, fn: (K, V) => U): Map<K, U> {
    val newMap: Map<K, U> = Map.new()
    var i = 0
    while i < self._entries.length {
      if self._entries[i] |bucket| {
        var cursor = bucket
        while cursor |cur| {
          newMap.insert(cur.key, fn(cur.key, cur.value))
          cursor = cur.next
        }
      }
      i += 1
    }

    newMap
  }

  func insert(self, key: K, value: V): V? {
    val hash = self._getKeyHash(key)

    if flattenOption(self._entries[hash]) |slot| {
      var cursor: MapEntry<K, V>? = slot
      while cursor |cur| {
        if cur.key == key {
          val old = cur.value
          cur.value = value
          return old
        } else if cur.next |next| {
          cursor = next
        } else {
          cur.next = MapEntry(key: key, value: value)
          self.size += 1
          return None
        }
      }
    } else {
      self._entries[hash] = MapEntry(key: key, value: value)
      self.size += 1
    }

    // resize if self.size > self._capacity * self._loadFactor

    None
  }

  func _getEntry(self, key: K): MapEntry<K, V>? {
    val hash = self._getKeyHash(key)

    if flattenOption(self._entries[hash]) |bucket| {
      var cursor: MapEntry<K, V>? = bucket
      while cursor |entry| {
        if entry.key == key {
          return entry
        } else {
          cursor = entry.next
        }
      }
    }

    None
  }

  func get(self, key: K): V? {
    if self._getEntry(key) |entry| {
      entry.value
    } else {
      None
    }
  }

  func getOr(self, key: K, default: V): V {
    self.get(key) ?: default
  }

  func getOrElse(self, key: K, getDefault: () => V): V {
    self.get(key) ?: getDefault()
  }

  func update(self, key: K, updater: (V) => V): V? {
    if self._getEntry(key) |entry| {
      val oldVal = entry.value
      entry.value = updater(oldVal)
      oldVal
    } else {
      None
    }
  }

  @Stub func remove(self, key: K): V?
}
