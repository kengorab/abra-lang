@Intrinsic("stdout_write")
func stdoutWrite(str: String)

func print(*items: Any[]) {
  var i = 0
  while i < items.length {
    val item = items._buffer.offset(i).load()
    stdoutWrite(item.toString())

    if i != items.length - 1 {
      stdoutWrite(" ")
    }

    i += 1
  }
}

func println(*items: Any[]) {
  print(items: items)
  stdoutWrite("\n")
}

@Stub func range(start: Int, end: Int, stepBy = 1): Int[]

type Byte {
  @Intrinsic("byte_from_int")
  func fromInt(value: Int): Byte
}

type Pointer<T> {
  @Intrinsic("pointer_null")
  func null<T>(): Pointer<T>

  @Intrinsic("pointer_malloc")
  func malloc<T>(count = 1): Pointer<T>

  //@Intrinsic("pointer_realloc")
  //func realloc(self, count: Int): Pointer<T>

  @Intrinsic("pointer_address")
  func address(self): Int

  @Intrinsic("pointer_store")
  func store(self, value: T)

  @Intrinsic("pointer_load")
  func load(self): T

  @Intrinsic("pointer_offset")
  func offset(self, offset: Int): Pointer<T>

  @Intrinsic("pointer_copy_from")
  func copyFrom(self, other: Pointer<T>, size: Int)
}

type Int {
  @Stub func abs(self): Int
  @Stub func asBase(self, base: Int): String
  @Stub func isEven(self): Bool
  @Stub func isOdd(self): Bool
  @Stub func isBetween(self, lower: Int, upper: Int, inclusive = false): Bool
}

type Float {
  @Stub func abs(self): Float
  @Stub func floor(self): Int
  @Stub func ceil(self): Int
  @Stub func round(self): Int
  @Stub func withPrecision(self, precision: Int): Float
}

type Bool {
  // No methods for Bool
}

type String {
  length: Int readonly
  _buffer: Pointer<Byte> = Pointer.null()

  func withLength(length: Int): String {
    String(length: length, _buffer: Pointer.malloc(length))
  }

  func isEmpty(self): Bool = self.length == 0

  @Stub func toLower(self): String
  @Stub func toUpper(self): String
  @Stub func padLeft(self, totalSize: Int, padding = " "): String
  @Stub func trim(self): String
  @Stub func trimStart(self, pattern: String? = None): String
  @Stub func trimEnd(self, pattern: String? = None): String
  @Stub func split(self, by = ""): String[]
  @Stub func splitAt(self, index: Int): (String, String)
  @Stub func lines(self): String[]
  @Stub func parseInt(self, radix = 10): Int?
  @Stub func parseFloat(self): Float?

  func concat<T>(self, suffix: T, *others: Any[]): String {
    val suffixStr = suffix.toString()
    val othersRepr = others.join()
    var newLength = self.length + suffixStr.length + othersRepr.length

    val newString = String.withLength(newLength)
    newString._buffer.copyFrom(self._buffer, self.length)
    newString._buffer
      .offset(self.length)
      .copyFrom(suffixStr._buffer, suffixStr.length)
    newString._buffer
      .offset(self.length + suffixStr.length)
      .copyFrom(othersRepr._buffer, othersRepr.length)
    newString
  }

  @Stub func replaceAll(self, pattern: String, replacement: String): String
}

type Array<T> {
  length: Int
  _buffer: Pointer<T> = Pointer.null()
  _capacity: Int = 0

  func withCapacity<T>(initialCapacity: Int): T[] {
    Array(length: 0, _buffer: Pointer.malloc(initialCapacity), _capacity: initialCapacity)
  }

  // TODO: custom toString implementations shouldn't need to be the first method declared
  func toString(self): String {
    val reprs: String[] = Array.withCapacity(self.length)
    var len = 2 // account for '[' and ']'
    var i = 0
    while i < self.length {
      val item = self._buffer.offset(i).load()
      val repr = item.toString()
      reprs.push(repr)
      len += repr.length
      if i != self.length - 1 {
        len += 2 // account for ", " unless last item
      }
      i += 1
    }

    // we have an extra 2 bytes for the trailing ", " but we need an extra 1 for the null termination anyway
    val str = String.withLength(len)
    var offset = 0
    str._buffer.offset(offset).store(Byte.fromInt(91)) // '['
    offset += 1

    i = 0
    while i < self.length {
      val repr = reprs._buffer.offset(i).load()
      str._buffer.offset(offset).copyFrom(repr._buffer, repr.length)
      offset += repr.length

      if i != self.length - 1 {
        str._buffer.offset(offset).store(Byte.fromInt(44)) // ','
        offset += 1
        str._buffer.offset(offset).store(Byte.fromInt(32)) // ' '
        offset += 1
      }

      i += 1
    }

    str._buffer.offset(offset).store(Byte.fromInt(93)) // ']'

    str
  }

  @Stub func isEmpty(self): Bool
  @Stub func enumerate(self): (T, Int)[]

  func push(self, item: T) {
    self._buffer.offset(self.length).store(item)
    self.length += 1
  }

  func pop(self): T? {
    if self.length == 0 {
      None
    } else {
      self.length -= 1
      self._buffer.offset(self.length).load()
    }
  }

  @Stub func popFront(self): T?
  @Stub func splitAt(self, index: Int): (T[], T[])
  @Stub func concat(self, other: T[]): T[]
  @Stub func map<U>(self, fn: (T) => U): U[]
  @Stub func filter(self, fn: (T) => Bool): T[]
  @Stub func reduce<U>(self, initialValue: U, fn: (U, T) => U): U
  @Stub func forEach(self, fn: (T) => Unit)

  func join(self, joiner = ""): String {
    val reprs: String[] = Array.withCapacity(self.length)
    var length = 0
    var i = 0
    while i < self.length {
      val item = self._buffer.offset(i).load()
      val repr = item.toString()
      reprs.push(repr)
      length += repr.length
      if i != self.length - 1 {
        length += joiner.length
      }
      i += 1
    }

    val str = String.withLength(length)
    i = 0
    var offset = 0
    while i < reprs.length {
      val repr = reprs._buffer.offset(i).load()
      str._buffer.offset(offset).copyFrom(repr._buffer, repr.length)
      offset += repr.length
      if i != reprs.length {
        str._buffer.offset(offset).copyFrom(joiner._buffer, joiner.length)
        offset += joiner.length
      }
      i += 1
    }

    str
  }

  @Stub func contains(self, item: T): Bool
  @Stub func find(self, fn: (T) => Bool): T?
  @Stub func findIndex(self, fn: (T) => Bool): (T, Int)?
  @Stub func any(self, fn: (T) => Bool): Bool
  @Stub func all(self, fn: (T) => Bool): Bool
  @Stub func none(self, fn: (T) => Bool): Bool
  @Stub func sortBy(self, fn: (T) => Int, reverse = false): T[]
  @Stub func dedupe(self): T[]
  @Stub func dedupeBy<U>(self, fn: (T) => U): T[]
  @Stub func partition<U>(self, fn: (T) => U): Map<U, T[]>
  @Stub func tally(self): Map<T, Int>
  @Stub func tallyBy<U>(self, fn: (T) => U): Map<U, Int>
  @Stub func asSet(self): Set<T>
  @Stub func getOr(self, index: Int, default: T): T
  @Stub func getOrElse(self, index: Int, getDefault: () => T): T
  @Stub func update(self, index: Int, updater: (T) => T)
  @Stub func reverse(self): T[]
}

type Set<T> {
  size: Int readonly

  @Stub func isEmpty(self): Bool
  @Stub func enumerate(self): (T, Int)[]
  @Stub func contains(self, item: T): Bool
  @Stub func insert(self, item: T)
  @Stub func remove(self, item: T): T?
  @Stub func map<U>(self, fn: (T) => U): U[]
  @Stub func filter(self, fn: (T) => Bool): Set<T>
  @Stub func reduce<U>(self, initialValue: U, fn: (U, T) => U): U
  @Stub func asArray(self): T[]
  @Stub func union(self, other: Set<T>): Set<T>
  @Stub func difference(self, other: Set<T>): Set<T>
  @Stub func intersection(self, other: Set<T>): Set<T>
}

type Map<K, V> {
  size: Int readonly

  @Stub func isEmpty(self): Bool
  @Stub func enumerate(self): (K, V)[]
  @Stub func keys(self): Set<K>
  @Stub func values(self): V[]
  @Stub func entries(self): Set<(K, V)>
  @Stub func containsKey(self, key: K): Bool
  @Stub func mapValues<U>(self, fn: (K, V) => U): Map<K, U>
  @Stub func getOr(self, key: K, default: V): V
  @Stub func getOrElse(self, key: K, getDefault: () => V): V
  @Stub func update(self, key: K, updater: (V) => V)
  @Stub func remove(self, key: K): V?
}
