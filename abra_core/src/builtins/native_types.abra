type NativeFloat {
  func toString(self): String {}
  func floor(self): Int {}
  func ceil(self): Int {}
  func round(self): Int {}
  func withPrecision(self, precision: Int): Float {}
  func abs(self): Float {}
}

type NativeInt {
  func toString(self): String {}
  func abs(self): Int {}
  func asBase(self, base: Int): String {}
  func isEven(self): Bool {}
  func isOdd(self): Bool {}
  func isBetween(self, lower: Int, upper: Int, inclusive: Bool = false): Bool {}
}

type NativeString {
  length: Int

  func toString(self): String {}
  func toLower(self): String {}
  func toUpper(self): String {}
  func padLeft(self, totalSize: Int, padding: String = " "): String {}
  func trim(self): String {}
  func trimStart(self, pattern: String = " "): String {}
  func trimEnd(self, pattern: String = " "): String {}
  func split(self, splitter: String): String[] {}
  func splitAt(self, index: Int): (String, String) {}
  func lines(self): String[] {}
  func chars(self): String[] {}
  func parseInt(self, radix: Int = 10): Int? {}
  func parseFloat(self): Float? {}
  func concat(self, str: Any, *others: Any[]): String {}
}

type NativeArray<T> {
  length: Int

  func fill<T1>(amount: Int, value: T1): T1[] {}
  func fillBy<T1>(amount: Int, fn: (Int) => T1): T1[] {}

  func toString(self): String {}
  func isEmpty(self): Bool {}
  func enumerate(self): (T, Int)[] {}
  func push(self, item: T, *others: T[]): Unit {}
  func pop(self): T? {}
  func popFront(self): T? {}
  func splitAt(self, index: Int): (T[], T[]) {}
  func concat(self, other: T[]): T[] {}
  func map<U>(self, fn: (T) => U): U[] {}
  func filter(self, fn: (T) => Bool): T[] {}
  func reduce<U>(self, initialValue: U, fn: (U, T) => U): U {}
  func join(self, joiner: String = ""): String {}
  func contains(self, item: T): Bool {}
  func find<U>(self, fn: (T) => (Bool | U?)): T? {}
  func findIndex<U>(self, fn: (T) => (Bool | U?)): (T, Int)? {}
  func any<U>(self, fn: (T) => (Bool | U?)): Bool {}
  func all<U>(self, fn: (T) => (Bool | U?)): Bool {}
  func none<U>(self, fn: (T) => (Bool | U?)): Bool {}
  func sortBy(self, fn: (T) => Int, reverse: Bool = false): T[] {}
  func dedupe(self): T[] {}
  func dedupeBy<U>(self, fn: (T) => U): T[] {}
  func partition<U>(self, fn: (T) => U): Map<U, T[]> {}
  func tally(self): Map<T, Int> {}
  func tallyBy<U>(self, fn: (T) => U): Map<U, Int> {}
  func asSet(self): Set<T> {}
  func getOrDefault(self, key: Int, default: T): T {}
  func getOrElse(self, key: Int, fn: () => T): T {}
  func update(self, key: Int, fn: (T) => T) {}
}

type NativeMap<K, V> {
  size: Int

  func fromPairs<T1, T2>(pairs: (T1, T2)[]): Map<T1, T2> {}

  func toString(self): String {}
  func isEmpty(self): Bool {}
  func enumerate(self): (K, V)[] {}
  func keys(self): Set<K> {}
  func values(self): Set<V> {}
  func entries(self): Set<(K, V)> {}
  func containsKey(self, key: K): Bool {}
  func mapValues<U>(self, fn: (K, V) => U): Map<K, U> {}
  func getOrDefault(self, key: K, default: V): V {}
  func getOrElse(self, key: K, fn: () => V): V {}
  func update(self, key: K, fn: (V) => V) {}
}

type NativeSet<T> {
  size: Int

  func toString(self): String {}
  func isEmpty(self): Bool {}
  func enumerate(self): (T, Int)[] {}
  func contains(self, value: T): Bool {}
  func insert(self, value: T) {}
  func remove(self, value: T) {}
  func map<U>(self, fn: (T) => U): U[] {}
  func filter(self, fn: (T) => Bool): Set<T> {}
  func reduce<U>(self, initialValue: U, fn: (U, T) => U): U {}
  func asArray(self): T[] {}
  func union(self, other: Set<T>): Set<T> {}
  func difference(self, other: Set<T>): Set<T> {}
  func intersection(self, other: Set<T>): Set<T> {}
}
